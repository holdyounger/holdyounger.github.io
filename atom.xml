<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oone</title>
  
  <subtitle>固执无罪，梦想无价 | Coding For Knowledge</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-20T03:18:29.995Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>mingming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Retmote Registry 服务</title>
    <link href="http://example.com/OS/Windows/%E6%9C%8D%E5%8A%A1/RemoteRegistry/"/>
    <id>http://example.com/OS/Windows/%E6%9C%8D%E5%8A%A1/RemoteRegistry/</id>
    <published>2023-09-20T01:30:16.830Z</published>
    <updated>2023-09-20T03:18:29.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Remote Registry是什么服务？</p><blockquote><p>Remote Registry,翻译为”远程注册表”,如果远程的计算机连接到了你的计算机那么他可以通过字符界面或者其他方式远程修改注册表.这是一个相当严重的漏洞,可以为黑客入侵提供早期的方便(修改某些项目便于入侵,比如操作系统版本).</p></blockquote></blockquote><p>[toc]</p><h1 id="开启-Remote-Regustiy-服务"><a href="#开启-Remote-Regustiy-服务" class="headerlink" title="开启 Remote Regustiy 服务"></a>开启 Remote Regustiy 服务</h1><p>默认情况下，Windows 7 禁用远程注册表服务（可能是出于安全原因）。</p><h2 id="方法1-ui"><a href="#方法1-ui" class="headerlink" title="方法1 ui"></a>方法1 ui</h2><p>打开windows服务，在服务中修改 Remote Registry 服务的启动类型为手动，然后启动 Remote Registry 服务。</p><h2 id="方法2-命令行"><a href="#方法2-命令行" class="headerlink" title="方法2 命令行"></a>方法2 命令行</h2><ol><li>要从命令行启用它，请键入以下内容：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\computername config remoteregistry start= auto</span><br></pre></td></tr></table></figure><p>确保 &#x3D; 符号和 auto 之间有一个空格，<br>如果您在本地计算机上执行此操作，您可以删除 \computername 部分，<br>您也可以将“remoteregistry”替换为另一个服务来启用或禁用它。</p><p>启用该服务后，您可以重新启动计算机，或者立即使用以下命令启动它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\computername start remoteregistry</span><br></pre></td></tr></table></figure><ol start="2"><li>使用ps工具</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start remoteregistry start= auto</span><br></pre></td></tr></table></figure><ul><li>启动服务并将其设置为自动 </li><li>不需要启动服务</li></ul><h1 id="Remote-Registry服务可以关闭吗？"><a href="#Remote-Registry服务可以关闭吗？" class="headerlink" title="Remote Registry服务可以关闭吗？"></a>Remote Registry服务可以关闭吗？</h1><p>因此关闭这个服务没有什么害处,而益处很多.强烈建议关闭,并且禁用.另外系统中没有其他服务是依赖或者跟此服务有关联的，所以禁用之后不会对其他服务产生影响。</p><p>Remote Registry服务关闭方法：</p><p>1、按住键盘的“Win+R”快捷组合键，打开“运行”对话命令窗口，输入“services.msc”命令，点击“确定”；，如图：</p><p><img src="/../images/RemoteRegistry/20171206102840976.jpg" alt="img"></p><p>2、打开服务界面后找到“Remote Registry”选项，并左键双击打开其属性对话窗口；</p><p><img src="/../images/RemoteRegistry/20171206102840304.jpg" alt="img"></p><p>3、在打开的“Remote Registry 的属性”对话窗口中，在启动类型选项中选择“禁用”选项，再点击“应用”–“停止”–“确定”按钮保存设置即可解决问题。</p><p>以上就是Remote Registry服务的详细介绍了，小编强烈建议关闭此服务，因为注册表是一台电脑的核心数据库，我们必须保证自己核心数据库的安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Remote Registry是什么服务？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Remote Registry,翻译为”远程注册表”,如果远程的计算机连接到了你的计算机那么他可以通过字符界面或者其他方式远程修改注册表.这是一个相当严重的漏洞,可</summary>
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/OS/Windows/"/>
    
    <category term="服务" scheme="http://example.com/categories/OS/Windows/%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="registry" scheme="http://example.com/tags/registry/"/>
    
    <category term="注册表" scheme="http://example.com/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>pdm用法整理</title>
    <link href="http://example.com/Code/Python/pdm%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/Code/Python/pdm%E7%94%A8%E6%B3%95/</id>
    <published>2023-09-19T09:07:32.015Z</published>
    <updated>2023-09-20T03:18:29.885Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/468445226">来了！划时代的 Python 包管理工具 – PDM - 知乎</a></p><h3 id="初始化-PDM-："><a href="#初始化-PDM-：" class="headerlink" title="初始化 PDM ："></a>初始化 PDM ：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdm init</span><br></pre></td></tr></table></figure><h3 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdm -h</span><br></pre></td></tr></table></figure><h3 id="切换python环境"><a href="#切换python环境" class="headerlink" title="切换python环境"></a>切换python环境</h3><p>当你在初始化 pdm 项目时，就已经选定了当前的 Python 版本和可用的 Python 版本范围，后面如果想更改，可以使用 use 命令，但版本要受之前设定的版本范围约束。</p><p>假设允许范围是 python 3.9+，当前使用的是 python 3.10，可以直接切换过去。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdm use python3.9</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/468445226&quot;&gt;来了！划时代的 Python 包管理工具 – PDM - 知乎&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;初始化-PDM-：&quot;&gt;&lt;a href=&quot;#初始化-PDM-：&quot; class=&quot;h</summary>
      
    
    
    
    <category term="Code" scheme="http://example.com/categories/Code/"/>
    
    <category term="Python" scheme="http://example.com/categories/Code/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows权限(Privilege Constants)</title>
    <link href="http://example.com/OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/Privilege%20constants/"/>
    <id>http://example.com/OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/Privilege%20constants/</id>
    <published>2023-09-19T08:34:38.273Z</published>
    <updated>2023-09-20T03:18:29.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>windows 提权时常用的 Constants</p><p>微软官方文档：<a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants">Privilege Constants (Winnt.h) - Win32 apps | Microsoft Learn</a></p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h2><table><thead><tr><th align="left">Constant&#x2F;value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><strong>SE_ASSIGNPRIMARYTOKEN_NAME</strong><br />TEXT(“SeAssignPrimaryTokenPrivilege”)</td><td align="left">Required to assign the <a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/p-gly"><em>primary token</em></a> of a process. User Right: Replace a process-level token.</td></tr><tr><td align="left"><strong>SE_AUDIT_NAME</strong><br />TEXT(“SeAuditPrivilege”)</td><td align="left">Required to generate audit-log entries. Give this privilege to secure servers. User Right: Generate security audits.</td></tr><tr><td align="left"><strong>SE_BACKUP_NAME</strong><br />TEXT(“SeBackupPrivilege”)</td><td align="left">Required to perform backup operations. This privilege causes the system to grant all read access control to any file, regardless of the <a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/a-gly"><em>access control list</em></a> (ACL) specified for the file. Any access request other than read is still evaluated with the ACL. This privilege is required by the <a href="https://learn.microsoft.com/en-us/windows/desktop/api/winreg/nf-winreg-regsavekeya"><strong>RegSaveKey</strong></a> and <a href="https://learn.microsoft.com/en-us/windows/desktop/api/winreg/nf-winreg-regsavekeyexa"><strong>RegSaveKeyEx</strong></a>functions. The following access rights are granted if this privilege is held: READ_CONTROLACCESS_SYSTEM_SECURITYFILE_GENERIC_READFILE_TRAVERSEUser Right: Back up files and directories. If the file is located on a removable drive and the “Audit Removable Storage” is enabled, the SE_SECURITY_NAME is required to have ACCESS_SYSTEM_SECURITY.</td></tr><tr><td align="left"><strong>SE_CHANGE_NOTIFY_NAME</strong><br />TEXT(“SeChangeNotifyPrivilege”)</td><td align="left">Required to receive notifications of changes to files or directories. This privilege also causes the system to skip all traversal access checks. It is enabled by default for all users. User Right: Bypass traverse checking.</td></tr><tr><td align="left"><strong>SE_CREATE_GLOBAL_NAME</strong><br />TEXT(“SeCreateGlobalPrivilege”)</td><td align="left">Required to create named file mapping objects in the global namespace during Terminal Services sessions. This privilege is enabled by default for administrators, services, and the local system account. User Right: Create global objects.</td></tr><tr><td align="left"><strong>SE_CREATE_PAGEFILE_NAME</strong><br />TEXT(“SeCreatePagefilePrivilege”)</td><td align="left">Required to create a paging file. User Right: Create a pagefile.</td></tr><tr><td align="left"><strong>SE_CREATE_PERMANENT_NAME</strong><br />TEXT(“SeCreatePermanentPrivilege”)</td><td align="left">Required to create a permanent object. User Right: Create permanent shared objects.</td></tr><tr><td align="left"><strong>SE_CREATE_SYMBOLIC_LINK_NAME</strong><br />TEXT(“SeCreateSymbolicLinkPrivilege”)</td><td align="left">Required to create a symbolic link. User Right: Create symbolic links.</td></tr><tr><td align="left">**SE_CREATE_TOKEN_NAME<br />**TEXT(“SeCreateTokenPrivilege”)</td><td align="left">Required to create a primary token. User Right: Create a token object. You cannot add this privilege to a user account with the “Create a token object” policy. Additionally, you cannot add this privilege to an owned process using Windows APIs.<strong>Windows Server 2003 and Windows XP with SP1 and earlier:</strong> Windows APIs can add this privilege to an owned process.</td></tr><tr><td align="left">**SE_DEBUG_NAME<br />**TEXT(“SeDebugPrivilege”)</td><td align="left">Required to debug and adjust the memory of a process owned by another account. User Right: Debug programs.</td></tr><tr><td align="left">**SE_DELEGATE_SESSION_USER_IMPERSONATE_NAME<br />**TEXT(“SeDelegateSessionUserImpersonatePrivilege”)</td><td align="left">Required to obtain an impersonation token for another user in the same session. User Right: Impersonate other users.</td></tr><tr><td align="left"><strong>SE_ENABLE_DELEGATION_NAME</strong><br />TEXT(“SeEnableDelegationPrivilege”)</td><td align="left">Required to mark user and computer accounts as trusted for delegation. User Right: Enable computer and user accounts to be trusted for delegation.</td></tr><tr><td align="left"><strong>SE_IMPERSONATE_NAME</strong><br />TEXT(“SeImpersonatePrivilege”)</td><td align="left">Required to impersonate. User Right: Impersonate a client after authentication.</td></tr><tr><td align="left"><strong>SE_INC_BASE_PRIORITY_NAME</strong><br />TEXT(“SeIncreaseBasePriorityPrivilege”)</td><td align="left">Required to increase the base priority of a process. User Right: Increase scheduling priority.</td></tr><tr><td align="left"><strong>SE_INCREASE_QUOTA_NAME</strong><br />TEXT(“SeIncreaseQuotaPrivilege”)</td><td align="left">Required to increase the quota assigned to a process. User Right: Adjust memory quotas for a process.</td></tr><tr><td align="left">**SE_INC_WORKING_SET_NAME<br />**TEXT(“SeIncreaseWorkingSetPrivilege”)</td><td align="left">Required to allocate more memory for applications that run in the context of users. User Right: Increase a process working set.</td></tr><tr><td align="left">**SE_LOAD_DRIVER_NAME<br />**TEXT(“SeLoadDriverPrivilege”)</td><td align="left">Required to load or unload a device driver. User Right: Load and unload device drivers.</td></tr><tr><td align="left">**SE_LOCK_MEMORY_NAME<br />**TEXT(“SeLockMemoryPrivilege”)</td><td align="left">Required to lock physical pages in memory. User Right: Lock pages in memory.</td></tr><tr><td align="left">**SE_MACHINE_ACCOUNT_NAME<br />**TEXT(“SeMachineAccountPrivilege”)</td><td align="left">Required to create a computer account. User Right: Add workstations to domain.</td></tr><tr><td align="left"><strong>SE_MANAGE_VOLUME_NAME</strong><br />TEXT(“SeManageVolumePrivilege”)</td><td align="left">Required to enable volume management privileges. User Right: Manage the files on a volume.</td></tr><tr><td align="left"><strong>SE_PROF_SINGLE_PROCESS_NAME</strong><br />TEXT(“SeProfileSingleProcessPrivilege”)</td><td align="left">Required to gather profiling information for a single process. User Right: Profile single process.</td></tr><tr><td align="left"><strong>SE_RELABEL_NAME</strong><br />TEXT(“SeRelabelPrivilege”)</td><td align="left">Required to modify the mandatory integrity level of an object. User Right: Modify an object label.</td></tr><tr><td align="left">**SE_REMOTE_SHUTDOWN_NAME<br />**TEXT(“SeRemoteShutdownPrivilege”)</td><td align="left">Required to shut down a system using a network request. User Right: Force shutdown from a remote system.</td></tr><tr><td align="left"><strong>SE_RESTORE_NAME</strong><br />TEXT(“SeRestorePrivilege”)</td><td align="left">Required to perform restore operations. This privilege causes the system to grant all write access control to any file, regardless of the ACL specified for the file. Any access request other than write is still evaluated with the ACL. Additionally, this privilege enables you to set any valid user or group SID as the owner of a file. This privilege is required by the <a href="https://learn.microsoft.com/en-us/windows/desktop/api/winreg/nf-winreg-regloadkeya"><strong>RegLoadKey</strong></a> function. The following access rights are granted if this privilege is held: WRITE_DACWRITE_OWNERACCESS_SYSTEM_SECURITYFILE_GENERIC_WRITEFILE_ADD_FILEFILE_ADD_SUBDIRECTORYDELETEUser Right: Restore files and directories. If the file is located on a removable drive and the “Audit Removable Storage” is enabled, the SE_SECURITY_NAME is required to have ACCESS_SYSTEM_SECURITY.</td></tr><tr><td align="left"><strong>SE_SECURITY_NAME</strong><br />TEXT(“SeSecurityPrivilege”)</td><td align="left">Required to perform a number of security-related functions, such as controlling and viewing audit messages. This privilege identifies its holder as a security operator. User Right: Manage auditing and security log.</td></tr><tr><td align="left"><strong>SE_SHUTDOWN_NAME</strong><br />TEXT(“SeShutdownPrivilege”)</td><td align="left">Required to shut down a local system. User Right: Shut down the system.</td></tr><tr><td align="left"><strong>SE_SYNC_AGENT_NAME</strong><br />TEXT(“SeSyncAgentPrivilege”)</td><td align="left">Required for a domain controller to use the <a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/l-gly"><em>Lightweight Directory Access Protocol</em></a> directory synchronization services. This privilege enables the holder to read all objects and properties in the directory, regardless of the protection on the objects and properties. By default, it is assigned to the Administrator and LocalSystem accounts on domain controllers. User Right: Synchronize directory service data.</td></tr><tr><td align="left"><strong>SE_SYSTEM_ENVIRONMENT_NAME</strong><br />TEXT(“SeSystemEnvironmentPrivilege”)</td><td align="left">Required to modify the nonvolatile RAM of systems that use this type of memory to store configuration information. User Right: Modify firmware environment values.</td></tr><tr><td align="left"><strong>SE_SYSTEM_PROFILE_NAME</strong><br />TEXT(“SeSystemProfilePrivilege”)</td><td align="left">Required to gather profiling information for the entire system. User Right: Profile system performance.</td></tr><tr><td align="left"><strong>SE_SYSTEMTIME_NAME</strong><br />TEXT(“SeSystemtimePrivilege”)</td><td align="left">Required to modify the system time. User Right: Change the system time.</td></tr><tr><td align="left"><strong>SE_TAKE_OWNERSHIP_NAME</strong><br />TEXT(“SeTakeOwnershipPrivilege”)</td><td align="left">Required to take ownership of an object without being granted discretionary access. This privilege allows the owner value to be set only to those values that the holder may legitimately assign as the owner of an object. User Right: Take ownership of files or other objects.</td></tr><tr><td align="left">**SE_TCB_NAME<br />**TEXT(“SeTcbPrivilege”)</td><td align="left">This privilege identifies its holder as part of the trusted computer base. Some trusted protected subsystems are granted this privilege. User Right: Act as part of the operating system.</td></tr><tr><td align="left">**SE_TIME_ZONE_NAME<br />**TEXT(“SeTimeZonePrivilege”)</td><td align="left">Required to adjust the time zone associated with the computer’s internal clock. User Right: Change the time zone.</td></tr><tr><td align="left"><strong>SE_TRUSTED_CREDMAN_ACCESS_NAME</strong><br />TEXT(“SeTrustedCredManAccessPrivilege”)</td><td align="left">Required to access Credential Manager as a trusted caller. User Right: Access Credential Manager as a trusted caller.</td></tr><tr><td align="left"><strong>SE_UNDOCK_NAME</strong><br />TEXT(“SeUndockPrivilege”)</td><td align="left">Required to undock a laptop. User Right: Remove computer from docking station.</td></tr><tr><td align="left">**SE_UNSOLICITED_INPUT_NAME<br />**TEXT(“SeUnsolicitedInputPrivilege”)</td><td align="left">Required to read unsolicited input from a <a href="https://learn.microsoft.com/en-us/windows/desktop/SecGloss/t-gly"><em>terminal</em></a> device. User Right: Not applicable.</td></tr></tbody></table><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>value不同，对应的操作和权限也不同，本文列举了有关 Privilege Constants 的一些使用方式。</p><h2 id="LookupPrivilegeValue"><a href="#LookupPrivilegeValue" class="headerlink" title="LookupPrivilegeValue"></a>LookupPrivilegeValue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnablePrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LUID PrivilegeRequired ;</span><br><span class="line">    BOOL bRes = FALSE;</span><br><span class="line">  </span><br><span class="line">    bRes = <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;PrivilegeRequired);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-AdjustTokenPrivileges-修改权限"><a href="#使用-AdjustTokenPrivileges-修改权限" class="headerlink" title="使用 AdjustTokenPrivileges 修改权限"></a>使用 AdjustTokenPrivileges 修改权限</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> BOOL <span class="title">CToolhelp::EnablePrivilege</span><span class="params">(PCTSTR szPrivilege, BOOL fEnable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Enabling the debug privilege allows the application to see</span></span><br><span class="line">   <span class="comment">// information about service applications</span></span><br><span class="line">   BOOL fOk = FALSE;    <span class="comment">// Assume function fails</span></span><br><span class="line">   HANDLE hToken;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Try to open this process&#x27;s access token</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, </span><br><span class="line">      &amp;hToken)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attempt to modify the given privilege</span></span><br><span class="line">      TOKEN_PRIVILEGES tp;</span><br><span class="line">      tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, szPrivilege, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">      tp.Privileges[<span class="number">0</span>].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      fOk = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Don&#x27;t forget to close the token handle</span></span><br><span class="line">      <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(fOk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;windows 提权时常用的 Constants&lt;/p&gt;
&lt;p&gt;微软官方文档：&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/secauthz/privilege-constants</summary>
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/OS/Windows/"/>
    
    <category term="权限与会话" scheme="http://example.com/categories/OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>AD域</title>
    <link href="http://example.com/OS/Windows/%E5%AE%89%E5%85%A8/AD%E5%9F%9F/"/>
    <id>http://example.com/OS/Windows/%E5%AE%89%E5%85%A8/AD%E5%9F%9F/</id>
    <published>2023-09-19T03:26:12.851Z</published>
    <updated>2023-09-20T03:18:29.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AD域"><a href="#AD域" class="headerlink" title="AD域"></a>AD域</h1><p>AD域（Active Directory Domain）是一种Windows Server的组织单元，用于管理计算机、用户、组织和其他资源。它提供了一种集中式的管理方式，可以让管理员轻松地管理网络中的资源。AD域支持以下功能：</p><ol><li>用户和计算机管理：可以使用AD域来管理网络中的用户和计算机，包括创建、删除、修改用户和计算机的属性等。</li><li>组织管理：可以使用AD域来管理网络中的组织，包括创建、删除、修改组织的属性等。</li><li>权限管理：可以使用AD域来管理网络中的权限，包括授予用户访问资源的权限等。</li><li>网络服务管理：可以使用AD域来管理网络中的服务，包括打印服务、邮件服务等。</li><li>数据备份和恢复：可以使用AD域来备份和恢复网络中的数据，以防止数据丢失。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AD域&quot;&gt;&lt;a href=&quot;#AD域&quot; class=&quot;headerlink&quot; title=&quot;AD域&quot;&gt;&lt;/a&gt;AD域&lt;/h1&gt;&lt;p&gt;AD域（Active Directory Domain）是一种Windows Server的组织单元，用于管理计算机、用户、组织和其</summary>
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/OS/Windows/"/>
    
    <category term="安全" scheme="http://example.com/categories/OS/Windows/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>DCSYNC攻击防护</title>
    <link href="http://example.com/OS/Windows/%E5%AE%89%E5%85%A8/DCSYNC%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/OS/Windows/%E5%AE%89%E5%85%A8/DCSYNC%E6%94%BB%E5%87%BB/</id>
    <published>2023-09-19T03:24:30.036Z</published>
    <updated>2023-09-20T03:18:29.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DCSYNC攻击"><a href="#DCSYNC攻击" class="headerlink" title="DCSYNC攻击"></a>DCSYNC攻击</h1><p>DCSYNC攻击是一种利用DC（域控制器）之间的同步过程来实现的攻击。攻击者可以利用这个过程来获取域管理员的权限，从而对域中的计算机和用户进行攻击。为了防护DCSYNC攻击，可以采取以下措施：</p><pre><code>1. 安装最新的安全补丁：确保所有的DC都安装了最新的安全补丁，以防止攻击者利用已知的漏洞进行攻击。2. 启用安全策略：启用安全策略，例如限制管理员的权限，以防止攻击者利用管理员权限进行攻击。3. 使用防火墙：使用防火墙来限制DC之间的通信，以防止攻击者利用通信过程进行攻击。4. 启用IPsec：启用IPsec来加密DC之间的通信，以防止攻击者截获通信内容。5. 启用身份验证：启用身份验证，例如使用Kerberos，以防止攻击者冒充域用户进行攻击。6. 定期审计：定期审计DC之间的通信，以及域用户的活动，以发现可能的攻击行为。</code></pre><h1 id="相关补充"><a href="#相关补充" class="headerlink" title="相关补充"></a>相关补充</h1><h2 id="域控制器"><a href="#域控制器" class="headerlink" title="域控制器"></a>域控制器</h2><p>域控制器（Domain Controller，DC）是一台服务器，管理网络和身份安全，有效地充当用户验证和授权进入域内 IT 资源的门卫。域控制器在微软目录服务术语中尤其重要，它是一台计算机，存储和管理域内的用户和计算机信息，以及网络上的其他信息。它负责为域内的用户和计算机提供身份验证和授权服务，并维护域内的安全性。</p><h2 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h2><p>Kerberos是一种网络认证协议，用于在网络上验证用户的身份。它使用一种称为“票据”的概念来实现身份验证，其中包含用户的身份信息和服务器的身份信息。当用户请求访问服务器时，它会向票据发行机（KDC）发送请求，请求一个票据。KDC会根据用户的身份信息和服务器的身份信息生成一个票据，并将其发送给用户。用户将票据发送给服务器，服务器会验证票据的有效性，并根据票据中的信息授予用户访问权限。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DCSYNC攻击&quot;&gt;&lt;a href=&quot;#DCSYNC攻击&quot; class=&quot;headerlink&quot; title=&quot;DCSYNC攻击&quot;&gt;&lt;/a&gt;DCSYNC攻击&lt;/h1&gt;&lt;p&gt;DCSYNC攻击是一种利用DC（域控制器）之间的同步过程来实现的攻击。攻击者可以利用这个过程</summary>
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/OS/Windows/"/>
    
    <category term="安全" scheme="http://example.com/categories/OS/Windows/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>windbg 分析实战</title>
    <link href="http://example.com/OS/Windows/Windbg/%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/OS/Windows/Windbg/%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/</id>
    <published>2023-09-19T01:05:07.687Z</published>
    <updated>2023-09-20T03:18:29.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Process-输出"><a href="#Process-输出" class="headerlink" title="!Process 输出"></a>!Process 输出</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; !process fffffa800c5c8060 3</span><br><span class="line">PROCESS fffffa800c5c8060</span><br><span class="line">    SessionId: 0  Cid: 06fc    Peb: 7fffffd4000  ParentCid: 025c</span><br><span class="line">    DirBase: 1f8dfb000  ObjectTable: fffff8a0020a44e0  HandleCount: 281.</span><br><span class="line">    Image: svchost.exe</span><br><span class="line">    VadRoot fffffa800c5c8570 Vads 128 Clone 0 Private 2532. Modified 992. Locked 0.</span><br><span class="line">    DeviceMap fffff8a001b400b0</span><br><span class="line">    Token                             fffff8a0020ac060</span><br><span class="line">    ElapsedTime                       00:06:27.486</span><br><span class="line">    UserTime                          00:00:00.046</span><br><span class="line">    KernelTime                        00:00:00.093</span><br><span class="line">    QuotaPoolUsage[PagedPool]         94704</span><br><span class="line">    QuotaPoolUsage[NonPagedPool]      32760</span><br><span class="line">    Working Set Sizes (now,min,max)  (4303, 50, 345) (17212KB, 200KB, 1380KB)</span><br><span class="line">    PeakWorkingSetSize                4717</span><br><span class="line">    VirtualSize                       57 Mb</span><br><span class="line">    PeakVirtualSize                   57 Mb</span><br><span class="line">    PageFaultCount                    6769</span><br><span class="line">    MemoryPriority                    BACKGROUND</span><br><span class="line">    BasePriority                      8</span><br><span class="line">    CommitCharge                      2766</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c5d0060  Cid 06fc.0700  Teb: 000007fffffde000 Win32Thread: fffff900c075cc10 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">            fffffa800c3d96a0  SynchronizationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c482060  Cid 06fc.0704  Teb: 000007fffffdc000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Alertable</span><br><span class="line">            fffffa800c471060  SynchronizationTimer</span><br><span class="line">            fffffa800c42d200  SynchronizationTimer</span><br><span class="line">            fffffa800c467680  SynchronizationEvent</span><br><span class="line">            fffffa800c48b440  SynchronizationEvent</span><br><span class="line">            fffffa800c47f1f0  SynchronizationEvent</span><br><span class="line">            fffffa800c534060  SynchronizationEvent</span><br><span class="line">            fffffa800c556060  SynchronizationEvent</span><br><span class="line">            fffffa800c5212f0  SynchronizationEvent</span><br><span class="line">            fffffa800c5213f0  SynchronizationEvent</span><br><span class="line">            fffffa800c41f5d0  SynchronizationTimer</span><br><span class="line">            fffffa800c4595d0  SynchronizationTimer</span><br><span class="line">            fffffa800c592240  SynchronizationEvent</span><br><span class="line">            fffffa800c593b00  ProcessObject</span><br><span class="line">            fffffa800c459550  SynchronizationEvent</span><br><span class="line">            fffffa800c59b400  SynchronizationEvent</span><br><span class="line">            fffffa800c3f6810  SynchronizationEvent</span><br><span class="line">            fffffa800c5a1120  SynchronizationEvent</span><br><span class="line">            fffffa800c5b5120  SynchronizationEvent</span><br><span class="line">            fffffa800c482610  SynchronizationTimer</span><br><span class="line">            fffffa800c466060  SynchronizationEvent</span><br><span class="line">            fffffa800c59b060  SynchronizationEvent</span><br><span class="line">            fffffa800c3ec2d0  SynchronizationEvent</span><br><span class="line">            fffffa800c466240  SynchronizationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c4ad370  Cid 06fc.0708  Teb: 000007fffffda000 Win32Thread: fffff900c07cac10 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">            fffffa800cbdf3e0  SynchronizationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c4a2060  Cid 06fc.0714  Teb: 000007fffff9e000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">            fffffa800c4a9110  NotificationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c537370  Cid 06fc.0718  Teb: 000007fffff9c000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">            fffffa80075eb840  NotificationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c54c370  Cid 06fc.0724  Teb: 000007fffff9a000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">            fffffa800c556140  NotificationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c54a060  Cid 06fc.072c  Teb: 000007fffffd6000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">            fffffa800c5386b0  SynchronizationEvent</span><br><span class="line">            fffffa800c521370  NotificationEvent</span><br><span class="line">            fffffa800c521140  NotificationEvent</span><br><span class="line">            fffffa800c54a5b0  NotificationEvent</span><br><span class="line">            fffffa800c543760  NotificationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c51e060  Cid 06fc.0734  Teb: 000007fffff96000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">            fffffa800b2f8600  SynchronizationEvent</span><br><span class="line">            fffffa800c5341d0  SynchronizationEvent</span><br><span class="line">            fffffa800c556620  SynchronizationEvent</span><br><span class="line">            fffffa800c583780  SynchronizationEvent</span><br><span class="line">            fffffa800c5ce280  SynchronizationEvent</span><br><span class="line">            fffffa800cbcf660  SynchronizationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c41e380  Cid 06fc.0754  Teb: 000007fffff94000 Win32Thread: 0000000000000000 WAIT: (WrLpcReply) UserMode Non-Alertable</span><br><span class="line">            fffffa800c41e748  Semaphore Limit 0x1</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c41f060  Cid 06fc.075c  Teb: 000007fffff90000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable</span><br><span class="line">            fffffa800c5b53c0  QueueObject</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c466300  Cid 06fc.0760  Teb: 000007fffff8e000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Alertable</span><br><span class="line">            fffffa800c3ec060  SynchronizationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800c461060  Cid 06fc.0764  Teb: 000007fffff8c000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">            fffffa800c41f790  SynchronizationEvent</span><br><span class="line">            fffffa800c41f810  NotificationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa8007c92060  Cid 06fc.00a0  Teb: 000007fffffd8000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable</span><br><span class="line">            fffffa800c3d9500  QueueObject</span><br><span class="line"></span><br><span class="line">        THREAD fffffa800780e640  Cid 06fc.19f0  Teb: 000007fffff98000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable</span><br><span class="line">            fffffa800c3d9500  QueueObject</span><br><span class="line"></span><br><span class="line">        THREAD fffffa80078fe650  Cid 06fc.1010  Teb: 000007fffff92000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable</span><br><span class="line">            fffffa800c3d9500  QueueObject</span><br><span class="line"></span><br><span class="line">        THREAD fffffa8007ebdb50  Cid 06fc.12e4  Teb: 000007fffff8a000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable</span><br><span class="line">            fffffa800d8a88c0  SynchronizationEvent</span><br><span class="line"></span><br><span class="line">        THREAD fffffa8008228b50  Cid 06fc.0e3c  Teb: 000007fffff88000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable</span><br><span class="line">            fffffa800c3d9500  QueueObject</span><br><span class="line"></span><br><span class="line">        THREAD fffffa8007800b50  Cid 06fc.0440  Teb: 000007fffff86000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable</span><br><span class="line">            fffffa800c3d9500  QueueObject</span><br></pre></td></tr></table></figure><p>这是Windows Debugger（WinDbg）中<code>!process</code>命令的输出，提供了关于特定进程的信息。<br>第一行显示了进程的ID，即<code>fffffa800c5c8060</code>。第二行显示了进程的会话ID，即<code>0</code>。第三行显示了调用进程的ID，即<code>025c</code>。<br>第四行显示了进程在内存中的基地址，即<code>1f8dfb000</code>。第五行显示了进程的对象表，即<code>ffff8a0020a44e0</code>。第六行显示了进程的句柄数，即<code>281</code>。<br>第七行显示了进程的图像，即<code>svchost.exe</code>。第八行显示了进程的虚拟地址根，即<code>ffffa800c5c8570</code>。第九行显示了进程中的VAD（虚拟地址目录）数，即<code>128</code>。第十行显示了进程是否为克隆进程，即<code>0</code>。第十一行显示了进程是否为私有进程，即<code>2532</code>。第十二行显示了进程的修改计数，即<code>992</code>。第十三行显示了进程的锁定计数，即<code>0</code>。<br>第十四行显示了进程的设备映射，即<code>ffff8a001b400b0</code>。第十五行显示了进程的令牌，即<code>ffff8a0020ac060</code>。第十六行显示了进程的运行时间，即<code>00:06:27.486</code>。第十七行显示了进程的用户时间，即<code>00:00:00.046</code>。第十八行显示了进程的内核时间，即<code>00:00:00.093</code>。第十九行显示了进程的配额池使用情况，即<code>94704</code>用于页面池和<code>32760</code>用于非页面池。第二十行显示了进程的工作集大小，即<code>4303</code>用于现在、<code>50</code>用于最小和<code>345</code>用于最大。第二十一行显示了进程的峰值工作集大小，即<code>4717</code>。第二十二行显示了进程的虚拟大小，即<code>57 MB</code>。第二十三行显示了进程的峰值虚拟大小，也是<code>57 MB</code>。第二十四行显示了进程的页面故障次数，即<code>6769</code>。第二十五行显示了进程的内存优先级，即<code>BACKGROUND</code>。第二十六行显示了进程的基本优先级，即<code>8</code>。第二十七行显示了进程的提交量，即<code>2766</code>。<br>最后一部分输出显示了进程的线程。每个线程都用一行表示，包括线程ID、Cid（连接ID）、Teb（线程环境块）和等待类型和等待的对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Process-输出&quot;&gt;&lt;a href=&quot;#Process-输出&quot; class=&quot;headerlink&quot; title=&quot;!Process 输出&quot;&gt;&lt;/a&gt;!Process 输出&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/OS/Windows/"/>
    
    <category term="Windbg" scheme="http://example.com/categories/OS/Windows/Windbg/"/>
    
    
  </entry>
  
  <entry>
    <title>windows进程间通信整理</title>
    <link href="http://example.com/OS/Windows/IPC/windows%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/OS/Windows/IPC/windows%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2023-09-18T09:47:55.967Z</published>
    <updated>2023-09-20T03:18:29.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：windows进程间通信的各种方式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A(windows进程间通信) --&gt; B[&quot;管道(pipe)&quot;]</span><br><span class="line">A --&gt; C[&quot;邮件槽(Mailslots)&quot;]</span><br><span class="line">A --&gt; D[&quot;文件映射(fileMapping)&quot;]</span><br><span class="line">A --&gt; E[&quot;信号量(Semaphore)&quot;]</span><br><span class="line">A --&gt; F[&quot;信号(signal)&quot;]</span><br><span class="line">A --&gt; G[&quot;套接字(Socket)&quot;]</span><br><span class="line">A --&gt; H[&quot;动态库(dll)&quot;]</span><br><span class="line">A --&gt; I[&quot;组件对象模型(COM)&quot;]</span><br><span class="line"></span><br><span class="line">B --&gt; B1[&quot;匿名管道(Anonymous pipe)&quot;]</span><br><span class="line">B --&gt; B2[&quot;命名管道(named pipe)&quot;]</span><br><span class="line"></span><br><span class="line">D --&gt; D1[&quot;共享内存(shared memory)&quot;]</span><br><span class="line"></span><br><span class="line">F --&gt; F1[&quot;windows没有信号这个概念，但是会提供类似功能的api，比如杀死进程。linux下的kill信号，windows下提供TerminateProcess&quot;]</span><br><span class="line"></span><br><span class="line">H --&gt; H1[&quot;地址无关代码：两个进程无法通过同一个dll进行数据交换&quot;]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：windows进程间通信的各种方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/OS/Windows/"/>
    
    <category term="IPC" scheme="http://example.com/categories/OS/Windows/IPC/"/>
    
    
    <category term="IPC" scheme="http://example.com/tags/IPC/"/>
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Win32多线程——线程同步之信号量（Semaphores）</title>
    <link href="http://example.com/OS/Windows/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8FSeamphorse/"/>
    <id>http://example.com/OS/Windows/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8FSeamphorse/</id>
    <published>2023-09-18T08:44:26.078Z</published>
    <updated>2023-09-20T03:18:29.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述： semaphores 的说明和使用</p><p>微软官方文档： </p><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/sync/semaphore-objects">Semaphore Objects - Win32 apps | Microsoft Learn</a></li></ul></blockquote><p>Semaphores是解决各种 producer&#x2F;consumer问题的关键要素。这种问题会存有一个缓冲区，可能在同一时间内被读出数据或被写入数据。</p><p>理论可以证明,mutex 是 semaphore 的一种退化。如果你产生一个semaphore 并令最大值为1,那就是一个 mutex。也因此, mutex又常被称为binary semaphore。在许多系统中, semaphores 常被使用, 因为 mutexes可能并不存在。在Win32中semaphores 被使用的情况就少得多，因为 mutex 存在的缘故。</p><h2 id="创建-semaphore"><a href="#创建-semaphore" class="headerlink" title="创建 semaphore"></a>创建 semaphore</h2><p><a href="https://learn.microsoft.com/zh-CN/windows/win32/api/winbase/nf-winbase-createsemaphorea">createSemaphoreA 函数 (winbase.h) - Win32 apps | Microsoft Learn</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">LPSECURITY_ATTRIBUTES lpAttributes,<span class="comment">// 安全属性, 可以设置NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">LONG lInitialCount,<span class="comment">// 初始值, [0, lMaximumCount]</span></span></span></span><br><span class="line"><span class="params"><span class="function">LONG lMaximumCount,<span class="comment">// 最大值, 这也就是在同一时间内能够锁住semaphore之线程的最多个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPCTSTR lpName<span class="comment">// 名称, 其他线程或进程可以根据名称引用该信号量; NULL则产生无名称信号量</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>如果成功就传回一个handle, 否则传回NULL. 不论哪一种情况,GetLastError()都会传回一个合理的结果. 如果指定的semaphore名称已经存在,则该函数还是成功的, GetLastError()会传回ERROR_ALREADY_EXISTS.</p><h2 id="获得-semaphore"><a href="#获得-semaphore" class="headerlink" title="获得 semaphore"></a>获得 semaphore</h2><blockquote><p> 通过信号量名，获得信号量对象句柄</p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-opensemaphorew">OpenSemaphoreW function (synchapi.h) - Win32 apps | Microsoft Learn</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenSemaphoreW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD   dwDesiredAccess, <span class="comment">// 访问权限，一般传入 SEMAPHORE_ALL_ACCESS </span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] BOOL    bInheritHandle, <span class="comment">// 信号量句柄继承性，一般传入TRUE即可</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCWSTR lpName <span class="comment">// 名称，不同进程中个线程可以通过名称来确保它们访问同一个信号量</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>semaphore的现值代表的意义是目前可用的资源数, 如果semaphore的现值为1, 表示还有一个锁定动作可以成功; 如果现值为5, 就表示还有五个锁定动作可以成功. 每当一个锁定动作成功, semaphore的现值就会减1. 你可以使用任何一种 <code>Wait()</code> 函数(例如 <code>WaitForSingleObject()</code> )要求锁定一个semaphore. 因此, 如果semaphore的现值不为0, <code>Wait()</code> 函数会立刻返回.<br>一个线程可以反复调用 <code>Wait()</code> 函数以产生新的锁定.  这和mutex绝不相同：拥有mutex的线程不论再调用多少次 <code>Wait()</code> 函数, 也不会被阻塞住。<br>一旦semaphore的现值降到0, 就表示资源已经耗尽. 此时, 任何线程如果调用Wait…()函数, 必然要等待, 直到某个锁定被解除为止.</p><h2 id="解除-semaphore"><a href="#解除-semaphore" class="headerlink" title="解除 semaphore"></a>解除 semaphore</h2><blockquote><p> 释放信号量</p><p> <a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-releasesemaphore">ReleaseSemaphore function (synchapi.h) - Win32 apps | Microsoft Learn</a></p><p> 注：传入的句柄必须有 <strong>SEMAPHORE_MODIFY_STATE</strong>  权限，参考 <a href="https://learn.microsoft.com/zh-cn/windows/win32/sync/synchronization-object-security-and-access-rights">同步对象安全性和访问权限 - Win32 apps | Microsoft Learn</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReleaseSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            HANDLE hSemaphore, <span class="comment">// 信号量的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            LONG   lReleaseCount, <span class="comment">// 表示增加个数，必须大于0且不超过最大资源数量</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] LPLONG lpPreviousCount <span class="comment">// 可以用来传出先前的资源计数，设为NULL表示不需要传出</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>ReleaseSemaphore函数会触发WaitForSingleObject函数。ReleaseSemaphore函数用于释放一个信号量对象的计数，而WaitForSingleObject函数用于等待一个信号量对象的计数。当ReleaseSemaphore函数被调用时，它会将信号量对象的计数增加，并且如果有一个线程正在等待这个信号量对象的计数，那么这个线程就会被唤醒。因此，ReleaseSemaphore函数会触发WaitForSingleObject函数。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="为什么-semaphore-要有一个初值"><a href="#为什么-semaphore-要有一个初值" class="headerlink" title="为什么 semaphore 要有一个初值"></a>为什么 semaphore 要有一个初值</h3><p>CreateSemaphore()的第二个参数是lInitialCount, 它的存在理由和CreateMutex()的bInitialOwner参数的存在理由是一样的. 如果你把初值设定为0, 你的线程就可以在产生semaphore之后进行所有必要的初始化工作. 待初始化工作完成后, 调用 ReleaseSemaphore()就可以把现值增加到其最大可能值.</p><h2 id="Demo-多线程同步"><a href="#Demo-多线程同步" class="headerlink" title="Demo 多线程同步"></a>Demo 多线程同步</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  </span></span><br><span class="line"><span class="type">long</span> g_nNum;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __stdcall <span class="title">Fun</span><span class="params">(<span class="type">void</span>* pPM)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_NUM = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//信号量与关键段  </span></span><br><span class="line">HANDLE            g_hThreadParameter;</span><br><span class="line">CRITICAL_SECTION  g_csThreadCode;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;     经典线程同步 信号量Semaphore\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化信号量和关键段  </span></span><br><span class="line">    g_hThreadParameter = <span class="built_in">CreateSemaphore</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NULL</span>);<span class="comment">//当前0个资源，最大允许1个同时访问  </span></span><br><span class="line">    <span class="built_in">InitializeCriticalSection</span>(&amp;g_csThreadCode);</span><br><span class="line"></span><br><span class="line">    HANDLE  handle[THREAD_NUM];</span><br><span class="line">    g_nNum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; THREAD_NUM)</span><br><span class="line">    &#123;</span><br><span class="line">        handle[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, Fun, &amp;i, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">WaitForSingleObject</span>(g_hThreadParameter, INFINITE);<span class="comment">//等待信号量&gt;0  </span></span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">WaitForMultipleObjects</span>(THREAD_NUM, handle, TRUE, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁信号量和关键段  </span></span><br><span class="line">    <span class="built_in">DeleteCriticalSection</span>(&amp;g_csThreadCode);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(g_hThreadParameter);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THREAD_NUM; i++)</span><br><span class="line">        <span class="built_in">CloseHandle</span>(handle[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __stdcall <span class="title">Fun</span><span class="params">(<span class="type">void</span>* pPM)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nThreadNum = *(<span class="type">int</span>*)pPM;</span><br><span class="line">    <span class="built_in">ReleaseSemaphore</span>(g_hThreadParameter, <span class="number">1</span>, <span class="literal">NULL</span>);<span class="comment">//信号量++  </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">50</span>);<span class="comment">//some work should to do  </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnterCriticalSection</span>(&amp;g_csThreadCode);</span><br><span class="line">    ++g_nNum;</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">0</span>);<span class="comment">//some work should to do  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程编号为%d  全局资源值为%d\n&quot;</span>, nThreadNum, g_nNum);</span><br><span class="line">    <span class="built_in">LeaveCriticalSection</span>(&amp;g_csThreadCode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述： semaphores 的说明和使用&lt;/p&gt;
&lt;p&gt;微软官方文档： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/sync/semaphore-o</summary>
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/OS/Windows/"/>
    
    <category term="多线程" scheme="http://example.com/categories/OS/Windows/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="semaphores" scheme="http://example.com/tags/semaphores/"/>
    
  </entry>
  
  <entry>
    <title>TEB (线程环境块)</title>
    <link href="http://example.com/OS/Windows/Windbg/TEB(%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%9D%97)/"/>
    <id>http://example.com/OS/Windows/Windbg/TEB(%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%9D%97)/</id>
    <published>2023-09-18T08:16:38.528Z</published>
    <updated>2023-09-20T03:18:29.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 概述：TEB（Thread <a href="https://so.csdn.net/so/search?q=Environment&spm=1001.2101.3001.7020">Environment</a> Block，线程环境块）指线程环境块，该结构体包含进程中运行线程的各种信息，进程中的每个线程都对应着一个TEB结构体。不同OS中TEB结构体的形态略微有点不同</p><p> 微软官方文档：</p><ul><li><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/debug/thread-environment-block--debugging-notes-">线程环境块 (调试说明) - Win32 apps | Microsoft Learn</a></p></li><li><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winternl/ns-winternl-teb">TEB (winternl.h) - Win32 apps | Microsoft Learn</a></p></li></ul></blockquote><p>[toc]</p><h1 id="TEB-结构体定义"><a href="#TEB-结构体定义" class="headerlink" title="TEB 结构体定义"></a>TEB 结构体定义</h1><h2 id="MSDN"><a href="#MSDN" class="headerlink" title="MSDN"></a>MSDN</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_TEB</span> &#123;</span><br><span class="line">  PVOID Reserved1[<span class="number">12</span>];</span><br><span class="line">  PPEB  ProcessEnvironmentBlock;</span><br><span class="line">  PVOID Reserved2[<span class="number">399</span>];</span><br><span class="line">  BYTE  Reserved3[<span class="number">1952</span>];</span><br><span class="line">  PVOID TlsSlots[<span class="number">64</span>];</span><br><span class="line">  BYTE  Reserved4[<span class="number">8</span>];</span><br><span class="line">  PVOID Reserved5[<span class="number">26</span>];</span><br><span class="line">  PVOID ReservedForOle;</span><br><span class="line">  PVOID Reserved6[<span class="number">4</span>];</span><br><span class="line">  PVOID TlsExpansionSlots;</span><br><span class="line">&#125; TEB, *PTEB;</span><br></pre></td></tr></table></figure><h2 id="Windows-XP-SP3"><a href="#Windows-XP-SP3" class="headerlink" title="Windows XP SP3"></a>Windows XP SP3</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">nt!_TEB</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x01c</span> EnvironmentPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> ClientId         : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x028</span> ActiveRpcHandle  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB</span><br><span class="line">   +<span class="number">0x034</span> LastErrorValue   : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> CsrClientThread  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Win32ThreadInfo  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> User32Reserved   : [<span class="number">26</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> UserReserved     : [<span class="number">5</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> WOW32Reserved    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0c4</span> CurrentLocale    : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> FpSoftwareStatusRegister : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> SystemReserved1  : [<span class="number">54</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0x1a4</span> ExceptionCode    : Int4B</span><br><span class="line">   +<span class="number">0x1a8</span> ActivationContextStack : _ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x1bc</span> SpareBytes1      : [<span class="number">24</span>] UChar</span><br><span class="line">   +<span class="number">0x1d4</span> GdiTebBatch      : _GDI_TEB_BATCH</span><br><span class="line">   +<span class="number">0x6b4</span> RealClientId     : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x6bc</span> GdiCachedProcessHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6c0</span> GdiClientPID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c4</span> GdiClientTID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c8</span> GdiThreadLocalInfo : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6cc</span> Win32ClientInfo  : [<span class="number">62</span>] Uint4B</span><br><span class="line">   +<span class="number">0x7c4</span> glDispatchTable  : [<span class="number">233</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xb68</span> glReserved1      : [<span class="number">29</span>] Uint4B</span><br><span class="line">   +<span class="number">0xbdc</span> glReserved2      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe0</span> glSectionInfo    : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe4</span> glSection        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe8</span> glTable          : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbec</span> glCurrentRC      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf0</span> glContext        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf4</span> LastStatusValue  : Uint4B</span><br><span class="line">   +<span class="number">0xbf8</span> StaticUnicodeString : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0xc00</span> StaticUnicodeBuffer : [<span class="number">261</span>] Uint2B</span><br><span class="line">   +<span class="number">0xe0c</span> DeallocationStack : Ptr32 Void</span><br><span class="line">   +<span class="number">0xe10</span> TlsSlots         : [<span class="number">64</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf10</span> TlsLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0xf18</span> Vdm              : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf1c</span> ReservedForNtRpc : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf20</span> DbgSsReserved    : [<span class="number">2</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf28</span> HardErrorsAreDisabled : Uint4B</span><br><span class="line">   +<span class="number">0xf2c</span> Instrumentation  : [<span class="number">16</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf6c</span> WinSockData      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf70</span> GdiBatchCount    : Uint4B</span><br><span class="line">   +<span class="number">0xf74</span> InDbgPrint       : UChar</span><br><span class="line">   +<span class="number">0xf75</span> FreeStackOnTermination : UChar</span><br><span class="line">   +<span class="number">0xf76</span> HasFiberData     : UChar</span><br><span class="line">   +<span class="number">0xf77</span> IdealProcessor   : UChar</span><br><span class="line">   +<span class="number">0xf78</span> Spare3           : Uint4B</span><br><span class="line">   +<span class="number">0xf7c</span> ReservedForPerf  : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf80</span> ReservedForOle   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf84</span> WaitingOnLoaderLock : Uint4B</span><br><span class="line">   +<span class="number">0xf88</span> Wx86Thread       : _Wx86ThreadState</span><br><span class="line">   +<span class="number">0xf94</span> TlsExpansionSlots : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0xf98</span> ImpersonationLocale : Uint4B</span><br><span class="line">   +<span class="number">0xf9c</span> IsImpersonating  : Uint4B</span><br><span class="line">   +<span class="number">0xfa0</span> NlsCache         : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa4</span> pShimData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa8</span> HeapVirtualAffinity : Uint4B</span><br><span class="line">   +<span class="number">0xfac</span> CurrentTransactionHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfb0</span> ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME</span><br><span class="line">   +<span class="number">0xfb4</span> SafeThunkCall    : UChar</span><br><span class="line">   +<span class="number">0xfb5</span> BooleanSpare     : [<span class="number">3</span>] UChar</span><br></pre></td></tr></table></figure><h3 id="各变量说明"><a href="#各变量说明" class="headerlink" title="各变量说明"></a>各变量说明</h3><p>“_TEB” 是一个Windows内核对象的结构体，用于描述一个线程的状态和信息。它包含了线程的一些基本信息，例如线程的堆栈指针、环境变量、堆栈大小等。<br>以下是 “_TEB” 结构体中的一些常用变量及其说明：</p><ul><li>*NtTeb: 指向当前线程的 “_TEB” 结构体的指针。</li><li>StackBase: 指向线程的堆栈起始地址。</li><li>StackLimit: 指向线程的堆栈结束地址。</li><li>StackReserveSize: 指定线程的堆栈大小。</li><li>EnvironmentPointer: 指向线程的环境变量的指针。</li><li>ThreadLocalStoragePointer: 指向线程的线程局部存储空间的指针。</li><li>*ProcessEnvironmentBlock: 指向进程的环境变量的指针。</li><li>BasePriority: 指定线程的优先级。</li><li>UniqueThreadID: 指定线程的唯一ID。</li><li>IdealProcessor: 指定线程的理想处理器。</li><li>IdealProcessorGroup: 指定线程的理想处理器组。</li><li>ThreadLocale: 指定线程的本地化信息。</li><li>ActiveStackAddress: 指向线程当前活跃的堆栈地址。</li><li>TlsSlots: 指向线程的线程局部存储空间的指针数组。</li><li>TlsExpansionSlots: 指定线程的线程局部存储空间的扩展槽数量。</li><li>Reserved: 保留字段。</li><li>Reserved2: 保留字段。</li></ul><p>这些变量可以用于查看和分析线程的状态和信息。您可以使用Windows调试工具中的 “dt” 命令查看这些变量的值和相关信息，例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dt</span> nt!_TEB &lt;teb_object&gt;</span><br></pre></td></tr></table></figure><p>其中 “<teb_object>“ 是线程的 “_TEB” 结构体的实例，例如 “fffffa800cd85b00”。这将显示线程的名称、大小、当前线程等信息。您可以根据需要进一步查看和分析这些信息。</p><h2 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h2><p>在用户模式调试中起着重要作用的成员有2个，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">………………………………………………………………………………</span><br><span class="line">+<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB</span><br></pre></td></tr></table></figure><h2 id="ProcessEnvironmentBlock成员："><a href="#ProcessEnvironmentBlock成员：" class="headerlink" title="ProcessEnvironmentBlock成员："></a>ProcessEnvironmentBlock成员：</h2><p>先看Offset 30处的ProcessEnvironmentBlock成员，它是指向PEB（Process Environment Block，进程环境块）结构体指针。PEB是进程环境块，每个进程对应1个PEB结构体。</p><h2 id="NtTib成员"><a href="#NtTib成员" class="headerlink" title="NtTib成员"></a>NtTib成员</h2><p><code>TEB</code>结构体的第一个成员为<code>_NT_TIB</code>结构体（<code>TIB</code>是Thread Information Block的简称，意为“线程信息块”），<code>_NT_TIB</code>结构体的定义如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_NT_TIB</span>          <span class="comment">//sizeof  1ch</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="number">00</span>h   <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span>  *ExceptionList;          <span class="comment">//SEH链入口</span></span><br><span class="line"> <span class="number">04</span>h   PVOID                            StackBase;              <span class="comment">//堆栈基址</span></span><br><span class="line"> <span class="number">08</span>h   PVOID                            StackLimit;             <span class="comment">//堆栈大小</span></span><br><span class="line"> <span class="number">0</span>ch   PVOID                            SubSystemTib;</span><br><span class="line">       <span class="keyword">union</span> &#123;</span><br><span class="line">           PVOID                FiberData;</span><br><span class="line"> <span class="number">10</span>h       DWORD                Version;</span><br><span class="line">       &#125;;</span><br><span class="line"> <span class="number">14</span>h   PVOID                            ArbitraryUserPointer;</span><br><span class="line"> <span class="number">18</span>h   <span class="keyword">struct</span> <span class="title class_">_NT_TIB</span>                   *Self;                  <span class="comment">//本NT_TIB结构自身的线性地址</span></span><br><span class="line">&#125;NT_TIB;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span>     NT_TIB      *PNT_TIB;</span><br></pre></td></tr></table></figure><p>ExceptionList成员指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，它用于Windows OS的SEH。Self成员是_NT_TIB结构体的自引用指针，也是TEB结构体的指针（因为TEB结构体的第一个成员就是_NT_TIB结构体）。那么我们如何在用户模式下访问到TEB结构体呢？只有访问它才能使用相应信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 概述：TEB（Thread &lt;a href=&quot;https://so.csdn.net/so/search?q=Environment&amp;spm=1001.2101.3001.7020&quot;&gt;Environment&lt;/a&gt; Block，线程环境块）指线程</summary>
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/OS/Windows/"/>
    
    <category term="Windbg" scheme="http://example.com/categories/OS/Windows/Windbg/"/>
    
    
  </entry>
  
  <entry>
    <title>windbg内核调试</title>
    <link href="http://example.com/OS/Windows/Windbg/windbg%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/"/>
    <id>http://example.com/OS/Windows/Windbg/windbg%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95/</id>
    <published>2023-09-18T06:41:17.366Z</published>
    <updated>2023-09-20T03:18:29.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：</p><p>参考：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/getting-started-with-windbg--kernel-mode-">WinDbg (内核模式) 入门 - Windows drivers | Microsoft Learn</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/getting-started-with-windbg--kern</summary>
      
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/OS/Windows/"/>
    
    <category term="Windbg" scheme="http://example.com/categories/OS/Windows/Windbg/"/>
    
    
  </entry>
  
  <entry>
    <title>netsh 抓包</title>
    <link href="http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E6%8A%93%E5%8C%85/netsh%E6%8A%93%E5%8C%85/"/>
    <id>http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E6%8A%93%E5%8C%85/netsh%E6%8A%93%E5%8C%85/</id>
    <published>2023-09-18T05:27:41.919Z</published>
    <updated>2023-09-18T05:27:41.919Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：windows系统下使用 <code>netsh</code> 命令抓包</p></blockquote><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1-打开管理员命令行"><a href="#1-打开管理员命令行" class="headerlink" title="1 打开管理员命令行"></a>1 打开管理员命令行</h2><p><kbd>win</kbd> -&gt; 输入 <code>cmd</code> -&gt; <kbd>以管理员身份运行</kbd></p><img src="images/netsh%E6%8A%93%E5%8C%85/image-20230825214027512.png" alt="image-20230825214027512" style="zoom:67%;" /><h2 id="2-输入以下命令开始抓包"><a href="#2-输入以下命令开始抓包" class="headerlink" title="2 输入以下命令开始抓包"></a>2 输入以下命令开始抓包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh trace start capture=YES report=YES persistent=YES</span><br></pre></td></tr></table></figure><p>运行成功后，如下所示</p><p><img src="/images/netsh%E6%8A%93%E5%8C%85/image-20230825214252186.png" alt="运行示例"></p><h2 id="3-运行-零信任客户端"><a href="#3-运行-零信任客户端" class="headerlink" title="3 运行 零信任客户端"></a>3 运行 零信任客户端</h2><p>连接tac，直到复现敲门失败情况</p><h2 id="4-回到-cmd-界面"><a href="#4-回到-cmd-界面" class="headerlink" title="4 回到 cmd 界面"></a>4 回到 <code>cmd</code> 界面</h2><p>键入并回车以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh trace stop</span><br></pre></td></tr></table></figure><p>回车后稍等一会，界面上会输出以下内容，将图示路径文件收集即可。</p><p><img src="/images/netsh%E6%8A%93%E5%8C%85/image-20230825214449220.png" alt="运行示例"></p><h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etl2pcapng.exe nettrace.etl nettrace.cap</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：windows系统下使用 &lt;code&gt;netsh&lt;/code&gt; 命令抓包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h1</summary>
      
    
    
    
    <category term="网络通信" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    <category term="抓包" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/SOCKET%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0(CC++)/"/>
    <id>http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/SOCKET%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0(CC++)/</id>
    <published>2023-09-18T05:27:41.913Z</published>
    <updated>2023-09-18T05:27:41.913Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Windows 下 Socket相关</p></blockquote><h1 id="一、socket-函数-创建套接字"><a href="#一、socket-函数-创建套接字" class="headerlink" title="一、socket()函数 创建套接字"></a>一、socket()函数 创建套接字</h1><p>Windows 不把套接字作为普通文件对待，而是返回 SOCKET 类型的句柄。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>实例，创建TCP套接字：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//创建TCP套接字</span></span><br></pre></td></tr></table></figure><h1 id="二、bind"><a href="#二、bind" class="headerlink" title="二、bind()"></a>二、bind()</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(SOCKET sock, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure><p><code>sock </code>为 socket 文件描述符<br><code>addr </code>为 sockaddr 结构体变量的指针<br><code>addrlen </code>为 addr 变量的大小，可由 sizeof() 计算得出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建套接字</span></span><br><span class="line">SOCKET servSock = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定套接字</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sockAddr;</span><br><span class="line"><span class="built_in">memset</span> (&amp;sockAddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(sockAddr)); <span class="comment">// 每个套接字都用0填充</span></span><br><span class="line">sockAddr.sin_family = PF_INET; <span class="comment">// 使用IPv4地址</span></span><br><span class="line">sockAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);<span class="comment">// 端口</span></span><br><span class="line"><span class="built_in">bind</span>(servSock, (SOCKADDR*)&amp;sockAddr, <span class="built_in">sizeof</span>(SOCKADDR));</span><br></pre></td></tr></table></figure><h4 id="sockaddr结构体"><a href="#sockaddr结构体" class="headerlink" title="sockaddr结构体"></a>sockaddr结构体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span>  sin_family;   <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="type">char</span>         sa_data[<span class="number">14</span>];  <span class="comment">//IP地址和端口号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="sockaddr-in-结构体"><a href="#sockaddr-in-结构体" class="headerlink" title="sockaddr_in 结构体"></a>sockaddr_in 结构体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span>     sin_family;   <span class="comment">//地址族（Address Family），也就是地址类型</span></span><br><span class="line">    <span class="type">uint16_t</span>        sin_port;     <span class="comment">//16位的端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span>  sin_addr;     <span class="comment">//32位IP地址</span></span><br><span class="line">    <span class="type">char</span>            sin_zero[<span class="number">8</span>];  <span class="comment">//不使用，一般用0填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>sin_family </code>和<code>socket()</code>的第一个参数的含义相同，取值也要保持一致。</li><li><code>sin_prot </code>为端口号。uint16_t 的长度为两个字节，理论上端口号的取值范围为 0<del>65536，但 0</del>1023 的端口一般由系统分配给特定的服务程序，例如 Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在 1024~65536 之间分配端口号。端口号需要用 <code>htons() </code>函数转换，后面会讲解为什么。</li><li><code>sin_addr </code>是 struct in_addr 结构体类型的变量，下面会详细讲解。</li><li><code>sin_zero[8]</code>是多余的8个字节，没有用，一般使用<code> memset()</code> 函数填充为 0。上面的代码中，先用 <code>memset()</code> 将结构体的全部字节填充为 0，再给前3个成员赋值，剩下的 <code>sin_zero </code>自然就是 0 了。</li></ol><h4 id="in-addr-结构体"><a href="#in-addr-结构体" class="headerlink" title="in_addr 结构体"></a>in_addr 结构体</h4><p>sockaddr_in 的第3个成员是 in_addr 类型的结构体，该结构体只包含一个成员，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">    <span class="type">in_addr_t</span>  s_addr;  <span class="comment">//32位的IP地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>in_addr_t </code>在头文件 &lt;netinet&#x2F;in.h&gt; 中定义，等价于 unsigned long，长度为4个字节。也就是说，<code>s_addr </code>是一个整数，而IP地址是一个字符串，所以需要** inet_addr() **函数进行转换，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ip = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, ip);</span><br></pre></td></tr></table></figure><p>运行结果：<br><code>16777343</code></p><h1 id="三、connect-函数"><a href="#三、connect-函数" class="headerlink" title="三、connect() 函数"></a>三、connect() 函数</h1><p>参数与<code>bind()</code>相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(SOCKET sock, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">int</span> addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure><h1 id="四、listen-函数"><a href="#四、listen-函数" class="headerlink" title="四、listen() 函数"></a>四、listen() 函数</h1><p>通过 listen() 函数可以让套接字进入被动监听状态，它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(SOCKET sock, <span class="type">int</span> backlog)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure><p><code>sock </code>为需要进入监听状态的套接字，<code>backlog </code>为请求队列的最大长度。</p><p><strong>被动监听：</strong>是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。<br>如果将 backlog 的值设置为 <strong>SOMAXCONN</strong>，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。<br>当请求队列满时，就不再接收新的请求，对于 <strong>Linux</strong>，客户端会收到 **ECONNREFUSED **错误，对于 <strong>Windows</strong>，客户端会收到 **WSAECONNREFUSED **错误。<br><strong>注意：</strong><code>listen()</code>只是让套接字处于监听状态，并没有接收请求。接收请求需要使用<code>accept()</code>函数。</p><h1 id="五、accept-函数"><a href="#五、accept-函数" class="headerlink" title="五、accept() 函数"></a>五、accept() 函数</h1><p>当套接字处于监听状态时，可以通过 <code>accept()</code>函数来接收客户端请求。它的原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(SOCKET sock, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span></span>;  <span class="comment">//Windows</span></span><br></pre></td></tr></table></figure><p>它的参数与 listen() 和 connect() 是相同的：<code>sock</code>为服务器端套接字，<code>addr</code>为 sockaddr_in 结构体变量，<code>addrlen</code>为参数 addr 的长度，可由 <code>sizeof()</code> 求得。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Windows 下 Socket相关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、socket-函数-创建套接字&quot;&gt;&lt;a href=&quot;#一、socket-函数-创建套接字&quot; class=&quot;headerlink&quot; title=&quot;一、soc</summary>
      
    
    
    
    <category term="网络通信" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>IO多路复用</title>
    <link href="http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2023-09-18T05:27:41.912Z</published>
    <updated>2023-09-18T05:27:41.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近面试，岗位是安全开发岗。问了较多的网络相关函数。其中关于io多路复用的问题，由于工作中涉及的比较少，回答的一塌糊涂。知耻而后勇，专门整理一遍记录一下这个知识点吧</p><p>主要是之前还专门写过一遍笔记用来记录当时的学习情况，还写的挺详细！！！</p><p><a href="https://blog.csdn.net/Fuel_Ming/article/details/122931926">【一文搞懂】FD_SET的使用_欧恩意的博客-CSDN博客</a></p></blockquote><p>[toc]</p><h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>顾名思义，就是可以多个可以重复使用的io（输入\输出）。</p><ul><li><p>多路：核心需求是要用尽可能少的线程来处理尽可能多的连接，这里的多路是指需要处理的众多连接。</p></li><li><p>复用：核心需求是要求使用尽可能少的线程，尽可能减少系统开销去处理尽可能多的连接，那么这个复用是指利用有限的资源。也就是说利用有限的资源去处理尽可能多的任务。例如：在阻塞IO中，一个连接需要一个线程去处理，但是在IO多路复用的模型中，则可以使用一个线程去处理多个任务。</p></li></ul><p>参考及引用：</p><ul><li><a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.XYD0TygzaUl">Linux – IO Multiplexing – Select vs Poll vs Epoll – Developers Area</a></li><li><a href="https://notes.shichao.io/unp/ch6/">Chapter 6. I&#x2F;O Multiplexing: The select and poll Functions - Shichao’s Notes</a></li><li><a href="https://www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/">select &#x2F; poll &#x2F; epoll: practical difference for system architects | UlduzSoft</a></li><li><a href="https://www.bilibili.com/video/BV1qJ411w7du/?spm_id_from=333.880.my_history.page.click&vd_source=2d8da596010444663e6f18397a9e3505">【并发】IO多路复用select&#x2F;poll&#x2F;epoll介绍_哔哩哔哩_bilibili</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近面试，岗位是安全开发岗。问了较多的网络相关函数。其中关于io多路复用的问题，由于工作中涉及的比较少，回答的一塌糊涂。知耻而后勇，专门整理一遍记录一下这个知识点吧&lt;/p&gt;
&lt;p&gt;主要是之前还专门写过一遍笔记用来记录当时的学习情况，还写的挺详细！！</summary>
      
    
    
    
    <category term="网络通信" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
    <category term="IO复用" scheme="http://example.com/tags/IO%E5%A4%8D%E7%94%A8/"/>
    
    <category term="wanlguo" scheme="http://example.com/tags/wanlguo/"/>
    
  </entry>
  
  <entry>
    <title>域名解析相关经验</title>
    <link href="http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/DNS/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/DNS/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86/</id>
    <published>2023-09-18T05:27:41.912Z</published>
    <updated>2023-09-18T05:27:41.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>整理记录排查网络问题事的域名解析相关问题</p></blockquote><p>[toc]</p><h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><h2 id="A-和-AAAA"><a href="#A-和-AAAA" class="headerlink" title="A 和 AAAA"></a><code>A</code> 和 <code>AAAA</code></h2><p><code>A</code> 和 <code>AAAA</code> 都是DNS记录，它们的作用是将域名解析到IP地址。具体来说，A记录将域名解析到IPv4地址，而AAAA记录将域名解析到IPv6地址。</p><p>因此，主要的区别在于 <code>A</code> 记录用于IPv4，而 <code>AAAA</code> 记录用于IPv6。</p><h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><h2 id="设置域名工具"><a href="#设置域名工具" class="headerlink" title="设置域名工具"></a>设置域名工具</h2><blockquote><p>常见方式是在网卡的配置界面设置 <code>dns</code> 服务器，在高级页面可以配置多个 <code>DNS</code> 服务器。但是，在特殊环境：</p><p>如使用 <code>netsh</code> 命令设置的静态 <code>dns</code> 服务器等与用户手动添加的 <code>dns</code> 一样时，可能会出现 <code>dns</code> 解析异常的问题。</p></blockquote><ul><li><code>quicksetdns_sec</code>工具:<a href="https://www.appinn.com/quicksetdns/">QuickSetDNS - 快速修改 DNS 服务器工具 - 小众软件</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;整理记录排查网络问题事的域名解析相关问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;基础知识点&quot;&gt;&lt;a href=&quot;#基础知识点&quot; class=&quot;headerlink&quot; title=&quot;基础知识点&quot;&gt;&lt;/a&gt;基础知</summary>
      
    
    
    
    <category term="网络通信" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    <category term="DNS" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/DNS/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="DNS" scheme="http://example.com/tags/DNS/"/>
    
    <category term="域名" scheme="http://example.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>查看浏览器DNS缓存</title>
    <link href="http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/DNS/%E6%9F%A5%E7%9C%8B%E6%B5%8F%E8%A7%88%E5%99%A8DNS%E7%BC%93%E5%AD%98/"/>
    <id>http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/DNS/%E6%9F%A5%E7%9C%8B%E6%B5%8F%E8%A7%88%E5%99%A8DNS%E7%BC%93%E5%AD%98/</id>
    <published>2023-09-18T05:27:41.912Z</published>
    <updated>2023-09-18T05:27:41.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：本文主要介绍如何在浏览器查看DNS缓存，同时罗列了DNS查询的一些顺序</p></blockquote><p>[toc]</p><h1 id="DNS-缓存与解析"><a href="#DNS-缓存与解析" class="headerlink" title="DNS 缓存与解析"></a>DNS 缓存与解析</h1><h2 id="DNS-缓存分类"><a href="#DNS-缓存分类" class="headerlink" title="DNS 缓存分类"></a>DNS 缓存分类</h2><h4 id="1、浏览器缓存"><a href="#1、浏览器缓存" class="headerlink" title="1、浏览器缓存"></a>1、浏览器缓存</h4><p>浏览器会根据一定频率缓存DNS记录；</p><h4 id="2、本地DNS缓存"><a href="#2、本地DNS缓存" class="headerlink" title="2、本地DNS缓存"></a>2、本地DNS缓存</h4><p>如果浏览器缓存中找不到解析记录，就会去询问操作系统中的缓存；</p><h4 id="3、本地HOSTS文件"><a href="#3、本地HOSTS文件" class="headerlink" title="3、本地HOSTS文件"></a>3、本地HOSTS文件</h4><p>HOSTS是记录域名与IP地址一一映射关系的本地文件，Windows系统中位于 <code>C:\Windows\System32\drivers\etc</code></p><h4 id="4、路由器DNS缓存"><a href="#4、路由器DNS缓存" class="headerlink" title="4、路由器DNS缓存"></a>4、路由器DNS缓存</h4><p>我们常用的路由器也带有自动缓存功能，路由器DNS被篡改会造成域名劫持，将访问网址定位到另外一个服务器；</p><h4 id="5、递归服务器缓存"><a href="#5、递归服务器缓存" class="headerlink" title="5、递归服务器缓存"></a>5、递归服务器缓存</h4><p>递归服务器在将解析结果告知客户端的同时，将记录缓存下来，当下次请求同一个域名时，直接会将记录返回，而无需再进行全球查询。</p><h2 id="DNS-解析顺序"><a href="#DNS-解析顺序" class="headerlink" title="DNS 解析顺序"></a>DNS 解析顺序</h2><p>DNS解析顺序是 “先查缓存，再递归解析”，查询顺序为：浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存 -&gt; 递归服务器缓存 -&gt; 递归查询</p><p>以 <code>www.baidu.com</code> 这个域名为例进行查询，具体流程如下：</p><h3 id="1-搜索浏览器自带的DNS缓存"><a href="#1-搜索浏览器自带的DNS缓存" class="headerlink" title="1. 搜索浏览器自带的DNS缓存"></a>1. 搜索浏览器自带的DNS缓存</h3><blockquote><p>当收到访问请求后，浏览器首先会查询浏览器自身的DNS缓存，这个缓存时间比较短（chrome:&#x2F;&#x2F;net-internals&#x2F;#dns 这里可以查询缓存的dns记录），且只能容纳 1000条缓存，如果缓存中有对应条目，返回结果，解析到此结束。</p></blockquote><p>在chrome打开 <code>chrome://net-internals/#dns</code> </p><p><img src="/images/%E6%9F%A5%E7%9C%8B%E6%B5%8F%E8%A7%88%E5%99%A8DNS%E7%BC%93%E5%AD%98/1.png" alt="image-20230822093936706"></p><p>如上所示，浏览器解析到了 <code>www.baidu.com</code> 的ip</p><h3 id="2-查询操作系统缓存和hosts本地文件"><a href="#2-查询操作系统缓存和hosts本地文件" class="headerlink" title="2. 查询操作系统缓存和hosts本地文件"></a>2. 查询操作系统缓存和hosts本地文件</h3><blockquote><p>如果浏览器缓存中没有找到对应条目（<code>ipconfig/displaydns</code>可以查看），操作系统也会有一个域名解析的过程，浏览器会先搜索操作系统的DNS缓存中是否有这个域名解析记录，如果有返回结果，解析结束。</p><p>此外，电脑本地文件HOSTS中可以设定域名到IP地址的指向关系。如果HOSTS文件中保存有该域名的记录，浏览器会首先使用这个IP地址，并将其结果缓存下来，缓存时间同样受域名失效时间和缓存空间大小决定。</p></blockquote><h3 id="3-查询路由器缓存"><a href="#3-查询路由器缓存" class="headerlink" title="3. 查询路由器缓存"></a>3. 查询路由器缓存</h3><blockquote><p>如果浏览器和操作系统中没有域名解析记录，就会查询路由器中的DNS缓存，如果路由器DNS缓存中有解析条目，直接返回结果，解析结束。</p></blockquote><h3 id="4-递归解析服务器缓存"><a href="#4-递归解析服务器缓存" class="headerlink" title="4. 递归解析服务器缓存"></a>4. 递归解析服务器缓存</h3><blockquote><p>如果本机和路由器DNS缓存中没有该域名的解析记录，浏览器就会向递归服务器发起请求，如果递归服务器缓存有该域名解析条目，返回结果，解析结束。</p></blockquote><h3 id="5-查询根域名服务器"><a href="#5-查询根域名服务器" class="headerlink" title="5. 查询根域名服务器"></a>5. 查询根域名服务器</h3><blockquote><p>如果递归服务器缓存中没有结果，就会委托递归服务器发起全球查询，首先递归服务器会向根域名服务器发起解析请求。根域名服务器告知.com顶级域名服务器地址。</p></blockquote><h3 id="6-查询顶级域名服务器"><a href="#6-查询顶级域名服务器" class="headerlink" title="6. 查询顶级域名服务器"></a>6. 查询顶级域名服务器</h3><blockquote><p>递归服务器向.com顶级域名服务器发起DNS请求，.com顶级服务器告知example.com所属权威域名服务器地址。</p></blockquote><h3 id="7-查询权威域名服务器"><a href="#7-查询权威域名服务器" class="headerlink" title="7. 查询权威域名服务器"></a>7. 查询权威域名服务器</h3><blockquote><p>递归服务器向example.com的权威域名服务器地址发起请求，权威服务器告知<a href="http://www.example.com所对应的ip地址./">www.example.com所对应的IP地址。</a></p></blockquote><h3 id="8-返回解析结果"><a href="#8-返回解析结果" class="headerlink" title="8. 返回解析结果"></a>8. 返回解析结果</h3><blockquote><p>得到<a href="http://www.example.com的ip地址后,递归服务器将结果告知客户端,客户端对该ip地址发起访问.整个dns解析流程到此结束./">www.example.com的IP地址后，递归服务器将结果告知客户端，客户端对该IP地址发起访问。整个DNS解析流程到此结束。</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：本文主要介绍如何在浏览器查看DNS缓存，同时罗列了DNS查询的一些顺序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;DNS-缓存与解析&quot;&gt;&lt;a href=&quot;#DNS-缓存与解析&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="网络通信" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    <category term="DNS" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/DNS/"/>
    
    
    <category term="DNS" scheme="http://example.com/tags/DNS/"/>
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>DNS用的是TCP协议还是UDP协议</title>
    <link href="http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/DNS/DNS%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/DNS/DNS%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-09-18T05:27:41.911Z</published>
    <updated>2023-09-18T05:27:41.911Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述: 关于 DNS 使用的是 TCP 还是 UDP 的说明</p><p>DNS缓存问题可以看这篇文章 <a href="./%E6%9F%A5%E7%9C%8B%E6%B5%8F%E8%A7%88%E5%99%A8DNS%E7%BC%93%E5%AD%98.md">【查看浏览器DNS缓存】</a></p></blockquote><p>[toc]</p><h1 id="DNS概述"><a href="#DNS概述" class="headerlink" title="DNS概述"></a>DNS概述</h1><p>DNS占用53号端口，同时使用TCP和UDP协议。</p><p>📌 那么DNS在什么情况下使用这两种协议？</p><ul><li><p>DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。</p></li><li><p>DNS区域传输的时候使用TCP协议：</p><ol><li><p>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</p></li><li><p>TCP是一种可靠连接，保证了数据的准确性。</p></li></ol></li></ul><p>🎃 域名解析时使用UDP协议：</p><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p><h1 id="DNS为什么用TCP和UDP"><a href="#DNS为什么用TCP和UDP" class="headerlink" title="DNS为什么用TCP和UDP"></a>DNS为什么用TCP和UDP</h1><p>DNS同时占用UDP和TCP端口53是公认的，这种单个应用协议同时使用两种传输协议的情况在TCP&#x2F;IP栈也算是个另类。但很少有人知道DNS分别在什么情况下使用这两种协议。</p><h2 id="先简单介绍下TCP与UDP"><a href="#先简单介绍下TCP与UDP" class="headerlink" title="先简单介绍下TCP与UDP"></a>先简单介绍下TCP与UDP</h2><blockquote><p>TCP是一种面向连接的协议，提供可靠的数据传输，一般服务质量要求比较高的情况，使用这个协议。UDP—用户数据报协议，是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p></blockquote><h4 id="TCP与UDP的区别："><a href="#TCP与UDP的区别：" class="headerlink" title="TCP与UDP的区别："></a>TCP与UDP的区别：</h4><p>UDP和TCP协议的主要区别是两者在如何实现信息的<span style="class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;">可靠传递</span>方面不同。TCP协议中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。 与TCP不同，UDP协议并不提供数据传送的保证机制。如果在从发送方到接收方的传递过程中出现数据报的丢失，协议本身并不能做出任何检测或提示。因此，通常人们把UDP协议称为不可靠的传输协议。相对于TCP协议，UDP协议的另外一个不同之处在于如何接收突发性的多个数据报。不同于TCP，UDP并不能确保数据的发送和接收顺序。事实上，UDP协议的这种乱序性基本上很少出现，通常只会在网络非常拥挤的情况下才有可能发生。</p><blockquote><p>既然UDP是一种不可靠的网络协议，那么还有什么使用价值或必要呢？</p><blockquote><p>其实不然，在有些情况下UDP协议可能会变得非常有用。因为UDP具有TCP所望尘莫及的速度优势。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。反观UDP由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。</p></blockquote></blockquote><p>DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；<br>DNS的规范规定了2种类型的DNS服务器，一个叫<span style="class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;">主DNS服务器</span>，一个叫<span style="class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;">辅助DNS服务器</span>。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。</p><h4 id="为什么既使用TCP又使用UDP？"><a href="#为什么既使用TCP又使用UDP？" class="headerlink" title="为什么既使用TCP又使用UDP？"></a>为什么既使用TCP又使用UDP？</h4><p>首先了解一下TCP与UDP传送字节的长度限制：</p><p>UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。</p><p>区域传送时使用TCP，主要有一下两点考虑：</p><ol><li><p>辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。</p></li><li><p>TCP是一种可靠的连接，保证了数据的准确性。</p></li></ol><h3 id="域名解析时使用UDP协议："><a href="#域名解析时使用UDP协议：" class="headerlink" title="域名解析时使用UDP协议："></a>域名解析时使用UDP协议：</h3><p>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><blockquote><p>UDP 与 TCP 的主要区别在于 UDP 不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP 在许多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。ICQ 短消息使用 UDP 协议发送消息。</p></blockquote><p>许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。记住，较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。</p><p>为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。</p><h2 id="TCP与UDP的选择"><a href="#TCP与UDP的选择" class="headerlink" title="TCP与UDP的选择"></a>TCP与UDP的选择</h2><p>如果比较UDP包和TCP包的结构，很明显UDP包不具备TCP包复杂的可靠性与控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。）</p><p>很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是当然的选择。当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择，如：DNS交换。把SNMP建立在UDP上的部分原因是设计者认为当发生网络阻塞时，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点连接将会用于绝大多数的网络应用。</p><h4 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。</p><p>一个TCP连接必须要经过三次“对话”才能建立起来。三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。</p><h4 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h4><p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！</p><p>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP&#x2F;IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包（如图2所示）。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。HTTP是用TCP协议传输的。</p><h2 id="TCP协议与UDP协议的区别"><a href="#TCP协议与UDP协议的区别" class="headerlink" title="TCP协议与UDP协议的区别"></a>TCP协议与UDP协议的区别</h2><p>TCP基于<strong>面向连接的协议</strong>，数据传输<strong>可靠</strong>，<strong>传输速度慢</strong>，适用于<strong>传输大量数据</strong>，可靠性要求高的场合。</p><p>UDP协议<strong>面向非连接协议</strong>，数据传输不可靠，<strong>传输速度快</strong>，适用于<strong>一次只传送少量数据</strong>、对可靠性要求不高的应用环境。</p><h4 id="面向连接的TCP"><a href="#面向连接的TCP" class="headerlink" title="面向连接的TCP"></a>面向连接的TCP</h4><p>“面向连接”就是在正式通信前必须要与对方建立起连接。比如你给别人打电话，必须等线路接通了、对方拿起话筒才能相互通话。</p><p>TCP协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高的数据通信系统往往使用TCP协议传输数据。</p><h4 id="面向非连接的UDP协议"><a href="#面向非连接的UDP协议" class="headerlink" title="面向非连接的UDP协议"></a>面向非连接的UDP协议</h4><p>“面向非连接“就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。这与现在风行的手机短信非常相似：你在发短信的时候，只需要输入对方手机号就OK了。</p><p>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境</p><p>UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。</p><h4 id="TCP协议与UDP协议支持的应用协议"><a href="#TCP协议与UDP协议支持的应用协议" class="headerlink" title="TCP协议与UDP协议支持的应用协议"></a>TCP协议与UDP协议支持的应用协议</h4><p>TCP支持的应用协议主要有：<strong>Telnet、FTP、SMTP</strong> 等；<br>UDP支持的应用层协议主要有：<strong>NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）</strong>等。</p><p>TCP和UDP都是位于OSI模型中的传输层中。</p><p>📢 <strong>TCP优点</strong>：面向连接的,具有实时性,就象打电话一样,两者必须建立连接.<br>它保证你所传输的东西是准确到达的,并且收方要给你一个收到或没有\收到的回复,所以它具有安全性的特点..<br>📢 <strong>UDP优点</strong>：面向无连接的,就象给某人寄信一样,对方不需要在邮局等着你的信到.<br>所以说,它没有保障性,不能确保你一定能收到信,不象TCP那样,,但是 它比TCP好的一点,就是速度快,因为他不需要双方交流是否收到,对发的东西有一个确认的过程.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述: 关于 DNS 使用的是 TCP 还是 UDP 的说明&lt;/p&gt;
&lt;p&gt;DNS缓存问题可以看这篇文章 &lt;a href=&quot;./%E6%9F%A5%E7%9C%8B%E6%B5%8F%E8%A7%88%E5%99%A8DNS%E7%BC%93%E5</summary>
      
    
    
    
    <category term="网络通信" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    <category term="DNS" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/DNS/"/>
    
    
    <category term="DNS" scheme="http://example.com/tags/DNS/"/>
    
    <category term="UDP" scheme="http://example.com/tags/UDP/"/>
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>DDoS攻击</title>
    <link href="http://example.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DDoS%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DDoS%E6%94%BB%E5%87%BB/</id>
    <published>2023-09-18T05:27:41.910Z</published>
    <updated>2023-09-18T05:27:41.911Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：DDoS() 技术鉴赏</p></blockquote><p>[toc]</p><h1 id="DDoS说明"><a href="#DDoS说明" class="headerlink" title="DDoS说明"></a>DDoS说明</h1><blockquote><p>DDoS(Distributed Denial of Service)即分布式拒绝服务攻击,是一种通过大量占用目标服务器资源的方式,使服务暂时中断或停止,无法对正常用户提供服务的攻击手段。</p></blockquote><p>DDoS攻击的主要特征包括:</p><blockquote><ul><li>分布式 - 利用大量分布在不同地点的攻击源进行攻击。</li><li>流量泛滥 - 通过发送大量流量淹没目标服务器的带宽或资源。常见的有UDP flood、ICMP flood等。</li><li>资源耗尽 - 占用目标服务器的关键系统资源,如连接数、线程数等。如SYN flood攻击。</li><li>攻击增强 - 通过各种方式增强攻击流量和效果。如IP地址欺骗。</li><li>多向量组合 - 综合使用各种类型的攻击手段,对目标发起多维攻击。</li></ul></blockquote><p>防御DDoS攻击的主要手段包括:</p><blockquote><ul><li><p>增加带宽 - 提高流量承载能力。</p></li><li><p>使用DDoS防护服务 - 由服务提供商过滤攻击流量。</p></li><li><p>限制连接和请求 - 加强对高流量源的访问控制。</p></li><li><p>丢弃无效流量 - 通过技术手段识别并丢弃攻击流量。</p></li><li><p>扩展关键系统资源 - 提高关键资源池容量。</p></li><li><p>服务降级 - 在被攻击时暂时停止非核心服务。</p></li><li><p>服务分散 - 通过CDN等方式分散服务,避免单点故障。</p></li><li><p>合理限速 - 对源IP访问频率和流量进行控制。</p><p>DDoS防御需要综合运用各种技术手段,从网络、服务和应用层进行防护,最大程度减轻攻击影响。</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：DDoS() 技术鉴赏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;DDoS说明&quot;&gt;&lt;a href=&quot;#DDoS说明&quot; class=&quot;headerlink&quot; title=&quot;DDoS说明&quot;&gt;&lt;/a&gt;DDoS说明</summary>
      
    
    
    
    <category term="网络安全" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="网络安全" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="DDoS" scheme="http://example.com/tags/DDoS/"/>
    
  </entry>
  
  <entry>
    <title>密钥分配</title>
    <link href="http://example.com/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E7%AC%AC7%E7%89%88%E3%80%8B/%E7%AC%AC7%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/7.5%20%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D/"/>
    <id>http://example.com/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E7%AC%AC7%E7%89%88%E3%80%8B/%E7%AC%AC7%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/7.5%20%E5%AF%86%E9%92%A5%E5%88%86%E9%85%8D/</id>
    <published>2023-09-18T05:27:41.909Z</published>
    <updated>2023-09-18T05:27:41.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h1><p>由于密码算法是公开的，网路的安全性就完全基于密钥的安全保护上。因此在密码学中出现了一个重要的分支——密钥管理。密钥管理包括：密钥的产生、分配、注入、验证和使用。本节只讨论密钥的分配。</p><blockquote><p><strong>密钥分配</strong>（或<strong>密钥分发</strong>）是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。</p><p>例如，可以派非常可靠的信使携带密钥分配给互相通信的各用户。这种方法称为<strong>网外分配方式</strong>。但随着用户的增多和网络流量的增大，密钥更换频繁（密钥必须定期更换才能做到可靠），派信使的办法已不再使用，而应采用网内分配方式，即对密钥自动分配。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密钥分配&quot;&gt;&lt;a href=&quot;#密钥分配&quot; class=&quot;headerlink&quot; title=&quot;密钥分配&quot;&gt;&lt;/a&gt;密钥分配&lt;/h1&gt;&lt;p&gt;由于密码算法是公开的，网路的安全性就完全基于密钥的安全保护上。因此在密码学中出现了一个重要的分支——密钥管理。密钥管理包括：</summary>
      
    
    
    
    <category term="立志博览群书" scheme="http://example.com/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="《计算机网络 第7版》" scheme="http://example.com/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88%E3%80%8B/"/>
    
    <category term="第7章 网络安全" scheme="http://example.com/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88%E3%80%8B/%E7%AC%AC7%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="密钥管理" scheme="http://example.com/tags/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/"/>
    
    <category term="对称密钥" scheme="http://example.com/tags/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5/"/>
    
    <category term="公钥" scheme="http://example.com/tags/%E5%85%AC%E9%92%A5/"/>
    
  </entry>
  
  <entry>
    <title>第7章 网络安全</title>
    <link href="http://example.com/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E7%AC%AC7%E7%89%88%E3%80%8B/%E7%AC%AC7%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/index/"/>
    <id>http://example.com/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20%E7%AC%AC7%E7%89%88%E3%80%8B/%E7%AC%AC7%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/index/</id>
    <published>2023-09-18T05:27:41.909Z</published>
    <updated>2023-09-18T05:27:41.910Z</updated>
    
    <content type="html"><![CDATA[<p>本章只是对计算机网络安全问题进行初步的介绍。</p><p>本章最重要的内容是：</p><ol><li>计算机完了过面临的安全性威胁和计算机网络安全的主要问题</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本章只是对计算机网络安全问题进行初步的介绍。&lt;/p&gt;
&lt;p&gt;本章最重要的内容是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算机完了过面临的安全性威胁和计算机网络安全的主要问题&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    <category term="立志博览群书" scheme="http://example.com/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="《计算机网络 第7版》" scheme="http://example.com/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88%E3%80%8B/"/>
    
    <category term="第7章 网络安全" scheme="http://example.com/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88%E3%80%8B/%E7%AC%AC7%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="网络安全" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="防火墙" scheme="http://example.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
    <category term="对称密钥" scheme="http://example.com/tags/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5/"/>
    
    <category term="公钥" scheme="http://example.com/tags/%E5%85%AC%E9%92%A5/"/>
    
    <category term="ssl" scheme="http://example.com/tags/ssl/"/>
    
    <category term="tls" scheme="http://example.com/tags/tls/"/>
    
    <category term="系统安全" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    <category term="数字签名与鉴别" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E9%89%B4%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>热补丁支持</title>
    <link href="http://example.com/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/3-13-%E7%83%AD%E8%A1%A5%E4%B8%81%E6%94%AF%E6%8C%81/"/>
    <id>http://example.com/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/3-13-%E7%83%AD%E8%A1%A5%E4%B8%81%E6%94%AF%E6%8C%81/</id>
    <published>2023-09-18T05:27:41.908Z</published>
    <updated>2023-09-18T05:27:41.908Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>补丁是指衣服、被褥上为遮掩破洞而钉补上的小布块。明白了吗？</p><blockquote><p>现在也指对于大型<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6">软件</a>系统(如<a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/233219">微软操作系统</a>)在使用过程中暴露的问题（一般由<a href="https://baike.baidu.com/item/%E9%BB%91%E5%AE%A2/118396">黑客</a>或<a href="https://baike.baidu.com/item/%E7%97%85%E6%AF%92/21267">病毒</a>设计者发现）而发布的解决问题的小程序。就像衣服烂了就要打补丁一样，人编写程序不可能十全十美的，所以<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>也免不了会出现BUG，而补丁是专门修复这些BUG做的因为原来发布的软件存在缺陷，发现之后另外编制一个小程序使其完善，这种小程序俗称补丁。补丁是由<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>的原来作者制作的，可以访问网站下载补丁。</p><p>补丁一般都是 <code>.exe</code> 文件</p></blockquote><h2 id="微软补丁"><a href="#微软补丁" class="headerlink" title="微软补丁"></a>微软补丁</h2><p><a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF">微软</a>的<a href="https://baike.baidu.com/item/Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">Windows操作系统</a>比较大，比较复杂。因此总有考虑不周的地方。有些病毒或者黑客就利用微软的漏洞进行攻击。微软发现漏洞后就发布一些补丁程序。 我们得到微软的补丁程序后安装到计算机上就叫打补丁。</p><blockquote><p>什么是微软补丁？</p><p>微软发布的系统补丁有两种类型：<code>Hotfix</code> 和 <code>Service Pack</code>，下面介绍它们之间的区别和联系。</p><ul><li><code>hotfix</code> 是微软针对某一个具体的系统漏洞或安全问题而发布的专门解决程序，<code>Hotfix</code>的程序文件名有严格的规定，一般格式为“产品名-KBXXXXXX-处理器平台-语言版本.exe”。现在一个例子来详细说明：微软针对震荡病毒而发布的<code>Hotfix</code>程序名为“Win2K-KB835732-X86-CHS.exe”，我们知道这个补丁是针对Win2000系统的，其知识库编号为 835732，应用于 X86 处理器平台，语言版本为简体中文。</li><li><code>Hotfix</code> 是针对某一个具体问题而发布的解决程序，因此它会经常发布，数量非常大。用户想要知道目前已经发布了哪些<code>Hotfix</code>程序是一件非常麻烦的事。因此微软将这些<code>Hotfix</code>补丁全部打包成一个程序提供给用户安装，这就是<code>Service Pack</code>，简称<code>SP</code>。<code>Service Pack</code>包含了发布日期以前所有的<code>Hotfix</code>程序，因此只要安装了它，就可以保证自己不会漏掉一个<code>Hotfix</code>程序。而且发布时间晚的<code>Service Pack</code>程序会包含以前的<code>Service Pack</code>，例如 <code>SP3</code>会包含<code>SP1</code>、<code>SP2</code>的所有补丁。</li></ul></blockquote><h1 id="热补丁支持"><a href="#热补丁支持" class="headerlink" title="热补丁支持"></a>热补丁支持</h1><blockquote><p>重新引导一台机器以便把最新的补丁都应用上，这对于服务器来说可能会意味着一段显著的宕机时间，这也正是为什么Windows要支持运行时刻的补丁方法，称为热补丁（hot patch，或简化为hotpatch）。与之相反的是冷补丁（coldpatch），它要求一次重新引导。热补丁并非只是简单地允许文件可在执行过程中被覆盖;相反地，它包括了一系列可能会被请求执行的复杂操作（这些操作也可能会组合起来）。</p></blockquote><h2 id="热补丁执行操作"><a href="#热补丁执行操作" class="headerlink" title="热补丁执行操作"></a>热补丁执行操作</h2><p>下表列出了这些操作：</p><table><thead><tr><th>操作</th><th>含义</th><th>用途</th></tr></thead><tbody><tr><td>映像文件改名称<br />（Rename Image)</td><td>替换磁盘上一个正在被其他应用程序使用的DLL，或者替换磁盘上一个已经被内核加载到系统中的驱动程序</td><td>当一个用户模式的库需要完整地被替换的时候，内核可以检测到哪些进程和服务正在引用该库，将它们卸载出内存，然后更新DLL，再重新启动这些程序和服务（通过<u>重启管理器</u>[restart manager]来完成）。当一个驱动程序需要被替换的时候，内核可以卸载该驱动程序（该驱动程序要求有一个卸载例程），更新驱动程序，然后重新加载替换后的驱动程序</td></tr><tr><td>对象交换<br />（Object Swap）</td><td>以原子操作的方式更改对象目录名字空间中的一个对象</td><td>当一个文件（往往是已知的DLL）需要被原子凡事修改名称，但不影响任何可能正在使用该文件的进程时（所以，这些进程可以立即使用新的文件，且仍然使用老的句柄，但不要求应用程序重新启动）</td></tr><tr><td>补丁函数代码<br />（Patch Function Code）</td><td>将一个映像文件中的一个或多个函数的代码替换为新的版本</td><td>如果在运行时刻一个DLL或驱动程序不能被替换或修改名称，则该映像中的函数可以直接被打上补丁。对于一个包含了新代码的热补丁DLL，当老的函数被调用时，它会跳转到新的代码中。</td></tr><tr><td>刷新系统DLL<br />（Refresh System DLL）</td><td>重新为Ntdll.dll加载内存映射区对象</td><td>Windows的系统原生库Ntdll.dll只在系统引导过程中被加载一次，以后只是被简单地复制到每个新进程的地址空间中。如果它呗热补丁了，那么，系统必须刷新这一内存区对象，以便加载新的版本</td></tr></tbody></table><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><mark style="background-color:red">运行时刻卸载</mark></p><p>热补丁文件的构成除了包括要替换的函数部分，还包括一个<u><code>Update.exe</code>的程序</u>以及<u>一个额外的<code>.hp</code>热补丁文件</u>。</p><ul><li><code>Update.exe</code>：完成该补丁的提取工作，也执行相应的更新过程。</li><li><code>.hp</code>热补丁文件：此文件包含一个特殊的<code>PE头</code>，称为<code>.HOT1</code>。该PE头包含了一个数据结构，描述了该文件中出现的各种补丁描述符（patch descriptor）。每一个补丁描述述符指明了在原始文件中需要被补丁的偏移位置、一个验证机制（它可以包含一份老数据的简单比较、一个校验和，或者一个散列值），以及待补丁的新数据。内核将解析这些描述符，并且执行恰当的修改动作。若是被保护的进程（protected process，有关进程的更多信息，参见《深入理解Windows操作系统》第5章），或者其他经过数字签名的二进制映像，在这些情况下，热补丁也必须被经过数字签名，以避免针对敏感文件或进程执行“伪造的”补丁。</li></ul><p>在编译时刻对热补丁的支持，是通过在每个函数的开始处加入7个额外的字节来做到的。其中5个字节被看做前一个函数的结束部分，2个字节被看作<strong>函数前缀</strong>（function prolog）部分，也就是函数的开始。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>使用热补丁也存在一些限制：</p><ol><li>与安全软件的不兼容。像安全软件类的第三方应用程序可能会阻止这样的补丁；补丁也可能与第三方应用程序的操作系统不兼容</li><li>补丁要修改一个文件的导出表或导入表</li><li>补丁要改变数据结构，修正无限循环，或者包含内联的汇编代码</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;补丁&quot;&gt;&lt;a href=&quot;#补丁&quot; class=&quot;headerlink&quot; title=&quot;补丁&quot;&gt;&lt;/a&gt;补丁&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="立志博览群书" scheme="http://example.com/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="《深入理解Windows操作系统》" scheme="http://example.com/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
    <category term="《深入理解Windows操作系统》" scheme="http://example.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
  </entry>
  
</feed>
