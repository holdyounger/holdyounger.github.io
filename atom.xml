<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oone</title>
  
  <subtitle>固执无罪，梦想无价 | Coding For Knowledge</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-08-24T13:33:57.287Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>mingming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【汇编】【实验楼】汇编教程笔记</title>
    <link href="http://example.com/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91%E3%80%90%E5%AE%9E%E9%AA%8C%E6%A5%BC%E3%80%91%E6%B1%87%E7%BC%96%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91%E3%80%90%E5%AE%9E%E9%AA%8C%E6%A5%BC%E3%80%91%E6%B1%87%E7%BC%96%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2024-08-24T13:33:55.196Z</published>
    <updated>2024-08-24T13:33:57.287Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：</p></blockquote><span id="more"></span><h2 id="DOS-及-DEBUG-介绍"><a href="#DOS-及-DEBUG-介绍" class="headerlink" title="DOS 及 DEBUG 介绍"></a>DOS 及 DEBUG 介绍</h2><h3 id="8086-寄存器组"><a href="#8086-寄存器组" class="headerlink" title="8086 寄存器组"></a>8086 寄存器组</h3><p>8086 寄存器都是 16 位的寄存器，根据用途可分为 4 种类型。分别是数据寄存器、地址寄存器、段寄存器和控制寄存器。</p><p>如图所示:</p><img src="/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91%E3%80%90%E5%AE%9E%E9%AA%8C%E6%A5%BC%E3%80%91%E6%B1%87%E7%BC%96%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/IMG-20240822100243453.png" class="" title="img"><h4 id="（1）数据寄存器"><a href="#（1）数据寄存器" class="headerlink" title="（1）数据寄存器"></a>（1）数据寄存器</h4><p>数据寄存器中每个寄存器又可以分为 2 个 8 位的寄存器。分别为 AH、AL，BH、BL，CH、CL，DH、DL。H 表示高字节（高 8 位）寄存器、L 表示低字节（低 8 位）寄存器。</p><p>例如：用 AX 寄存器存放一个字 1234H，表示为 (AX)&#x3D;1234H，即高字节 12 放在 AH，低字节 34 放在 AL 中。</p><h4 id="（2）地址寄存器"><a href="#（2）地址寄存器" class="headerlink" title="（2）地址寄存器"></a>（2）地址寄存器</h4><p>地址寄存器包括指针和变址寄存器 SP、BP、SI、DI 四个 16 位寄存器。</p><p>顾名思义，它们可用来存放存储器操作数的偏移地址。另外，它们也可以作为通用寄存器用。</p><h4 id="（3）段寄存器"><a href="#（3）段寄存器" class="headerlink" title="（3）段寄存器"></a>（3）段寄存器</h4><p>8086CPU 有 4 个 16 位的段寄存器，分别是 CS 代码段寄存器、DS 数据段寄存器、ES 附加段寄存器、SS 堆栈段寄存器。</p><h4 id="（4）控制寄存器"><a href="#（4）控制寄存器" class="headerlink" title="（4）控制寄存器"></a>（4）控制寄存器</h4><p>控制寄存器包括 IP 和 FLAGS（又称为 PSW 程序状态字）两个 16 位寄存器，用于控制程序的执行。</p><p>IP 指令指针寄存器，用来存放代码段中的偏移地址，指出当前正在执行指令的下一条指令所在单元的偏移地址。</p><p>FLAGS 标志寄存器中的某位代表 CPU 的 1 个标志，表示出 CPU 的某种执行状态。最低位为 D0，最高位为 D15。8086CPU 的标志寄存器共有 9 个标志，分别为 6 个条件码标志和 3 个控制标志。如图：</p><img src="/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91%E3%80%90%E5%AE%9E%E9%AA%8C%E6%A5%BC%E3%80%91%E6%B1%87%E7%BC%96%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/IMG-20240822100243575.png" class="" title="img"><p>（1）条件码标志</p><ul><li>CF 进位标志。当指令执行结果的最高位向前有进位时，CF&#x3D;1，否则 CF&#x3D;0。</li><li>SF 符号标志。当指令执行结果的最高位（符号位）为负时，SF&#x3D;1，否则 SF&#x3D;0。</li><li>ZF 零标志。当指令执行结果为 0 时，ZF&#x3D;1，结果不为 0 时，ZF&#x3D;0。</li><li>OF 溢出标志。当指令执行结果有溢出（超出了数的表示范围）时，OF&#x3D;1，否则 OF&#x3D;0。</li><li>AF 辅助进位标志。当指令执行结果的第 3 位（半字节）向前有进位时，AF&#x3D;1，否则 AF&#x3D;0。</li><li>PF 奇偶标志。当指令执行结果中 1 的个数为偶数个时，PF&#x3D;1，否则 PF&#x3D;0。</li></ul><p>（2）控制标志</p><ul><li>DF 方向标志。执行串处理指令时，若设置 DF&#x3D;0，存储单元的地址寄存器的值自动增加，若设置 DF&#x3D;1，存储单元的地址寄存器的值自动减小。</li><li>IF 中断标志。设置 IF&#x3D;1，允许 CPU 响应可屏蔽中断，IF&#x3D;0 则不响应。</li><li>TF 陷阱标志。在 DEBUG 调试时，TF&#x3D;1，采用单步执行方式，即进入陷阱；TF&#x3D;0，正常执行程序。</li></ul><p>例：两个二进制数相加运算，有关标志位自动发生变化。</p><img src="/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91%E3%80%90%E5%AE%9E%E9%AA%8C%E6%A5%BC%E3%80%91%E6%B1%87%E7%BC%96%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/IMG-20240822100243689.png" class="" title="img"><p>根据计算结果可知 CPU 会自动地把标志位设为：CF&#x3D;0，SF&#x3D;1，ZF&#x3D;0，OF&#x3D;0，PF&#x3D;0，即无进位，结果为负数，结果不为 0，没有溢出，奇数个 1。</p><p>对溢出的判断也可以从简单的角度理解，因为进行运算的二进制数是补码，可看出本题是一个负数和一个正数相加，结果为负数，不溢出。若两个正数相加，结果为负数，或者两个负数相加，结果为正数，那都是溢出了，说明 8 位补码已经表示不了该结果。</p><p><strong><code>小贴士</code></strong> DEBUG 下的标志位表示</p><p>在 DEBUG 调试环境下以字母缩写的形式表示各个标志位的状态。进入 DEBUG 后，用 R 命令查看寄存器状态时，可以看到除了陷阱标志以外的标志位的状态。</p><p>如表 2-1 所示：</p><img src="/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91%E3%80%90%E5%AE%9E%E9%AA%8C%E6%A5%BC%E3%80%91%E6%B1%87%E7%BC%96%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/IMG-20240822100243788.png" class="" title="此处输入图片的描述"><p><strong><code>小贴士</code></strong> 数的补码运算</p><p>在计算机中，对带符号数可用真值和机器数两个概念表示。</p><p>真值，就是带有“+”、“-”号的实际数值；所谓机器数，则是把“+”、“-”符号数值化（0、1）后所得到的计算机实际能表示的数。</p><p>机器数有三种码表示，分别是原码、反码和补码。汇编语言中，数都是以补码的形式表示的，因此必须掌握数的补码表示和补码的运算。这三种码的定义如下：</p><ul><li>原码。原码将最高位作为符号位，正数为 0，负数为 1，其余 7 位作为数值位。</li><li>反码。正数的反码与正数的原码一样。而求负数的反码时，符号位为 1，数值位在原码的基础上求反。</li><li>补码。正数的补码与正数的原码一样。求负数的补码时，符号位为 1，数值位在原码的基础上求反加 1。</li></ul><p>例：十进制数 +5 和 -5 分别表示成二进制数原码、反码和补码。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[+5]原 = [+5]反 = [+5]补 = 00000101B  </span><br><span class="line">[-5]原 = 10000101B  </span><br><span class="line">[-5]反 = 11111010B  </span><br><span class="line">[-5]补 = 11111011B  </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="B_Code" scheme="http://example.com/categories/B-Code/"/>
    
    <category term="汇编" scheme="http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"/>
    
    
    <category term="汇编" scheme="http://example.com/tags/%E6%B1%87%E7%BC%96/"/>
    
    <category term="实验楼" scheme="http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"/>
    
  </entry>
  
  <entry>
    <title>【汇编】Tail Call Elimination</title>
    <link href="http://example.com/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91Tail%20Call%20Elimination/"/>
    <id>http://example.com/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91Tail%20Call%20Elimination/</id>
    <published>2024-08-24T13:33:47.922Z</published>
    <updated>2024-08-24T13:42:16.002Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：Tail Call Elimination（尾调用消除）是一种编译优化技术，旨在减少因函数调用而产生的栈空间使用，特别是在递归调用或尾调用频繁的场景中。</p></blockquote><span id="more"></span><p>参考文章：</p><ul><li><a href="https://codemachine.com/articles/x64_deep_dive.html">CodeMachine - Article - X64 Deep Dive</a></li></ul><h2 id="1-Tail-Call-Elimination"><a href="#1-Tail-Call-Elimination" class="headerlink" title="1. Tail Call Elimination"></a>1. Tail Call Elimination</h2><blockquote><p>[!note] 尾调用是指一个函数在其返回语句中调用另一个函数，且该调用是该函数的最后一条指令。尾调用消除（TCO）则是一种编译器优化技术，它能够在<font color="#f79646">不增加调用栈深度</font>的情况下，将尾调用转化为一种类似于跳转（goto）的操作，从而避免在调用栈上创建新的栈帧。</p></blockquote><p>X64编译器可以通过将函数的最后一次调用替换为跳转到被调用方来优化该调用。这避免了为被调用方设置堆栈帧的开销。调用方和被调用方共享相同的堆栈帧，被调用方直接返回给调用方的调用方。当调用方和被调用方具有相同的参数时，这尤其有益，因为如果相关参数已经在所需的寄存器中，并且这些寄存器没有更改，则不必重新加载它们。</p><p>图 1 显示了在调用 Function4时 Function1中的尾部调用消除。Function1跳转到 Function4，当 Function4完成执行时，它直接返回到 Function1的调用方。</p><p>调用过程大致如下所示：<br><img src="/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91Tail%20Call%20Elimination/IMG-20240824214215827.png" alt="图1"></p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><blockquote><p>[!info] 简单说就是减少创建堆栈的过程</p></blockquote><p>在传统的函数调用中，每当一个函数被调用时，<font color="#f79646">都会在调用栈上创建一个新的栈帧来保存函数的局部变量、参数以及返回地址等信息</font>。而在尾调用的情况下，由于被调用的函数是调用函数的最后一条指令，且调用函数在被调用函数返回后没有其他操作需要执行，因此理论上可以不需要保存调用函数的栈帧信息。</p><p>编译器在检测到尾调用时，会优化这个调用过程，使其不再在调用栈上创建新的栈帧，而是直接复用当前栈帧，将参数和返回地址等信息更新为被调用函数所需的信息，并跳转到被调用函数的执行入口。这样，当被调用函数返回时，就可以直接返回到调用函数的调用者处，而不需要再经过调用函数的栈帧。</p><h2 id="3-说明"><a href="#3-说明" class="headerlink" title="3. 说明"></a>3. 说明</h2><p>这里以快速排序为例</p><blockquote><p>[!info] 参考文章：<a href="https://www.geeksforgeeks.org/tail-call-elimination/">Tail Call Elimination - GeeksforGeeks</a></p></blockquote><p>常规的写法如下所示，通过递归调用最终达到对整个数据排序的目的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tail recursive function for QuickSort </span></span><br><span class="line"><span class="comment">arr[] --&gt; Array to be sorted, </span></span><br><span class="line"><span class="comment">low --&gt; Starting index, </span></span><br><span class="line"><span class="comment">high --&gt; Ending index */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span> (low &lt; high) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">/* pi is partitioning index, arr[p] is now </span></span><br><span class="line"><span class="comment">at right place */</span></span><br><span class="line"><span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Separately sort elements before </span></span><br><span class="line"><span class="comment">// partition and after partition </span></span><br><span class="line"><span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>); </span><br><span class="line"><span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以考虑使用 Tail Call Elimination 来进行替换优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* QuickSort after tail call elimination </span></span><br><span class="line"><span class="comment">arr[] --&gt; Array to be sorted, </span></span><br><span class="line"><span class="comment">low --&gt; Starting index, </span></span><br><span class="line"><span class="comment">high --&gt; Ending index */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">start: </span><br><span class="line"><span class="keyword">if</span> (low &lt; high) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">/* pi is partitioning index, arr[p] is now </span></span><br><span class="line"><span class="comment">at right place */</span></span><br><span class="line"><span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Separately sort elements before </span></span><br><span class="line"><span class="comment">// partition and after partition </span></span><br><span class="line"><span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Update parameters of recursive call </span></span><br><span class="line"><span class="comment">// and replace recursive call with goto </span></span><br><span class="line">low = pi+<span class="number">1</span>; </span><br><span class="line">high = high; </span><br><span class="line"><span class="keyword">goto</span> start; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// See below link for complete running code </span></span><br><span class="line"><span class="comment">// https://ide.geeksforgeeks.org/dbq4yl </span></span><br></pre></td></tr></table></figure><p>这么做的目的是为了让编译器可以识别到尾调用消除。添加 <code>start</code> 标签，并且在尾部添加 <code>goto</code> 即可。</p><h2 id="4-尾部调用消除的堆栈管理"><a href="#4-尾部调用消除的堆栈管理" class="headerlink" title="4. 尾部调用消除的堆栈管理"></a>4. 尾部调用消除的堆栈管理</h2><p>递归使用堆栈来跟踪函数调用。每次函数调用时，一个新的帧被推送到包含本地变量和调用数据的堆栈上。<font color="#f79646">假设一个堆栈帧需要 O (1) ，即常量内存空间，那么对于 N 个递归调用内存需要 O (N)。</font></p><p><font color="#f79646">尾调用消除降低了从 O (N)到 O (1)的递归的空间复杂度。当函数调用被消除时，不会创建新的堆栈帧，函数将在常量内存空间中执行。</font></p><p>函数可以在常量内存空间中执行，因为在尾递归函数中，在调用语句之后没有语句，所以不需要保留父函数的状态和框架。子函数被调用并立即完成，它不必将控制返回给父函数。</p><p>由于不会对返回的值执行任何计算，也不会留下任何语句供执行，因此可以根据当前函数调用的要求修改当前框架。因此，不需要保留以前函数调用的堆栈帧，函数在常量内存空间中执行。这使得尾部递归更快，内存友好。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：Tail Call Elimination（尾调用消除）是一种编译优化技术，旨在减少因函数调用而产生的栈空间使用，特别是在递归调用或尾调用频繁的场景中。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="B_Code" scheme="http://example.com/categories/B-Code/"/>
    
    <category term="汇编" scheme="http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"/>
    
    
    <category term="汇编" scheme="http://example.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>【汇编】汇编导读</title>
    <link href="http://example.com/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91%E6%B1%87%E7%BC%96%E5%AF%BC%E8%AF%BB/"/>
    <id>http://example.com/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91%E6%B1%87%E7%BC%96%E5%AF%BC%E8%AF%BB/</id>
    <published>2024-08-24T13:33:41.508Z</published>
    <updated>2024-08-24T13:33:43.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：汇编相关知识、文章整理</p></blockquote><span id="more"></span><h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><a href="https://codemachine.com/articles/x64_deep_dive.html">CodeMachine - Article - X64 Deep Dive</a></li><li><a href="https://malwaretech.com/2023/12/an-introduction-to-bypassing-user-mode-edr-hooks.html">An Introduction to Bypassing User Mode EDR Hooks</a></li><li><a href="https://learn.microsoft.com/zh-cn/cpp/build/x64-software-conventions?view=msvc-170">x64 ABI 约定 | Microsoft Learn</a></li></ul><h2 id="在线实验环境"><a href="#在线实验环境" class="headerlink" title="在线实验环境"></a>在线实验环境</h2><p><a href="https://www.lanqiao.cn/courses/83">汇编语言（第 2 版，郑晓薇著）配套实验_大学公开课 - 蓝桥云课</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：汇编相关知识、文章整理&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="B_Code" scheme="http://example.com/categories/B-Code/"/>
    
    <category term="汇编" scheme="http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"/>
    
    
    <category term="汇编" scheme="http://example.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>【驱动】禁用签名</title>
    <link href="http://example.com/A_OS/Windows/%E9%A9%B1%E5%8A%A8/%E3%80%90%E9%A9%B1%E5%8A%A8%E3%80%91%E7%A6%81%E7%94%A8%E7%AD%BE%E5%90%8D/"/>
    <id>http://example.com/A_OS/Windows/%E9%A9%B1%E5%8A%A8/%E3%80%90%E9%A9%B1%E5%8A%A8%E3%80%91%E7%A6%81%E7%94%A8%E7%AD%BE%E5%90%8D/</id>
    <published>2024-08-24T13:12:27.817Z</published>
    <updated>2024-08-24T13:12:27.817Z</updated>
    
    <content type="html"><![CDATA[<p>方法一：使用命令提示符</p><ol><li><p>首先，按下Win+X组合键，选择“命令提示符（管理员）”。</p></li><li><p>在命令提示符窗口中，输入以下命令并按下回车键，开启 [[Win10 测试模式]]</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> testsigning on </span><br></pre></td></tr></table></figure></li><li><p>系统会显示“操作成功完成”的提示信息，表示已成功禁用驱动签名。</p></li><li><p>重新启动电脑，即可生效。</p></li></ol><p>现在，你已经成功禁用了Win10的驱动签名限制，可以自由安装非官方或未经认证的驱动程序了！但是请注意，禁用驱动签名可能会带来一定的安全风险，所以在安装驱动程序时，请确保来源可靠，并及时恢复驱动签名以保证系统的安全性。</p><p>希望本文的教程能够帮助到大家，让你的电脑更加自由灵活。如果你有任何问题或者建议，欢迎在评论区留言，我会尽力解答。祝大家使用愉快！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方法一：使用命令提示符&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先，按下Win+X组合键，选择“命令提示符（管理员）”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在命令提示符窗口中，输入以下命令并按下回车键，开启 [[Win10 测试模式]]&lt;/p&gt;
&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="驱动" scheme="http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>【网安】网络审计</title>
    <link href="http://example.com/B_Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E5%AE%89/%E7%BD%91%E7%BB%9C%E5%AE%A1%E8%AE%A1/%E3%80%90%E7%BD%91%E5%AE%89%E3%80%91%E7%BD%91%E7%BB%9C%E5%AE%A1%E8%AE%A1/"/>
    <id>http://example.com/B_Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E5%AE%89/%E7%BD%91%E7%BB%9C%E5%AE%A1%E8%AE%A1/%E3%80%90%E7%BD%91%E5%AE%89%E3%80%91%E7%BD%91%E7%BB%9C%E5%AE%A1%E8%AE%A1/</id>
    <published>2024-08-24T02:03:52.147Z</published>
    <updated>2024-08-24T13:48:38.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：网络审计的说明、文章推荐相关整理</p></blockquote><span id="more"></span><h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><a href="https://townsendcenter.berkeley.edu/blog/internet-censorship-part-1-technology-working-web">Internet Censorship (Part 1): The Technology of the Working Web | Townsend Center for the Humanities</a></li><li><a href="https://townsendcenter.berkeley.edu/blog/internet-censorship-part-2-technology-information-control">Internet Censorship (Part 2): The Technology of Information Control | Townsend Center for the Humanities</a></li></ul><h3 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h3><ul><li><a href="https://ssd.eff.org/module/understanding-and-circumventing-network-censorship">How to: Understand and Circumvent Network Censorship | Surveillance Self-Defense</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：网络审计的说明、文章推荐相关整理&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="B_Code" scheme="http://example.com/categories/B-Code/"/>
    
    <category term="网络编程" scheme="http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="网安" scheme="http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E5%AE%89/"/>
    
    <category term="网络审计" scheme="http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E5%AE%89/%E7%BD%91%E7%BB%9C%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="网络安全" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="网络安全/网络审计" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E7%BD%91%E7%BB%9C%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【考研政治】马原笔记</title>
    <link href="http://example.com/A_A%E7%A0%94/%E6%94%BF%E6%B2%BB/%E9%A9%AC%E5%8E%9F/%E3%80%90%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E3%80%91%E9%A9%AC%E5%8E%9F%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/A_A%E7%A0%94/%E6%94%BF%E6%B2%BB/%E9%A9%AC%E5%8E%9F/%E3%80%90%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E3%80%91%E9%A9%AC%E5%8E%9F%E7%AC%94%E8%AE%B0/</id>
    <published>2024-08-22T01:00:34.657Z</published>
    <updated>2024-08-24T14:04:11.893Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：马原刷题笔记</p></blockquote><span id="more"></span><h2 id="著作相关"><a href="#著作相关" class="headerlink" title="著作相关"></a>著作相关</h2><p>🔎<strong>精讲出处：</strong>P2，考点2-拓展与点拨④<br>🔎<strong>简析：</strong></p><p>   1844年8月底，马克思、恩格斯在巴黎会面。此前他们曾有过一面之缘，但这次会面使他们发现彼此的基本观点完全一致，并从此开始了毕生的合作。1844年9月至11月，<strong>他们在巴黎合写了《神圣家族》一书（第一次合作的著作）</strong>，<font color="#f79646">批判青年黑格尔派的主观唯心主义</font>。接着又在布鲁塞尔合写了《德意志意识形态》。<font color="#f79646">《德意志意识形态》首次系统阐述了历史唯物主义的基本观点，实现了历史观上的伟大变革。</font></p><p>   《哲学的贫困》是1847年马克思为批判蒲鲁东的《贫困的哲学》而写的著作。这部重要的著作是马克思主义学说最早发表的文本。<font color="#f79646">马克思主义的新世界观与马克思主义经济科学的“决定性的东西”</font>，都是通过这一文本第一次公开问世的。</p><p>   《共产党宣言》发表于1848年，标志着<font color="#f79646">马克思主义的公开问世</font>。<br><strong>🔎点拨：</strong><br>   1876—1878年，<strong>恩格斯写出了《反杜林论》，全面阐述了马克思主义理论体系（2020年真题第1题考点）。马克思逝世后，恩格斯撰写了《家庭、私有制和国家的起源》《路德维希·费尔巴哈和德国古典哲学的终结》等著作，进一步发展了马克思主义理论。</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：马原刷题笔记&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_A研" scheme="http://example.com/categories/A-A%E7%A0%94/"/>
    
    <category term="政治" scheme="http://example.com/categories/A-A%E7%A0%94/%E6%94%BF%E6%B2%BB/"/>
    
    <category term="马原" scheme="http://example.com/categories/A-A%E7%A0%94/%E6%94%BF%E6%B2%BB/%E9%A9%AC%E5%8E%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>【组策略】账户锁定策略</title>
    <link href="http://example.com/A_OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/%E3%80%90%E7%BB%84%E7%AD%96%E7%95%A5%E3%80%91%E8%B4%A6%E6%88%B7%E9%94%81%E5%AE%9A%E7%AD%96%E7%95%A5/"/>
    <id>http://example.com/A_OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/%E3%80%90%E7%BB%84%E7%AD%96%E7%95%A5%E3%80%91%E8%B4%A6%E6%88%B7%E9%94%81%E5%AE%9A%E7%AD%96%E7%95%A5/</id>
    <published>2024-08-20T03:05:26.938Z</published>
    <updated>2024-08-20T03:05:26.938Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：Windows 安全设置下账户锁定策略相关内容</p></blockquote><span id="more"></span><h2 id="账户锁定策略条目"><a href="#账户锁定策略条目" class="headerlink" title="账户锁定策略条目"></a>账户锁定策略条目</h2><p>打开方式：Win+R -&gt; gpedit.msc（域控本地管理员无法修改）。如果是在域控服务器上，则需要输入 <code>rsop.msc</code> 来查看，如果修改请查看下一小节。</p><img src="/A_OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/%E3%80%90%E7%BB%84%E7%AD%96%E7%95%A5%E3%80%91%E8%B4%A6%E6%88%B7%E9%94%81%E5%AE%9A%E7%AD%96%E7%95%A5/image-20240819085031278.png" class="" title="账户锁定策略"><h3 id="账户锁定时间"><a href="#账户锁定时间" class="headerlink" title="账户锁定时间"></a>账户锁定时间</h3><blockquote><p>帐户锁定时间</p><p>此安全设置确定锁定帐户在自动解锁之前保持锁定的分钟数。可用范围从 0 到 99,999 分钟。如果将帐户锁定时间设置为 0，帐户将一直被锁定直到管理员明确解除对它的锁定。</p><p>如果定义了帐户锁定阈值，则帐户锁定时间必须大于或等于重置时间。</p><p>默认值: 无，因为只有在指定了帐户锁定阈值时，此策略设置才有意义。</p></blockquote><p>即账户被锁定后开始，过了多长时间才能解锁</p><h3 id="账户锁定阈值"><a href="#账户锁定阈值" class="headerlink" title="账户锁定阈值"></a>账户锁定阈值</h3><blockquote><p>帐户锁定阈值</p><p>此安全设置确定导致用户帐户被锁定的登录尝试失败的次数。在管理员重置锁定帐户或帐户锁定时间期满之前，无法使用该锁定帐户。可以将登录尝试失败次数设置为介于 0 和 999 之间的值。如果将值设置为 0，则永远不会锁定帐户。</p><p>在使用 Ctrl+Alt+Del 或密码保护的屏幕保护程序锁定的工作站或成员服务器上的密码尝试失败将计作登录尝试失败。</p><p>默认值: 0。</p></blockquote><p>即账户在尝试登录时，失败几次后会锁定账户。</p><h3 id="重置账户锁定计数器"><a href="#重置账户锁定计数器" class="headerlink" title="重置账户锁定计数器"></a>重置账户锁定计数器</h3><blockquote><p>在此后复位帐户锁定计数器</p><p>此安全设置确定在某次登录尝试失败之后将登录尝试失败计数器重置为 0 次错误登录尝试之前需要的时间。可用范围是 1 到 99,999 分钟。</p><p>如果定义了帐户锁定阈值，此重置时间必须小于或等于帐户锁定时间。</p><p>默认值: 无，因为只有在指定了帐户锁定阈值时，此策略设置才有意义。</p></blockquote><p>即账户锁定阈值在锁定之后经过多久使账户锁定阈值清 0。</p><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="域控服务器的策略如何设置"><a href="#域控服务器的策略如何设置" class="headerlink" title="域控服务器的策略如何设置"></a>域控服务器的策略如何设置</h3><p>在域控服务器上，修改登录策略。</p><ol><li>工具 -&gt; 组策略管理<style>.touzulkykjsc{zoom:50%;}</style><img src="/A_OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/%E3%80%90%E7%BB%84%E7%AD%96%E7%95%A5%E3%80%91%E8%B4%A6%E6%88%B7%E9%94%81%E5%AE%9A%E7%AD%96%E7%95%A5/image-20240819091704238.png" class="touzulkykjsc" alt="组策略管理"></li><li>编辑默认域控<style>.slopvyzjvrqx{zoom:50%;}</style><img src="/A_OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/%E3%80%90%E7%BB%84%E7%AD%96%E7%95%A5%E3%80%91%E8%B4%A6%E6%88%B7%E9%94%81%E5%AE%9A%E7%AD%96%E7%95%A5/image-20240819091849163.png" class="slopvyzjvrqx" alt="编辑默认域"></li><li>组策略管理编辑器<style>.cxhptdxhggqb{zoom: 50%;}</style><img src="/A_OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/%E3%80%90%E7%BB%84%E7%AD%96%E7%95%A5%E3%80%91%E8%B4%A6%E6%88%B7%E9%94%81%E5%AE%9A%E7%AD%96%E7%95%A5/image-20240819091938710.png" class="cxhptdxhggqb" alt="image-20240819091938710"></li></ol><h2 id="C-获取锁定策略"><a href="#C-获取锁定策略" class="headerlink" title="C++ 获取锁定策略"></a>C++ 获取锁定策略</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">IsAccountLockoutPolicyOpen</span><span class="params">(LPCWSTR ServerName, BOOL&amp; bOpen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;确认账户锁定策略是否开启&quot;</span>);</span><br><span class="line">BOOL bSuc = FALSE;</span><br><span class="line">DWORD dwLevel = <span class="number">3</span>;</span><br><span class="line">USER_MODALS_INFO_3 *pBuf = <span class="literal">NULL</span>;</span><br><span class="line">NET_API_STATUS nStatus = <span class="built_in">NetUserModalsGet</span>(ServerName,</span><br><span class="line">dwLevel,</span><br><span class="line">(LPBYTE *)&amp;pBuf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nStatus == NERR_Success)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pBuf != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">bSuc = TRUE;</span><br><span class="line"><span class="keyword">if</span>(pBuf-&gt;usrmod3_lockout_threshold == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">bOpen = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bOpen = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pBuf != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">NetApiBufferFree</span>(pBuf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bSuc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：Windows 安全设置下账户锁定策略相关内容&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="组策略" scheme="http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/"/>
    
    <category term="安全设置" scheme="http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/"/>
    
    <category term="账户策略" scheme="http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/"/>
    
    
    <category term="gpedit" scheme="http://example.com/tags/gpedit/"/>
    
    <category term="组策略/安全设置/账户策略/账户锁定策略" scheme="http://example.com/tags/%E7%BB%84%E7%AD%96%E7%95%A5-%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE-%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5-%E8%B4%A6%E6%88%B7%E9%94%81%E5%AE%9A%E7%AD%96%E7%95%A5/"/>
    
    <category term="安全设置" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>【组策略】密码策略</title>
    <link href="http://example.com/A_OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/%E3%80%90%E7%BB%84%E7%AD%96%E7%95%A5%E3%80%91%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5/"/>
    <id>http://example.com/A_OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/%E3%80%90%E7%BB%84%E7%AD%96%E7%95%A5%E3%80%91%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5/</id>
    <published>2024-08-20T03:05:26.925Z</published>
    <updated>2024-08-20T03:05:26.926Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述: 组策略-密码策略说明</p></blockquote><span id="more"></span><h2 id="0x01-密码策略如下图所示："><a href="#0x01-密码策略如下图所示：" class="headerlink" title="0x01 密码策略如下图所示："></a>0x01 密码策略如下图所示：</h2><img src="/A_OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/%E3%80%90%E7%BB%84%E7%AD%96%E7%95%A5%E3%80%91%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5/IMG-20240816175508336.png" class="" title="密码策略"><h2 id="0x02-详细说明"><a href="#0x02-详细说明" class="headerlink" title="0x02 详细说明"></a>0x02 详细说明</h2><h3 id="1-放宽最小密码长度限制"><a href="#1-放宽最小密码长度限制" class="headerlink" title="1 放宽最小密码长度限制"></a>1 放宽最小密码长度限制</h3><h3 id="2-密码必须符合复杂性要求"><a href="#2-密码必须符合复杂性要求" class="headerlink" title="2 密码必须符合复杂性要求"></a>2 密码必须符合复杂性要求</h3><h3 id="3-密码长度最小值"><a href="#3-密码长度最小值" class="headerlink" title="3 密码长度最小值"></a>3 密码长度最小值</h3><h3 id="4-密码最短使用期限"><a href="#4-密码最短使用期限" class="headerlink" title="4 密码最短使用期限"></a>4 密码最短使用期限</h3><h3 id="5-密码最长使用期限"><a href="#5-密码最长使用期限" class="headerlink" title="5 密码最长使用期限"></a>5 密码最长使用期限</h3><h4 id="注册表："><a href="#注册表：" class="headerlink" title="注册表："></a>注册表：</h4><h3 id="6-强制密码历史"><a href="#6-强制密码历史" class="headerlink" title="6 强制密码历史"></a>6 强制密码历史</h3><h3 id="7-用户可还原的加密来存储密码"><a href="#7-用户可还原的加密来存储密码" class="headerlink" title="7 用户可还原的加密来存储密码"></a>7 用户可还原的加密来存储密码</h3><h3 id="8-最小密码长度审核"><a href="#8-最小密码长度审核" class="headerlink" title="8 最小密码长度审核"></a>8 最小密码长度审核</h3><h1 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h1><p>用NetUser函数修改密码策略</p><p>可以使用 <code>NetUserModalsGet</code> 来查询密码策略，最后需要使用 <code>NetApiBufferFree</code> 来释放<br>查询到的数据空间。还可以使用 <code>NetUserModalsSet</code> 可以对密码策略进行设定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS <span class="title">NetUserModalsGet</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_opt_ LPCWSTR servername,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_     DWORD   level,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_    LPBYTE  *bufptr</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">// 查询密码策略</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS <span class="title">NetApiBufferFree</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPVOID Buffer</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">// 释放查询的数据空间</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS <span class="title">NetUserModalsSet</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPCWSTR servername,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  DWORD   level,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPBYTE  buf,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_ LPDWORD parm_err</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; <span class="comment">// 设定密码策略</span></span><br></pre></td></tr></table></figure><p>这两个函数中 <code>level</code> 参数决定了要处理数据的类型，可以取值的内容为</p><table><thead><tr><th>Value</th><th>Meaning</th><th>Structure</th></tr></thead><tbody><tr><td>0</td><td>Specifies global password parameters.</td><td>USER_MODALS_INFO_0</td></tr><tr><td>1</td><td>Specifies logon server and domain controller information.</td><td>USER_MODALS_INFO_1</td></tr><tr><td>2</td><td>Specifies the domain name and identifier.</td><td>USER_MODALS_INFO_2</td></tr><tr><td>3</td><td>Specifies lockout information.</td><td>USER_MODALS_INFO_3</td></tr><tr><td>1001</td><td>Specifies the minimum allowable password length.</td><td>USER_MODALS_INFO_1001</td></tr><tr><td>1002</td><td>Specifies the maximum allowable password age.</td><td>USER_MODALS_INFO_1002</td></tr><tr><td>1003</td><td>Specifies the minimum allowable password age.</td><td>USER_MODALS_INFO_1003</td></tr><tr><td>1004</td><td>Specifies forced logoff information.</td><td>USER_MODALS_INFO_1004</td></tr><tr><td>1005</td><td>Specifies the length of the password history.</td><td>USER_MODALS_INFO_1005</td></tr><tr><td>1006</td><td>Specifies the role of the logon server.</td><td>USER_MODALS_INFO_1006</td></tr><tr><td>1007</td><td>Specifies domain controller information.</td><td>USER_MODALS_INFO_1007</td></tr></tbody></table><p>如下是使用 <code>NetUserModalsGet</code> 查询时，我们关注的结构体信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USER_MODALS_INFO_0</span> &#123;</span><br><span class="line">  DWORD usrmod0_min_passwd_len; <span class="comment">// 密码长度最小值</span></span><br><span class="line">  DWORD usrmod0_max_passwd_age; <span class="comment">// 密码最长使用期限(秒)</span></span><br><span class="line">  DWORD usrmod0_min_passwd_age; <span class="comment">// 密码最短使用期限(秒)</span></span><br><span class="line">  DWORD usrmod0_force_logoff; <span class="comment">// 过期后强制注销的期限(秒)</span></span><br><span class="line">  DWORD usrmod0_password_hist_len; <span class="comment">// 强制密码历史个数</span></span><br><span class="line">&#125; USER_MODALS_INFO_0, *PUSER_MODALS_INFO_0, *LPUSER_MODALS_INFO_0;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USER_MODALS_INFO_3</span> &#123;</span><br><span class="line">  DWORD usrmod3_lockout_duration; <span class="comment">// 账户锁定时间(秒)</span></span><br><span class="line">  DWORD usrmod3_lockout_observation_window; <span class="comment">// 重置账户锁定计数器(秒)</span></span><br><span class="line">  DWORD usrmod3_lockout_threshold; <span class="comment">// 账户锁定阈值</span></span><br><span class="line">&#125; USER_MODALS_INFO_3, *PUSER_MODALS_INFO_3, *LPUSER_MODALS_INFO_3;</span><br></pre></td></tr></table></figure><p>使用 <code>NetUserModalsSet</code> 除了以上结构体进行整体设置外，还可以对部分参数进行单独设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USER_MODALS_INFO_1001</span> &#123;</span><br><span class="line">  DWORD usrmod1001_min_passwd_len; <span class="comment">// 密码长度最小值</span></span><br><span class="line">&#125; USER_MODALS_INFO_1001, *PUSER_MODALS_INFO_1001, *LPUSER_MODALS_INFO_1001;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USER_MODALS_INFO_1002</span> &#123;</span><br><span class="line">  DWORD usrmod1002_max_passwd_age; <span class="comment">// 密码最长使用期限(秒)</span></span><br><span class="line">&#125; USER_MODALS_INFO_1002, *PUSER_MODALS_INFO_1002, *LPUSER_MODALS_INFO_1002;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USER_MODALS_INFO_1003</span> &#123;</span><br><span class="line">  DWORD usrmod1003_min_passwd_age; <span class="comment">// 密码最短使用期限(秒)</span></span><br><span class="line">&#125; USER_MODALS_INFO_1003, *PUSER_MODALS_INFO_1003, *LPUSER_MODALS_INFO_1003;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USER_MODALS_INFO_1004</span> &#123;</span><br><span class="line">  DWORD usrmod1004_force_logoff; <span class="comment">// 过期后强制注销的期限(秒)</span></span><br><span class="line">&#125; USER_MODALS_INFO_1004, *PUSER_MODALS_INFO_1004, *LPUSER_MODALS_INFO_1004;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_USER_MODALS_INFO_1005</span> &#123;</span><br><span class="line">  DWORD usrmod1005_password_hist_len; <span class="comment">// 强制密码历史个数</span></span><br><span class="line">&#125; USER_MODALS_INFO_1005, *PUSER_MODALS_INFO_1005, *LPUSER_MODALS_INFO_1005;</span><br></pre></td></tr></table></figure><h4 id="密码复杂度的处理"><a href="#密码复杂度的处理" class="headerlink" title="密码复杂度的处理"></a>密码复杂度的处理</h4><p>看到这里是不是发现一个问题，那就是 <code>密码必须符合复杂性要求</code> 这项配置，查询不到。<br>我们可以通过直接读取 <code>SAM</code> 注册表的信息，来判断密码复杂度是否启用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckPwdComplexPolicy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HKEY hKey = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 打开密码策略注册表</span></span><br><span class="line">    LONG lResult = <span class="built_in">RegOpenKeyEx</span>(HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">&quot;SAM\\SAM\\Domains\\Account&quot;</span>, <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (lResult != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 读取密码策略注册表信息</span></span><br><span class="line">    DWORD dwLen = <span class="number">1024</span>;</span><br><span class="line">    BYTE pBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    lResult = <span class="built_in">RegQueryValueEx</span>(hKey, <span class="string">&quot;F&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, pBuf, &amp;dwLen);</span><br><span class="line">    <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">    <span class="keyword">if</span> (lResult != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 检查密码复杂度是否启用</span></span><br><span class="line">    <span class="keyword">if</span> (pBuf[<span class="number">76</span>] != <span class="number">1</span>) <span class="keyword">return</span> FALSE; <span class="comment">// 复杂度(0未启用)(1已启用)</span></span><br><span class="line">    <span class="comment">// if (pBuf[80] &lt; 8) return FALSE; // 最小长度</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通情况下 <code>SAM</code> 注册表是不允许访问的，就需要我们首先修改一下访问 <code>SAM</code> 的权限</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ModifySamRegPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PACL pOldDacl = <span class="literal">NULL</span>;</span><br><span class="line">    PSECURITY_DESCRIPTOR pSID = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取SAM主键的DACL</span></span><br><span class="line">    DWORD dRet = <span class="built_in">GetNamedSecurityInfo</span>(<span class="string">&quot;MACHINE\\SAM\\SAM&quot;</span>,</span><br><span class="line">        SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;pOldDacl, <span class="literal">NULL</span>, &amp;pSID);</span><br><span class="line">    <span class="keyword">if</span> (dRet != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LocalFree</span>(pSID);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个ACE,允许Administrators组成员完全控制对象,并允许子对象继承此权限</span></span><br><span class="line">    EXPLICIT_ACCESS_A eia = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">BuildExplicitAccessWithName</span>(&amp;eia, <span class="string">&quot;Administrators&quot;</span>,</span><br><span class="line">        KEY_ALL_ACCESS, SET_ACCESS, SUB_CONTAINERS_AND_OBJECTS_INHERIT);</span><br><span class="line">    <span class="comment">// 将新的ACE加入DACL</span></span><br><span class="line">    PACL pNewDacl = <span class="literal">NULL</span>;</span><br><span class="line">    dRet = <span class="built_in">SetEntriesInAcl</span>(<span class="number">1</span>, &amp;eia, pOldDacl, &amp;pNewDacl);</span><br><span class="line">    <span class="keyword">if</span> (dRet != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LocalFree</span>(pSID);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新SAM主键的DACL   </span></span><br><span class="line">    dRet = <span class="built_in">SetNamedSecurityInfo</span>(<span class="string">&quot;MACHINE\\SAM\\SAM&quot;</span>,</span><br><span class="line">        SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, <span class="literal">NULL</span>, <span class="literal">NULL</span>, pNewDacl, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dRet != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LocalFree</span>(pNewDacl);</span><br><span class="line">        <span class="built_in">LocalFree</span>(pSID);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述: 组策略-密码策略说明&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="组策略" scheme="http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/"/>
    
    <category term="安全设置" scheme="http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/"/>
    
    <category term="账户策略" scheme="http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/"/>
    
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="组策略/安全设置/账户策略/密码策略" scheme="http://example.com/tags/%E7%BB%84%E7%AD%96%E7%95%A5-%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE-%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5-%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5/"/>
    
    <category term="gpedit" scheme="http://example.com/tags/gpedit/"/>
    
  </entry>
  
  <entry>
    <title>【win】通过PID获取端口</title>
    <link href="http://example.com/A_OS/Windows/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E3%80%90win%E3%80%91%E9%80%9A%E8%BF%87PID%E8%8E%B7%E5%8F%96%E7%AB%AF%E5%8F%A3/"/>
    <id>http://example.com/A_OS/Windows/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E3%80%90win%E3%80%91%E9%80%9A%E8%BF%87PID%E8%8E%B7%E5%8F%96%E7%AB%AF%E5%8F%A3/</id>
    <published>2024-08-18T16:00:00.000Z</published>
    <updated>2024-08-24T13:54:40.945Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：通过 PID 获取进程的端口。</p></blockquote><span id="more"></span><h2 id="思路说明"><a href="#思路说明" class="headerlink" title="思路说明"></a>思路说明</h2><p>主要是通过 <code>GetExtendedTcpTable</code> 获取系统当前所有的 TCP 连接。通过获取到的数据结构体 <code>PMIB_TCPTABLE_OWNER_PID</code> 中的参数 dwOwningPid 来判断当前端口所属进程，从而达到获取当前进程端口的目的。</p><h2 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h2><ul><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-getextendedtcptable">GetExtendedTcpTable function (iphlpapi.h) - Win32 apps | Microsoft Learn</a><br>根据参数 5 <code>TCP_TABLE_CLASS</code> 的不同，会返回不同的结构体内容。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT16 <span class="title">GetProcessPort</span><span class="params">(DWORD dwProcesId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PMIB_TCPTABLE_OWNER_PID pTcpTable = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">DWORD dwNum = <span class="number">0</span>;</span><br><span class="line">UINT16 uLocalPort = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (dwProcesId == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> uLocalPort;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetExtendedTcpTable</span>(pTcpTable, &amp;dwSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, <span class="number">0</span>) != ERROR_INSUFFICIENT_BUFFER)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pTcpTable = (MIB_TCPTABLE_OWNER_PID*)<span class="built_in">new</span>(std::nothrow) <span class="type">char</span>[dwSize];<span class="comment">//重新分配缓冲区</span></span><br><span class="line"><span class="keyword">if</span> (!pTcpTable)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetExtendedTcpTable</span>(pTcpTable, &amp;dwSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, <span class="number">0</span>) != NO_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[GetProcessPort] GetExtendedTcpTable failed (%d)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">dwNum = pTcpTable-&gt;dwNumEntries; <span class="comment">//TCP连接的数目</span></span><br><span class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pTcpTable-&gt;table[i].dwOwningPid == dwProcesId)</span><br><span class="line">&#123;</span><br><span class="line">uLocalPort = <span class="built_in">htons</span>((u_short)pTcpTable-&gt;table[i].dwLocalPort);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pTcpTable != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * pT = (<span class="type">char</span> *)pTcpTable;</span><br><span class="line"><span class="keyword">delete</span>[] pT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> uLocalPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：通过 PID 获取进程的端口。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="进程线程" scheme="http://example.com/categories/A-OS/Windows/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="windows/API" scheme="http://example.com/tags/windows-API/"/>
    
    <category term="端口" scheme="http://example.com/tags/%E7%AB%AF%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>【CPP】虚函数</title>
    <link href="http://example.com/B_Code/CPP/%E3%80%90CPP%E3%80%91%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/B_Code/CPP/%E3%80%90CPP%E3%80%91%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2024-08-15T04:22:47.263Z</published>
    <updated>2024-08-17T12:14:19.597Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：虚函数的相关问题整理及逆向分析，以及如何通过数组指定调用虚函数。</p></blockquote><span id="more"></span><p>相关文章推荐：</p><ul><li><a href="https://blog.csdn.net/qq_42048450/article/details/117282640">C++虚函数详解-CSDN博客</a></li><li><a href="https://www.cnblogs.com/tgycoder/p/5427303.html">C++中的RTTI机制解析 - RunningSnail - 博客园</a></li></ul><p>环境说明：</p><ul><li><a href="https://www.onlinegdb.com/">https://www.onlinegdb.com/</a></li><li>C++ 14</li></ul><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><ol><li>虚函数表属于类，类的所有对象共享这个类的虚函数表。<blockquote><p><span style="background:#b1ffff">意思就是创建的所有类对象指向的虚函数表都是同一个地址。</span></p></blockquote></li><li>继承状态下的虚函数表内存<ol><li>没有重写时，继续使用父类的元素地址</li><li>重写后，使用当前类的元素地址</li></ol></li><li>派生类函数中多出来的虚函数的访问（基类指针指向派生类成员）</li></ol><p>以上说明在文中都有 Demo 。</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><h3 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h3><p>这块内容比较简单，写个代码简单跑下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类大小为1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="type">int</span> m_ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类大小为4</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="type">int</span> m_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类大小为8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">FunA</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 补充，这里不过有多少个虚函数，其虚函数总和大小都为4，因为虚函数都会被保存在虚函数表中。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">FunB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类大小为8</span></span><br><span class="line"><span class="comment">// 要考虑到大小对齐的问题，参考结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="type">char</span> m_ch;</span><br><span class="line"><span class="type">int</span> m_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类大小为8，和父类大小一直</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类和父类数据对齐的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小为1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="type">char</span> m_ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类大小为8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="type">int</span> m_val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数据成员和虚函数对齐的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类大小为16</span></span><br><span class="line"><span class="comment">// 要考虑到大小对齐的问题，参考结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="type">char</span> m_ch;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 补充，这里不过有多少个虚函数，其虚函数总和大小都为4，因为虚函数都会被保存在虚函数表中。</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">FunB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类大小为16</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="type">int</span> m_val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子类有额外的虚函数时的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类大小为 16</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="type">char</span> m_ch; <span class="comment">// 去掉这个大小变为 8，子类大小不变</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类大小为 16</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="type">int</span> m_val;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="通过指针访问虚函数表"><a href="#通过指针访问虚函数表" class="headerlink" title="通过指针访问虚函数表"></a>通过指针访问虚函数表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// char m_ch;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base::funcA&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base::funcB&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base::funcC&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> U8 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> FunCall = <span class="built_in">void</span>(*)();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base obj;</span><br><span class="line">    </span><br><span class="line">    U8* objAddr = (U8*)&amp;obj;</span><br><span class="line">    U8* objRef = (U8*)*objAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里有必要单独再去了解下 RTTI 的概念</span></span><br><span class="line">    ((FunCall)objRef[<span class="number">0</span>])();</span><br><span class="line">    ((FunCall)objRef[<span class="number">1</span>])();</span><br><span class="line">    ((FunCall)objRef[<span class="number">2</span>])();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base::funcA</span><br><span class="line">Base::funcB</span><br><span class="line">Base::funcC</span><br></pre></td></tr></table></figure><blockquote><p>关于 RPPI :<br>调试的时候看到的类指针是这样的，如下所示：</p></blockquote><table><thead><tr><th>名称</th><th>值</th><th>类型</th></tr></thead><tbody><tr><td>__vfptr</td><td>0x00007ff74a8dbcf8 {VirtualFun.exe!void(* Base::&#96;vftable’[4])()} {0x00007ff74a8d14ab {VirtualFun.exe!Base::funcA(void)}, …}</td><td>void * *</td></tr><tr><td>[0x00000000]</td><td>0x00007ff74a8d14ab {VirtualFun.exe!Base::funcA(void)}</td><td>void *</td></tr><tr><td>[0x00000001]</td><td>0x00007ff74a8d1212 {VirtualFun.exe!Base::funcB(void)}</td><td>void *</td></tr><tr><td>[0x00000002]</td><td>0x00007ff74a8d11cc {VirtualFun.exe!Base::funcC(void)}</td><td>void *</td></tr><tr><td>可以看到类指针指向的位置不是 3个，而是 4个。这就涉及到了 RTTI 的知识了。</td><td></td><td></td></tr><tr><td>RTTI (Run Time Type Identification) 即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。</td><td></td><td></td></tr></tbody></table><h3 id="虚函数表的地址"><a href="#虚函数表的地址" class="headerlink" title="虚函数表的地址"></a>虚函数表的地址</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// char m_ch;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base::funcA&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base::funcB&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base::funcC&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 funcB 函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::funcB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> U8 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> FunCall = <span class="built_in">void</span>(*)();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base obj;</span><br><span class="line">    BaseA objA;</span><br><span class="line">    </span><br><span class="line">    U8* objAddr = (U8*)&amp;obj;</span><br><span class="line">    U8* objRef = (U8*)*objAddr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p &quot;</span>, objRef[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    U8* objAddrA = (U8*)&amp;objA;</span><br><span class="line">    U8* objRefA = (U8*)*objAddrA;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p &quot;</span>, objRefA[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x5b2da1042388 0x5b2da10423c6 0x5b2da1042404 </span><br><span class="line">0x5b2da1042388 0x5b2da1042442 0x5b2da1042404</span><br></pre></td></tr></table></figure><p>可以看到 <code>funcA</code> 和 <code>funcC</code> 的地址是一样的。<code>FuncB</code> 的地址发生了变化，这是因为在派生类中重写了 <code>funcB</code> 函数。</p><h3 id="基类指针访问派生类成员"><a href="#基类指针访问派生类成员" class="headerlink" title="基类指针访问派生类成员"></a>基类指针访问派生类成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// char m_ch;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::funcA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::funcB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::funcC&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseA</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::funcB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funcD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;BaseA::funcD&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> U8 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> FunCall = <span class="built_in">void</span>(*)();</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Base* obj = <span class="keyword">new</span> BaseA;</span><br><span class="line">        U8* objAddr = (U8*)obj;</span><br><span class="line">        U8* objRef = (U8*)*objAddr;</span><br><span class="line">        ((FunCall)objRef[<span class="number">2</span>])();</span><br><span class="line">((FunCall)objRef[<span class="number">3</span>])(); <span class="comment">// 通过下标就可以访问到虚函数表的第4个，也就是子类的虚函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：虚函数的相关问题整理及逆向分析，以及如何通过数组指定调用虚函数。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="B_Code" scheme="http://example.com/categories/B-Code/"/>
    
    <category term="CPP" scheme="http://example.com/categories/B-Code/CPP/"/>
    
    
    <category term="CPP/虚函数" scheme="http://example.com/tags/CPP-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【IDA】IDA插件</title>
    <link href="http://example.com/B_Code/IDA/%E3%80%90IDA%E3%80%91IDA%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/B_Code/IDA/%E3%80%90IDA%E3%80%91IDA%E6%8F%92%E4%BB%B6/</id>
    <published>2024-08-15T02:31:21.791Z</published>
    <updated>2024-08-15T10:35:31.986Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IDA 插件推荐</p></blockquote><span id="more"></span><p><a href="https://github.com/herosi/classinformer-ida8">herosi&#x2F;classinformer-ida8: IDA Class Informer plugin for IDA 8.x</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;IDA 插件推荐&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="B_Code" scheme="http://example.com/categories/B-Code/"/>
    
    <category term="IDA" scheme="http://example.com/categories/B-Code/IDA/"/>
    
    
    <category term="IDA" scheme="http://example.com/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>【Obsidian】使用手册</title>
    <link href="http://example.com/E_%E6%89%8B%E5%86%8C/%E3%80%90Obsidian%E3%80%91%E6%89%8B%E5%86%8C/"/>
    <id>http://example.com/E_%E6%89%8B%E5%86%8C/%E3%80%90Obsidian%E3%80%91%E6%89%8B%E5%86%8C/</id>
    <published>2024-08-14T06:54:20.214Z</published>
    <updated>2024-08-15T10:35:31.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="白板"><a href="#白板" class="headerlink" title="白板"></a>白板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Mindmap</span><br><span class="line">## Mindmap</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">
&lt;h1 id=&quot;白板&quot;&gt;&lt;a href=&quot;#白板&quot; class=&quot;headerlink&quot; title=&quot;白板&quot;&gt;&lt;/a&gt;白板&lt;/h1&gt;


&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    <category term="E_手册" scheme="http://example.com/categories/E-%E6%89%8B%E5%86%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>【Qt】文章导读</title>
    <link href="http://example.com/B_Code/Qt/%E3%80%90Qt%E3%80%91%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/"/>
    <id>http://example.com/B_Code/Qt/%E3%80%90Qt%E3%80%91%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/</id>
    <published>2024-08-13T10:32:49.953Z</published>
    <updated>2024-08-15T10:35:31.986Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：Qt 文章汇总</p></blockquote><span id="more"></span><p><a href="%E3%80%90Qt%E3%80%91%E5%8A%A0%E5%AF%86.md">【Qt】加密</a><br><a href="%E3%80%90Qt%E3%80%91%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB.md">【Qt】常用基础代码汇总</a><br><a href="%E3%80%90Qt%E3%80%91%E4%B8%AD%E8%8B%B1%E6%96%87%E5%88%87%E6%8D%A2.md">【Qt】中英文切换</a><br><a href="%E3%80%90Qt%E3%80%91pro%E6%96%87%E4%BB%B6%E7%94%A8%E6%B3%95.md">【Qt】pro文件用法</a><br><a href="%E3%80%90Qt%E3%80%91QAction%20Icon%20%E5%A4%A7%E5%B0%8F.md">【Qt】QAction Icon 大小</a><br><a href="%E3%80%90Qt%E3%80%91QListWidget%20%E7%94%A8%E6%B3%95%E6%95%B4%E7%90%86.md">【Qt】QListWidget 用法整理</a><br><a href="%E3%80%90Qt%E3%80%91Qss.md">【Qt】Qss</a><br><a href="%E3%80%90Qt%E3%80%91%E8%BF%87%E6%BB%A4%E5%99%A8.md">【Qt】过滤器</a><br><a href="%E3%80%90Qt%E3%80%91%E8%8E%B7%E5%8F%96cmd%E8%BE%93%E5%87%BA.md">【Qt】获取cmd输出</a><br><a href="%E3%80%90Qt%E3%80%91%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2.md">【Qt】随机字符串</a><br><a href="%E3%80%90Qt%E3%80%91%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B0%94%E6%B3%A1.md">【Qt】自定义气泡</a><br><a href="%E3%80%90Qt%E3%80%91Win%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5.md">【Qt】Win消息通知</a><br><a href="%E3%80%90Qt%E3%80%91%E7%AA%97%E5%8F%A3%E5%B1%85%E4%B8%AD.md">【Qt】窗口居中</a><br><a href="%E3%80%90Qt%E3%80%91%E7%AA%97%E5%8F%A3%E6%8B%96%E6%8B%BD.md">【Qt】窗口拖拽</a><br><a href="%E3%80%90Qt%E3%80%91%E8%8E%B7%E5%8F%96%E6%8E%A7%E4%BB%B6%E4%BD%8D%E7%BD%AE.md">【Qt】获取控件位置</a><br><a href="%E3%80%90Qt%E3%80%91%E6%88%AA%E5%9B%BE.md">【Qt】截图</a><br><a href="%E3%80%90Qt%E3%80%91%E6%B0%94%E6%B3%A1.md">【Qt】气泡</a><br><a href="%E3%80%90Qt%E3%80%91%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%E5%BF%AB%E6%8D%B7%E9%94%AE.md">【Qt】全局注册快捷键</a><br><a href="%E3%80%90Qt%E3%80%91%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC.md">【Qt】图片旋转</a><br><a href="%E3%80%90Qt%E3%80%91%E9%87%8D%E5%90%AF.md">【Qt】重启</a><br><a href="%E3%80%90Qt%E3%80%91QtHttp%E4%B8%8B%E8%BD%BD.md">【Qt】QtHttp下载</a><br><a href="QWin/%E3%80%90Qt%E3%80%91%E7%AA%97%E5%8F%A3%E9%80%82%E9%85%8D%E7%B3%BB%E7%BB%9F%E7%BC%A9%E6%94%BE.md">【Qt】窗口适配系统缩放</a><br><a href="QWebEngineView/%E3%80%90Qt%E3%80%91%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E6%85%A2.md">【Qt】网页加载慢</a><br><a href="QWebEngineView/%E3%80%90Qt%E3%80%91%E7%AA%97%E4%BD%93%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%88%96%E7%AA%97%E4%BD%93%E5%8D%8A%E9%80%8F%E6%98%8E.md">【Qt】窗体不显示或窗体半透明</a><br><a href="QTableWidget/%E3%80%90Qt%E3%80%91QTableWidget%E9%81%8D%E5%8E%86.md">【Qt】QTableWidget遍历</a><br><a href="QLineEdit/%E3%80%90Qt%E3%80%91QLineEdit%E4%BF%AE%E6%94%B9%E9%83%A8%E5%88%86%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F.md">【Qt】QLineEdit修改部分文本样式</a><br><a href="QLineEdit/%E3%80%90Qt%E3%80%91QLineEdit%20%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E6%98%BE%E7%A4%BA%E5%8F%8A%E5%85%B6%E6%98%BE%E7%A4%BA%E6%A0%B7%E5%BC%8F.md">【Qt】QLineEdit 修改密码显示及其显示样式</a><br><a href="%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98/%E3%80%90Qt%E3%80%91%E9%94%AE%E7%9B%98%E9%95%BF%E6%8C%89.md">【Qt】键盘长按</a><br><a href="%E5%86%85%E5%AD%98/%E3%80%90Qt%E3%80%91%E9%87%8D%E5%A4%8Dnew%E9%97%AE%E9%A2%98.md">【Qt】重复new问题</a><br><a href="%E5%8A%A8%E7%94%BB/%E3%80%90Qt%E3%80%91QStackWidget%E5%8A%A8%E7%94%BB2.md">【Qt】QStackWidget动画2</a><br><a href="%E5%8A%A8%E7%94%BB/%E3%80%90Qt%E3%80%91%E5%90%AF%E5%8A%A8%E5%8A%A8%E7%94%BB.md">【Qt】启动动画</a><br><a href="%E5%8A%A8%E7%94%BB/%E3%80%90Qt%E3%80%91%E4%BB%BB%E5%8A%A1%E6%A0%8F%E8%BF%9B%E5%BA%A6%E6%9D%A1.md">【Qt】任务栏进度条</a><br><a href="%E5%8A%A8%E7%94%BB/%E3%80%90Qt%E3%80%91%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1.md">【Qt】圆形进度条</a><br><a href="%E5%8A%A8%E7%94%BB/%E3%80%90Qt%E3%80%91QStackWidget%E5%8A%A8%E7%94%BB.md">【Qt】QStackWidget动画</a><br><a href="%E5%8A%A8%E7%94%BB/%E3%80%90Qt%E3%80%91%E5%8A%A8%E7%94%BB.md">【Qt】动画</a><br><a href="%E5%8A%A8%E7%94%BB/%E3%80%90Qt%E3%80%91%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C.md">【Qt】动画效果</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：Qt 文章汇总&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="B_Code" scheme="http://example.com/categories/B-Code/"/>
    
    <category term="Qt" scheme="http://example.com/categories/B-Code/Qt/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows API 索引</title>
    <link href="http://example.com/A_OS/Windows/API/%E3%80%90winapi%E3%80%91%E5%AF%BC%E8%AF%BB/"/>
    <id>http://example.com/A_OS/Windows/API/%E3%80%90winapi%E3%80%91%E5%AF%BC%E8%AF%BB/</id>
    <published>2024-08-13T07:59:39.120Z</published>
    <updated>2024-08-16T02:00:25.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：Windows API 文章汇总</p></blockquote><span id="more"></span><p><a href="%E3%80%90winapi%E3%80%91%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0.md">【winapi】查看进程启动命令行参数</a><br><a href="%E3%80%90winapi%E3%80%91VirtualProtect.md">【winapi】VirtualProtect</a><br><a href="%E3%80%90winapi%E3%80%91%E7%AE%A1%E9%81%93%E7%9A%84%E4%BD%BF%E7%94%A8.md">【winapi】管道的使用</a><br><a href="%E3%80%90winapi%E3%80%91%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E4%BA%8B%E4%BB%B6.md">【winapi】监控系统事件</a><br><a href="%E3%80%90winapi%E3%80%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%93%E5%BC%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E9%A1%B5.md">【winapi】命令行打开系统设置页</a><br><a href="%E3%80%90winapi%E3%80%91%E5%88%B7%E6%96%B0%E6%89%98%E7%9B%98%E5%9B%BE%E6%A0%87.md">【winapi】刷新托盘图标</a><br><a href="%E3%80%90winapi%E3%80%91%E7%B3%BB%E7%BB%9F%E9%94%81.md">【winapi】系统锁</a><br><a href="%E3%80%90winapi%E3%80%91API_%E5%8A%A0%E8%BD%BD%E5%8A%A8%E6%80%81%E5%BA%93.md">【winapi】API_加载动态库</a><br><a href="%E3%80%90winapi%E3%80%91%E3%80%90Win7%E3%80%91%E5%BC%B9%E5%87%BAU%E7%9B%98.md">【winapi】【Win7】弹出U盘</a><br><a href="%E3%80%90winapi%E3%80%91%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%90%8D.md">【winapi】获取系统当前用户名</a><br><a href="%E3%80%90winapi%E3%80%91CreateProcess.md">【winapi】CreateProcess</a><br><a href="%E3%80%90winapi%E3%80%91%E5%AE%89%E5%85%A8%E5%8A%A0%E8%BD%BDDLL.md">【winapi】安全加载DLL</a><br><a href="%E3%80%90winapi%E3%80%91%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7.md">【winapi】获取当前登录用户</a><br><a href="%E3%80%90winapi%E3%80%91%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%9F%9F%E5%90%8D.md">【winapi】获取系统域名</a><br><a href="%E3%80%90winapi%E3%80%91%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6.md">【winapi】删除文件目录下的所有文件</a><br><a href="%E3%80%90winapi%E3%80%91FormatErrMessage.md">【winapi】FormatErrMessage</a><br><a href="%E3%80%90winapi%E3%80%91FormatMessageA.md">【winapi】FormatMessageA</a><br><a href="%E3%80%90winapi%E3%80%91GetModuleHandle.md">【winapi】GetModuleHandle</a><br><a href="%E3%80%90winapi%E3%80%91GetPrivageProfileString.md">【winapi】GetPrivageProfileString</a><br><a href="%E3%80%90winapi%E3%80%91ShellExecute.md">【winapi】ShellExecute</a><br><a href="%E3%80%90winapi%E3%80%91VirtualAlloc.md">【winapi】VirtualAlloc</a><br><a href="CreateRemoteThread/%E3%80%90winapi%E3%80%91%E8%BF%9C%E7%A8%8B%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%87%8A%E6%94%BEDLL.md">【winapi】远程加载和释放DLL</a><br><a href="CreateRemoteThread/%E3%80%90winapi%E3%80%91CreateRemoteThread%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.md">【winapi】CreateRemoteThread简单使用</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：Windows API 文章汇总&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="API" scheme="http://example.com/categories/A-OS/Windows/API/"/>
    
    
  </entry>
  
  <entry>
    <title>【Win7】弹出U盘</title>
    <link href="http://example.com/A_OS/Windows/API/%E3%80%90winapi%E3%80%91%E3%80%90Win7%E3%80%91%E5%BC%B9%E5%87%BAU%E7%9B%98/"/>
    <id>http://example.com/A_OS/Windows/API/%E3%80%90winapi%E3%80%91%E3%80%90Win7%E3%80%91%E5%BC%B9%E5%87%BAU%E7%9B%98/</id>
    <published>2024-08-12T07:51:38.616Z</published>
    <updated>2024-08-23T01:11:52.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：Win7 弹出U盘的方式汇总</p></blockquote><span id="more"></span><p>参考文章：</p><ul><li><a href="https://www.codeproject.com/articles/13839/how-to-prepare-a-usb-drive-for-safe-removal">How to Prepare a USB Drive for Safe Removal - CodeProject</a><br>参考代码：</li><li><a href="https://github.com/balena-io-modules/mountutils">balena-io-modules&#x2F;mountutils: Cross platform mount related utilities</a></li><li><a href="https://github.com/dindinw/imdisk/blob/3f4672f83f02d18230bc1d47eb4617d106cc922c/cli/imdisk.c">imdisk&#x2F;cli&#x2F;imdisk.c at 3f4672f83f02d18230bc1d47eb4617d106cc922c · dindinw&#x2F;imdisk</a></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>用户环境：Windows 7 x64 旗舰版 </p></blockquote><p>客户反馈使用 [U盘小助手] 弹出U盘时报错。弹出失败，每次都需要强制弹出才能弹出U盘，且强制弹出后 [Explorer] 界面仍会显示 U盘 对应的磁盘（没有容量）。但是使用系统的弹出是可以弹出的，且U盘图标弹出逻辑也正常。</p><img src="/A_OS/Windows/API/%E3%80%90winapi%E3%80%91%E3%80%90Win7%E3%80%91%E5%BC%B9%E5%87%BAU%E7%9B%98/IMG-20240816095738730.png" class=""><img src="/A_OS/Windows/API/%E3%80%90winapi%E3%80%91%E3%80%90Win7%E3%80%91%E5%BC%B9%E5%87%BAU%E7%9B%98/IMG-20240816095738807.png" class=""><p>异常情况就是上述两者发生：</p><img src="/A_OS/Windows/API/%E3%80%90winapi%E3%80%91%E3%80%90Win7%E3%80%91%E5%BC%B9%E5%87%BAU%E7%9B%98/IMG-20240816095738951.png" class=""><h2 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h2><h3 id="句柄未关闭"><a href="#句柄未关闭" class="headerlink" title="句柄未关闭"></a>句柄未关闭</h3><p>排查是否有未关闭的句柄导致弹出失败。具体就是使用 [Process Explorer] 查找 [U盘] 句柄。</p><h3 id="被拦截"><a href="#被拦截" class="headerlink" title="被拦截"></a>被拦截</h3><ol><li>查看系统日志</li><li>查看 API 调用</li></ol><h3 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a>查看代码</h3><p>如果以上均排查不出来问题，那就只能看是不是代码写的有问题了。</p><p>以上只是常见的排查思路，具体问题具体分析。</p><h3 id="弹出调用失败"><a href="#弹出调用失败" class="headerlink" title="弹出调用失败"></a>弹出调用失败</h3><p>代码中调用弹出的接口是 <code>CM_Request_Device_Eject_Ex</code></p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>驱动问题，调用 <code>CM_Request_Device_Eject_Ex</code> 弹出时 <code>pVetoType</code> 返回 <code>PNP_VetoIllegalDeviceRequest</code>，表示当前设备不支持。这个在别的机器上是无法复现，截止目前我也不知道这个问题的根源是什么。只能通过别的方式弹出。</p><p>目前看只有 <code>CM_Request_Device_Eject_Ex</code> 才能从设备管理器界面弹出U盘。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CMAPI</span></span><br><span class="line"><span class="function">CONFIGRET</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">CM_Request_Device_Eject_ExW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_  DEVINST       dnDevInst,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ PPNP_VETO_TYPE pVetoType,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_writes_opt_(ulNameLength) LPWSTR pszVetoName,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_  ULONG         ulNameLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_  ULONG         ulFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HMACHINE   hMachine</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>当 <code>CM_Request_Device_Eject_Ex</code> 接口不支持调用时，常见的方式就是调用 <code>DeviceIOControl</code> 来强制弹出U盘。示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STDAPI_</span>(BOOL) <span class="built_in">EjectVolumeForce</span>(DWORD dwVolLetter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Enter EjectVolumeForce&quot;</span>);</span><br><span class="line"></span><br><span class="line">WCHAR wszVolume[<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">WCHAR  wszVolShort[<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">DWORD dwReturn = <span class="number">0</span>;</span><br><span class="line">HANDLE hVolume = INVALID_HANDLE_VALUE;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line"></span><br><span class="line"><span class="built_in">StringCchPrintf</span>(wszVolShort, <span class="built_in">ARRAYSIZE</span>(wszVolShort), <span class="string">L&quot;%c:\\&quot;</span>, dwVolLetter);</span><br><span class="line"><span class="built_in">StringCchPrintf</span>(wszVolume, <span class="built_in">ARRAYSIZE</span>(wszVolume), <span class="string">L&quot;\\\\.\\%c:&quot;</span>, dwVolLetter);</span><br><span class="line"></span><br><span class="line">hVolume = <span class="built_in">CreateFile</span>(wszVolume, GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hVolume == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;ERROR! Can not open volume!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 硬盘强制弹出失败率大</span></span><br><span class="line"><span class="keyword">if</span> (DRIVE_FIXED == <span class="built_in">GetDriveType</span>(wszVolShort))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;DRIVE_FIXED == GetDriveType(wszVolShort)&quot;</span>);</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;GetDriveType(wszVolShort) == %d&quot;</span>, <span class="built_in">GetDriveType</span>(wszVolShort));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始暴力弹出</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">DeviceIoControl</span>(hVolume, FSCTL_DISMOUNT_VOLUME, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwReturn, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwTmp = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;IOCTL_STORAGE_MEDIA_REMOVAL&quot;</span>);</span><br><span class="line">bRet = <span class="built_in">DeviceIoControl</span>(hVolume, IOCTL_STORAGE_MEDIA_REMOVAL, &amp;dwTmp, <span class="built_in">sizeof</span>(dwTmp), <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwReturn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;IOCTL_STORAGE_MEDIA_REMOVAL, bRet==%d&quot;</span>, bRet);</span><br><span class="line">bRet = <span class="built_in">DeviceIoControl</span>(hVolume, IOCTL_DISK_EJECT_MEDIA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwReturn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;IOCTL_DISK_EJECT_MEDIA bRet==%d&quot;</span>, bRet);</span><br><span class="line">bRet = <span class="built_in">DeviceIoControl</span>(hVolume, IOCTL_STORAGE_EJECT_MEDIA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwReturn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;IOCTL_STORAGE_EJECT_MEDIA bRet==%d&quot;</span>, bRet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 弹出是否成功</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">PathFileExists</span>(wszVolShort))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DeleteJunctionPoint</span>(dwVolLetter);</span><br><span class="line">bRet = TRUE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE != hVolume)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hVolume);</span><br><span class="line">hVolume = INVALID_HANDLE_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在大多是机器都是正常的，但是在该客户的机器，调用上述代码后，虽然U盘设备已经移除，但是explorer 仍会有U盘图标显示。对此，我的解决方案就是刷新一下 explorer 界面，让已弹出的U盘不显示。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>总共试了以下多个 API 尝试通知到 explorer。</p><h3 id="API-1-DeleteVolumeMountPointW-不要用"><a href="#API-1-DeleteVolumeMountPointW-不要用" class="headerlink" title="API 1 DeleteVolumeMountPointW (不要用)"></a>API 1 DeleteVolumeMountPointW (不要用)</h3><p>由于尝试了多个 API 无果后，就尝试了调用了 以下接口，导致了后续一系列问题，在此避坑，建议了解当前函数的使用场景后再决定是否调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeleteVolumeMountPointW</span><br></pre></td></tr></table></figure><h3 id="API-2-DefineDosDevice"><a href="#API-2-DefineDosDevice" class="headerlink" title="API 2 DefineDosDevice"></a>API 2 DefineDosDevice</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-definedosdevicea">DefineDosDeviceA 函数 (winbase.h) - Win32 apps | Microsoft Learn</a><br>DefineDosDevice 会删除驱动器号。但是在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveDrive</span><span class="params">(<span class="type">char</span> driveLetter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;RemoveDrive&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> deviceName[] = <span class="string">L&quot;\\??\\X:&quot;</span>;</span><br><span class="line">deviceName[<span class="number">4</span>] = driveLetter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除设备挂载点</span></span><br><span class="line"><span class="built_in">DefineDosDevice</span>(DDD_REMOVE_DEFINITION, deviceName, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API-3-SendMessage"><a href="#API-3-SendMessage" class="headerlink" title="API 3 SendMessage"></a>API 3 SendMessage</h3><p>通过 <code>SendMessage</code> 发送 <code>WM_DEVICECHANGE</code> 消息给所有窗口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NotifyDeviceRemoval</span><span class="params">(DWORD dwVolLetter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;NotifyDeviceRemoval&quot;</span>);</span><br><span class="line">DEV_BROADCAST_VOLUME dbv = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">dbv.dbcv_size = <span class="built_in">sizeof</span>(DEV_BROADCAST_VOLUME);</span><br><span class="line">dbv.dbcv_devicetype = DBT_DEVTYP_VOLUME;</span><br><span class="line">dbv.dbcv_unitmask = <span class="number">1</span> &lt;&lt; (dwVolLetter - <span class="string">L&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SendMessage</span>(HWND_BROADCAST, WM_DEVICECHANGE, DBT_DEVICEREMOVECOMPLETE, (LPARAM)&amp;dbv); <span class="comment">// 这一步其实已经是可以了，但是这个客户机器还是不行，调用后设备管理器界面会有延迟，但是 explorer 界面会立即刷新。</span></span><br><span class="line"><span class="built_in">SendMessage</span>(HWND_BROADCAST, WM_DEVICECHANGE, DBT_DEVICEREMOVECOMPLETE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API-4-RunDLL32-EXE"><a href="#API-4-RunDLL32-EXE" class="headerlink" title="API 4 RunDLL32.EXE"></a>API 4 RunDLL32.EXE</h3><p>调用 <code>RunDLL32.EXE</code> 来实现弹出。以下两种方法均不可行，有需求可以深入研究下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EjectDriveWithShell</span><span class="params">(<span class="type">char</span> driveLetter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;EjectDriveWithShell&quot;</span>);</span><br><span class="line"><span class="type">wchar_t</span> command[] = <span class="string">L&quot;RunDLL32.EXE shell32.dll,Control_RunDLL hotplug.dll&quot;</span>;</span><br><span class="line"><span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>, <span class="string">L&quot;open&quot;</span>, command, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SW_SHOWNORMAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunDLL32.EXE shell32.dll,SHInvokeCommand 0 &quot;EjectPC&quot; &quot;%c:\\&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EjectDriveWithShell</span><span class="params">(<span class="type">char</span> driveLetter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;EjectDriveWithShell&quot;</span>);</span><br><span class="line"><span class="type">wchar_t</span> command[MAX_PATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">wsprintf</span>(command, <span class="string">L&quot;RunDLL32.EXE shell32.dll,SHInvokeCommand 0 \&quot;EjectPC\&quot; \&quot;%c:\\\\\&quot;&quot;</span>, driveLetter);</span><br><span class="line"><span class="built_in">ShellExecute</span>(<span class="literal">NULL</span>, <span class="string">L&quot;open&quot;</span>, command, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SW_SHOWNORMAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API-5-重新挂载达到刷新目的"><a href="#API-5-重新挂载达到刷新目的" class="headerlink" title="API 5 重新挂载达到刷新目的"></a>API 5 重新挂载达到刷新目的</h3><p>结果：同样不生效，U盘设备移除，但是 Expolorer 图标仍在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemountDrive</span><span class="params">(<span class="type">char</span> driveLetter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;RemountDrive&quot;</span>);</span><br><span class="line"><span class="type">wchar_t</span> deviceName[] = <span class="string">L&quot;\\\\.\\X:&quot;</span>;</span><br><span class="line">deviceName[<span class="number">4</span>] = driveLetter;</span><br><span class="line"></span><br><span class="line">HANDLE hDevice = <span class="built_in">CreateFile</span>(deviceName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hDevice != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">DWORD bytesReturned;</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, FSCTL_DISMOUNT_VOLUME, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bytesReturned, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, IOCTL_STORAGE_EJECT_MEDIA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;bytesReturned, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新挂载驱动器</span></span><br><span class="line">hDevice = <span class="built_in">CreateFile</span>(deviceName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hDevice != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API-5-BroadcastSystemMessage"><a href="#API-5-BroadcastSystemMessage" class="headerlink" title="API 5 BroadcastSystemMessage"></a>API 5 BroadcastSystemMessage</h3><p>调用 <code>BroadcastSystemMessage</code> 广播通知设备改动<br>结果：不生效，图标在、设备也在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BroadcastDeviceChange</span><span class="params">(DWORD dwVolLetter)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 模拟设备移除消息</span></span><br><span class="line">DEV_BROADCAST_VOLUME dbv;</span><br><span class="line">dbv.dbcv_size = <span class="built_in">sizeof</span>(DEV_BROADCAST_VOLUME);</span><br><span class="line">dbv.dbcv_devicetype = DBT_DEVTYP_VOLUME;</span><br><span class="line">dbv.dbcv_reserved = <span class="number">0</span>;</span><br><span class="line">dbv.dbcv_unitmask = <span class="number">1</span> &lt;&lt; (dwVolLetter - <span class="string">L&#x27;A&#x27;</span>); <span class="comment">// 假设 E: 是 U 盘的盘符</span></span><br><span class="line">dbv.dbcv_flags = DBTF_MEDIA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向系统广播设备变更消息</span></span><br><span class="line"><span class="built_in">BroadcastSystemMessage</span>(BSF_IGNORECURRENTTASK | BSF_POSTMESSAGE, BSM_ALLCOMPONENTS, WM_DEVICECHANGE, DBT_DEVICEREMOVECOMPLETE, (LPARAM)&amp;dbv);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API-6-刷新设备列表"><a href="#API-6-刷新设备列表" class="headerlink" title="API 6 刷新设备列表"></a>API 6 刷新设备列表</h3><p>调用 <code>SetupDI*</code> 接口刷新设备列表。<br>结果：无效。因为设备并没有实际弹出，所有刷新后设备列表还是会有便携设备存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RefreshDevice</span><span class="params">(LPCWSTR deviceInstanceId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;RefreshDevice&quot;</span>);</span><br><span class="line">HDEVINFO deviceInfoSet = <span class="built_in">SetupDiGetClassDevs</span>(<span class="literal">NULL</span>, deviceInstanceId, <span class="literal">NULL</span>, DIGCF_ALLCLASSES | DIGCF_PRESENT);</span><br><span class="line"><span class="keyword">if</span> (deviceInfoSet == INVALID_HANDLE_VALUE) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SP_DEVINFO_DATA deviceInfoData;</span><br><span class="line">deviceInfoData.cbSize = <span class="built_in">sizeof</span>(SP_DEVINFO_DATA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SetupDiEnumDeviceInfo</span>(deviceInfoSet, <span class="number">0</span>, &amp;deviceInfoData)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SetupDiCallClassInstaller</span>(DIF_PROPERTYCHANGE, deviceInfoSet, &amp;deviceInfoData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetupDiDestroyDeviceInfoList</span>(deviceInfoSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API-7-刷新-Explorer-界面"><a href="#API-7-刷新-Explorer-界面" class="headerlink" title="API 7 刷新 Explorer 界面"></a>API 7 刷新 Explorer 界面</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">RefreshFolderViews</span><span class="params">(UINT csidl, LONG wEventId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPITEMIDLIST pidl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(<span class="built_in">SHGetSpecialFolderLocation</span>(<span class="literal">NULL</span>, csidl, &amp;pidl)))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidl, 0);</span></span><br><span class="line"><span class="built_in">SHChangeNotify</span>(wEventId, SHCNF_IDLIST|SHCNF_FLUSH, pidl, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">CoTaskMemFree</span>(pidl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h2><p>调用 <code>DeivceIOControl</code> 强制弹出，然后通知界面刷新。</p><p>界面刷新调用了 <code>SendMessage</code> 和 <code>SHChangeNotify</code>，代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NotifyDeviceRemoval</span>(dwVolLetter);</span><br><span class="line"><span class="built_in">SHChangeNotify</span>(SHCNE_DRIVEREMOVED, SHCNF_PATH, wszVolShort, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">SHChangeNotify</span>(SHCNE_DRIVEADD, SHCNF_PATH, wszVolShort, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>事实上，只要 <code>CM_Request_Device_Eject_Ex</code> 调用成功，那图标缓存和设备列表都会更新，但是调用失败的时候就比较复杂，尤其是返回 <code>PNP_VetoIllegalDeviceRequest</code> 时，没有合适的方法能从设备列表移除设备。</p><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WCHAR wszDrivePoint[<span class="number">3</span>] = <span class="string">L&quot; :&quot;</span>;</span><br><span class="line">wszDrivePoint[<span class="number">0</span>] = dwVolLetter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DefineDosDevice</span>(DDD_REMOVE_DEFINITION | DDD_EXACT_MATCH_ON_REMOVE, wszDrivePoint, <span class="literal">NULL</span>))</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;DDD_REMOVE_DEFINITION bRet==%d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：Win7 弹出U盘的方式汇总&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="API" scheme="http://example.com/categories/A-OS/Windows/API/"/>
    
    
    <category term="Windows/Win7" scheme="http://example.com/tags/Windows-Win7/"/>
    
  </entry>
  
  <entry>
    <title>【服务】Windows 更新医生服务</title>
    <link href="http://example.com/A_OS/Windows/%E6%9C%8D%E5%8A%A1/%E3%80%90%E6%9C%8D%E5%8A%A1%E3%80%91Windows%20%E6%9B%B4%E6%96%B0%E5%8C%BB%E7%94%9F%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/A_OS/Windows/%E6%9C%8D%E5%8A%A1/%E3%80%90%E6%9C%8D%E5%8A%A1%E3%80%91Windows%20%E6%9B%B4%E6%96%B0%E5%8C%BB%E7%94%9F%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-08-12T07:05:26.949Z</published>
    <updated>2024-08-15T09:19:54.681Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：Windows 更新医生服务说明</p></blockquote><span id="more"></span><p>相关链接：</p><ul><li><a href="https://malwaretips.com/blogs/windows-update-medic-service-process-why-is-it-running/">Windows Update Medic Service Process: Why Is It Running?</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：Windows 更新医生服务说明&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="服务" scheme="http://example.com/categories/A-OS/Windows/%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="服务" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="svchost" scheme="http://example.com/tags/svchost/"/>
    
  </entry>
  
  <entry>
    <title>【服务】svchost 启动命令行整理</title>
    <link href="http://example.com/A_OS/Windows/%E6%9C%8D%E5%8A%A1/%E3%80%90%E6%9C%8D%E5%8A%A1%E3%80%91svchost%20%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/A_OS/Windows/%E6%9C%8D%E5%8A%A1/%E3%80%90%E6%9C%8D%E5%8A%A1%E3%80%91svchost%20%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%95%B4%E7%90%86/</id>
    <published>2024-08-12T06:47:37.273Z</published>
    <updated>2024-08-16T01:56:17.945Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>:construction: 概述：Windows Svchost 对应的服务和启动命令行整理</p></blockquote><span id="more"></span><table><thead><tr><th>启动命令行</th><th>对应服务</th></tr></thead><tbody><tr><td>svchost.exe -k wusvcs -p</td><td><a href="obsidian://open?vault=source&file=_posts%2FA_OS%2FWindows%2F%E6%9C%8D%E5%8A%A1%2F%E3%80%90%E6%9C%8D%E5%8A%A1%E3%80%91Windows%20%E6%9B%B4%E6%96%B0%E5%8C%BB%E7%94%9F%E6%9C%8D%E5%8A%A1">Windows 更新医生服务</a></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;:construction: 概述：Windows Svchost 对应的服务和启动命令行整理&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="服务" scheme="http://example.com/categories/A-OS/Windows/%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>【异常处理】WPD驱动异常</title>
    <link href="http://example.com/A_OS/Windows/%E5%BC%82%E5%B8%B8%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/%E3%80%90%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%91WPD%E9%A9%B1%E5%8A%A8%E5%BC%82%E5%B8%B8/"/>
    <id>http://example.com/A_OS/Windows/%E5%BC%82%E5%B8%B8%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/%E3%80%90%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%91WPD%E9%A9%B1%E5%8A%A8%E5%BC%82%E5%B8%B8/</id>
    <published>2024-08-12T06:14:43.094Z</published>
    <updated>2024-08-15T09:53:24.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：本文记录 WPD 驱动加载异常，错误代码（10）如何解决</p></blockquote><span id="more"></span><p>报错如下所示：该设备无法启动。（代码 10）<br><img src="/./%E3%80%90%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%91WPD%E9%A9%B1%E5%8A%A8%E5%BC%82%E5%B8%B8/IMG-20240812144419365.png"></p><h2 id="相关解决办法"><a href="#相关解决办法" class="headerlink" title="相关解决办法"></a>相关解决办法</h2><p><a href="https://zh.211service.com/how-fix-wpd-filesystem-volume-driver-issue-windows-10-8-7">如何修复Windows 10&#x2F;8&#x2F;7上的WPD FileSystem Volume Driver问题 - 其他</a></p><p><a href="https://www.cnblogs.com/xiaohi/p/13698144.html">win7 64 USB驱动（支持Z390、H370、B360、H310） - article - 博客园</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：本文记录 WPD 驱动加载异常，错误代码（10）如何解决&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="异常及错误处理" scheme="http://example.com/categories/A-OS/Windows/%E5%BC%82%E5%B8%B8%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="驱动" scheme="http://example.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>【DbgHelp】通过PDB在PE中查找函数</title>
    <link href="http://example.com/A_OS/Windows/DbgHelp/%E3%80%90DbgHelp%E3%80%91%E9%80%9A%E8%BF%87PDB%E5%9C%A8PE%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/A_OS/Windows/DbgHelp/%E3%80%90DbgHelp%E3%80%91%E9%80%9A%E8%BF%87PDB%E5%9C%A8PE%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0/</id>
    <published>2024-08-11T16:00:00.000Z</published>
    <updated>2024-08-20T09:36:28.839Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：如何使用 PDB 查找 PE 中的特定函数名的函数</p></blockquote><span id="more"></span><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>如果查找指定PE中是否声明和使用了某函数，则需要使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/dbghelp/">Dbghelp.h 标头 - Win32 apps | Microsoft Learn</a> 模块。</p><ol><li><p>如何获取 PDB 文件<br>需要调用 symchk 从微软下载，symchk 的调用命令如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symchk /r &lt;路径到PE文件&gt; /s SRV*&lt;本地符号存储路径&gt;*&lt;微软符号服务器路径&gt;</span><br><span class="line">   </span><br><span class="line"># 示例</span><br><span class="line"></span><br><span class="line">symchk /r C:\Windows\System32\notepad.exe /s SRV*C:\Symbols*http:<span class="comment">//msdl.microsoft.com/download/symbols</span></span><br></pre></td></tr></table></figure></li><li><p>加载  PDB 文件<br>加载 PDB 需要调用 <code>SymLoadModuleExW</code> 加载</p></li><li><p>查找符号<br>查找符号可使用 <code>SymFromNameW</code> 或者 <code>SymEnumSymbolsW</code>，区别在于 <code>SymEnumSymbolsW</code> 注册的回调可以看到是查找的函数名详细信息。</p></li></ol><p>下载后获取符号下载路径<br>需要获取 PDB 文件的下载路径，大致形式如下所示，其中 <code>acppage.pdb</code>  为 PE 文件中获取的 PDB 文件名，<code>E07A9D2F9AE2077290F2627631E6C50C1</code> 为 PE 文件中获取的 GUID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d:\symbols\acppage.pdb\E07A9D2F9AE2077290F2627631E6C50C1\acppage.pdb</span><br></pre></td></tr></table></figure><p>PE 解析简要说明，相关函数名为 <code>GetPdbFileInfo</code> ：</p><ol><li>读取 PE 中的 <code>IMAGE_DIRECTORY_ENTRY_DEBUG</code> 区</li><li>根据偏移获取 <code>PIMAGE_DEBUG_DIRECTORY</code></li><li>遍历  <code>IMAGE_DEBUG_DIRECTORY</code>，查找 <code>Type</code> 为 <code>IMAGE_DEBUG_TYPE_CODEVIEW</code> 的 <code>IMAGE_DEBUG_DIRECTORY</code></li><li>查看当前块标志位是否为 <code>CV_SIGNATURE_RSDS</code>(<code>SDSR</code>)  ，如果是，则通过 PCV_INFO_PDB70 解析当前内存块，读取签名和 PDB 文件名</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FindTheSqlMagicCode.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strsafe.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Dbghelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shlwapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;Dbghelp.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;shlwapi.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CV_SIGNATURE_NB10   <span class="string">&#x27;01BN&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CV_SIGNATURE_RSDS   <span class="string">&#x27;SDSR&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESET   <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK   <span class="string">&quot;\033[30m&quot;</span>      <span class="comment">/* Black */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED     <span class="string">&quot;\033[31m&quot;</span>      <span class="comment">/* Red */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN   <span class="string">&quot;\033[32m&quot;</span>      <span class="comment">/* Green */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW  <span class="string">&quot;\033[33m&quot;</span>      <span class="comment">/* Yellow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE    <span class="string">&quot;\033[34m&quot;</span>      <span class="comment">/* Blue */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGENTA <span class="string">&quot;\033[35m&quot;</span>      <span class="comment">/* Magenta */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CYAN    <span class="string">&quot;\033[36m&quot;</span>      <span class="comment">/* Cyan */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE   <span class="string">&quot;\033[37m&quot;</span>      <span class="comment">/* White */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOLDGREEN    <span class="string">&quot;\033[1m\033[32m&quot;</span>      <span class="comment">/* Bold Green */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CodeView header </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CV_HEADER</span> </span><br><span class="line">&#123;</span><br><span class="line">DWORD CvSignature; <span class="comment">// NBxx</span></span><br><span class="line">LONG  Offset;      <span class="comment">// Always 0 for NB10</span></span><br><span class="line">&#125; * PCV_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CodeView NB10 debug information </span></span><br><span class="line"><span class="comment">// (used when debug information is stored in a PDB 2.00 file) </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CV_INFO_PDB20</span> </span><br><span class="line">&#123;</span><br><span class="line">CV_HEADER  Header; </span><br><span class="line">DWORD      Signature;       <span class="comment">// seconds since 01.01.1970</span></span><br><span class="line">DWORD      Age;             <span class="comment">// an always-incrementing value </span></span><br><span class="line">BYTE       PdbFileName[<span class="number">1</span>];  <span class="comment">// zero terminated string with the name of the PDB file </span></span><br><span class="line">&#125; * PCV_INFO_PDB20;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CodeView RSDS debug information </span></span><br><span class="line"><span class="comment">// (used when debug information is stored in a PDB 7.00 file) </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CV_INFO_PDB70</span> </span><br><span class="line">&#123;</span><br><span class="line">DWORD      CvSignature; </span><br><span class="line">GUID       Signature;       <span class="comment">// unique identifier </span></span><br><span class="line">DWORD      Age;             <span class="comment">// an always-incrementing value </span></span><br><span class="line">BYTE       PdbFileName[<span class="number">1</span>];  <span class="comment">// zero terminated string with the name of the PDB file </span></span><br><span class="line">&#125; * PCV_INFO_PDB70;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LPBYTE <span class="title">GetRVAOffset</span><span class="params">(LPBYTE pBuffer, DWORD dwVirtualOffset)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;</span><br><span class="line">PIMAGE_NT_HEADERS32  pNtHeader32 = (PIMAGE_NT_HEADERS32)(pBuffer + pDosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_NT_HEADERS64  pNtHeader64 = (PIMAGE_NT_HEADERS64)(pBuffer + pDosHeader-&gt;e_lfanew);</span><br><span class="line">BOOL bIsX64 = pNtHeader32-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nSectionNum = bIsX64 ? pNtHeader64-&gt;FileHeader.NumberOfSections : pNtHeader32-&gt;FileHeader.NumberOfSections;</span><br><span class="line">PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)(pBuffer + pDosHeader-&gt;e_lfanew + (bIsX64 ? <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS64) : <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS32)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// search for absolute offset</span></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; nSectionNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwStart = pSection-&gt;VirtualAddress;  </span><br><span class="line"><span class="keyword">if</span>( dwStart &lt;= dwVirtualOffset &amp;&amp; dwVirtualOffset &lt; dwStart + pSection-&gt;SizeOfRawData)&#123;  </span><br><span class="line"><span class="keyword">return</span> pBuffer + pSection-&gt;PointerToRawData + (dwVirtualOffset - dwStart);  </span><br><span class="line">&#125;</span><br><span class="line">pSection++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetImageSize</span><span class="params">(LPBYTE pBuffer, BOOL&amp; bIsX64)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;</span><br><span class="line">PIMAGE_NT_HEADERS32  pNtHeader32 = (PIMAGE_NT_HEADERS32)(pBuffer + pDosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_NT_HEADERS64  pNtHeader64 = (PIMAGE_NT_HEADERS64)(pBuffer + pDosHeader-&gt;e_lfanew);</span><br><span class="line">bIsX64 = pNtHeader32-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC;</span><br><span class="line"></span><br><span class="line">DWORD SizeOfImage = bIsX64 ? pNtHeader64-&gt;OptionalHeader.SizeOfImage: pNtHeader32-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SizeOfImage;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">WCHAR*  <span class="title">CharToWchar</span><span class="params">(CHAR* sSour)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(sSour) + <span class="number">1</span>;</span><br><span class="line"><span class="type">size_t</span> converted = <span class="number">0</span>;</span><br><span class="line">WCHAR *wzDest = <span class="literal">NULL</span>;</span><br><span class="line">wzDest = (WCHAR*)<span class="keyword">new</span> WCHAR[len];</span><br><span class="line"><span class="built_in">mbstowcs_s</span>(&amp;converted, wzDest, len, sSour, _TRUNCATE);</span><br><span class="line"><span class="keyword">return</span> wzDest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>*  <span class="title">WCharToChar</span><span class="params">(WCHAR* wzSour)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ULONG ulLength = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* szDest = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wzSour != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ulLength = <span class="built_in">WideCharToMultiByte</span>(CP_ACP,<span class="literal">NULL</span>, wzSour,<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,FALSE);</span><br><span class="line">szDest = <span class="keyword">new</span> <span class="type">char</span>[ulLength + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (szDest == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(szDest, <span class="number">0</span>, ulLength + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">WideCharToMultiByte</span>(CP_OEMCP, <span class="literal">NULL</span>, wzSour, <span class="number">-1</span>, szDest, ulLength, <span class="literal">NULL</span>, FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> szDest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetPdbFileInfo</span><span class="params">(LPCWSTR lpszFilePath</span></span></span><br><span class="line"><span class="params"><span class="function">, LPWSTR szPdbFileName</span></span></span><br><span class="line"><span class="params"><span class="function">, DWORD dwPdbFileNameCch</span></span></span><br><span class="line"><span class="params"><span class="function">, LPWSTR szPdbGuid</span></span></span><br><span class="line"><span class="params"><span class="function">, DWORD dwPdbGuidCch</span></span></span><br><span class="line"><span class="params"><span class="function">, LPWSTR szChecksum</span></span></span><br><span class="line"><span class="params"><span class="function">, DWORD dwChecksumCch</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">DWORD dwTotalRead = <span class="number">0</span>, dwRead = <span class="number">0</span>;</span><br><span class="line">DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">BOOL bFound = FALSE;</span><br><span class="line">HANDLE hFile = INVALID_HANDLE_VALUE;</span><br><span class="line">LPBYTE pBuffer = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// read the file into memory</span></span><br><span class="line">HANDLE hFile = ::<span class="built_in">CreateFileW</span>( lpszFilePath</span><br><span class="line">, GENERIC_READ</span><br><span class="line">, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE</span><br><span class="line">, <span class="literal">NULL</span></span><br><span class="line">, OPEN_EXISTING</span><br><span class="line">, FILE_ATTRIBUTE_NORMAL</span><br><span class="line">, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span>( hFile == INVALID_HANDLE_VALUE )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dwSize = <span class="built_in">GetFileSize</span>( hFile, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>( dwSize &lt; <span class="number">4096</span> ) <span class="comment">// hardcode for file size limit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pBuffer = (LPBYTE)<span class="built_in">HeapAlloc</span>( <span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, dwSize);</span><br><span class="line"><span class="keyword">if</span>(!pBuffer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( dwTotalRead &lt; dwSize &amp;&amp;</span><br><span class="line"><span class="built_in">ReadFile</span>( hFile, pBuffer + dwTotalRead, dwSize - dwTotalRead, &amp;dwRead, <span class="literal">NULL</span>) )</span><br><span class="line">&#123;</span><br><span class="line">dwTotalRead += dwRead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">::<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pBuffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dwTotalRead != dwSize)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(pBuffer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">HeapFree</span>( <span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, pBuffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPWSTR lpszpdbInfo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// locate the DEBUG section</span></span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuffer;</span><br><span class="line"><span class="keyword">if</span>( pDosHeader-&gt;e_magic == IMAGE_DOS_SIGNATURE )</span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_DATA_DIRECTORY pDataDic;</span><br><span class="line">PIMAGE_NT_HEADERS32  pNtHeader32 = (PIMAGE_NT_HEADERS32)(pBuffer + pDosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_NT_HEADERS64  pNtHeader64 = (PIMAGE_NT_HEADERS64)(pBuffer + pDosHeader-&gt;e_lfanew);</span><br><span class="line"><span class="keyword">if</span>( pNtHeader32-&gt;Signature == IMAGE_NT_SIGNATURE )</span><br><span class="line">&#123;</span><br><span class="line">BOOL bIsX64 = pNtHeader32-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC;</span><br><span class="line"><span class="keyword">if</span>( !bIsX64 )</span><br><span class="line">pDataDic = &amp;pNtHeader32-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pDataDic = &amp;pNtHeader64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( pDataDic &amp;&amp; pDataDic-&gt;Size &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//The number of entries in the debug directory can be obtained by dividing the size of the debug directory (as specified in the optional header’s data directory entry) by the size of IMAGE_DEBUG_DIRECTORY structure.</span></span><br><span class="line"><span class="type">int</span> nNumberOfEntries = pDataDic-&gt;Size / <span class="built_in">sizeof</span>(IMAGE_DEBUG_DIRECTORY);</span><br><span class="line">PIMAGE_DEBUG_DIRECTORY pDebugDic = (PIMAGE_DEBUG_DIRECTORY)<span class="built_in">GetRVAOffset</span>( pBuffer, pDataDic-&gt;VirtualAddress);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; nNumberOfEntries &amp;&amp; !bFound ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// CodeView debug information (stored in the executable) or Program Database debug information (stored in PDB file)</span></span><br><span class="line"><span class="keyword">if</span>( pDebugDic-&gt;Type == IMAGE_DEBUG_TYPE_CODEVIEW )</span><br><span class="line">&#123;</span><br><span class="line">LPBYTE pDebugData = pBuffer + pDebugDic-&gt;PointerToRawData;</span><br><span class="line">DWORD dwCVSignature = *(LPDWORD)pDebugData; </span><br><span class="line"><span class="keyword">if</span>( dwCVSignature == CV_SIGNATURE_RSDS  )</span><br><span class="line">&#123;</span><br><span class="line">PCV_INFO_PDB70 pCvInfo = (PCV_INFO_PDB70)pDebugData; </span><br><span class="line"><span class="built_in">StringCbPrintfW</span>( szPdbGuid, dwPdbFileNameCch</span><br><span class="line">, <span class="string">L&quot;%08X%04X%04X%02X%02X%02X%02X%02X%02X%02X%02X%d&quot;</span></span><br><span class="line">, pCvInfo-&gt;Signature.Data1</span><br><span class="line">, pCvInfo-&gt;Signature.Data2</span><br><span class="line">, pCvInfo-&gt;Signature.Data3</span><br><span class="line">, pCvInfo-&gt;Signature.Data4[<span class="number">0</span>]</span><br><span class="line">, pCvInfo-&gt;Signature.Data4[<span class="number">1</span>]</span><br><span class="line">, pCvInfo-&gt;Signature.Data4[<span class="number">2</span>]</span><br><span class="line">, pCvInfo-&gt;Signature.Data4[<span class="number">3</span>]</span><br><span class="line">, pCvInfo-&gt;Signature.Data4[<span class="number">4</span>]</span><br><span class="line">, pCvInfo-&gt;Signature.Data4[<span class="number">5</span>]</span><br><span class="line">, pCvInfo-&gt;Signature.Data4[<span class="number">6</span>]</span><br><span class="line">, pCvInfo-&gt;Signature.Data4[<span class="number">7</span>]</span><br><span class="line">, pCvInfo-&gt;Age</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">lpszpdbInfo = <span class="built_in">CharToWchar</span>((LPSTR)pCvInfo-&gt;PdbFileName);</span><br><span class="line"><span class="built_in">StringCbCopy</span>( szPdbFileName, dwPdbFileNameCch, lpszpdbInfo);</span><br><span class="line"><span class="keyword">delete</span>[]lpszpdbInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( bIsX64 )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">StringCbPrintfW</span>( szChecksum, dwChecksumCch</span><br><span class="line">, <span class="string">L&quot;%x%x&quot;</span></span><br><span class="line">, pNtHeader64-&gt;FileHeader.TimeDateStamp</span><br><span class="line">, pNtHeader64-&gt;OptionalHeader.SizeOfImage</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">StringCbPrintfW</span>( szChecksum, dwChecksumCch</span><br><span class="line">, <span class="string">L&quot;%x%x&quot;</span></span><br><span class="line">, pNtHeader32-&gt;FileHeader.TimeDateStamp</span><br><span class="line">, pNtHeader32-&gt;OptionalHeader.SizeOfImage</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bFound = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pDebugDic++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HeapFree</span>( <span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, pBuffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bFound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD  <span class="title">RunTheSymchk</span><span class="params">(LPWSTR szCommandLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwMbrId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">STARTUPINFO si;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(si));</span><br><span class="line">si.cb = <span class="built_in">sizeof</span>(si);</span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;pi, <span class="built_in">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL bResult = ::<span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>,szCommandLine , <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bResult)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WaitForSingleObject</span>(pi.hProcess,<span class="number">180</span>*<span class="number">1000</span>) == WAIT_TIMEOUT)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dwCode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GetExitCodeProcess</span>(pi.hProcess,(DWORD*)&amp;dwCode))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line"><span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WINDBG_INSTALLPATH <span class="string">L&quot;D:\\Windows Kits\\10\\Debuggers\\x64&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SYMBOLS_DIR <span class="string">L&quot;d:\\symbols\\&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SYMBOLS_FORMATS <span class="string">L&quot;SRV*%ws*http://msdl.microsoft.com/download/symbols&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_PATH <span class="string">L&quot;D:\\Documents\\D_IDA\\SHClient\\SHClient.exe&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMCHCKCMD_LINE_FORMATS <span class="string">L&quot;%ws\\symchk.exe  /r  %ws  /s %ws&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDR_IS_DATAFILE(handle)      (((ULONG_PTR)(handle)) &amp;  (ULONG_PTR)1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDR_IS_IMAGEMAPPING(handle)  (((ULONG_PTR)(handle)) &amp; (ULONG_PTR)2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDR_IS_RESOURCE(handle)      (LDR_IS_IMAGEMAPPING(handle) || LDR_IS_DATAFILE(handle))</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">// #define SYMBOL_NAME  L&quot;PsspDumpThread&quot;</span></span><br><span class="line"><span class="comment">// #define SYMBOL_NAME  L&quot;DownloadAndStagePayloads&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL_NAME  <span class="string">L&quot;*Payload*&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENUM_PATH  <span class="string">L&quot;D:\\Documents\\TestScanPath&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENEABLE_DEEP_CALL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMBOL_NAME  <span class="string">L&quot;*Payload*&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENUM_PATH  <span class="string">L&quot;C:\\Windows\\System32&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENEABLE_DEEP_CALL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// PSYM_ENUMERATESYMBOLS_CALLBACKW PsymEnumeratesymbolsCallback;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetNtdllBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN64)</span></span><br><span class="line">ULONG64 peb = __readgsqword(<span class="number">0x60</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">ULONG64 peb = __readfsdword(<span class="number">0x30</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ULONG64 ldr = *(ULONG64*)(peb + <span class="number">0x18</span>);</span><br><span class="line">PLIST_ENTRY modlist = *(PLIST_ENTRY*)(ldr + <span class="number">0x10</span>); <span class="comment">// 第二个加载的 dll 就是 ntdll</span></span><br><span class="line"><span class="keyword">return</span> *(<span class="type">void</span>**)((ULONG64)modlist-&gt;Flink + <span class="number">0x30</span>); <span class="comment">// 获取第二个 listEntry 之后，再获取</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;std::pair&lt;wstring, wstring&gt;&gt; g_FindReslt;</span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">PsymEnumeratesymbolsCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ PSYMBOL_INFOW pSymInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ ULONG SymbolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_opt_ PVOID UserContext</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">wprintf</span>(GREEN <span class="string">L&quot;%s-&gt;%s, Size:%d\n&quot;</span> WHITE, (WCHAR*)UserContext, pSymInfo-&gt;Name, SymbolSize);</span><br><span class="line"></span><br><span class="line">g_FindReslt.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_pair</span>&lt;wstring, wstring&gt;((WCHAR*)UserContext, pSymInfo-&gt;Name));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">IsExeOrDll</span><span class="params">(<span class="type">const</span> WCHAR* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> WCHAR* patterns[] = &#123; <span class="string">L&quot;*.exe&quot;</span>, <span class="string">L&quot;*.dll&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">PathMatchSpecW</span>(path, patterns[<span class="number">0</span>]) == TRUE)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">PathMatchSpecW</span>(path, patterns[<span class="number">1</span>]) == TRUE)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FindAllDlls</span><span class="params">(<span class="type">const</span> WCHAR* Path, <span class="type">int</span> iDeep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (iDeep &gt; <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WCHAR TargetPath[MAX_PATH] = &#123;&#125;;</span><br><span class="line">WCHAR szTempPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">LPCWSTR lpszFilePath = TEST_PATH;</span><br><span class="line"><span class="comment">//仅测试用 大量字符串申请用堆而不是栈</span></span><br><span class="line">DWORD dwLastError = <span class="number">0</span>;</span><br><span class="line">DWORD ModuleSize = <span class="number">0</span>;</span><br><span class="line">WCHAR szPdbFileName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR szPdbGuid[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR szChecksum[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR szCommandLine[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR szNtSymbolUrl[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR szPdbSymbolPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">LPSTR lpszPdbPath = <span class="literal">NULL</span>;</span><br><span class="line">WCHAR szSymbolName[MAX_SYM_NAME];</span><br><span class="line">DWORD dwSizeOfSymbol = <span class="built_in">sizeof</span>(SYMBOL_INFOW) + MAX_SYM_NAME * <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line">PBYTE pBuffer = <span class="keyword">new</span> BYTE[dwSizeOfSymbol];</span><br><span class="line">PSYMBOL_INFOW pSymbol = (PSYMBOL_INFOW)pBuffer;</span><br><span class="line">HMODULE hModuleBase = <span class="literal">NULL</span>;</span><br><span class="line">PBYTE pModuleBase = <span class="literal">NULL</span>;</span><br><span class="line">PBYTE pSymAdr = <span class="literal">NULL</span>;</span><br><span class="line">PBYTE lpDestCall = <span class="literal">NULL</span>;</span><br><span class="line">LPWSTR lpszCFile = <span class="literal">NULL</span>;</span><br><span class="line">MEMORY_BASIC_INFORMATION MbInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">BOOL bIsX64 = FALSE;</span><br><span class="line"><span class="built_in">StringCbCopy</span>(TargetPath, MAX_PATH, Path);</span><br><span class="line"><span class="built_in">StringCbCat</span>(TargetPath, MAX_PATH, <span class="string">L&quot;\\*.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">WIN32_FIND_DATA fd = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HANDLE hFind = <span class="built_in">FindFirstFile</span>(TargetPath, &amp;fd);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">StrCmpCW</span>(<span class="string">L&quot;AppVStreamingUX.exe&quot;</span>, fd.cFileName) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">StrCmpCW</span>(<span class="string">L&quot;SIHClient.exe&quot;</span>, fd.cFileName) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hFind != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!(fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> iFileExFlag = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> WCHAR* filename = fd.cFileName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(iFileExFlag = <span class="built_in">IsExeOrDll</span>(filename)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">szTempPath[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">StringCbCopy</span>(szTempPath, MAX_PATH, Path);</span><br><span class="line"><span class="comment">// szTempPath[wcslen(szTempPath)] = 0;</span></span><br><span class="line"><span class="built_in">PathAppend</span>(szTempPath, fd.cFileName);</span><br><span class="line">lpszFilePath = szTempPath;</span><br><span class="line"><span class="built_in">GetPdbFileInfo</span>(lpszFilePath, szPdbFileName, MAX_PATH, szPdbGuid, MAX_PATH, szChecksum, MAX_PATH);</span><br><span class="line"></span><br><span class="line"><span class="built_in">StringCbPrintf</span>(szNtSymbolUrl, MAX_PATH * <span class="built_in">sizeof</span>(WCHAR), NT_SYMBOLS_FORMATS, NT_SYMBOLS_DIR);</span><br><span class="line"><span class="built_in">StringCbPrintf</span>(szCommandLine, MAX_PATH * <span class="built_in">sizeof</span>(WCHAR), SYMCHCKCMD_LINE_FORMATS, WINDBG_INSTALLPATH, lpszFilePath, szNtSymbolUrl);</span><br><span class="line"></span><br><span class="line"><span class="built_in">StringCbCopy</span>(szPdbSymbolPath, MAX_PATH * <span class="built_in">sizeof</span>(WCHAR), NT_SYMBOLS_DIR);</span><br><span class="line"><span class="built_in">StringCbCat</span>(szPdbSymbolPath, MAX_PATH * <span class="built_in">sizeof</span>(WCHAR), szPdbFileName);</span><br><span class="line"><span class="built_in">StringCbCat</span>(szPdbSymbolPath, MAX_PATH * <span class="built_in">sizeof</span>(WCHAR), <span class="string">L&quot;\\&quot;</span>);</span><br><span class="line"><span class="built_in">StringCbCat</span>(szPdbSymbolPath, MAX_PATH * <span class="built_in">sizeof</span>(WCHAR), szPdbGuid);</span><br><span class="line"><span class="built_in">StringCbCat</span>(szPdbSymbolPath, MAX_PATH * <span class="built_in">sizeof</span>(WCHAR), <span class="string">L&quot;\\&quot;</span>);</span><br><span class="line"><span class="built_in">StringCbCat</span>(szPdbSymbolPath, MAX_PATH * <span class="built_in">sizeof</span>(WCHAR), szPdbFileName);</span><br><span class="line"><span class="comment">// if (iFileExFlag == 1)</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; (iFileExFlag == <span class="number">1</span> ? MAGENTA : CYAN);</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;%d Load:%ws\r\n&quot;</span>, g_idx++, lpszFilePath);</span><br><span class="line">std::cout &lt;&lt; WHITE;</span><br><span class="line">&#125;</span><br><span class="line">hModuleBase = <span class="built_in">LoadLibraryExW</span>(lpszFilePath, <span class="literal">NULL</span>, LOAD_LIBRARY_AS_IMAGE_RESOURCE);</span><br><span class="line">pModuleBase = (PBYTE)hModuleBase;</span><br><span class="line"></span><br><span class="line">BOOL bNeedUnload = TRUE;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetModuleHandle</span>(filename))</span><br><span class="line">&#123;</span><br><span class="line">bNeedUnload = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LDR_IS_RESOURCE</span>(hModuleBase))</span><br><span class="line">&#123;</span><br><span class="line">ULONG_PTR  ulTemp = (ULONG_PTR)hModuleBase;</span><br><span class="line">ulTemp = ulTemp - <span class="number">2</span>;</span><br><span class="line">pModuleBase = (PBYTE)ulTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pModuleBase == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ModuleSize = <span class="built_in">GetImageSize</span>((LPBYTE)pModuleBase, bIsX64);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">if</span> (!bIsX64)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hModuleBase);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">PathFileExists</span>(szPdbSymbolPath))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// RunTheSymchk(szCommandLine);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD64 baseAddr = <span class="number">0</span>;</span><br><span class="line">lpszPdbPath = <span class="built_in">WCharToChar</span>(szPdbSymbolPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// if (!SymLoadModule64(GetCurrentProcess(), NULL, (STRSAFE_LPCSTR)lpszPdbPath, NULL, (DWORD64)pModuleBase, ModuleSize))</span></span><br><span class="line"><span class="keyword">if</span> (!(baseAddr = <span class="built_in">SymLoadModuleExW</span>(<span class="built_in">GetCurrentProcess</span>(), <span class="literal">NULL</span>, (PCWSTR)szPdbSymbolPath, <span class="literal">NULL</span>, (DWORD64)pModuleBase, ModuleSize, <span class="literal">NULL</span>, <span class="number">0</span>)))</span><br><span class="line">&#123;</span><br><span class="line">dwLastError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="keyword">delete</span>[] lpszPdbPath;</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hModuleBase);</span><br><span class="line"><span class="built_in">SymUnloadModule</span>(<span class="built_in">GetCurrentProcess</span>(), (DWORD64)pModuleBase);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] lpszPdbPath;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pSymbol-&gt;SizeOfStruct = <span class="built_in">sizeof</span>(SYMBOL_INFO);;</span><br><span class="line">pSymbol-&gt;MaxNameLen = MAX_SYM_NAME;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">SymFromNameW</span>(<span class="built_in">GetCurrentProcess</span>(), SYMBOL_NAME, pSymbol))</span><br><span class="line">&#123;</span><br><span class="line">dwLastError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hModuleBase);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">SymEnumSymbolsW</span>(<span class="built_in">GetCurrentProcess</span>(), baseAddr, SYMBOL_NAME, PsymEnumeratesymbolsCallback, (PVOID)lpszFilePath))</span><br><span class="line">&#123;</span><br><span class="line">dwLastError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hModuleBase);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g_FindReslt.emplace_back(lpszFilePath);</span></span><br><span class="line"><span class="comment">// wprintf(MAGENTA L&quot;FileX64:%ws\r\n&quot; WHITE, lpszFilePath);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">pSymAdr = (PBYTE)pSymbol-&gt;Address;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">VirtualQuery</span>(pSymAdr, &amp;MbInfo, <span class="built_in">sizeof</span>(MbInfo)) == <span class="built_in">sizeof</span>(MbInfo))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (MbInfo.State != MEM_COMMIT)</span><br><span class="line">&#123;</span><br><span class="line">dwLastError = <span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hModuleBase);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x150</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*(pSymAdr + i) == <span class="number">0x4c</span> &amp;&amp; *(pSymAdr + i + <span class="number">1</span>) == <span class="number">0x8d</span> &amp;&amp; *(pSymAdr + i + <span class="number">2</span>) == <span class="number">0x5</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> jmpadr = *(<span class="type">int</span>*)(pSymAdr + i + <span class="number">3</span>);</span><br><span class="line">jmpadr = jmpadr + <span class="number">7</span>;</span><br><span class="line">lpDestCall = jmpadr + pSymAdr + i;</span><br><span class="line">lpszCFile = <span class="built_in">CharToWchar</span>((<span class="type">char</span>*)lpDestCall);</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;Find:%ws %ws\r\n&quot;</span>, lpszFilePath, lpszCFile);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">FreeLibrary</span>(hModuleBase);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">StrCmpCW</span>(fd.cFileName, <span class="string">L&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">StrCmpCW</span>(fd.cFileName, <span class="string">L&quot;..&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造子目录的路径</span></span><br><span class="line">TCHAR subDirectory[MAX_PATH];</span><br><span class="line"><span class="built_in">StringCbCopy</span>(subDirectory, MAX_PATH, Path);</span><br><span class="line"><span class="built_in">StringCbCat</span>(subDirectory, MAX_PATH, <span class="string">L&quot;\\&quot;</span>);</span><br><span class="line"><span class="built_in">StringCbCat</span>(subDirectory, MAX_PATH, fd.cFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用FindAllDlls</span></span><br><span class="line"><span class="keyword">if</span> (ENEABLE_DEEP_CALL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">FindAllDlls</span>(subDirectory, iDeep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">FindNextFile</span>(hFind, &amp;fd));</span><br><span class="line"></span><br><span class="line"><span class="built_in">FindClose</span>(hFind);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">EnableXXXPrivilege</span><span class="params">(LPCTSTR pszPrivilegeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hToken;</span><br><span class="line">LUID seXXXNameValue;</span><br><span class="line">TOKEN_PRIVILEGES tkp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enable the SeXXXPrivilege</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(),</span><br><span class="line">TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;OpenProcessToken() failed, Error = %d  %s is not available.\n&quot;</span>, <span class="built_in">GetLastError</span>(), pszPrivilegeName);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, pszPrivilegeName, &amp;seXXXNameValue))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;LookupPrivilegeValue() failed, Error = %d %s is not available.\n&quot;</span>, <span class="built_in">GetLastError</span>(), pszPrivilegeName);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Luid = seXXXNameValue;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tkp, <span class="keyword">sizeof</span> tkp, <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;AdjustTokenPrivileges() failed, Error = %d %s is not available.\n&quot;</span>, <span class="built_in">GetLastError</span>(), pszPrivilegeName);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将wstring转换成string</span></span><br><span class="line"><span class="function">string <span class="title">wstring2string</span><span class="params">(wstring wstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string result;</span><br><span class="line"><span class="comment">//获取缓冲区大小，并申请空间，缓冲区大小事按字节计算的  </span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, wstr.<span class="built_in">c_str</span>(), wstr.<span class="built_in">size</span>(), <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//宽字节编码转换成多字节编码  </span></span><br><span class="line"><span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, wstr.<span class="built_in">c_str</span>(), wstr.<span class="built_in">size</span>(), buffer, len, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">//删除缓冲区并返回值  </span></span><br><span class="line">result.<span class="built_in">append</span>(buffer);</span><br><span class="line"><span class="keyword">delete</span>[] buffer;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutputToFile</span><span class="params">(std::vector&lt;std::pair&lt;wstring, wstring&gt;&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!outfile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> res : g_FindReslt)</span><br><span class="line">&#123;</span><br><span class="line">outfile &lt;&lt; <span class="built_in">wstring2string</span>(res.first) &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="built_in">wstring2string</span>(res.second) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">outfile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PVOID OldValue;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Wow64DisableWow64FsRedirection</span>(&amp;OldValue))</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;File system redirection disabled.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">wcout &lt;&lt; WHITE &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EnableXXXPrivilege</span>(SE_DEBUG_NAME);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">SymInitializeW</span>(<span class="built_in">GetCurrentProcess</span>(), <span class="literal">NULL</span>, FALSE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwSymOpt = <span class="built_in">SymGetOptions</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iDeep = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">FindAllDlls</span>(ENUM_PATH, iDeep);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl&lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (auto res : g_FindReslt)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">wcout &lt;&lt; RED &lt;&lt; res.first &lt;&lt; &quot;\t&quot; &lt;&lt; res.second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">wcout &lt;&lt; WHITE &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新启用文件系统重定向</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Wow64RevertWow64FsRedirection</span>(OldValue)) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;File system redirection re-enabled.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cerr &lt;&lt; <span class="string">&quot;Failed to re-enable file system redirection.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">OutputToFile</span>(g_FindReslt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序执行完成后，将控制台窗口置顶</span></span><br><span class="line">HWND consoleWindow = <span class="built_in">GetConsoleWindow</span>(); <span class="comment">// 获取控制台窗口句柄</span></span><br><span class="line"><span class="built_in">ShowWindow</span>(consoleWindow, SW_SHOW); <span class="comment">// 显示控制台窗口</span></span><br><span class="line"><span class="built_in">SetForegroundWindow</span>(consoleWindow); <span class="comment">// 将控制台窗口置顶</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：如何使用 PDB 查找 PE 中的特定函数名的函数&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="DbgHelp" scheme="http://example.com/categories/A-OS/Windows/DbgHelp/"/>
    
    
  </entry>
  
  <entry>
    <title>【PnP】 CodeCollections</title>
    <link href="http://example.com/A_OS/Windows/PnP/%E3%80%90PnP%E3%80%91CodeCollect/"/>
    <id>http://example.com/A_OS/Windows/PnP/%E3%80%90PnP%E3%80%91CodeCollect/</id>
    <published>2024-08-09T01:55:45.535Z</published>
    <updated>2024-08-15T09:19:55.121Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述: PnP 相关代码汇总</p></blockquote><span id="more"></span><h2 id="1-弹出U盘"><a href="#1-弹出U盘" class="headerlink" title="1. 弹出U盘"></a>1. 弹出U盘</h2><h3 id="1-1-EjectVolume-弹出U盘"><a href="#1-1-EjectVolume-弹出U盘" class="headerlink" title="1.1. EjectVolume 弹出U盘"></a>1.1. <code>EjectVolume</code> 弹出U盘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STDAPI_</span>(BOOL) <span class="built_in">EjectVolume</span>(DWORD dwVolLetter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Enter EjectVolume\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">DWORD_PTR lrRet = <span class="number">0</span>;</span><br><span class="line">HWND hWnd = <span class="built_in">FindWindow</span>(WNDCLASS_CACHEWND, <span class="literal">NULL</span>);</span><br><span class="line">LRESULT lr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != hWnd)</span><br><span class="line">&#123;</span><br><span class="line">lr = <span class="built_in">SendMessageTimeout</span>(hWnd, WM_DEREGISTER_UDISK, dwVolLetter, <span class="number">0</span>, SMTO_BLOCK, <span class="number">3000</span>, &amp;lrRet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WCHAR wszVolShort[<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">WCHAR szParentInstanceId[MAX_DEVICE_ID_LEN] = &#123;&#125;;</span><br><span class="line">VOLUMECOLLECTION VolCll = &#123;&#125;;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line">BOOL bUsed = FALSE;</span><br><span class="line">HANDLE hVolume = INVALID_HANDLE_VALUE;</span><br><span class="line">CONFIGRET conRet = <span class="number">0</span>;</span><br><span class="line">DEVINST dnDevInst = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EnableXXXPrivilege</span>(SE_LOAD_DRIVER_NAME);</span><br><span class="line"><span class="built_in">EnableXXXPrivilege</span>(SE_UNDOCK_NAME);</span><br><span class="line"></span><br><span class="line">bRet = <span class="built_in">GetVolumeCollection</span>((BYTE)dwVolLetter, &amp;VolCll, szParentInstanceId);</span><br><span class="line"><span class="keyword">if</span> (!bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Get volume instance id error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">StringCchPrintf</span>(wszVolShort, <span class="built_in">ARRAYSIZE</span>(wszVolShort), <span class="string">L&quot;%c:\\&quot;</span>, dwVolLetter);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">PathFileExists</span>(wszVolShort))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Not Find Volume:%c, Delete letter\n&quot;</span>, dwVolLetter);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要直接尝试弹出</span></span><br><span class="line"><span class="comment">// 先判断是否占用</span></span><br><span class="line">DWORD volumeFlags = GENERIC_READ | GENERIC_WRITE;</span><br><span class="line">hVolume = <span class="built_in">CreateVolumeHandleFromDriveLetter</span>((WCHAR)dwVolLetter,volumeFlags);</span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hVolume)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;ERROR! Can not open volume! Maybe it&#x27;s locked\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hVolume);</span><br><span class="line">hVolume = INVALID_HANDLE_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNP_VETO_TYPE VetoType;</span><br><span class="line">bRet = <span class="built_in">CMRequestRemoveDev</span>(dwVolLetter, szParentInstanceId, VetoType);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (VetoType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> PNP_VetoTypeUnknown:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] for unspecified reason&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoLegacyDevice:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] due to legacy device&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoPendingClose:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] due to pending close&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoWindowsApp:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] due to windows application&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoWindowsService:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] due to service&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoOutstandingOpen:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] due to outstanding handles on device&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoDevice:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] by device&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoDriver:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] by driver&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoIllegalDeviceRequest:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] as the request was invalid for the device&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">EjectVolumeForce</span>(dwVolLetter))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CMRequestRemoveDev</span>(dwVolLetter, szParentInstanceId, VetoType);</span><br><span class="line">bRet = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoInsufficientPower:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] because there would be insufficient system power to continue&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoNonDisableable:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] due to non-disableable device&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoLegacyDriver:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] due to legacy driver&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PNP_VetoInsufficientRights:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] insufficient permissions&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;[Eject] due to uncoded reason&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-GetVolumeCollection-获取设备ID"><a href="#1-2-GetVolumeCollection-获取设备ID" class="headerlink" title="1.2. GetVolumeCollection 获取设备ID"></a>1.2. <code>GetVolumeCollection</code> 获取设备ID</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STDAPI_</span>(BOOL) <span class="built_in">GetVolumeCollection</span>(BYTE byVolLetter, PVOLUMECOLLECTION pVolCll, LPWSTR pParentInstId)</span><br><span class="line">&#123;</span><br><span class="line">WCHAR szParentInstanceId[MAX_DEVICE_ID_LEN] = &#123;&#125;; </span><br><span class="line">WCHAR szTmpInstanceId[MAX_DEVICE_ID_LEN] =&#123;&#125;;</span><br><span class="line">WCHAR szDriveLetters[<span class="number">26</span>*<span class="number">2</span>*<span class="number">4</span>] =&#123;&#125;;</span><br><span class="line">BOOL bRet;</span><br><span class="line">DWORD cbBytesReturned; </span><br><span class="line">LPWSTR pszDriveRoot = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">size_t</span> uStrlen;</span><br><span class="line"></span><br><span class="line">pVolCll-&gt;dwCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bRet = <span class="built_in">GetParentInstanceId</span>(byVolLetter, szParentInstanceId, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!bRet)</span><br><span class="line"><span class="keyword">return</span> FALSE;                                            pszLogicalDrives); </span><br><span class="line"></span><br><span class="line">cbBytesReturned = <span class="built_in">GetLogicalDriveStrings</span> (<span class="built_in">ARRAYSIZE</span>(szDriveLetters)*<span class="built_in">sizeof</span>(WCHAR), </span><br><span class="line">                                                  szDriveLetters); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (pszDriveRoot = szDriveLetters; *pszDriveRoot != <span class="built_in">TEXT</span>(<span class="string">&#x27;\0&#x27;</span>); </span><br><span class="line">             pszDriveRoot += uStrlen + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">StringCchLength</span>(pszDriveRoot, <span class="number">26</span>*<span class="number">2</span>*<span class="number">4</span>, &amp;uStrlen);</span><br><span class="line"><span class="keyword">if</span> (((BYTE)(*pszDriveRoot) == <span class="string">&#x27;A&#x27;</span>) || ((BYTE)(*pszDriveRoot) == <span class="string">&#x27;a&#x27;</span>) </span><br><span class="line">|| ((BYTE)(*pszDriveRoot) == <span class="string">&#x27;B&#x27;</span>) || ((BYTE)(*pszDriveRoot) == <span class="string">&#x27;b&#x27;</span>))   <span class="comment">//skip floppy and the target volume</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">bRet = <span class="built_in">GetParentInstanceId</span>((BYTE)(*pszDriveRoot), szTmpInstanceId, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (bRet &amp;&amp; (<span class="built_in">StrCmpI</span>(szParentInstanceId,szTmpInstanceId) == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">pVolCll-&gt;byVolume[pVolCll-&gt;dwCount] = (BYTE)(*pszDriveRoot);</span><br><span class="line">pVolCll-&gt;dwCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pParentInstId)</span><br><span class="line"><span class="built_in">StringCchCopy</span>(pParentInstId, MAX_DEVICE_ID_LEN, szParentInstanceId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetParentInstanceId</span><span class="params">(BYTE byVolLetter,LPWSTR pParentInstId, LPWSTR pParentDevName,DWORD dwBufSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hDevice = INVALID_HANDLE_VALUE;  </span><br><span class="line">WCHAR szDeviceName[<span class="number">8</span>]; </span><br><span class="line">STORAGE_PROPERTY_QUERY spq; </span><br><span class="line">STORAGE_DEVICE_NUMBER sdn; </span><br><span class="line">STORAGE_DEVICE_NUMBER sdnTmp; </span><br><span class="line">BOOL bSuccess;</span><br><span class="line">DWORD cbBytesReturned; </span><br><span class="line">BYTE byBuffer[<span class="number">4096</span>]; </span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line">GUID *pGuidInferface = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//GUID *pGuidClass = NULL; </span></span><br><span class="line">HDEVINFO hIntDevInfo = INVALID_HANDLE_VALUE; </span><br><span class="line">DWORD dwIndex;</span><br><span class="line">SP_DEVICE_INTERFACE_DATA interfaceData; </span><br><span class="line">SP_DEVINFO_DATA deviceInfoData;</span><br><span class="line">CONFIGRET configret; </span><br><span class="line">DEVINST dnDevInstParent;</span><br><span class="line">WCHAR szDeviceInstanceID[MAX_DEVICE_ID_LEN]=&#123;&#125;;</span><br><span class="line">    HANDLE hDev = INVALID_HANDLE_VALUE; </span><br><span class="line">    PSP_DEVICE_INTERFACE_DETAIL_DATA pInterfaceDetailData = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">StringCchPrintf</span>(szDeviceName, <span class="built_in">ARRAYSIZE</span>(szDeviceName), <span class="string">L&quot;\\\\.\\%c:&quot;</span>, byVolLetter);</span><br><span class="line">hDevice = <span class="built_in">CreateFile</span> (szDeviceName,             </span><br><span class="line"><span class="number">0</span>, </span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE,  </span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING, </span><br><span class="line"><span class="number">0</span>, </span><br><span class="line"><span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spq.PropertyId = StorageDeviceProperty; </span><br><span class="line">spq.QueryType = PropertyStandardQuery; </span><br><span class="line">spq.AdditionalParameters[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">bSuccess = <span class="built_in">DeviceIoControl</span> (hDevice,  </span><br><span class="line">IOCTL_STORAGE_QUERY_PROPERTY,     </span><br><span class="line">&amp;spq, <span class="built_in">sizeof</span>(spq),              </span><br><span class="line">&amp;byBuffer, <span class="built_in">sizeof</span>(byBuffer),     </span><br><span class="line">&amp;cbBytesReturned,                </span><br><span class="line">(LPOVERLAPPED) <span class="literal">NULL</span>);   </span><br><span class="line"> STORAGE_DEVICE_DESCRIPTOR *psdp = (STORAGE_DEVICE_DESCRIPTOR *)byBuffer; </span><br><span class="line"><span class="keyword">if</span> (!bSuccess || psdp-&gt;BusType != BusTypeUsb)     <span class="comment">//Not USB device, just return</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span> (hDevice); </span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bSuccess = <span class="built_in">DeviceIoControl</span> (hDevice,                         </span><br><span class="line">IOCTL_STORAGE_GET_DEVICE_NUMBER,  </span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,                         </span><br><span class="line">(LPVOID)&amp;sdn, <span class="built_in">sizeof</span>(sdn),      </span><br><span class="line">&amp;cbBytesReturned,                </span><br><span class="line">(LPOVERLAPPED) <span class="literal">NULL</span>);  </span><br><span class="line"><span class="comment">// GetLastError of ERROR_MORE_DATA indicates to the caller that the buffer was not large enough to accommodate the data requested </span></span><br><span class="line"><span class="keyword">if</span> (!bSuccess)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span> (hDevice); </span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sdn.DeviceType == FILE_DEVICE_CD_ROM || sdn.DeviceType == FILE_DEVICE_DVD) </span><br><span class="line">&#123; </span><br><span class="line">pGuidInferface = (GUID*)&amp;GUID_DEVINTERFACE_CDROM; </span><br><span class="line"><span class="comment">//pGuidClass = (GUID*)&amp;GUID_DEVCLASS_CDROM; </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="comment">//if (sdn.DeviceType == FILE_DEVICE_DISK) </span></span><br><span class="line">&#123; </span><br><span class="line">pGuidInferface = (GUID*)&amp;GUID_DEVINTERFACE_DISK; </span><br><span class="line"><span class="comment">//pGuidClass = (GUID*)&amp;GUID_DEVCLASS_DISKDRIVE; </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span> (hDevice); </span><br><span class="line">    hDevice = INVALID_HANDLE_VALUE; </span><br><span class="line"></span><br><span class="line">hIntDevInfo = <span class="built_in">SetupDiGetClassDevs</span> (pGuidInferface, <span class="literal">NULL</span>, <span class="literal">NULL</span>, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE); </span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE == hIntDevInfo)</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (dwIndex = <span class="number">0</span>; ;dwIndex ++) </span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;interfaceData, <span class="built_in">sizeof</span>(interfaceData)); </span><br><span class="line">        interfaceData.cbSize = <span class="built_in">sizeof</span>(interfaceData); </span><br><span class="line">        bSuccess = <span class="built_in">SetupDiEnumDeviceInterfaces</span> (hIntDevInfo, <span class="literal">NULL</span>, pGuidInferface, dwIndex, &amp;interfaceData); </span><br><span class="line">        <span class="keyword">if</span> (!bSuccess) &#123; </span><br><span class="line">            DWORD dwErrorCode = <span class="built_in">GetLastError</span>(); </span><br><span class="line">            <span class="keyword">if</span> (dwErrorCode == ERROR_NO_MORE_ITEMS) </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="comment">//else  </span></span><br><span class="line">            <span class="comment">//    break;  // ERROR!!! </span></span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">cbBytesReturned = <span class="number">0</span>; </span><br><span class="line">bSuccess = <span class="built_in">SetupDiGetDeviceInterfaceDetail</span> (hIntDevInfo, &amp;interfaceData, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;cbBytesReturned, <span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span> ((!bSuccess &amp;&amp; <span class="built_in">GetLastError</span>() != ERROR_INSUFFICIENT_BUFFER)</span><br><span class="line"> || cbBytesReturned == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">continue</span>;  <span class="comment">// ERROR!!! </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (pInterfaceDetailData) </span><br><span class="line">pInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) <span class="built_in">LocalFree</span> (pInterfaceDetailData); </span><br><span class="line"> </span><br><span class="line">pInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) <span class="built_in">LocalAlloc</span> (LPTR, cbBytesReturned); </span><br><span class="line">pInterfaceDetailData-&gt;cbSize = <span class="built_in">sizeof</span>(SP_DEVICE_INTERFACE_DETAIL_DATA); </span><br><span class="line"><span class="built_in">ZeroMemory</span> (&amp;deviceInfoData, <span class="built_in">sizeof</span>(deviceInfoData)); </span><br><span class="line">deviceInfoData.cbSize = <span class="built_in">sizeof</span>(deviceInfoData); </span><br><span class="line">bSuccess = <span class="built_in">SetupDiGetDeviceInterfaceDetail</span> (hIntDevInfo, &amp;interfaceData, </span><br><span class="line">pInterfaceDetailData, cbBytesReturned, &amp;cbBytesReturned, &amp;deviceInfoData); </span><br><span class="line"><span class="keyword">if</span> (!bSuccess) </span><br><span class="line"><span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">hDev = <span class="built_in">CreateFile</span> (pInterfaceDetailData-&gt;DevicePath,  </span><br><span class="line"><span class="number">0</span>,                                   </span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE,  </span><br><span class="line"><span class="literal">NULL</span>,                                </span><br><span class="line">OPEN_EXISTING,                       </span><br><span class="line"><span class="number">0</span>,                                  </span><br><span class="line"><span class="literal">NULL</span>);   </span><br><span class="line"><span class="keyword">if</span> (hDev == INVALID_HANDLE_VALUE)</span><br><span class="line"><span class="keyword">continue</span>;  <span class="comment">//ERROR</span></span><br><span class="line"></span><br><span class="line">        bSuccess = <span class="built_in">DeviceIoControl</span> (hDev,                           </span><br><span class="line">                                    IOCTL_STORAGE_GET_DEVICE_NUMBER,  </span><br><span class="line">                                    <span class="literal">NULL</span>, <span class="number">0</span>,                        </span><br><span class="line">                                    (LPVOID)&amp;sdnTmp, <span class="built_in">sizeof</span>(sdnTmp),     </span><br><span class="line">                                    &amp;cbBytesReturned,               </span><br><span class="line">                                    (LPOVERLAPPED) <span class="literal">NULL</span>);    </span><br><span class="line"><span class="built_in">CloseHandle</span>(hDev);</span><br><span class="line"><span class="keyword">if</span> (!bSuccess)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((sdn.DeviceType != sdnTmp.DeviceType) || (sdn.DeviceNumber != sdnTmp.DeviceNumber))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//found the device</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MYTRACE(L&quot;pInterfaceDetailData-&gt;DevicePath: %s&quot;, pInterfaceDetailData-&gt;DevicePath);</span></span><br><span class="line"></span><br><span class="line">configret = <span class="built_in">CM_Get_Parent</span> (&amp;dnDevInstParent, deviceInfoData.DevInst, <span class="number">0</span>); </span><br><span class="line"><span class="keyword">if</span> (CR_SUCCESS != configret)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">configret = <span class="built_in">CM_Get_Device_ID</span> (dnDevInstParent, szDeviceInstanceID, <span class="built_in">ARRAYSIZE</span>(szDeviceInstanceID), <span class="number">0</span>); </span><br><span class="line"><span class="keyword">if</span> (CR_SUCCESS != configret)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pParentInstId)</span><br><span class="line"><span class="built_in">StringCchCopy</span>(pParentInstId, MAX_DEVICE_ID_LEN, szDeviceInstanceID);</span><br><span class="line"><span class="keyword">if</span> (pParentDevName &amp;&amp; dwBufSize &gt; <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">LPWSTR pDevName = pInterfaceDetailData-&gt;DevicePath;</span><br><span class="line">LPWSTR pfind = <span class="built_in">StrStrI</span>(pDevName, <span class="string">L&quot;ven_&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pfind)</span><br><span class="line">&#123;</span><br><span class="line">pDevName = pfind + <span class="number">4</span>;</span><br><span class="line">pfind = <span class="built_in">StrChr</span>(pDevName, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line"><span class="built_in">StringCbCopyN</span>(pParentDevName, dwBufSize, pDevName, (pfind-pDevName)*<span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line"><span class="built_in">StringCbCat</span>(pParentDevName, dwBufSize, <span class="string">L&quot; &quot;</span>);</span><br><span class="line">pDevName =  pInterfaceDetailData-&gt;DevicePath;</span><br><span class="line">&#125;</span><br><span class="line">pfind = <span class="built_in">StrStrI</span>(pDevName, <span class="string">L&quot;prod_&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pfind)</span><br><span class="line">&#123;</span><br><span class="line">pDevName = pfind + <span class="number">5</span>;</span><br><span class="line">pfind = <span class="built_in">StrChr</span>(pDevName, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line"><span class="built_in">StringCbCatN</span>(pParentDevName, dwBufSize, pDevName, (pfind-pDevName)*<span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//replace &#x27;_&#x27; with &#x27; &#x27;</span></span><br><span class="line">pDevName = pParentDevName;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">pfind = <span class="built_in">StrChr</span>(pDevName, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pfind)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">*pfind = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">pDevName = pfind +<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">wcsupr</span>(pParentDevName);</span><br><span class="line"><span class="comment">//_wcsupr_s(pParentDevName, wcslen());</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bRet = TRUE;  <span class="comment">//Success</span></span><br><span class="line"><span class="keyword">break</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pInterfaceDetailData)</span><br><span class="line"><span class="built_in">LocalFree</span>( pInterfaceDetailData);</span><br><span class="line"><span class="keyword">if</span> (hIntDevInfo )</span><br><span class="line"><span class="built_in">SetupDiDestroyDeviceInfoList</span>(hIntDevInfo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-CMRequestRemoveDev-移除设备"><a href="#1-3-CMRequestRemoveDev-移除设备" class="headerlink" title="1.3. CMRequestRemoveDev 移除设备"></a>1.3. CMRequestRemoveDev 移除设备</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMRequestRemoveDev</span><span class="params">(DWORD dwVolLetter, WCHAR* szParentInstanceId, PNP_VETO_TYPE&amp; VetoType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DEVINST dnDevInst = <span class="literal">NULL</span>;</span><br><span class="line">DEVINST parentDevInst = <span class="literal">NULL</span>;</span><br><span class="line">VOLUMECOLLECTION VolCll = &#123;&#125;;</span><br><span class="line">CONFIGRET conRet = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">conRet = <span class="built_in">CM_Locate_DevNode</span>(&amp;dnDevInst, szParentInstanceId, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conRet == CR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">WCHAR szVetoName[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;CM_Request_Device_Eject_Ex&quot;</span>);</span><br><span class="line">conRet = <span class="built_in">CM_Request_Device_Eject_Ex</span>(dnDevInst, &amp;VetoType, szVetoName, MAX_PATH, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;CM_Request_Device_Eject_Ex ! rt:%d, VetoType:%d, info:%s&quot;</span>, conRet, VetoType, szVetoName);</span><br><span class="line"><span class="keyword">if</span> (conRet == CR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;CM_Request_Device_Eject_Ex  SUCCESS!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (conRet == CR_REMOVE_VETOED &amp;&amp; VetoType == PNP_VetoIllegalDeviceRequest)</span><br><span class="line">&#123;</span><br><span class="line">conRet = <span class="built_in">CM_Query_And_Remove_SubTree</span>(dnDevInst,</span><br><span class="line">&amp;VetoType,</span><br><span class="line">szVetoName,</span><br><span class="line">MAX_PATH,</span><br><span class="line"></span><br><span class="line"><span class="comment">// We have to add the `CM_REMOVE_NO_RESTART` flag because</span></span><br><span class="line"><span class="comment">// otherwise the just-removed device may be immediately</span></span><br><span class="line"><span class="comment">// redetected, which might happen on XP and Vista.</span></span><br><span class="line"><span class="comment">// See https://www.codeproject.com/articles/13839/how-to-prepare-a-usb-drive-for-safe-removal</span></span><br><span class="line"></span><br><span class="line">CM_REMOVE_NO_RESTART);</span><br><span class="line"><span class="keyword">if</span> (conRet == CR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;CM_Request_Device_Eject_Ex FAILED! rt:%d, VetoType:%d, info:%s&quot;</span>, conRet, VetoType, szVetoName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;CM_Locate_DevNode eject %d volume(s) error!\n&quot;</span>, VolCll.dwCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-强制弹出U盘"><a href="#2-强制弹出U盘" class="headerlink" title="2. 强制弹出U盘"></a>2. 强制弹出U盘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">LockVolume</span><span class="params">(HANDLE volume)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD bytesReturned;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> tries = <span class="number">0</span>; tries &lt; <span class="number">20</span>; tries++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">DeviceIoControl</span>(volume,</span><br><span class="line">FSCTL_LOCK_VOLUME,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;bytesReturned,</span><br><span class="line"><span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnlockVolume</span><span class="params">(HANDLE volume)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD bytesReturned;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DeviceIoControl</span>(volume,</span><br><span class="line">FSCTL_UNLOCK_VOLUME,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;bytesReturned,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">STDAPI_</span>(BOOL) <span class="built_in">EjectVolumeForce</span>(DWORD dwVolLetter)</span><br><span class="line">&#123;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line">WCHAR  wszVolShort[<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">DWORD dwReturn = <span class="number">0</span>;</span><br><span class="line">HANDLE hVolume = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="built_in">StringCchPrintf</span>(wszVolShort, <span class="built_in">ARRAYSIZE</span>(wszVolShort), <span class="string">L&quot;%c:\\&quot;</span>, dwVolLetter);</span><br><span class="line"></span><br><span class="line">DWORD volumeFlags = GENERIC_READ | GENERIC_WRITE;</span><br><span class="line">hVolume = <span class="built_in">CreateVolumeHandleFromDriveLetter</span>(dwVolLetter, volumeFlags);</span><br><span class="line"><span class="keyword">if</span> (hVolume == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;ERROR! Can not open volume!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (DRIVE_FIXED == <span class="built_in">GetDriveType</span>(wszVolShort))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;DRIVE_FIXED == GetDriveType&quot;</span>);</span><br><span class="line"></span><br><span class="line">ULONG deviceNumber = <span class="built_in">GetDeviceNumberFromVolumeHandle</span>(hVolume);</span><br><span class="line"><span class="keyword">if</span> (!deviceNumber) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Couldn&#x27;t get device number from volume handle&quot;</span>);</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CloseHandle</span>(hVolume)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Couldn&#x27;t close volume handle&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Ejecting fixed drive&quot;</span>);</span><br><span class="line">bRet = <span class="built_in">EjectFixedDriveByDeviceNumber</span>(deviceNumber);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">LockVolume</span>(hVolume))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;LockVolume Failed&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始暴力弹出</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">DeviceIoControl</span>(hVolume, FSCTL_DISMOUNT_VOLUME, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwReturn, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwTmp = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;IOCTL_STORAGE_MEDIA_REMOVAL&quot;</span>);</span><br><span class="line">bRet = <span class="built_in">DeviceIoControl</span>(hVolume, IOCTL_STORAGE_MEDIA_REMOVAL, &amp;dwTmp, <span class="built_in">sizeof</span>(dwTmp), <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwReturn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;IOCTL_STORAGE_MEDIA_REMOVAL, bRet==%d&quot;</span>, bRet);</span><br><span class="line">bRet = <span class="built_in">DeviceIoControl</span>(hVolume, IOCTL_DISK_EJECT_MEDIA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwReturn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;IOCTL_DISK_EJECT_MEDIA bRet==%d&quot;</span>, bRet);</span><br><span class="line">bRet = <span class="built_in">DeviceIoControl</span>(hVolume, IOCTL_STORAGE_EJECT_MEDIA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwReturn, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;IOCTL_STORAGE_EJECT_MEDIA bRet==%d&quot;</span>, bRet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">UnlockVolume</span>(hVolume))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;UnlockVolume Failed&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出是否成功</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">PathFileExists</span>(wszVolShort))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DeleteJunctionPoint</span>(dwVolLetter);</span><br><span class="line">bRet = TRUE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bRet = FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (INVALID_HANDLE_VALUE != hVolume)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hVolume);</span><br><span class="line">hVolume = INVALID_HANDLE_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免不生效，多调用几个</span></span><br><span class="line"><span class="comment">// RefreshFolderViews(CSIDL_DESKTOP, SHCNE_UPDATEDIR);</span></span><br><span class="line"><span class="built_in">NotifyDeviceRemoval</span>(dwVolLetter);</span><br><span class="line"><span class="built_in">SHChangeNotify</span>(SHCNE_DRIVEREMOVED, SHCNF_PATH, wszVolShort, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">SHChangeNotify</span>(SHCNE_DRIVEADD, SHCNF_PATH, wszVolShort, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-弹出硬盘"><a href="#3-弹出硬盘" class="headerlink" title="3. 弹出硬盘"></a>3. 弹出硬盘</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adapted from https://www.codeproject.com/articles/13839/how-to-prepare-a-usb-drive-for-safe-removal</span></span><br><span class="line"><span class="comment">// which is licensed under &quot;The Code Project Open License (CPOL) 1.02&quot;</span></span><br><span class="line"><span class="comment">// https://www.codeproject.com/info/cpol10.aspx</span></span><br><span class="line"><span class="function">DEVINST <span class="title">GetDeviceInstanceFromDeviceNumber</span><span class="params">(ULONG deviceNumber)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> GUID* guid = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> GUID*&gt;(&amp;GUID_DEVINTERFACE_DISK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get device interface info set handle for all devices attached to system</span></span><br><span class="line">DWORD deviceInformationFlags = DIGCF_PRESENT | DIGCF_DEVICEINTERFACE;</span><br><span class="line">HDEVINFO deviceInformation = <span class="built_in">SetupDiGetClassDevs</span>(guid,</span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">deviceInformationFlags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deviceInformation == INVALID_HANDLE_VALUE) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD memberIndex = <span class="number">0</span>;</span><br><span class="line">BYTE buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetailData =</span><br><span class="line">(PSP_DEVICE_INTERFACE_DETAIL_DATA)buffer;</span><br><span class="line"></span><br><span class="line">SP_DEVINFO_DATA deviceInformationData;</span><br><span class="line">DWORD requiredSize;</span><br><span class="line"></span><br><span class="line">SP_DEVICE_INTERFACE_DATA deviceInterfaceData;</span><br><span class="line">deviceInterfaceData.cbSize = <span class="built_in">sizeof</span>(SP_DEVICE_INTERFACE_DATA);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">SetupDiEnumDeviceInterfaces</span>(deviceInformation,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">guid,</span><br><span class="line">memberIndex,</span><br><span class="line">&amp;deviceInterfaceData)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requiredSize = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">SetupDiGetDeviceInterfaceDetail</span>(deviceInformation,</span><br><span class="line">&amp;deviceInterfaceData,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">&amp;requiredSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (requiredSize == <span class="number">0</span> || requiredSize &gt; <span class="built_in">sizeof</span>(buffer)) </span><br><span class="line">&#123;</span><br><span class="line">memberIndex++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deviceInterfaceDetailData-&gt;cbSize = <span class="built_in">sizeof</span>(SP_DEVICE_INTERFACE_DETAIL_DATA);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ZeroMemory</span>((PVOID)&amp;deviceInformationData, <span class="built_in">sizeof</span>(SP_DEVINFO_DATA));</span><br><span class="line">deviceInformationData.cbSize = <span class="built_in">sizeof</span>(SP_DEVINFO_DATA);</span><br><span class="line"></span><br><span class="line">BOOL result = <span class="built_in">SetupDiGetDeviceInterfaceDetail</span>(deviceInformation,</span><br><span class="line">&amp;deviceInterfaceData,</span><br><span class="line">deviceInterfaceDetailData,</span><br><span class="line"><span class="built_in">sizeof</span>(buffer),</span><br><span class="line">&amp;requiredSize,</span><br><span class="line">&amp;deviceInformationData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line">memberIndex++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LPCTSTR devicePath = deviceInterfaceDetailData-&gt;DevicePath;</span><br><span class="line">HANDLE driveHandle = <span class="built_in">CreateVolumeHandleFromDevicePath</span>(devicePath, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (driveHandle == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">memberIndex++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ULONG currentDriveDeviceNumber =</span><br><span class="line"><span class="built_in">GetDeviceNumberFromVolumeHandle</span>(driveHandle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(driveHandle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!currentDriveDeviceNumber) &#123;</span><br><span class="line">memberIndex++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deviceNumber == currentDriveDeviceNumber) &#123;</span><br><span class="line"><span class="built_in">SetupDiDestroyDeviceInfoList</span>(deviceInformation);</span><br><span class="line"><span class="keyword">return</span> deviceInformationData.DevInst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memberIndex++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetupDiDestroyDeviceInfoList</span>(deviceInformation);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">EjectFixedDriveByDeviceNumber</span><span class="params">(ULONG deviceNumber)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DEVINST deviceInstance = <span class="built_in">GetDeviceInstanceFromDeviceNumber</span>(deviceNumber);</span><br><span class="line"><span class="keyword">if</span> (!deviceInstance) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Couldn&#x27;t get instance from device number&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONFIGRET status;</span><br><span class="line">PNP_VETO_TYPE vetoType = PNP_VetoTypeUnknown;</span><br><span class="line">WCHAR szVetoName[MAX_PATH];</span><br><span class="line"></span><br><span class="line"><span class="comment">// It&#x27;s often seen that the removal fails on the first</span></span><br><span class="line"><span class="comment">// attempt but works on the second attempt.</span></span><br><span class="line"><span class="comment">// See https://www.codeproject.com/articles/13839/how-to-prepare-a-usb-drive-for-safe-removal</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> tries = <span class="number">0</span>; tries &lt; <span class="number">3</span>; tries++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tries != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Retrying&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Ejecting device instance&quot;</span>);</span><br><span class="line">status = <span class="built_in">CM_Request_Device_Eject</span>(deviceInstance,</span><br><span class="line">&amp;vetoType,</span><br><span class="line">szVetoName,</span><br><span class="line">MAX_PATH,</span><br><span class="line"><span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status == CR_SUCCESS) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Ejected device instance successfully&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Ejecting was vetoed&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We use this as an indicator that the device driver</span></span><br><span class="line"><span class="comment">// is not setting the `SurpriseRemovalOK` capability.</span></span><br><span class="line"><span class="comment">// See https://msdn.microsoft.com/en-us/library/windows/hardware/ff539722(v=vs.85).aspx</span></span><br><span class="line"><span class="keyword">if</span> (status == CR_REMOVE_VETOED &amp;&amp;</span><br><span class="line">vetoType == PNP_VetoIllegalDeviceRequest) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Removing subtree&quot;</span>);</span><br><span class="line">status = <span class="built_in">CM_Query_And_Remove_SubTree</span>(deviceInstance,</span><br><span class="line">&amp;vetoType,</span><br><span class="line">szVetoName,</span><br><span class="line">MAX_PATH,</span><br><span class="line">CM_REMOVE_NO_RESTART);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status == CR_ACCESS_DENIED) &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status == CR_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MYTRACE</span>(<span class="string">L&quot;Couldn&#x27;t eject device instance&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-获取设备数"><a href="#4-获取设备数" class="headerlink" title="4. 获取设备数"></a>4. 获取设备数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetDeviceNumber</span><span class="params">(HANDLE deviceHandle, STORAGE_DEVICE_NUMBER&amp; deviceNumber)</span> </span>&#123;</span><br><span class="line">DWORD bytesReturned = <span class="number">0</span>;</span><br><span class="line">BOOL result = <span class="built_in">DeviceIoControl</span>(</span><br><span class="line">deviceHandle,</span><br><span class="line">IOCTL_STORAGE_GET_DEVICE_NUMBER,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&amp;deviceNumber,</span><br><span class="line"><span class="built_in">sizeof</span>(STORAGE_DEVICE_NUMBER),</span><br><span class="line">&amp;bytesReturned,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-获取设备ID"><a href="#5-获取设备ID" class="headerlink" title="5. 获取设备ID"></a>5. 获取设备ID</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetDeviceInstanceId</span><span class="params">(HDEVINFO deviceInfoSet, SP_DEVINFO_DATA&amp; deviceInfoData, std::wstring&amp; deviceInstanceId)</span> </span>&#123;</span><br><span class="line">WCHAR buffer[<span class="number">1024</span>];</span><br><span class="line">DWORD requiredSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">BOOL result = <span class="built_in">SetupDiGetDeviceInstanceIdW</span>(</span><br><span class="line">deviceInfoSet,</span><br><span class="line">&amp;deviceInfoData,</span><br><span class="line">buffer,</span><br><span class="line"><span class="built_in">sizeof</span>(buffer) / <span class="built_in">sizeof</span>(buffer[<span class="number">0</span>]),</span><br><span class="line">&amp;requiredSize</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">deviceInstanceId = buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述: PnP 相关代码汇总&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="PnP" scheme="http://example.com/categories/A-OS/Windows/PnP/"/>
    
    
  </entry>
  
</feed>
