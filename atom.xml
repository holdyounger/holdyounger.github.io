<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oone</title>
  
  <subtitle>固执无罪，梦想无价 | Coding For Knowledge</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-29T02:13:02.777Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>mingming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【开发】查看编译的lib的运行库是什么</title>
    <link href="http://example.com/A_OS/Windows/%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/%E6%9F%A5%E7%9C%8B%E7%BC%96%E8%AF%91%E7%9A%84lib%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%BA%93/"/>
    <id>http://example.com/A_OS/Windows/%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/%E6%9F%A5%E7%9C%8B%E7%BC%96%E8%AF%91%E7%9A%84lib%E6%96%87%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%BA%93/</id>
    <published>2023-12-29T02:08:27.232Z</published>
    <updated>2023-12-29T02:13:02.777Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：如何查看编译的 lib 的运行库是啥</p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /directives foo.lib</span><br></pre></td></tr></table></figure><table><thead><tr><th>dumpbin输出</th><th>对应的运行库</th></tr></thead><tbody><tr><td>&#x2F;DEFAULTLIB:MSVCRTD</td><td>&#x2F;MDd</td></tr><tr><td>&#x2F;DEFAULTLIB:MSVCRT</td><td>&#x2F;MD</td></tr><tr><td>&#x2F;DEFAULTLIB:LIBCMT</td><td>&#x2F;MT</td></tr><tr><td>&#x2F;DEFAULTLIB:LIBCMTD</td><td>&#x2F;MTD</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：如何查看编译的 lib 的运行库是啥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cmd&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="开发相关" scheme="http://example.com/categories/A-OS/Windows/%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="lib" scheme="http://example.com/tags/lib/"/>
    
    <category term="dumpbin" scheme="http://example.com/tags/dumpbin/"/>
    
  </entry>
  
  <entry>
    <title>c-Linux 设备管理</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/c-Linux%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/c-Linux%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</id>
    <published>2023-12-27T07:15:36.586Z</published>
    <updated>2023-12-27T08:14:25.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：</p><ul><li>Linux 系统设备管理的特点</li><li>Linux 设备驱动程序的接口</li><li>Linux 的磁盘高速缓存</li><li>Linux 字符设备缓冲区管理</li><li>Linux 的设备驱动</li></ul></blockquote><h2 id="0x01-Linux-系统设备管理的特点"><a href="#0x01-Linux-系统设备管理的特点" class="headerlink" title="0x01 Linux 系统设备管理的特点"></a>0x01 Linux 系统设备管理的特点</h2><p>Linux 系统把设备分为两大类。</p><ul><li>块设备：用于存储信息，它对信息的存取是以信息块为单位的，如通常使用的磁盘、磁带等等。</li><li>字符设备：通常用于输入输入出，作为人和计算机之间的接口，它对信息的存取是以字符为单位进行的，如键盘、鼠标、显示器、打印机等等。</li></ul><p>Linux 系统把 I&#x2F;O 设备看作文件，称为特别文件。例如：打印机的文件名为 <code>lp</code> ，控制终端的文件名为 <code>console</code>。这些特别文件组织在目录 <code>/dev</code> 下。如果要访问打印机可以使用路径 <code>/dev/lp</code> ，使用系统调用 <code>open</code> 可以打开设备文件并进行操作。</p><p>Linux 系统的这一特点使得任何外部设备在用户面前与普通文件完全一样，而不必涉及它的物理特性，给用户带来极大的方便。在文件系统内部，外部设备和普通文件一样受到存取控制的保护，仅仅在最终驱动设备时才转向各个设备的驱动程序。块设备上的普通文件和目录文件并不是设备特殊文件，但是块设备本身可以作为特殊文件来访问。</p><h2 id="0x02-文件系统与设备驱动程序的接口"><a href="#0x02-文件系统与设备驱动程序的接口" class="headerlink" title="0x02 文件系统与设备驱动程序的接口"></a>0x02 文件系统与设备驱动程序的接口</h2><p>Linux 系统为各类设备分别配置不同的驱动程序，在用户程序中通过该文件操作方式使用设备，如：打开、关闭、读、写等等，由文件系统转入设备驱动程序。</p><p>核心与设备驱动程序的接口是块设备开关表和字符设备开关表。每一种设备类型在表中占用一个表目，包含若干数据项，其中有一项为该类设备驱动程序入口地址，在系统调用时引导核心转向适当的驱动程序接口。</p><p>对设备特殊文件的系统调用，根据文件类型转入块设备开关表或字符设备开关表进行打开、关闭块设备或字符设备的操作。字符设备特殊文件的系统调用 <code>read</code>、<code>write</code> 系统调用则通过高速缓冲模块转向设备驱动模块中的策略过程。</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/c-Linux%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/1.png" class="" title="图片描述"><h2 id="0x03-设备开关表"><a href="#0x03-设备开关表" class="headerlink" title="0x03 设备开关表"></a>0x03 设备开关表</h2><p>Linux 系统吧块设备和字符设备又分别细分为若干类。如块设备可分为硬盘、软盘、磁带、光盘等，字符设备可分为终端设备、打印机等。为指定一类设备，将设备类从 0 开始顺序编号，称为主设备号；同一类的设备可能有许多，为了指定一台具体设备，需要一个次设备号来标识。因此，在指定一台具体设备时要给出块设备&#x2F;字符设备、主设备号、次设备号。如下图所示:</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/c-Linux%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/2.png" class="" title="图片描述"><p>设备开关表相当于一个二维矩阵，每一行含有同一类设备的驱动程序入口地址，主设备号与行号一一对应；每一列是完全不同操作（<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>）的驱动程序入口地址，如下表所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/c-Linux%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/3.png" class="" title="图片描述"><h2 id="0x04-磁盘高速缓存读写策略"><a href="#0x04-磁盘高速缓存读写策略" class="headerlink" title="0x04 磁盘高速缓存读写策略"></a>0x04 磁盘高速缓存读写策略</h2><p>对文件系统的一切存取操作都能通过直接从磁盘上读或写来实现，当磁盘 I&#x2F;O 的速度较慢，系统性能较低。为了减少对磁盘的存取频率，Linux 使用了磁盘高速缓存技术。</p><p>Linux 磁盘缓冲管理策略试图把尽可能多的有用数据保存在缓冲区中，磁盘缓冲管理模块位于文件系统和块设备驱动程序之间。当从磁盘中读数据时，文件系统先从磁盘高速缓存中读，如果数据已在高速缓存中，则不必启动磁盘 I&#x2F;O ，如果数据不再高速缓存中，则启动磁盘 I&#x2F;O ，从磁盘读取数据送往高速缓存，进程再冲高速缓存中读取数据。</p><p>当进程向磁盘上写数据时，先往高速缓存中写数据，以便随后读取它时能够直接从高速缓存上读取而不需要启动磁盘读写。Linux 采用“延时写”策略，即如果缓存区还没有写满这不会急于将缓冲区中的数据写到磁盘上，而是在缓冲管理数据结构中对该缓冲区设置延迟写标志，当高速缓存中的数据延迟到必须向磁盘上写的时候再进行写磁盘操作。</p><h2 id="0x05-磁盘缓冲管理的数据结构"><a href="#0x05-磁盘缓冲管理的数据结构" class="headerlink" title="0x05 磁盘缓冲管理的数据结构"></a>0x05 磁盘缓冲管理的数据结构</h2><p>Linux 使用多个内存缓冲区进行磁盘缓冲，为了合理有效地管理和使用这些缓冲区，必须按照一定策略进行管理。管理的依据是缓冲区的相关信息，为了能访问这些信息，必须将其按一定数据结构进行组织。</p><p>首先，给每个缓冲区建立“缓冲首部”来存放该缓冲区的相关信息，如下图所示。</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/c-Linux%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/4.png" class="" title="图片描述"><p>其中内容有：</p><ul><li>设备号 <code>dev</code>：缓冲区内包含的信息所属设备的设备号</li><li>块号 <code>blkno</code>：该缓冲区对应的磁盘的物理块号</li><li>状态 <code>flag</code>：描述了缓冲区的当状态，包括： - 忙标志 <code>BUSY</code>：缓冲区当前是否正忙 - 有效位 <code>AVE</code>：缓冲区包含的数据是否有效 - 延迟写位 <code>DELWR</code>：是否延迟写 - 写标志位 <code>WRITE</code>：是否正在把缓冲区的内容写到磁盘上 - 读标志位 <code>READ</code>：是否从磁盘往缓冲区读取数据信息 - 等待位 <code>WAIT</code>：是否有一个进程正在等待该缓冲区 - 设备缓冲区队列前向指针 <code>b-forw</code> - 设备缓冲区队列后向指针 <code>b-back</code> - 空闲缓冲区队列前向指针 <code>av-forw</code> - 空闲缓冲区队列后向指针 <code>av-back</code></li></ul><p>要对所有缓冲区进行管理，必须将所有缓冲区首部组织成一定的数据结构， Linux 建立了两个缓冲区队列；空闲缓冲区队列和设备缓冲区队列。空闲缓冲区队列如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/c-Linux%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/5.png" class="" title="图片描述"><p>为了对缓冲区进行分配，把所有空闲缓冲区组织成一个队列，队列中的所有缓冲区的忙标志位 <code>BUSY</code> 均为 0 。该队列是一个双向循环链表。</p><p>对于每类设备都建立一个设备缓冲区队列，由与该类设备有关的所有缓冲区构成。此队列中的所有缓冲区首部的忙标志位 <code>BUSY</code> 均为 1 。该队列同样是一个双向循环链表。</p><p>任何缓冲区首部不是位于空闲缓冲区队列中就是位于设备缓冲区队列中。设备缓冲区队列如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/c-Linux%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/6.png" class="" title="图片描述"><h2 id="0x06-Linux-磁盘缓冲区管理算法"><a href="#0x06-Linux-磁盘缓冲区管理算法" class="headerlink" title="0x06 Linux 磁盘缓冲区管理算法"></a>0x06 Linux 磁盘缓冲区管理算法</h2><p>Linux 提供的磁盘高速缓冲区不属于任何进程专用，而是由多个进程共享，由操作系统进行统一管理。为了提高使用效率，必须采取适当的管理策略。</p><p>当某进程要从一个磁盘读取数据时，首先需要检查要读取数据的磁盘块是否包含在某缓冲区中，如果不在，则从空闲缓冲区队列中分配给它一个空闲缓冲区；当某进程要将数据写入磁盘时，首先查看一下要写的磁盘块是否在某缓冲区中，如果不在则为这个磁盘块分配一个空闲缓冲区，被分配的空闲缓冲区从空闲缓冲队列中退出并进入对应的设备缓冲区队列，该缓冲区的 <code>BUSY</code> 标志位置一。</p><p>当缓冲区的信息读到相应进程的内存区后，或进程信息写到缓冲区后，，使释放进程使用的缓冲区，将 <code>flag</code> 中的 <code>BUSY</code> 标志位清零并送入空闲缓冲区队列尾部，即将置为延迟写的缓冲区也送入空闲缓冲队列，这样可以使得有限的缓冲区得到充分利用，满足多个并发进程的需求。</p><p>当一个缓冲区被送往空闲缓冲区队列尾部时，并不退出设备缓冲区队列，而是仍然留在原队列中，这样使得此次使用完毕送往空闲缓冲区队列的缓冲区能够暂时保存最后的信息应对可能的访问。如果将其保留在设备缓冲区队列中，当后来要读取的磁盘数据仍然保留在此缓冲区中时可以直接从缓冲区中读取而不需要再次启动磁盘 I&#x2F;O ，提高了读盘速度，这正是使用高速磁盘缓存的目的。</p><p>如果要使得使用完毕送入空闲缓冲区队列的缓冲区重新分配给其他设备，则可以将该缓冲区同时从空闲缓冲区队列和原设备缓冲区队列中抽出，送入新的设备缓冲区队列。</p><p>因为被使用过的缓冲区放在空闲缓冲区队列的末尾，随着不断地从空闲缓冲区队列上取下缓冲区，后面的缓冲区会不断地向队列首部移动。如果一个延迟写标志位为 1 的缓冲区移动到了空闲缓冲区队列的头部，当其被重新分配之前，需要将内部的内容写入到相应设备指定的磁盘块中。</p><h2 id="0x07-字符缓冲区及其队列"><a href="#0x07-字符缓冲区及其队列" class="headerlink" title="0x07 字符缓冲区及其队列"></a>0x07 字符缓冲区及其队列</h2><p>Linux 中为字符设备的数据传输设置了一个公用的字符缓冲池，该缓冲池内包含有若干个缓冲区，但是每个缓冲区很小，仅有几个到几十字节。为了合理使用这些缓冲区，将其组织成一定的数据结构。同块设备缓冲区的管理类似，建立空闲字符缓冲区队列和设备字符缓冲区队列。</p><p>每个字符缓冲区由四部分组成：</p><ul><li>缓冲区的第一个字符位置</li><li>缓冲器的最后一个字符位置</li><li>指向下一个字符缓冲区的指针</li><li>字符缓冲区</li></ul><p>如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/c-Linux%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/7.png" class="" title="图片描述"><p>对字符空闲区的操作是每次送入一个字符或取出一个字符。送入字符再字符缓冲区的尾部进行；取出字符从字符缓冲区的头部进行。随着不断往字符缓冲区中放入字符，最后一个字符的位置会向后推移，直到字符缓冲区的末尾，第一个字符的位置不一定是字符缓冲区的开始位置，随着不断地从缓冲区中取出字符，第一个字符的位置不断后移直到字符缓冲区的末尾。</p><h2 id="0x08-空闲缓冲区的分配与回收"><a href="#0x08-空闲缓冲区的分配与回收" class="headerlink" title="0x08 空闲缓冲区的分配与回收"></a>0x08 空闲缓冲区的分配与回收</h2><p>在一个进程中使用字符设备进行 I&#x2F;O 操作时，文件系统会为该字符设备分配一个空闲缓冲区。分配时会检查空闲缓冲区队列，当队列非空时则直接从队列首部取出一个空闲缓冲区分配给这个字符设备并将其送入该字符设备的设备缓冲区队列，并将指向该缓冲区的指针返回给调用进程；当空闲缓冲区队列为空时，则请求 I&#x2F;O 操作的进程将被阻塞等待直到有空闲缓冲区可用。</p><p>当字符缓冲区中的数据被提取完毕后，便要释放该缓冲区，将该缓冲区送入空闲字符缓冲区队列的首部。若此时有申请空闲缓冲区而阻塞的进程则会唤醒该进程。</p><h2 id="0x09-Linux-的设备驱动"><a href="#0x09-Linux-的设备驱动" class="headerlink" title="0x09 Linux 的设备驱动"></a>0x09 Linux 的设备驱动</h2><p>设备驱动是指控制具体的物理设备完成 I&#x2F;O 操作，与硬件的物理特性和数据传输控制方式密切相关，不同类型的设备、不同数据传输控制方式要采用不同设备驱动方式。</p><p>Linux 首先把设备分为块设备、字符设备两大类，然后再对块设备和字符设备具体分类，针对每一类设备分别开发不同的设备驱动程序。</p><h2 id="0x0a-块设备驱动"><a href="#0x0a-块设备驱动" class="headerlink" title="0x0a 块设备驱动"></a>0x0a 块设备驱动</h2><ol><li>数据结构</li></ol><p>块设备表，对每一类块设备分别设置块设备表，记录该类设备的相关信息。其内容包括：</p><ul><li>忙标志：标志设备的忙闲状态，0 表示空闲，1 表示正忙。</li><li>出错次数：指设备 I&#x2F;O 出错次数。每次 I&#x2F;O 完成后，就转入设备中断处理程序，设备中断处理程序检测此次 I&#x2F;O 过程是否出错，如果出错则将出错次数加一，如果出错次数没用超过规定值则中断处理程序重新启动一次数据传输；如果出错次数超出规定值则认为是真正的数据传输错误，不会再重新启动数据传输。</li><li>设备缓冲区队列头指针：分配给该设备的缓冲区队列的头指针</li><li>设备缓冲区队列尾指针：分配给该设备的缓冲区队列的尾指针</li><li>I&#x2F;O 请求队列头指针：请求该类设备 I&#x2F;O 操作的请求块组成的队列的头指针</li><li>I&#x2F;O 请求队列尾指针：请求该类设备 I&#x2F;O 操作的请求块组成的队列的尾指针</li></ul><p>I&#x2F;O 请求队列。用户进程的 I&#x2F;O 请求包括要求完成 I&#x2F;O 操作的逻辑设备名、要求的操作、传送数据在内存中的起始地址、传送数据的长度，将这些信息组织成 I&#x2F;O 请求块 <code>iorb</code>。逻辑设备名相同（同一类设备）的 I&#x2F;O 请求块构成一个队列，称为 I&#x2F;O 请求队列。每一类设备都分别有一个 I&#x2F;O 请求队列。</p><ol><li>磁盘设备驱动程序</li></ol><p>驱动程序控制设备具体实现进程的高级 I&#x2F;O 请求包括打开、关闭、读、写等。</p><ul><li>打开。磁盘在使用之前必须进行打开操作，其目的是在使用磁盘之前进行必要的初始化————设置硬盘的工作参数，硬盘工作参数存放在主存中操作系统结构硬盘控制块中，它是驱动程序对硬盘进行控制的依据。硬盘工作参数存放在硬盘的引导区中，因此要将引导区内容读到硬盘控制块中必须进行部分初始化工作。</li><li>读写硬盘。由策略接口程序 <code>strategy</code> 完成，每次只读写一个扇区，Linux 中对硬盘有两种读方式和三种写方式： - 一般读方式：把当前所需盘块中的内容读入缓冲区 - 预先读：进程读顺序文件的盘块时，会预先读取下一盘块的内容 - 一般写方式：把缓冲区数据写到盘块，进程必须等待写操作完成 - 异步写方式：把缓冲区数据写到盘块，进程不必等待写操作完成 - 延迟写：先将数据写到缓冲区，标记该缓冲区延迟写，挂到空闲缓冲区队列尾部等到后续时间再写到盘块中</li></ul><p>硬盘读写驱动过程：</p><ul><li>将逻辑块号转换为物理块号</li><li>申请 DMA</li><li>将物理块号转换为盘面号&#x2F;柱面号&#x2F;扇区号</li><li>移动磁头到指定柱面</li><li>向硬件控制器发送读写命令</li><li>CPU 发出读写命令后不必等待，继续执行其他进程</li><li>当传输结束后，硬盘控制器会向 CPU 发送中断信号</li><li>CPU 响应后转入硬盘中断处理程序</li></ul><h2 id="0x0b-字符设备驱动"><a href="#0x0b-字符设备驱动" class="headerlink" title="0x0b 字符设备驱动"></a>0x0b 字符设备驱动</h2><p>字符设备作为人和计算机之间的接口设备，人们通常通过字符设备向计算机输入信息（指令、数据）或输出信息。字符设备以字符作为数据传输单位，速度较慢。常见的字符设备有终端、行式打印机、卡片输入机等等。</p><p>字符设备的传递使用一组专用的寄存器来实现。每种字符设备的控制器一般都有三个寄存器：</p><ul><li>控制寄存器接收 CPU 发送来的命令、控制设备的操作；</li><li>状态寄存器保存设备的状态；</li><li>数据寄存器暂存要传送的数据；</li></ul><ol><li>数据结构</li></ol><p>对每一类字符设备分别家里字符设备表，记录使用该类字符设备所需的各种信息，由于字符设备种类繁多，不同种类的字符设备特性差别较大，因此其字符设备表差别较大。</p><ol><li>终端驱动程序</li></ol><p>字符设备种类繁多，其驱动程序哥不相同，这里就以终端驱动沉香古为例讲述 Linux 系统中字符设备驱动程序的工作原理：</p><p>终端主要由键盘和显示器构成，终端驱动程序控制终端设备和进程之间的字符数据传输，包括以下五种操作：</p><ul><li><code>ttopen</code>：打开终端设备，建立终端机器与终端进程之间的对应关系</li><li><code>ttclose</code>：切断终端设备与进程之间的对应关系</li><li><code>ioctl</code>：用于对终端机器的控制</li><li><code>ttread</code>：从终端设备读取数据</li><li><code>ttwrite</code>：向终端设备发送数据</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 系统设备管理的特点&lt;/li&gt;
&lt;li&gt;Linux 设备驱动程序的接口&lt;/li&gt;
&lt;li&gt;Linux 的磁盘高速缓存&lt;/li&gt;
&lt;li&gt;Linux 字符设备缓冲区管理&lt;/li&gt;
&lt;li&gt;Linux 的设备</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>7-进程间通信方式之共享内存</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</id>
    <published>2023-12-26T16:00:00.000Z</published>
    <updated>2023-12-27T04:30:50.012Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：知识点：</p><ul><li>Linux 共享内存方式原理介绍</li><li>Linux 共享内存相关 API 介绍</li></ul></blockquote><h2 id="0x01-Linux-进程间通信方式之共享内存概述"><a href="#0x01-Linux-进程间通信方式之共享内存概述" class="headerlink" title="0x01 Linux 进程间通信方式之共享内存概述"></a>0x01 Linux 进程间通信方式之共享内存概述</h2><p>在 Linux 中，每个进程都有属于自己的进程控制块（PCB）和地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址进行映射，通过内存管理单元（MMU）进行管理。两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存。如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/1.png" class="" title="图片描述"><p>当两个进程通过页表将虚拟地址映射到物理地址时，在物理地址中有一块共同的内存区，即共享内存，这块内存可以被两个进程同时看到。这样当一个进程进行写操作，另一个进程读操作就可以实现进程间通信。但是，我们要确保一个进程在写的时候不能被读，因此我们使用信号量来实现同步与互斥。</p><p>对于一个共享内存，实现采用的是引用计数的原理，当进程脱离共享存储区后，计数器减一，挂架成功时，计数器加一，只有当计数器变为零时，才能被删除。当进程终止时，它所附加的共享存储区都会自动脱离。</p><h2 id="0x02-Linux-共享内存使用步骤"><a href="#0x02-Linux-共享内存使用步骤" class="headerlink" title="0x02 Linux 共享内存使用步骤"></a>0x02 Linux 共享内存使用步骤</h2><ul><li>创建共享内存。也就是从内存中获得一段共享内存区域，这里用到的函数是 <code>shmget()</code></li><li>映射共享内存。也就是把这段创建的共享内存映射到具体的进程空间中，这里使用的函数是 <code>shmat()</code> 。到这一步就可以使用这段共享内存了，也就是可以使用不带缓冲的 I&#x2F;O 读写命令对其进行操作。</li><li>撤销映射。使用完共享内存就需要撤销，用到的函数是 <code>shmdt()</code>。</li></ul><p>其中用到的 Linux 系统函数介绍如下：</p><ol><li><code>shmget()</code> 函数创建共享内存</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    key：共享内存的键值，多个进程可以通过它访问同一个共享内存，其中 IPC_PRIVATE 用于创建当前进程私有的共享内存</span></span><br><span class="line"><span class="comment">    size：共享内存的大小</span></span><br><span class="line"><span class="comment">    shmflg：同 open() 函数的权限位</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功：共享内存段标识符</span></span><br><span class="line"><span class="comment">    失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li><code>shmat()</code> 函数映射共享内存</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    shmid：要映射的共享内存标识符</span></span><br><span class="line"><span class="comment">    shmaddr：将共享内存映射到指定地址，注意这里的是 void 型指针，如果是 0 则系统将自动分配地址并将共享内存映射到调用进程的地址空间</span></span><br><span class="line"><span class="comment">    shmflg：SHM_RDONLY（共享内存只读），0（可读写）</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功：被映射的段地址</span></span><br><span class="line"><span class="comment">    失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="实验一-shmem-demo"><a href="#实验一-shmem-demo" class="headerlink" title="实验一 shmem_demo"></a>实验一 shmem_demo</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE     256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> shmid;<span class="comment">//共享内存标识符</span></span><br><span class="line">    <span class="type">char</span> *shm_addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> flag[] = <span class="string">&quot;SHIYANLOU&quot;</span>;<span class="comment">//标志字符串</span></span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建共享内存 */</span></span><br><span class="line">    shmid = <span class="built_in">shmget</span>(IPC_PRIVATE, BUFFER_SIZE, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;shmget error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Create shared-memory: %d \n&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示共享内存情况 */</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建子进程 */</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child prograss ...\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="comment">//映射共享内存</span></span><br><span class="line">        shm_addr = <span class="built_in">shmat</span>(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(shm_addr == (<span class="type">char</span> *)<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Child: shmat&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child : Attach shared-memory [%p]\n&quot;</span>, <span class="built_in">getpid</span>(), shm_addr);</span><br><span class="line">        <span class="comment">/* 显示内存情况 */</span></span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">strncmp</span>(shm_addr, flag, <span class="built_in">strlen</span>(flag)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child : Wait for enable data...\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 共享内存有效数据显示 */</span></span><br><span class="line">        <span class="built_in">strcpy</span>(buf, shm_addr+<span class="built_in">strlen</span>(flag));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child : Shared-memory: %s\n&quot;</span>, <span class="built_in">getpid</span>(), buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 解除共享内存映射 */</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">shmdt</span>(shm_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;shmdt error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child : Deattach shared-memory\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 删除共享内存 */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Child : shmctl(IPC_RMID&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child : Delete shared-memory\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 子进程退出 */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        shm_addr = <span class="built_in">shmat</span>(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(shm_addr == (<span class="type">char</span> *)<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Parent: shmat&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Parent : Attach shared-memory : [%p]\n&quot;</span>, <span class="built_in">getpid</span>(), shm_addr);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nInput some string:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fgets</span>(buf, BUFFER_SIZE, stdin);</span><br><span class="line">        <span class="built_in">strncpy</span>(shm_addr + <span class="built_in">strlen</span>(flag), buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">strncpy</span>(shm_addr, flag, <span class="built_in">strlen</span>(flag));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 解除共享内存映射 */</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">shmdt</span>(shm_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Parent : shmdt error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Parent : Deattach shared-memory\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitpid</span>(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nFinished...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VS Code 平台下的终端窗口使用 <code>gcc</code> 工具完成可执行文件编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc shmem_demo.c -o shmem_demo</span><br><span class="line">./shmem_demo</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/2.png" class="" title="图片描述"><h2 id="实验二——shmem-sem-c"><a href="#实验二——shmem-sem-c" class="headerlink" title="实验二——shmem_sem.c"></a>实验二——shmem_sem.c</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE     256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义联合体 */</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">semid_ds</span> *buf;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_sem</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> init_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">semun</span> sem_union;</span><br><span class="line">    sem_union.val = init_val;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, sem_union) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;init semaphore error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">del_sem</span><span class="params">(<span class="type">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">semun</span> sem_union;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// perror(&quot;Delete semaphore error.\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_p</span><span class="params">(<span class="type">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;P error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_v</span><span class="params">(<span class="type">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;P error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> sem_id;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span> *shm_addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建信号量</span></span><br><span class="line">    sem_id = <span class="built_in">semget</span>(<span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;a&#x27;</span>), <span class="number">1</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="built_in">init_sem</span>(sem_id, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建共享内存</span></span><br><span class="line">    shmid = <span class="built_in">shmget</span>(IPC_PRIVATE, BUFFER_SIZE, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Create Shared-memory : %d\n&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示共享内存情况</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork() error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="comment">//映射共享内存</span></span><br><span class="line">        shm_addr = <span class="built_in">shmat</span>(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(shm_addr == (<span class="type">char</span> *)<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Child: shmat&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child : Attach shared-memory [%p]\n&quot;</span>, <span class="built_in">getpid</span>(), shm_addr);</span><br><span class="line">        <span class="comment">/* 显示内存情况 */</span></span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child : Wait for enable data...\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 共享内存有效数据显示 */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">            <span class="built_in">sem_p</span>(sem_id);</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, shm_addr);</span><br><span class="line">            <span class="built_in">memset</span>(shm_addr, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child : Shared-memory: %s\n&quot;</span>, <span class="built_in">getpid</span>(), buf);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((!<span class="built_in">strncmp</span>(buf, <span class="string">&quot;q&quot;</span>, <span class="number">1</span>)) || (!<span class="built_in">strncmp</span>(buf, <span class="string">&quot;Q&quot;</span>, <span class="number">1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child Will Quit.\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sem_v</span>(sem_id);</span><br><span class="line">        <span class="built_in">del_sem</span>(sem_id);</span><br><span class="line">        <span class="comment">/* 解除共享内存映射 */</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">shmdt</span>(shm_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;shmdt error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child : Deattach shared-memory\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 删除共享内存 */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Child : shmctl(IPC_RMID&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Child : Delete shared-memory\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 子进程退出 */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        shm_addr = <span class="built_in">shmat</span>(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(shm_addr == (<span class="type">char</span> *)<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Parent: shmat&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Parent : Attach shared-memory : [%p]\n&quot;</span>, <span class="built_in">getpid</span>(), shm_addr);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nInput some string:\n&quot;</span>);</span><br><span class="line">            <span class="built_in">fgets</span>(buf, BUFFER_SIZE, stdin);</span><br><span class="line">            <span class="built_in">strncpy</span>(shm_addr, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">            <span class="built_in">sem_v</span>(sem_id);</span><br><span class="line">            <span class="keyword">if</span>((!<span class="built_in">strncmp</span>(buf, <span class="string">&quot;q&quot;</span>, <span class="number">1</span>)) || (!<span class="built_in">strncmp</span>(buf, <span class="string">&quot;Q&quot;</span>, <span class="number">1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[%d]Parent Will Quit.\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 解除共享内存映射 */</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">shmdt</span>(shm_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Parent : shmdt error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]Parent : Deattach shared-memory\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitpid</span>(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nFinished...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 共享内存方式原理介绍&lt;/li&gt;
&lt;li&gt;Linux 共享内存相关 API 介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x01-Linux-进程间通信方式之共享内存概</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>8-Linux 线程概述</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/8-Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/8-Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0/</id>
    <published>2023-12-26T16:00:00.000Z</published>
    <updated>2023-12-27T05:55:17.724Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：知识点</p><ul><li>Linux 线程的基本概念</li><li>Linux 共享内存相关 API 介绍</li></ul></blockquote><h2 id="0x01-Linux-线程的基本概念"><a href="#0x01-Linux-线程的基本概念" class="headerlink" title="0x01 Linux 线程的基本概念"></a>0x01 Linux 线程的基本概念</h2><p>Linux 操作系统引入线程主要是为了提高系统的执行效率，减少处理机的空转时间和在进行调度切换时因保护现场信息所用的时间，便于系统管理。</p><p>线程（<code>Threads</code>）是进程中执行运算的最小单位，即执行处理机调度的基本代为。在 Linux 操作系统中，可以在一个进程内部进行线程切换，现场保护工作量小，并且通过共享线程的基本资源可以减轻系统开销。此外，进程中线程的切换也能提高现场切换的效率。因此，一个进程内的基本调度单位称为线程或轻型线程，这个调度单位既可以由操作系统内核控制，也可以由用户程序控制。下面就将前面所学到的进程与线程进行比较来进一步理解线程的概念：</p><ul><li>进程是操作系统资源分配的基本单位。所有与该进程有关的资源，如外部设备、缓冲区队列等，都被记录在进程控制块 PCB 中，以表示该进程拥有这些资源。同一进程的所有线程共享该进程的所有资源。</li><li>线程是分配处理机的基本单位。它与资源分配无关，即真正在处理机上运行的是线程。</li><li>一个线程只能属于一个进程，而一个进程可以拥有多个线程，但至少有一个线程。</li><li>线程在执行过程中需要协作同步，不同进程的线程间要利用消息通信的方式实现同步（进程间通信）。</li></ul><p>虽然上面列出了很多线程与进程的区别，但是在 Linux 操作系统中并没有进行太多区分，对进程和线程都用了相同的描述方法以及相同的调度和管理策略。</p><h2 id="0x02-Linux-线程的状态"><a href="#0x02-Linux-线程的状态" class="headerlink" title="0x02 Linux 线程的状态"></a>0x02 Linux 线程的状态</h2><p>Linux 操作系统中，线程与进程一样，也有自己的状态。线程有三种基本状态，即执行、阻塞和就绪，没有进程状态中的挂起状态。因此，线程是一个只与内存和寄存器相关的概念，内容不会因为交换而进入内存。</p><p>针对线程的三种状态，系统中存在五种基本操作来转换线程状态：</p><ul><li>派生：线程在进程中派生出来，也可再派生线程。用户可以通过相关的系统调用派生自己的线程。在 Linux 系统中，库函数 <code>clone()</code> 和 <code>creat_thread()</code> 分别用来派生不同执行模式下的线程。新派生的线程具有相应的数据结构指针和变量，这些指针和变量作为寄存器上下文放在本线程的寄存器和堆栈中。新派生的线程被放入就绪队列。</li><li>调度：选择一个就绪线程进入执行状态。</li><li>阻塞：像进程一样，如果一个线程在执行过程中需要等待某个事件发生，则被阻塞，阻塞时，寄存器上下文、程序计数器以及堆栈指针都会得到保存。</li><li>激活：如果阻塞线程所等待的事件发生，则该线程被激活并进入就绪队列。</li><li>结束：如果一个线程执行结束，它的寄存器上下文以及堆栈内容等将被释放。</li></ul><h2 id="0x03-引入线程的优势"><a href="#0x03-引入线程的优势" class="headerlink" title="0x03 引入线程的优势"></a>0x03 引入线程的优势</h2><p>多线程机制是指操作系统支持在一个进程内自行多个线程的能力。从线程的观点分析，<code>MS-DOS</code> 仅支持一个用户进程和一个线程；<code>UNIX</code> 系统支持多个用户进程，当一个进程只能有一个线程；<code>WindowsNT</code> 、<code>Solaris</code> 、 <code>Linux</code> 等支持多进程多线程。</p><p>虽然多种系统都支持多线程，但是实现的方式也不相同。线程有两个基本类型：</p><ul><li>用户级线程</li><li>系统级线程（核心级线程）</li></ul><ol><li>用户级线程 用户级线程简称为 <code>ULT</code> ，由用户应用程序建立的，并由用户应用程序负责对这些线程进行调度和管理，操作系统内核并不知道有用户级线程的存在，只对进程进行管理。因此这种线程与内核无关。<code>MS-DOS</code> 和 <code>UNIX</code> 操作系统下线程就属于这种。</li></ol><p>这种纯 <code>ULT</code> 方法的优点如下：</p><ul><li>应用程序中线程的开关的时空开箱远远小于内核级线程的开销</li><li>线程的调度算法与操作系统的调度算法无关</li><li>用户级线程方法适用于任何操作系统，因为与内核无关</li></ul><p>缺点也很明显，如下：</p><ul><li>在一个典型的操作系统中，有许多系统请求正被阻塞着，因此，当线程执行一个系统请求时，不仅本线程阻塞，而且该线程所在进程中的所有线程都会被阻塞</li><li>在该方法的系统中，因为每个进程每次只能由一个线程在 CPU 中运行，因此，一个线程应用无法利用多处理器的优点。</li></ul><ol><li>内核级线程</li></ol><p>内核级线程简称为 <code>KLT</code> 。内核级线程中所有线程的创建、调度和管理全部由操作系统内核负责完成。一个应用进程可按多线程方式编写程序，当它被提交给多线程操作系统运行时，内核为它创建一个进程和一个线程，线程在运行中还会创建新的线程。操作系统内核给应用程序提供相应的系统调用和应用程序接口，以使用户程序可以创建、执行、撤销线程。这种内核级线程的优点如下：</p><ul><li>内核可以调度一个进程中的线程，使其同时在多个处理机上并行运行，从而提高系统的效率</li><li>当进程中的一个线程被阻塞时，进程中的其他线程仍然可运行</li><li>内核本身可以以线程方式实现</li></ul><p>缺点也很明显，由于线程调度程序运行在内核态，而应用程序运行在用户态，因此同一个进程中的线程切换要经过用户态到内核态，再从内核态到用户态的两次模式装换。</p><ol><li>用户级线程与核心机线程相结合的模式</li></ol><p>由于用户级线程和内核级线程各有特点，因此，如果将两种方式相结合起来，则可以吸取两者的优点，结合起来的系统称为多线程的操作系统。内核支持多线程的建立、调度和管理。同时系统中又提供使用线程库，允许用户应用程序建立、调度和管理用户级线程。</p><p><code>Linux</code> 的内核级线程和其他操作系统的内核实现不同。大多数操作系统单独定义描述线程的数据结构，采用单独的线程管理方式，提供专门的线程调度，这些都增加了内核和调度程序的复杂性。而在 <code>Linux</code> 中，将线程定义为“执行上下文”，它实际上只是进程的另外执行上下文而已，和进程采用同样的表示、管理、调度方式。这样，<code>Linux</code> 内核并不需要区分线程和进程，只需要一个进程&#x2F;线程管理数组，而且调度程序也只有进程的调度程序，内核的实现相对简单得多，而且节约系统用于管理方面的时间开销。</p><h2 id="0x04-Linux线程相关-API-函数"><a href="#0x04-Linux线程相关-API-函数" class="headerlink" title="0x04 Linux线程相关 API 函数"></a>0x04 Linux线程相关 API 函数</h2><p>Linux 系统下的多线程遵循 POSIX 线程接口，称为 <code>pthread</code> ，编写 Linux 下的多线程程序需要使用头文件 <code>pthread.h</code> ，编译时需要使用 <code>-pthread</code> 链接使用库 <code>libpthread.a</code>，创建线程的函数接口是 <code>pthread_create</code> ，具体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *<span class="keyword">restrict</span> thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*), <span class="type">void</span> *<span class="keyword">restrict</span> arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    thread：负责向调用者传递子线程的线程号</span></span><br><span class="line"><span class="comment">    attr：负责控制线程的各种属性，具体会用到属性设置结构体 pthread_attr_t，如下：</span></span><br><span class="line"><span class="comment">        typedef struct</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            int                             detachstate;  //线程的分离状态</span></span><br><span class="line"><span class="comment">            int                             schedpolicy;  //线程调度策略</span></span><br><span class="line"><span class="comment">            structsched_param               schedparam;  //线程的调度参数</span></span><br><span class="line"><span class="comment">            int                             inheritsched;  //线程的继承性</span></span><br><span class="line"><span class="comment">            int                             scope;       //线程的作用域</span></span><br><span class="line"><span class="comment">            size_t                          guardsize;   //线程栈末尾的警戒缓冲区大小</span></span><br><span class="line"><span class="comment">            int                             stackaddr_set;   //线程堆栈的地址集</span></span><br><span class="line"><span class="comment">            void*                           stackaddr;   //线程栈的位置</span></span><br><span class="line"><span class="comment">            size_t                          stacksize;    //线程栈的大小</span></span><br><span class="line"><span class="comment">        &#125;pthread_attr_t;</span></span><br><span class="line"><span class="comment">    start_routine：这个参数负责指定子线程需要允许的函数，这个参数需要一个函数指针。</span></span><br><span class="line"><span class="comment">    arg：参数指定子线程运行函数所需的参数值。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功返回 0，识别返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>线程退出函数 <code>pthread_exit(void *retval)</code> ，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    retval：留给主线程回收使用的退出状态值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>主线程回收子线程资源函数 <code>pthread_join()</code>，当调用 <code>pthread_join()</code> 时，当前线程会处于阻塞状态，直到被调用的线程结束后，当前线程才会重新开始执行。当 <code>pthread_join()</code> 函数返回后，被调用线程才算真正意义上的结束，内存空间才会被释放（如果被调用线程是非分离情况下），具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> th, <span class="type">void</span> **thread_return)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    th：被连接线程的线程号</span></span><br><span class="line"><span class="comment">    thread_return：指向一个被连接线程的返回码的接收位置</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功返回 0，失败返回一个 error number</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>多线程程序中可能会存在数据不一致的情况，那么如何保证数据一致呢？可以考虑同一时间只有一个线程访问数据。互斥量(mutex)就是一把锁。多个线程只有一把锁一个钥匙，谁上的锁就只有谁能开锁。当一个线程要访问一个共享变量时，先用锁把变量锁住，然后再操作，操作完了之后再释放掉锁，完成。当另一个线程也要访问这个变量时，发现这个变量被锁住了，无法访问，它就会一直等待，直到锁没了，它再给这个变量上个锁，然后使用，使用完了释放锁，以此进行。这个即使有多个线程同时访问这个变量，也好象是对这个变量的操作是顺序进行的。</p><p>互斥变量使用特定的数据类型：<code>pthread_mutex_t</code>，使用互斥量前要先初始化，使用的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对互斥量加锁解锁的函数如下：</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>对于线程锁的相关介绍有很多，后面有机会咱们详细介绍一下。这里先暂时了解部分用于线程同步使用。</p><h2 id="0x05-实验一：Linux-线程创建"><a href="#0x05-实验一：Linux-线程创建" class="headerlink" title="0x05 实验一：Linux 线程创建"></a>0x05 实验一：Linux 线程创建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mythread1</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the 1st pthread,created by xiaoqiang!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mythread2</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the 2st pthread,created by xiaoqiang!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pthread_t</span> id1,id2;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_create</span>(&amp;id1, <span class="literal">NULL</span>, (<span class="type">void</span> *)mythread1,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create pthread error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_create</span>(&amp;id2, <span class="literal">NULL</span>, (<span class="type">void</span> *)mythread2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create pthread error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(id1,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(id2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x06-实验二：Linux-线程同步问题"><a href="#0x06-实验二：Linux-线程同步问题" class="headerlink" title="0x06 实验二：Linux 线程同步问题"></a>0x06 实验二：Linux 线程同步问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> thread[<span class="number">2</span>];  <span class="comment">//两个线程</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mut;</span><br><span class="line"><span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;thread1 : I&#x27;m thread 1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)   <span class="comment">//模拟线程执行时间</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;thread1 : number = %d\n&quot;</span>,number);</span><br><span class="line">                <span class="built_in">pthread_mutex_lock</span>(&amp;mut);</span><br><span class="line">                        number++;</span><br><span class="line">                <span class="built_in">pthread_mutex_unlock</span>(&amp;mut);</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread1 :主函数在等我完成任务吗？\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread2 : I&#x27;m thread 2\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;thread2 : number = %d\n&quot;</span>,number);</span><br><span class="line">                <span class="built_in">pthread_mutex_lock</span>(&amp;mut);</span><br><span class="line">                        number++;</span><br><span class="line">                <span class="built_in">pthread_mutex_unlock</span>(&amp;mut);</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread2 :主函数在等我完成任务吗？\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_create</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">//创建两个线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;thread, <span class="number">0</span>, <span class="built_in">sizeof</span>(thread));          <span class="comment">//comment1</span></span><br><span class="line">        <span class="comment">/*创建线程*/</span></span><br><span class="line">        <span class="keyword">if</span>((temp = <span class="built_in">pthread_create</span>(&amp;thread[<span class="number">0</span>], <span class="literal">NULL</span>, thread1, <span class="literal">NULL</span>)) != <span class="number">0</span>)  <span class="comment">//comment2</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;线程1创建失败!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;线程1被创建\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((temp = <span class="built_in">pthread_create</span>(&amp;thread[<span class="number">1</span>], <span class="literal">NULL</span>, thread2, <span class="literal">NULL</span>)) != <span class="number">0</span>)  <span class="comment">//comment3</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;线程2创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;线程2被创建\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_wait</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/*等待线程结束*/</span></span><br><span class="line">        <span class="keyword">if</span>(thread[<span class="number">0</span>] !=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">           &#123;             <span class="comment">//comment4</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">pthread_join</span>(thread[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;线程1已经结束\n&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">if</span>(thread[<span class="number">1</span>] !=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//comment5</span></span><br><span class="line"></span><br><span class="line">               <span class="built_in">pthread_join</span>(thread[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;线程2已经结束\n&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/*用默认属性初始化互斥锁*/</span></span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mut,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是主函数哦，我正在创建线程，呵呵\n&quot;</span>);</span><br><span class="line">        <span class="built_in">thread_create</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是主函数哦，我正在等待线程完成任务阿，呵呵\n&quot;</span>);</span><br><span class="line">        <span class="built_in">thread_wait</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：知识点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 线程的基本概念&lt;/li&gt;
&lt;li&gt;Linux 共享内存相关 API 介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x01-Linux-线程的基本概念&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>9-处理机调度与死锁.md</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/9-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/9-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/</id>
    <published>2023-12-26T16:00:00.000Z</published>
    <updated>2023-12-27T06:00:20.200Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：</p><ul><li>处理机的三级调度</li><li>作业调度及进程调度的概念</li><li>调度算法的评价准则</li><li>几种常用的作业调度、进程调度算法</li><li>死锁的概念及产生原因</li><li>死锁的预防办法</li><li>死锁的检测与恢复方法</li></ul></blockquote><h2 id="0x01-分级调度"><a href="#0x01-分级调度" class="headerlink" title="0x01 分级调度"></a>0x01 分级调度</h2><p>操作系统的一个非常重要的功能就是管理计算机资源，提高系统的效率。对处理机的管理是操作系统的基本功能之一。在早起的计算机系统中，对 CPU 的管理非常简单，与其他系统资源一样在整个操作系统运行过程中被单独一个作业所独占，不存在处理机分配和调度问题。随着多道程序设计技术和各种类型的操作系统的出现，各种不同的 CPU 管理方式开始使用，为用户提供不同性能的操作系统。</p><p>典型的批处理作业，从进入系统并驻留在外部存储的后备队列上开始，直到作业运行完毕，基本都需要经过这样的三级调度：作业调度、对换以及进程调度。</p><h2 id="0x02-调度的层次"><a href="#0x02-调度的层次" class="headerlink" title="0x02 调度的层次"></a>0x02 调度的层次</h2><ol><li>作业调度</li></ol><p>作业调度又称为高级调度或长调度，用于选择把外部存储中处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源。如何，将新创建的进程排在进程就绪队列中，准备执行。在批处理系统中，作业进入系统后，是先驻留在外部存储上的，因此需要有作业调度的过程，以便将它们分批地装入内存。在分时系统中，为了做到及时响应，用户通过键盘输入的命令或数据等，都是被直接送入内存的，因而无须再配置作业调度机制。同样地，在实时操作系统中，通常也不需要作业调度。</p><p>一个作业从提交给计算机系统到执行结束、退出系统，一般要经历提交、后备、执行和完成四种状态，如下：</p><ul><li>提交状态：一个作业从输入设备进入外部存储设备的过程称为提交状态，处于提交状态的作业，因信息尚未全部进入系统，所以不能被调度程序选中；</li><li>后备状态（收容状态）：输入管理系统不断将作业输入到外部存储对应部分，若一个作业的全部信息都输入到了输入井中，则在它还未被调度执行前，该作业处于后备状态；</li><li>执行状态：作业调度程序从后备作业中选取若干个作业到内存投入运行，为被选中作业建立进程并分配必要的资源，这时，这些被选中的作业处于执行状态。从宏观上看，这些作业证处于在执行过程中，从微观上看，在某一时刻，由于处理机总数少于并发执行的进程数，因此，不是所有被选中作业都占有处理机，其中的大部分处于等待资源或就绪状态。哪个作业的那个进程被分配给处理机，这就是进程调度需要完成的任务；</li><li>完成状态：当作业运行完毕，当它所占用的资源尚未全部被系统收回时，该作业处于完成状态。在这种状态下，系统需要做部分善后处理工作。</li></ul><ol><li>对换</li></ol><p>对换又称交换调度或中级调度，其主要任务是按照给定的原则和策略，将处于外部存储交换区中的就绪状态或等待状态的进程调入内存，或把处于内存就绪状态或内存等待状态的进程交换到外部存储交换区。交换调度主要涉及内存管理与扩充。（这部分将在后面的内存管理中详细讲到）</p><ol><li>进程调度</li></ol><p>进程调度又称为低级调度或微观调度，其主要任务是按照某种策略和算法，将处理机分配给一个处于就绪状态的进程。在确定了占用处理机的进程后，系统必须进行进程上下文切换以建立与占用处理机进程相适应的执行环境。进程调度可以分为以下两种方式：</p><ul><li>非抢占方式。非抢占方式不允许进程抢占已经分配出去的处理机。采用非抢占调度方式时，可能引起进程调度的原因有正在执行的进程执行完成、因发生某事件而不能机修执行、执行中的进程因提出 I&#x2F;O 请求而暂停执行、在进程通信或同步过程中执行了某种原语操作等等。非抢占调度方式的优点是实现简单、系统开销小，适用于大部分的批处理系统环境，但是很难满足紧急任务的要求。</li><li>抢占方式。抢占调度方式允许调度程序根据某种原则暂停正在执行的进程，将处理机收回，重新分配给另一个进程。抢占的原则有优先级原则、短作业优先原则、时间片原则等。</li></ul><p>作业调度和进程调度关系如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/9-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/1.png" class="" title="图片描述"><h2 id="0x03-调度算法"><a href="#0x03-调度算法" class="headerlink" title="0x03 调度算法"></a>0x03 调度算法</h2><p>在操作系统中，调度的实质是一种资源分配，因而调度算法是根据系统的资源分配策略，规定资源分配的算法。现有的各种调度算法中，有的适用于作业调度，有的则适用于进程调度，也有一些两者都适用的算法。</p><p>对于不同的系统和调度目标，应采用不同的调度算法。例如，在批处理系统中，考虑作业的平均周转时间，应采用短作业优先的调度算法；在分时系统中，为了保证系统具有合理的响应时间，应采用轮转法进行调度。下面就简单了解一下目前主流的几种调度算法。</p><h2 id="0x04-单道批处理系统的调度算法"><a href="#0x04-单道批处理系统的调度算法" class="headerlink" title="0x04 单道批处理系统的调度算法"></a>0x04 单道批处理系统的调度算法</h2><p>单道批处理系统中，作业调度的主要任务是解决作业之间的自动接续问题，减少操作员的干预，提高系统资源的利用率，所采用的调度算法比较简单，有如下几种：</p><ul><li>先来先服务调度算法：按照作业或进程到达的前后持续进行调度</li><li>短作业（进程）优先调度算法：对短作业或短进程优先调度的算法</li></ul><h2 id="0x05-多道批处理系统的调度算法"><a href="#0x05-多道批处理系统的调度算法" class="headerlink" title="0x05 多道批处理系统的调度算法"></a>0x05 多道批处理系统的调度算法</h2><p>在多道程序设计系统中，由于谋道作业的输入输出操作由通道代行控制，将 CPU 从繁多的 I&#x2F;O 操作中解脱出来，因此 CPU 可再分配给另一道作业，从而形成了多道作业并发执行的结果，减少了 CPU 对 I&#x2F;O 的等待时间。但是，由于作业不同，各作业执行时包含的 I&#x2F;O 操作时间的比例不同。基于这些原因，大多数多道程序系统的调度策略采用：先来先服务、考虑优先级、分时和优先级相结合、综合考虑资源要求等。</p><ul><li>先来先服务调度：按照作业或进程进入就绪队列的前后顺序进行调度执行；</li><li>基于优先级调度：每一道作业或者进程都设定了一定的优先级别，优先级别可以由用户定义，也可以由系统设定或计算确定。调度时挑选优先级高者，优先级相同时，按进程进入就绪态队列或作业进入后备态队列的先后顺序；</li><li>分时和优先级相结合调度：适用于分时操作系统中或者通用操作系统；</li><li>综合考虑资源要求调度：综合考虑每一道作业或进程对资源的要求进行调度分配；</li></ul><h2 id="0x06-Linux-系统的调度算法"><a href="#0x06-Linux-系统的调度算法" class="headerlink" title="0x06 Linux 系统的调度算法"></a>0x06 Linux 系统的调度算法</h2><p>前面讲了基本上所有的调度算法及其优缺点，那么在 Linux 操作系统下是什么样的情况呢。Linux 系统作业调度非常简单，或者说没有作业调度，作业一旦提交就直接进入内存，建立对应的进程，继而进入下一级的调度。交换调度主要涉及系统存储管理的内容（这部分在后面的内存管理中讲述）。</p><p>Linux 操作系统中的内核级线程和进程在表示、管理调度方面没有差别，系统也没用专门的线程调度，采用进程调度统一处理进程和内核线程。</p><h4 id="Linux-系统的进程调度策略"><a href="#Linux-系统的进程调度策略" class="headerlink" title="Linux 系统的进程调度策略"></a>Linux 系统的进程调度策略</h4><p>Linux 系统的调度程序就是内核中的 <code>schedule()</code> 函数，主要任务就是在就绪队列 <code>run_queue</code> 中选出一个进程并投入运行。<code>schedule()</code> 函数需要确定以下部分参数：</p><ul><li>进程调试算法 <code>policy</code></li><li>进程过程剩余时间片 <code>counter</code></li><li>进程静态优先级 <code>priority</code></li><li>实时进程优先级 <code>rt_priority</code></li><li>用户可控制 <code>nice</code> 因子</li></ul><p>上面参数被存放在进程控制块中相应的调度成员中，Linux 系统提供了三种进程调度算法，这三种算法可以由用户通过宏定义选择，具体可用调度策略如下：</p><table><thead><tr><th>调度策略标志</th><th>所代表的调度策略</th></tr></thead><tbody><tr><td><code>#define SCHED_OTHER</code></td><td>普通的分时进程</td></tr><tr><td><code>#define SCHED_FIFO</code></td><td>先进先出的实时进程</td></tr><tr><td><code>#define SCHED_RR</code></td><td>基于优先级的轮转算法</td></tr><tr><td><code>#define SCHED_YIELD</code></td><td>不是调度策略，表示进程让出 CPU</td></tr></tbody></table><p>Linux 内核将进程分为实时进程和非实时进程（普通进程）两种，实时进程获得 CPU 比普通进程优先，用户可以通过系统调用 <code>sched_setschedule()</code> 函数改变自己的调度策略，通过系统调用 <code>sys_setpriority()</code> 和 <code>sys_nice()</code> 改变其静态优先级。</p><h2 id="0x07-死锁问题"><a href="#0x07-死锁问题" class="headerlink" title="0x07 死锁问题"></a>0x07 死锁问题</h2><p>计算机系统中有很多资源属于单独的资源，但是在很多进程中都要共享这类资源，这样，若干进程就会相互竞争有限的资源，因获取不到资源而陷入阻塞状态。</p><p>系统发送死锁现象不仅浪费大量的系统资源，甚至导致整个系统奔溃，带来严重的后果。所以，对死锁问题再理论上和技术上都必须给予高度重视，采取一些有效的措施来预防、避免死锁的发生。</p><h2 id="0x08-死锁的概念"><a href="#0x08-死锁的概念" class="headerlink" title="0x08 死锁的概念"></a>0x08 死锁的概念</h2><p>死锁是进程死锁的简称，是由 Dijkstra 于 1965 年研究银行家算法时提出的，也是计算机操作系统乃至并发程序设计中非常重要但又最难处理的问题之一。掌握操作系统中对于死锁的处理方法，对计算机中处理并发程序的竞争问题有很大的帮助。</p><p>如下图所示，P1 进程占据资源 R1，P2 进程占据资源 R2，当 P1 进程期望得到资源 R2，而 P2 进程也期望访问资源 R1 时彼此都不能继续执行从而陷入死锁。</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/9-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/2.png" class="" title="图片描述"><p>简单来说，死锁就是指多个进程在循环等待其他进程占有的资源，因为始终等待不到其他进程释放资源从而进入无限期等待状态；也可以说死锁是进程之间无限期互相等待的事件。</p><p>其实，在前面的部分操作实验中，我们已经解决过死锁问题。比如之前的生产者和消费者问题中，要控制两个个进程之间执行的顺序就是为了避免死锁的发生。</p><h2 id="0x09-死锁产生的原因及必要条件"><a href="#0x09-死锁产生的原因及必要条件" class="headerlink" title="0x09 死锁产生的原因及必要条件"></a>0x09 死锁产生的原因及必要条件</h2><p>从前面的介绍中可以将系统产生死锁的根本原因归结为以下几点：</p><ul><li>个进程竞争优先的资源</li><li>进程推进顺序不当</li></ul><p>而死锁产生的必然条件，换句话说，当系统如果可能发生死锁则一定存在如下情况或者条件：</p><ul><li>互斥条件：对于一个排他性资源，同一时刻只能由最多一个进程占有；</li><li>占有且申请条件：进程至少占有一个资源，但是又申请新的资源，等待新资源的时候仍然没有释放已占用资源；</li><li>不可抢占条件：进程所获得的资源在未使用完毕前不能强行被其他进程夺取；</li><li>环路条件：存在一个进程等待序列</li></ul><h2 id="0x0a-解决死锁的基本方法"><a href="#0x0a-解决死锁的基本方法" class="headerlink" title="0x0a 解决死锁的基本方法"></a>0x0a 解决死锁的基本方法</h2><p>为了保证系统的正常运行，应事先采取措施，预防或避免死锁的发生。在系统已出现死锁后，要及时检测到死锁并解除死锁。目前用于处理死锁问题的方法如下：</p><ul><li>死锁的预防：采取某种策略，限制并发进程对资源的请求，从而保证死锁的必要条件在系统执行的任何时间都得不到满足；</li><li>死锁的避免：在分配资源时，根据资源的使用情况提前做出预测，给定一个合适、安全的进程推进顺序，从而避免死锁的发生；</li><li>死锁的检测：允许系统发生死锁。系统设置专用结构应对死锁的发生。当死锁发生时，能够检测到死锁并找出对应的进程和资源；</li><li>死锁的解除：与死锁检测配套措施，用于将进程从死锁状态解救出来。</li></ul><h2 id="0x0b-产生死锁实例"><a href="#0x0b-产生死锁实例" class="headerlink" title="0x0b 产生死锁实例"></a>0x0b 产生死锁实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> thread[<span class="number">2</span>];  <span class="comment">//两个线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义两个锁，给两个线程分别使用 */</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_0;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_1;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 首先将自己的线程锁 1 上锁，然后访问共享数据 number ，对其进行 + 1 操作，接着不释放线程锁1 而是尝试去获取 线程锁 2 */</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;thread[1] : I&#x27;m thread 1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread[1]: mutex_0 already lock!\n&quot;</span>);</span><br><span class="line">    number++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread[1]: number++--&gt;[%d]\n&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread[1]: I will deadlock....\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 会在上一步死锁，线程死等在此处 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread1 :主函数在等我完成任务吗？\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 首先将自己的线程锁 2 上锁，确保线程1 在获取线程锁 2 时无限等待（死锁），然后尝试去获取线程锁 1（也被线程 1 上锁，所以还是会无限等待。*/</span></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;thread[2] : I&#x27;m thread 2\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保线程1 先将锁 1 上锁 */</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread[2]: mutex_1 already lock!\n&quot;</span>);</span><br><span class="line">    number++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread[2]: number++--&gt;[%d]\n&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread[2]: I will deadlock....\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 会在上一步死锁，线程死等在此处 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread2 :主函数在等我完成任务吗？\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_create</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">//创建两个线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;thread, <span class="number">0</span>, <span class="built_in">sizeof</span>(thread));          <span class="comment">//comment1</span></span><br><span class="line">    <span class="comment">/*创建线程*/</span></span><br><span class="line">    <span class="keyword">if</span>((temp = <span class="built_in">pthread_create</span>(&amp;thread[<span class="number">0</span>], <span class="literal">NULL</span>, thread1, <span class="literal">NULL</span>)) != <span class="number">0</span>)  <span class="comment">//comment2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread 1 创建失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread 1 被创建\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((temp = <span class="built_in">pthread_create</span>(&amp;thread[<span class="number">1</span>], <span class="literal">NULL</span>, thread2, <span class="literal">NULL</span>)) != <span class="number">0</span>)  <span class="comment">//comment3</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread 2 创建失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread 2 被创建\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_wait</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*等待线程结束*/</span></span><br><span class="line">    <span class="keyword">if</span>(thread[<span class="number">0</span>] !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(thread[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread 1 已经结束\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(thread[<span class="number">1</span>] !=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//comment5</span></span><br><span class="line">        <span class="built_in">pthread_join</span>(thread[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread 2 已经结束\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/*用默认属性初始化互斥锁*/</span></span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex_0,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex_1,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是主函数哦，我正在创建线程\n&quot;</span>);</span><br><span class="line">        <span class="built_in">thread_create</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是主函数哦，我正在等待线程完成任务\n&quot;</span>);</span><br><span class="line">        <span class="built_in">thread_wait</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理机的三级调度&lt;/li&gt;
&lt;li&gt;作业调度及进程调度的概念&lt;/li&gt;
&lt;li&gt;调度算法的评价准则&lt;/li&gt;
&lt;li&gt;几种常用的作业调度、进程调度算法&lt;/li&gt;
&lt;li&gt;死锁的概念及产生原因&lt;/li&gt;
&lt;li&gt;死锁</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>a-Linux 内存管理</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/a-Linux%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/a-Linux%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-12-26T16:00:00.000Z</published>
    <updated>2023-12-27T06:48:00.301Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：主要讲述 Linux 操作系统中的内存管理方式及存储器管理的基本概念及原理，从中说明 Linux 操作系统对内存的管理模式以及在 Linux 操作系统中运行的进程的内存管理情况和内存读取、调用的最底层实现方式</p><ul><li>Linux 分页管理机制</li><li>虚拟内存段的组织与管理</li><li>内存的共享和保护</li><li>内存空间管理</li><li>空闲内存管理</li><li>内核态内存的申请与释放</li><li>用户态内存的申请与释放</li><li>Linux 系统交换空间</li><li>存储管理系统的缓冲机制</li></ul></blockquote><h2 id="0x01-Linux分页管理机制"><a href="#0x01-Linux分页管理机制" class="headerlink" title="0x01 Linux分页管理机制"></a>0x01 Linux分页管理机制</h2><p>Linux 采用“按需调页”算法，支持三层管理策略。由于 Intel CPU 在硬件级提供了段式存储管理和二层页式存储管理功能，Linux 操作系统作为一种软件，必须与之兼容。Linux 根据 Intel 处理器的要求，最低限度地设置与段相关的结构和初始化程序，但实质上是放弃了段式存储管理。Intel 微型计算机上的 Linux 系统考虑到 CPU 的限制，将第二层的页式管理（<code>pmd</code>）与第一层的页式管理（<code>pgd</code>）合并，因此真正发挥作用的是以页目录和页表为中心的数据结构和函数。</p><p>在 Linux 中，每个用户进程都可以访问 4GB 的线性虚拟内存空间。其中，0<del>3GB 的虚拟地址空间是用户空间，用户进程可以直接对其进行访问；3GB</del>4GB 的虚拟内存地址空间为内核态空间，存放仅供内核态访问的代码和数据，用户态进程不可访问。当用户进程通过中断或系统调用访问内核态空间时，就会触发处理特权级转换，即从操作系统的用户态转换到内核态。</p><blockquote><p>Linux的虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分， 将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，称为“用户空间。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p></blockquote><p>所有进程从 3GB 到 4GB 的虚拟空间是一样的，有相同的页目录项和页表，对应相同的物理内存段。Linux 以此方式使得内核态进程共享代码段和数据段。</p><p>内核态虚拟空间从 3GB 到 3GB+4MB 的一段被映射到物理空间 0<del>4MB。因此，进程处于内核态时，只要通过虚拟空间 3GB</del>3GB+4MB 段即可访问物理空间 0~4MB 段。</p><p>既然对于用户空间来说访问的内存地址都是连续的 4GB 线性虚拟地址，那么就需要知道 Linux 是如何划分虚拟空间。Linux 采用“按需调页”技术管理虚拟内存。标准 Linux 的虚拟页表分为三级页表，依次为页目录（<code>PGD</code> Page Directory）、中间页目录（<code>PMD</code> Page Middle Directory）和页表（<code>PTE</code> PageTable），如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/a-Linux%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1.png" class="" title="图片描述"><p>在 Intel CPU 上，Linux 的页表结构实际上为两级。IA-32 体系结构的页管理机制中的页目录是 PGD，页表是 PTE，而 PGD 和 PMD 实际上合二为一。在用户进程中用到的与内存管理有关的数据结构是 <code>mm_struct</code> 结构，此结构中包含了用户进程中与存储有关的信息，具体结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>       * <span class="title">mmap</span>;</span> <span class="comment">/* 指向虚拟区间（VMA）链表 */</span></span><br><span class="line">　　<span class="type">rb_root_t</span>                   mm_rb; ／*指向red_black树*/</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>       * <span class="title">mmap_cache</span>;</span> <span class="comment">/* 指向最近找到的虚拟区间*/</span></span><br><span class="line">　　<span class="type">pgd_t</span>                       * pgd; ／*指向进程的页目录*/　</span><br><span class="line">　　<span class="type">atomic_t</span>                    mm_users; <span class="comment">/* 用户空间中的有多少用户*/</span></span><br><span class="line">　　<span class="type">atomic_t</span>                    mm_count; <span class="comment">/* 对&quot;struct mm_struct&quot;有多少引用*/</span></span><br><span class="line">　　<span class="type">int</span>                         map_count; <span class="comment">/* 虚拟区间的个数*/</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>         <span class="title">mmap_sem</span>;</span></span><br><span class="line">　　<span class="type">spinlock_t</span>                  page_table_lock; <span class="comment">/* 保护任务页表和 mm-&gt;rss */</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>            <span class="title">mmlist</span>;</span> <span class="comment">/*所有活动（active）mm的链表 */</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">long</span>               start_code, end_code, start_data, end_data; <span class="comment">/*start_code 代码段起始地址,end_code 代码段结束地址,start_data 数据段起始地址, start_end 数据段结束地址*/</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">long</span>               start_brk, brk, start_stack; <span class="comment">/*start_brk 和brk记录有关堆的信息, start_brk是用户虚拟地址空间初始化时，堆的结束地址, brk 是当前堆的结束地址, start_stack 是栈的起始地址*/</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">long</span>               arg_start, arg_end, env_start, env_end; <span class="comment">/*arg_start 参数段的起始地址, arg_end 参数段的结束地址, env_start 环境段的起始地址, env_end 环境段的结束地址*/</span></span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">long</span>               rss, total_vm, locked_vm;</span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">long</span>               def_flags;</span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">long</span>               cpu_vm_mask;</span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">long</span>               swap_address;</span><br><span class="line">　　<span class="type">unsigned</span>                    dumpable:<span class="number">1</span>;</span><br><span class="line">　　<span class="type">mm_context_t</span>                context; <span class="comment">/* Architecture-specific MM context, 是与平台相关的一个结构，对i386 几乎用处不大*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个进程都有一个页目录，存储该进程所使用的内存页面情况。Linux 按照“按需调页”的原则，只分配必需的内存页面，从而避免了页表过多占用存储空间的情况出现。例如，系统调用 <code>fork</code> 分配内存页面的情况如下：</p><ul><li>内核态堆栈 1 页；</li><li>页目录 1 页；</li><li>页表几页；</li></ul><p>而系统调用 <code>exec</code> 分配内存页面的情况则：</p><ul><li>可执行文件的文件头 1 页；</li><li>用户堆栈 1 页或几页；</li></ul><p>这样，当进程开始运行时，如果执行代码不在内存中，将产生第一次缺页中断，让操作系统分配内存页面，并将执行代码装入内存中。此后，按需要逐渐分配更多的内存页面，并参与页面调度。当系统内存不足时，由操作系统决定是否将该进程的一部分页面换出到磁盘交换区或交换文件中。进程终止时，操作系统释放所有该进程占用的资源，包括内存页面。</p><h2 id="0x02-虚拟内存段的组织与管理"><a href="#0x02-虚拟内存段的组织与管理" class="headerlink" title="0x02 虚拟内存段的组织与管理"></a>0x02 虚拟内存段的组织与管理</h2><p>用户程序总共拥有 4GB 的虚拟空间，但是并不是 4GB 空间都可以让用户进程读写或申请使用。用户进程实际上可以申请的虚拟空间为 0 ~ 3GB 。在用户进程创建时，已由系统调用 <code>fork()</code> 的执行函数 <code>do_fork()</code> 将内核的代码段和数据段映射到 3GB 以后的虚拟空间，供内核态进程访问。所有进程的 3GB~4GB 的虚拟控件的映像都是相同的，并以此方式共享代码段和数据段。</p><p>为了能够以自然的方式管理进程虚拟控件，Linux 定义了虚拟段（<code>vma</code> virtual memory area），一个 <code>vma</code> 段是某个进程的一段连续的虚拟控件，在这段虚拟空间的所有单元拥有相同的特征。例如，属于同一个进程具有相同的访问权限，将同时被锁定、受保护等。</p><p>虚拟段的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*  第一个缓存行具有VMA树移动的信息*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;                     <span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;                       <span class="comment">/* The first byte after our end address within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span>   <span class="comment">/* 每个任务的VM区域的链接列表，按地址排序*/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     此VMA左侧最大的可用内存间隙（以字节为单位）。</span></span><br><span class="line"><span class="comment">     在此VMA和vma-&gt; vm_prev之间，</span></span><br><span class="line"><span class="comment">     或者在VMA rbtree中我们下面的一个VMA与其-&gt;vm_prev之间。</span></span><br><span class="line"><span class="comment">     这有助于get_unmapped_area找到合适大小的空闲区域。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 第二个缓存行从这里开始*/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>    <span class="comment">/* 我们所属的address space*/</span></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;      <span class="comment">/* 此VMA的访问权限 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags;     <span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     对于具有地址空间（address apace）和后备存储(backing store)的区域，</span></span><br><span class="line"><span class="comment">     链接到address_space-&gt;i_mmap间隔树，或者链接到address_space-&gt; i_mmap_nonlinear列表中的vma。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> rb_subtree_last;</span><br><span class="line">        &#125; linear;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">nonlinear</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     在其中一个文件页面的COW之后，文件的MAP_PRIVATE vma可以在i_mmap树和anon_vma列表中。</span></span><br><span class="line"><span class="comment">     MAP_SHARED vma只能位于i_mmap树中。</span></span><br><span class="line"><span class="comment">     匿名MAP_PRIVATE，堆栈或brk vma（带有NULL文件）只能位于anon_vma列表中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span>                <span class="comment">/* 由mmap_sem和* page_table_lock序列化*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>                      <span class="comment">/* Serialized by page_table_lock 由page_table_lock序列化*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span>      <span class="comment">/* 用于处理此结构体的函数指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 后备存储（backing store）的信息: */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;                         <span class="comment">/* 以PAGE_SIZE为单位的偏移量（在vm_file中），*不是* PAGE_CACHE_SIZE*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>                          <span class="comment">/* 我们映射到文件（可以为NULL）*/</span></span><br><span class="line">    <span class="type">void</span> * vm_private_data;                         <span class="comment">/* 是vm_pte（共享内存） */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合前面的内存管理数据结构，可以绘制如下的 Linux 内存管理框图：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/a-Linux%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.png" class="" title="图片描述"><h2 id="0x03-内存的共享和保护"><a href="#0x03-内存的共享和保护" class="headerlink" title="0x03 内存的共享和保护"></a>0x03 内存的共享和保护</h2><p>Linux 中内存共享以页表的形式实现，共享该页的各进程的页表表项直接指向共享页，如下图所示。这种结构不需要设立共享页表，节约内存的占用，但是效率较低。当共享页状态发生变化时，共享该页的各进程的页表均需要修改，并要多次访问页表。</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/a-Linux%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.png" class="" title="图片描述"><p>Linux 可以对虚拟段中的任意部分加锁或保护。对进程的虚拟地址加锁，其实质就是对 <code>vma</code> 段的 <code>vm_flags</code> 属性与 <code>VM_LOCKED(0X2000)</code> 进行“或”操作，虚拟内存加锁后，它对应的物理页面驻留内存不再被页面置换程序换出。加锁操作有三种：</p><ul><li>Mlock：对指定的一段虚拟空间加锁；</li><li>Munlock：对指定的一段虚拟空间解锁；</li><li>Mlockall：对进程的所有虚拟空间解锁；</li></ul><p>对进程的虚拟地址施行地址保护措施就是重新设置 <code>vma</code> 段的访问权限，其实质就是对 <code>vma</code> 段的 <code>vm_flags</code> 属性重置 <code>PORT_READ(0X1)</code> 、<code>PORT_WRITE(0X2)</code>、<code>PROT_EXEC(0X4)</code>，重新设定 <code>vm_page_port</code> 属性，与此同时，对虚拟地址范围内的所有页表项，其访问权限也相应调整，保护操作由系统调用 <code>mprotect</code> 实施。</p><p>虚拟段加锁、保护操作可以有以下几种方式：</p><ul><li>对整个虚拟段加锁或保护</li><li>对虚拟段前部加锁或保护</li><li>对虚拟段后部加锁或保护</li><li>对虚拟段中部加锁或保护</li></ul><h2 id="0x04-内存空间管理"><a href="#0x04-内存空间管理" class="headerlink" title="0x04 内存空间管理"></a>0x04 内存空间管理</h2><p>尽管 Linux 采用虚拟存储管理策略，有些申请仍然需要直接分配物理空间。例如，为刚创建的进程分配页目录，为装入进程的代码段分配空间，为 I&#x2F;O 操作准备缓冲区等。物理内存以页帧为单位，页帧的长度固定，等于页长，对于 Intel CPU 默认为 4KB。</p><p>Linux 对物理内存的管理通过 <code>mem_map</code> 表描述。<code>mem_map</code> 在系统初始化时，由 <code>free_area_init()</code> 函数创建，如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/a-Linux%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/4.png" class="" title="图片描述"><h2 id="0x05-空闲内存管理"><a href="#0x05-空闲内存管理" class="headerlink" title="0x05 空闲内存管理"></a>0x05 空闲内存管理</h2><p>在物理内存低端，紧跟 <code>mem_map</code> 表的 <code>bitmap</code> 表以位示图方式记录了有有物理内存的空闲情况。与 <code>mem_map</code> 一样，<code>bitmap</code> 表在系统初始化时由 <code>free_area_init()</code> 函数创建，如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/a-Linux%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5.png" class="" title="图片描述"><h2 id="0x06-内核态的内存的申请与释放"><a href="#0x06-内核态的内存的申请与释放" class="headerlink" title="0x06 内核态的内存的申请与释放"></a>0x06 内核态的内存的申请与释放</h2><p>内核态内存是用来存放 Linux 内核系统数据结构的内存区域，处于进程虚拟空间的 3GB~4GB 范围内。以 Intel CPU 为例，申请的内存块大小 <code>blocksize</code> 有 32、64、128、512 等。在 <code>blocksize</code> 中能够申请到的块的大小近似于 2 的次幂，所差的恰好是管理数据结构所占用的字节数，如 16 是 <code>struct page_dsecriptor</code> 结构的长度。</p><p>管理内核空间空闲块的数据结构及相互关系如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/a-Linux%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6.png" class="" title="图片描述"><h2 id="0x07-用户态内存的申请与释放"><a href="#0x07-用户态内存的申请与释放" class="headerlink" title="0x07 用户态内存的申请与释放"></a>0x07 用户态内存的申请与释放</h2><p>Linux 用 <code>kmalloc()</code> 函数和 <code>kfree()</code> 函数提供内核内存申请、释放的接口，它还实现另一种虚拟空间的申请、释放接口，就是 <code>vmalloc()</code> 和 <code>vfree()</code>。</p><p>由 <code>vmalloc()</code> 分配的存储空间在进程的虚拟空间是连续的，当它对应的物理内存扔需要经过缺页中断后由缺页中断服务程序分配，所分配的物理页帧不是连续的。这些特征和访问用户内存相似，所以&#x3D;&#x3D;不妨把 <code>vmalloc()</code> 和 <code>vfree()</code> 成为用户态内存的申请和释放界面&#x3D;&#x3D;。</p><p>可分配的虚拟空间在 <code>3GB+high_memory+HOLE_8MB</code> 以上的高端，由 <code>vmlist</code> 链表管理。<code>3GB</code> 是内核态赖以访问物理内存的起始地址。<code>high_memory</code> 是安装在计算机中实际可用的物理内存的最高地址。 因此 <code>3GB+high_memory</code> 也是物理内存的上界。 <code>HOLE_8MB</code> 则是长度为 8MB 的“隔离带”，起越界保护作用。这样，<code>vmlist</code>管辖的虚拟空间既不与进程用户态<code>0~3GB</code>的虚拟空间冲突，也不与进程内核态映射的 <code>3GB~3GB+high_memory</code> 的虚拟空间冲突。</p><p><code>vmlist</code>链表的节点类型 <code>vm_struct</code> 具体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;  <span class="comment">/* 虚拟内存块的占用标志 */</span></span><br><span class="line">    <span class="type">void</span>                *addr;  <span class="comment">/* 虚拟内存块的起始地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       size;   <span class="comment">/* 虚拟内存块的长度 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span>    *<span class="title">next</span>;</span>  <span class="comment">/* 下一个虚拟内存块 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>起始时，<code>vmlist</code> 只有一个节点，<code>vmlist_addr</code> 置为 <code>VMALLOC_START</code>（段地址 3GB，偏移量 <code>high_memory+8MB</code>）。动态管理过程中，<code>vmlist</code> 的虚拟内存块按起始地址从小到大排序，每个虚拟内存块之后都有一个 <code>4KB</code> 大小的“隔离带”，用来检查指针的越界错误，用户申请大块连续空间可用 <code>vmalloc()</code> ，如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/a-Linux%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/7.png" class="" title="图片描述"><h2 id="0x08-交换空间"><a href="#0x08-交换空间" class="headerlink" title="0x08 交换空间"></a>0x08 交换空间</h2><p>计算机的物理内存空间总是影响机器性能。内存太小时，操作系统采用交换的方式。1970 年以后，按需调页算法得到了应用，是 Linux 操作系统采用的虚拟存储器的策略。换页操作时，Linux 区分两种不同的内存数据。一部分没有写权限的进程空间在换页时无需存入交换空间，直接丢弃即可。那些修改过的页面，换页时，其内容必须保存，保存的位置属于交换空间的某个页面。</p><p>Linux 采用两种方式保存换出的页面，一种是整个块设备，如磁盘的一个分区，称为交换设备；另一种是文件系统的固定长度的文件，称为交换文件。交换设备和交换文件统称为交换空间。</p><p>尽管交换空间有两种不同的方式，当它们的内部格式是一致的。一个交换空间最多可容纳 <code>32687</code> 个页面。如果一个交换空间不够用，Linux 允许并行管理多个交换空间，交换设备远比交换文件有效。在交换设备中，属于同一个页面的数据块总是连续的，第一个数据块地址确定，后续的数据库可以按顺序读出或写入，而在交换文件中，属于同一个页面的数据块虽然在逻辑上是连续的，但是数据块的实际位置可能是零散的。</p><p>当交换进程 <code>kswapd</code> 尝试换出页面时，调用测试进程 <code>try_to_swap_out()</code> 测试页面的存在时间。如果某个物理页面可以换出，则调用 <code>get_swap_page()</code> 申请交换空间的页面，得到交换进程的入口地址 <code>entry</code>，将要换出的物理页面换到 <code>entry</code> 指定的交换空间的某个页面中。</p><h2 id="0x09-页交换进程与页面交换"><a href="#0x09-页交换进程与页面交换" class="headerlink" title="0x09 页交换进程与页面交换"></a>0x09 页交换进程与页面交换</h2><p>当物理页面不够时，Linux 存储管理系统必须释放部分物理页面，将它们的内容写到交换空间。实现这个功能的就是内核态交换程序 <code>kswwapd</code>。</p><p><code>kswapd</code> 属于一种特殊的进程，成为内核态进程。Linux 的内核态进程没有虚拟存储空间进程，它们运行在内核态，直接使用物理地址空间。它不仅能够将页面换出交换空间，而且保证系统中有足够的空闲页面，保证存储系统高效运行。</p><p><code>kswapd</code> 在系统初始启动时由内核态进程 <code>init</code> 创建，其初始化程序段以调用 <code>init_swap_timer()</code> 函数结束，进而转入 <code>while(1)</code> 循环，并马上睡眠。</p><p>内核交换进程依照 3 种方式缩减系统使用的物理页面，</p><ul><li><code>page cache</code>和<code>buffer cache</code></li><li>换出 <code>SYSTEM V</code> 共享内存占用的页面</li><li>换出或丢弃进程占用的页面</li></ul><h2 id="0x0a-缺页中断和页面交换"><a href="#0x0a-缺页中断和页面交换" class="headerlink" title="0x0a 缺页中断和页面交换"></a>0x0a 缺页中断和页面交换</h2><p>磁盘中的可执行文件映像 <code>Image</code> 一旦被映射到一个进程的虚拟空间就可以开始执行。由于只有该映像区的开始部分调入内存，因此，进程迟早会执行到那些尚未调入内存的代码。当一个进程访问了一个还没有有效页表项的虚拟地址时（即页表项的 P 位为 0），处理器将产生缺页中断，通知操作系统，并将出现缺页的虚拟地址（在 CR2 寄存器中）和缺页时访问虚拟内存的模式，并传递给 Linux 的缺页中断服务程序。</p><p>在系统初始化时，设定了缺页中断服务程序为 <code>do_page_fault()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set_ttrap_gate(<span class="number">14</span>, &amp;page_fault);</span><br><span class="line">ENTRY(page_fault)</span><br><span class="line">pushI$SYMBOL_NAME(do_page_fault)</span><br><span class="line">jmp error_code  <span class="comment">/* 异常中断服务程序统一入口 */</span></span><br></pre></td></tr></table></figure><p>根据控制寄存器 <code>CR2</code> 传递的缺页地址，Linux 必须找到用来表示缺页的虚拟存储区的 <code>vm_area_struct</code> 结构。在搜索进程的 <code>vm_area_struct</code> 结构时，对搜索时间应有严格的限制。为了有效地处理搜索工作，Linux 将所有的 <code>vm_area_struct</code> 结构通过 AVL 平衡树连接起来。如果没用找到与缺页相对应的 <code>vm_area_struct</code> 结构，那么说明进程访问了一个非法存储器，Linux 向进程发送信号 <code>GIGSEGV</code> ，如果进程没用处理该信号的函数，该进程将被终止。</p><p>Linux 接着检测缺页时访问模式是否合法。如果进程对该页的访问超越权限，例如试图对只允许读操作的页面进行写操作，系统也将向该进程发送一个信号，通知进程的存储访问出错。经过以上两步检查，可以确定肯定是正常的缺页中断。</p><p>Linux 还区分产生缺页中断的页面是在交换空间，还是在磁盘中作为某一可执行文件映像的一部分，进而做出不同的处理，这一点通过页表项中的位来区分。如果该页面所对应的页表项是无效的（<code>p=0</code>），但是非空，说明缺页在交换空间中。否则，页面是某一个可执行文件映像（<code>image</code>）的一部分。</p><p>并不是所有的 <code>vm_area_struct</code> 结构变量都有完整的一套虚拟存储操作，有些甚至没有 <code>nopage</code> 操作函数指针。在这种情况下，Linux 将使用缺省的操作函数为该虚拟页面找到物理页帧，同时为其设置一页表项。如果 <code>vm_area_struct</code> 结构变量中有 <code>nopage</code> 操作函数，Linux 使用该操作函数。</p><p>Linux 的 <code>nopage</code> 函数通常用来调入已被存储映射的可执行磁盘映像，而且它是利用 <code>page cache</code> 来将所需映像页调入内存的。</p><h2 id="0x0b-存储管理系统的缓冲机制"><a href="#0x0b-存储管理系统的缓冲机制" class="headerlink" title="0x0b 存储管理系统的缓冲机制"></a>0x0b 存储管理系统的缓冲机制</h2><p>存储管理系统的缓冲机制主要包括 <code>kmalloc cache</code>、<code>swap cache</code> 和 <code>page cache Kmalloc cache</code> 在 “内核态内存的申请与释放”已做了介绍，本节介绍另外两种 <code>cache</code></p><ol><li><code>Swap cache</code> 如果以前被调出到交换空间的页面由于进程再次访问而调入物理内存，只要该页调入后没有被修改过，那么它的内容与交换空间中的内容是一样的。在这种情况下，交换空间中的备份还是有效的。因此在该页再度换出时，就没必要执行写操作。Linux 采用 <code>swap_cache</code> 表描述的 <code>swap cache</code> 来实现这种思想。<code>swap cache</code> 实质上是关于页表项的一个列表，<code>swap_cache</code> 表位于 <code>mem_map</code> 表之前。</li></ol><p>每一物理页面都在 <code>swap cache</code> 中占有一表项，<code>swap_cache</code> 表项的总数就是物理页面总数，若该物理页面的内容是新创建的，或虽然曾经换出过，但换出后，该物理页面已经被修改时，则该表项清零。内容非零的表现，正好是某个进程的页表项，描述了页面在交换空间中的位置。</p><p>当 Linux 将一物理页面调出到交换空间时，它先查询 <code>swap cache</code> ，如果其中有与该页面对应的有效页表项，那就不需要将该页写出，因为原交换空间中的内容与待换出的页面内容是一致的。</p><ol><li><code>Page Cache</code> Linux 的 <code>page cache</code> 的作用是加快对磁盘的访问速度，文件被映射到内存中，每次读取一页，而这些页就保存于 <code>page cache</code> 中。</li></ol><p>每当需要读取文件的一页时，总是首先通过 <code>page cache</code> 读取。如果所需页面在 <code>page cache</code> 中，就返回指向表示该页面的 <code>mem-map-1</code>的指针。否则必须从文件系统中调入。接着，Linux 申请一物理页，将该页从磁盘文件中调入内存。</p><p>如果有可能的话，Linux 还发出读取当前页面后一个页面的读操作请求。这种预读一页的思想来自局部原理，即在进程读当前页时，它的后一页也可能被进程用到。</p><p>随着越来越多的文件页面被读取、执行，<code>page cache</code> 将会变得越来越大。进程不再需要的页面应从 <code>page cache</code> 中删除。当 Linux 在使用内存过程中发现屋里页面渐变稀少时，将缩减 <code>page cache</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：主要讲述 Linux 操作系统中的内存管理方式及存储器管理的基本概念及原理，从中说明 Linux 操作系统对内存的管理模式以及在 Linux 操作系统中运行的进程的内存管理情况和内存读取、调用的最底层实现方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lin</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>b-Linux 系统文件管理</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/b-Linux%20%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/b-Linux%20%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2023-12-26T16:00:00.000Z</published>
    <updated>2023-12-27T07:15:32.883Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：从逻辑结构上看，Linux 系统中的文件是没有结构的流式文件。从物理结构上看，Linux 采用混合多重索引结构，即将文件所占用磁盘的盘块号直接或间接存放在该文件索引节点的地址项中。在查找文件时只要找到该文件的索引节点就可以用直接或间接的寻址方式获得指定文件的盘块号。</p><ul><li>Linux 文件的物理结构</li><li>Linux 文件系统</li><li>Linux 文件目录管理命令</li><li>Linux 操作系统下的软链接和硬链接</li></ul></blockquote><h2 id="0x01-Linux文件的屋里结构"><a href="#0x01-Linux文件的屋里结构" class="headerlink" title="0x01 Linux文件的屋里结构"></a>0x01 Linux文件的屋里结构</h2><p>在 Linux 中根据文件的大小，形成小型、中型、大型和巨型等不同规模的文件，如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/b-Linux%20%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/1.png" class="" title="图片描述"><h2 id="0x02-寻址方式"><a href="#0x02-寻址方式" class="headerlink" title="0x02 寻址方式"></a>0x02 寻址方式</h2><ol><li>直接寻址方式</li></ol><p>Linux 系统为了提高对文件的检索速度，采用直接寻址方式。在索引节点中建立 12 个地址项，用来直接存放该文件所在的盘块号，对应的盘块称为直接块。</p><ol><li>一次间接寻址方式</li></ol><p>当文件较大时，Linux 系统提供了一次间接寻址方式。在这种寻址方式中，一次间接地址项中所对应的盘块（间接块）存放的不是文件所在的物理盘块号，而是直接块的块号表。为了通过间接块读取文件数据，需要先读取间接块找到对应的直接块项，然后从直接块中读取数据。</p><ol><li>多次间接寻址方式</li></ol><p>对于大型或巨型的文件，Linux 系统又引入了二次间接寻址和三次间接寻址。二次间接项中存放的是一次间接块号表，三次间接项对应的盘块中放有二次间接块号表。</p><h2 id="0x03-地址转换"><a href="#0x03-地址转换" class="headerlink" title="0x03 地址转换"></a>0x03 地址转换</h2><p>Linux 系统利用地址转换过程将逻辑文件中的字节偏移量转换成文件的物理块号。首先，将字节偏移量转换成文件逻辑块号及块内偏移量，然后将逻辑块号转换成物理块号。</p><ol><li>直接地址</li></ol><p>当文件逻辑盘块号小于 12 时，将逻辑块号转换成物理块号的方法是将文件逻辑块号转换为索引节点的地址项下标，然后从该地址项中就可以直接获得该文件的物理盘块号。</p><ol><li>间接地址</li></ol><p>当计算出的文件逻辑块号大于或等于 12 而小于 268 时，采用一次间接地址方式。将逻辑块号转换为物理块号的方法是从一次间接项中得到一级间接的盘块号，根据该间接块的内容计算一次间接块中的地址下标，即将文件的逻辑块号减去 12 ，从相应下标的地址项中得到物理块号。</p><h2 id="0x04-Linux文件系统"><a href="#0x04-Linux文件系统" class="headerlink" title="0x04 Linux文件系统"></a>0x04 Linux文件系统</h2><p>和普通 Unix 系统意义，Linux 使用树状的文件系统。每个系统都有一个根目录，从这里开始可以遍历整个系统中的所有文件，Linux 文件系统中没有类似 Windows 系统中的驱动器和盘符的概念。</p><h2 id="0x05-Linux文件类型"><a href="#0x05-Linux文件类型" class="headerlink" title="0x05 Linux文件类型"></a>0x05 Linux文件类型</h2><p>Linux 系统下的文件类型主要有：</p><ul><li>普通文件：C 语言元代码、SHELL 脚本、二进制的可执行文件等。分为纯文本和二进制。</li><li>目录文件：目录，存储文件的唯一地方。</li><li>链接文件：指向同一个文件或目录的的文件。</li><li>特殊文件：与系统外设相关的，通常在&#x2F;dev 下面。分为块设备和字符设备。</li></ul><p>在 Linux 系统下可以在终端使用 <code>ls –l</code>、<code>file</code>、<code>stat</code> 几个命令来查看文件的类型等相关信息。如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/b-Linux%20%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2.png" class="" title="图片描述"><h2 id="0x06-Linux-文件存储结构"><a href="#0x06-Linux-文件存储结构" class="headerlink" title="0x06 Linux 文件存储结构"></a>0x06 Linux 文件存储结构</h2><p>Linux 正统的文件系统(如 <code>ext2</code>、<code>ext3</code>)一个文件由目录项、inode 和数据块组成。</p><ul><li>目录项：包括文件名和 inode 节点号。</li><li><code>inode</code>：又称文件索引节点，是文件基本信息的存放地和数据块指针存放地。</li><li>数据块：文件的具体内容存放地。</li></ul><p>Linux 正统的文件系统(如 <code>ext2</code>、<code>ext3</code> 等)将硬盘分区时会划分出目录块、<code>inode Table</code> 区块和 <code>data block</code> 数据区域。一个文件由一个目录项、<code>inode</code> 和数据区域块组成。<code>Inode</code> 包含文件的属性(如读写属性、<code>owner</code>等，以及指向数据块的指针)，数据区域块则是文件内容。当查看某个文件时，会先从 <code>inode table</code> 中查出文件属性及数据存放点，再从数据块中读取数据。</p><p>如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/b-Linux%20%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/3.png" class="" title="图片描述"><p>其中目录项的结构如下(每个文件的目录项存储在改文件所属目录的文件内容里)，如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/b-Linux%20%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/4.png" class="" title="图片描述"><p>其中文件的 inode 结构如下（inode 里所包含的文件信息可以通过 <code>stat filename</code> 查看得到）：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/b-Linux%20%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/5.png" class="" title="图片描述"><p>以上只反映大体的结构，linux 文件系统本身在不断发展。但是以上概念基本是不变的。且如 <code>ext2</code>、<code>ext3</code>、<code>ext4</code> 文件系统也存在很大差别，如果要了解可以查看专门的文件系统介绍。</p><h2 id="0x07-软连接、硬链接"><a href="#0x07-软连接、硬链接" class="headerlink" title="0x07 软连接、硬链接"></a>0x07 软连接、硬链接</h2><p>软链接和硬链接是我们常见的两种概念：</p><ul><li>硬链接：是给文件一个副本，同时建立两者之间的链接关系。修改其中一个，与其链接的文件同时被修改。如果删除其中 [color&#x3D;red] 任意一个 [&#x2F;color] 其余的文件将不受影响。</li><li>软链接:也叫符号链接,他只是对源文件在新的位置建立一个“快捷方式（借用一下 <code>wondows</code> 常用词）”，所以，当源文件删除时，符号链接的文件将成为无源之水-&gt;仅仅剩下个文件名了，当然删除这个链接，也不会影响到源文件，但对链接文件的使用、引用都是直接调用源文件的。</li></ul><p>具体关系可以看下图：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/b-Linux%20%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/8.png" class="" title="图片描述"><p>从图上可以看出硬链接和软链接的区别：</p><ul><li>硬链接原文件和新文件的 <code>inode</code> 编号一致。而软链接不一样。</li><li>对原文件删除，会导致软链接不可用，而硬链接不受影响。</li><li>对原文件的修改，软、硬链接文件内容也一样的修改，因为都是指向同一个文件内容的。</li></ul><h2 id="0x08-Linux文件目录管理"><a href="#0x08-Linux文件目录管理" class="headerlink" title="0x08 Linux文件目录管理"></a>0x08 Linux文件目录管理</h2><p>磁盘和文件空间使用命令：</p><ul><li><code>dd</code>：把指定的输入文件复制到指定的输出文件中，并且在复制过程中进行格式转换。</li><li><code>fdisk</code>：创建和维护分区表的程序，它兼容 DOS 类型的分区表、BSD 或者 SUN 类型的磁盘列表。</li><li><code>df</code>：可以显示所有文件系统对 i 节点和磁盘块的使用情况</li><li><code>du</code>：该命令逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块( 1024 字节)的情况。</li></ul><p>文件目录与管理使用命令：</p><ul><li><code>cd</code>：改变当前工作目录</li><li><code>pwd</code>：显示当前工作目录的全路径名</li><li><code>mkdir</code>：创建目录</li><li><code>rmdir</code>：删除目录</li><li><code>ls</code>：用于显示目录内容，类似 <code>DOS</code> 下的 <code>dir</code> 命令，它的使用权限是所有用户</li><li><code>cp</code>：带目录复制</li><li><code>rm</code>：删除文件或目录</li><li><code>mv</code>：目录更名或搬移</li></ul><p>查看文件内容命令：</p><ul><li><code>cat</code>: <code>cat [file]</code> 查看文件的内容。全称是 concatenate 的意思，将文件内容连续输出到屏幕上。第一行到最后一行显示。</li><li><code>tac</code>: <code>tac [file]</code> 和 <code>cat</code> 刚好相反 是从最后一行到第一行的方式查看。</li></ul><p><code>cat</code> 有个比较不好的地方时当文件比较大时候没办法看清楚，这个时候可以用 <code>more</code> 或者 <code>Less</code> 命令。</p><ul><li><code>more</code>: <code>more [file]</code> 如果使用 <code>grep</code> 或者 <code>find</code> 等命令时，可以配合使用 <code>more</code> 一页一页的查看。如果看到一半想退出，则敲入’q’即可退出。</li><li><code>less</code>: <code>less [file]</code> <code>less</code>比 <code>more</code> 更有弹性，可以上下翻页。</li></ul><p>如果只想读取文件的头几行或者文件的末尾几行，可以用 <code>head</code> 或 <code>tail</code>.</p><ul><li><code>head –n [file]</code>：读取文件的前 n 行。</li><li><code>tail –n [file]</code>：读取文件末尾 n 行。</li></ul><p>以上命令都是用于查看字符文件，二进制文件出来的都是乱码，要看二进制文件的内容，可以用 <code>od</code> 命令,如查看一个 MP3 文件里面的内容: <code>od shijiemori.mp3</code></p><p>文件目录与权限命令：</p><ul><li><code>chmod</code>：修改文件或目录的存取权限</li><li><code>chown</code>：改变文件拥有者</li><li><code>chgrp</code>：改变文件的所属组</li><li><code>umask</code>：用来设定[权限掩码]。[权限掩码]是由 3 个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。</li></ul><p>文件查找命令：</p><ul><li><code>which</code>: <code>which [filename]</code> 该命令用于查询通过 PATH 路径到该路径内查找可执行文件。如：Which passwd:查找可执行文件 passwd</li><li><code>whereis</code>: <code>whereis [-bmsu] [keyword]</code> 该命令用于把相关字的文件和目录都列出来。(Linux 会将文件都记录在一个文件数据库里面，该命令式从数据库去查询，所以速度比较快,Linux 每天会更新该数据库)</li><li><code>locate</code>: <code>locate [filename]</code> 该命令用于把相关字的文件和目录都列出来。查找数据特别快，也是通过数据库方式来查询。但是数据库一周更新一次，所以可能有些存在数据查不到。可以去修改配置文件。</li><li><code>find</code>: <code>find [path] [参数] [keyword]</code> 该命令用于在指定路径下查找文件。不是通过数据来查询，所以速度会比较慢。</li></ul><h2 id="0x09-Linux文件系统常见目录描述"><a href="#0x09-Linux文件系统常见目录描述" class="headerlink" title="0x09 Linux文件系统常见目录描述"></a>0x09 Linux文件系统常见目录描述</h2><p>Linux 各种发行版的目录结构基本一致，各个目录简单介绍如下：</p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>&#x2F;</td><td>根目录</td></tr><tr><td>&#x2F;bin</td><td>做为基础系统所需要的最基础的命令就是放在这里。比如 ls、cp、mkdir 等命令；功能和&#x2F;usr&#x2F;bin 类似，这个目录中的文件都是可执行的，普通用户都可以使用的命令。</td></tr><tr><td>&#x2F;boot</td><td>Linux 的内核及引导系统程序所需要的文件，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB 或 LILO 系统引导管理器也位于这个目录；启动装载文件存放位置，如 kernels,initrd,grub。一般是一个独立的分区。</td></tr><tr><td>&#x2F;dev</td><td>一些必要的设备,声卡、磁盘等。还有如 &#x2F;dev&#x2F;null. &#x2F;dev&#x2F;console &#x2F;dev&#x2F;zero &#x2F;dev&#x2F;full 等。</td></tr><tr><td>&#x2F;etc</td><td>系统的配置文件存放地. 一些服务器的配置文件也在这里；比如用户帐号及密码配置文件；&#x2F;etc&#x2F;opt:&#x2F;opt 对应的配置文件；&#x2F;etc&#x2F;X11:Xwindows 系统配置文件；&#x2F;etc&#x2F;xml:XML 配置文件；……</td></tr><tr><td>&#x2F;home</td><td>用户工作目录，和个人配置文件，如个人环境变量等，所有的账号分配一个工作目录。一般是一个独立的分区。</td></tr><tr><td>&#x2F;lib</td><td>库文件存放地。bin 和 sbin 需要的库文件。类似 windows 的 DLL。</td></tr><tr><td>&#x2F;media</td><td>可拆卸的媒介挂载点，如 CD-ROMs、移动硬盘、U 盘，系统默认会挂载到这里来。</td></tr><tr><td>&#x2F;mnt</td><td>临时挂载文件系统。这个目录一般是用于存放挂载储存设备的挂载目录的，比如有 cdrom 等目录。可以参看 &#x2F;etc&#x2F;fstab 的定义。</td></tr><tr><td>&#x2F;opt</td><td>可选的应用程序包。</td></tr><tr><td>&#x2F;proc</td><td>操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如 cpu、硬盘分区、内存信息等）存放在这里。&#x2F;proc 目录伪装的文件系统 proc 的挂载目录，proc 并不是真正的文件系统，它的定义可以参见 &#x2F;etc&#x2F;fstab 。</td></tr><tr><td>&#x2F;root</td><td>Root 用户的工作目录</td></tr><tr><td>&#x2F;sbin</td><td>和 bin 类似，是一些可执行文件，不过不是所有用户都需要的，一般是系统管理所需要使用得到的。</td></tr><tr><td>&#x2F;tmp</td><td>系统的临时文件，一般系统重启不会被保存。</td></tr><tr><td>&#x2F;usr</td><td>包含了系统用户工具和程序。&#x2F;usr&#x2F;bin：非必须的普通用户可执行命令；&#x2F;usr&#x2F;include：标准头文件； &#x2F;usr&#x2F;lib:&#x2F;usr&#x2F;bin&#x2F; 和 &#x2F;usr&#x2F;sbin&#x2F;的库文件； &#x2F;usr&#x2F;sbin:非必须的可执行文件；&#x2F;usr&#x2F;src:内核源码；&#x2F;usr&#x2F;X11R6:X Window System, Version 11, Release 6.</td></tr><tr><td>&#x2F;srv</td><td>该目录存放一些服务启动之后需要提取的数据</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：从逻辑结构上看，Linux 系统中的文件是没有结构的流式文件。从物理结构上看，Linux 采用混合多重索引结构，即将文件所占用磁盘的盘块号直接或间接存放在该文件索引节点的地址项中。在查找文件时只要找到该文件的索引节点就可以用直接或间接的寻址方</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>d-Linux 网络基础.md</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/d-Linux%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/d-Linux%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2023-12-26T16:00:00.000Z</published>
    <updated>2023-12-27T08:25:23.664Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：Linux 操作系统实际上是一个网络操作系统，系统管理的很大部分工作其实都和网络有关。</p><ul><li>TCP&#x2F;IP 协议</li><li>Linux 网络配置</li><li>基本网络服务</li><li>网络安全</li><li>Linux 下网络通信基本流程和操作</li></ul></blockquote><h2 id="0x01-TCP-x2F-IP-协议"><a href="#0x01-TCP-x2F-IP-协议" class="headerlink" title="0x01 TCP&#x2F;IP 协议"></a>0x01 TCP&#x2F;IP 协议</h2><p>在信息化设备中，及刷机已经从单一使用发展到了集群使用。越来越多的应用领域需要计算机在一定的地理范围内联合起来进行集群工作，从而促进了计算机和通信技术的紧密结合，形成了计算机网络。</p><p>在计算机网络中，为了实现计算机之间的相互通信，有许多不同的通信规程和约定，这些规程和约定就是计算机网络协议。这就要求不同的计算机厂商在开发和研制自己的网络系统时需要遵循一个统一的约定。网络标准化组织在 1981 年颁布了开放系统互联参考模型，即 ISO&#x2F;OSI 模型，如下图所示，现在大部分网络协议都是参考这标准设计的。</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/d-Linux%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1.png" class="" title="图片描述"><p>TCP&#x2F;IP 于 20 世纪 70 年代开始研究和开发，现在也广泛用于各种网络中，不论是局域网还是广域网都可以用 TCP&#x2F;IP 协议来构造网络环境。同时 TCP&#x2F;IP 协议也是 Unix、Linux 等操作系统中最重要的网络协议。以 TCP&#x2F;IP 为核心协议的 Internet 更加促进了 TCP&#x2F;IP 的应用和发展。</p><p>从体系结构上来看， TCP&#x2F;IP 协议是 OSI 参考模型七层结构的简化，它只有应用层、传输层、网际层和网络接口层。其中：</p><ul><li>TCP&#x2F;IP 网络接口层对应于 OSI 参考模型的物理层和数据链路层；</li><li>TCP&#x2F;IP 网际层对应于 OSI 参考模型的网络层；</li><li>TCP&#x2F;IP 传输层包含 TCP、UDP 两个协议，对应于 OSI 参考模型的传输层；</li><li>TCP&#x2F;IP 应用层包含了 OSI 参考模型的会话层、表示层、应用层；</li></ul><p>TCP&#x2F;IP 协议是由一组通信协议组成的协议簇，其核心部分包括传输层协议（TCP 和 UDP）、网络层协议（IP）和网络接口层，这三层部分的协议内容都在操作系统内核中实现。而应用层协议，如 FTP、HTTP 等协议都是通过网络编程接口与核心协议打交道，整个协议簇是一种分层结构，下层为上层服务，不同层次之间通过一些接口通信。</p><ol><li>以太网</li></ol><p>1980 年 9 月由美国 Xerox、Intel、DEC 公司合作第一次公布了 Ethernet 的物理层和数据链路层的技术规范，成为世界上第一个局域网工业标准。IEEE 802.3 国际标准是在 Ethernet 标准的基础上制定的。</p><p>以太网工作起来就像一个总线系统，每一台机器都通过一个分接器挂在一根很长的电缆上。为了让机器识别到自己生，每块以太网卡都有一个由制造商唯一分配的地址 <code>MAC</code> 地址。当一块以太网卡想要同另一块以太网卡对话时，它将向整个以太网电缆发送信息，其中包括自己的 <code>MAC</code> 地址和接收者的 <code>MAC</code> 地址。两块以太网卡试图在同一时间发送数据时，便会产生冲突。解决这种冲突的办法就是两台计算机取消这次发送各自等待一段随机时间再发送数据的尝试。</p><p>允许 Linux 和 TCP&#x2F;IP 在以太网地址和 IP 地址间进行连接的是地址解析协议（<code>ARP</code>）缓存。当一台 Linux 机器开始在以太网上发消息时，它会通过 <code>ARP</code> 询问子网上其他机器的 <code>MAC</code> 地址。</p><ol><li>IP 协议</li></ol><p>IP 协议位于 TCP&#x2F;IP 协议簇的第三层，是 TCP&#x2F;IP 协议的传输系统，也是整个 TCP&#x2F;IP 协议簇的核心。 IP 协议负责数据报在计算机之间的寻址，决定数据传送到哪里以及出现网络故障时如何更换路由。IP 不保证传送的可靠性，在主机资源不足的情况下，它可能丢弃某些数据包，同时 IP 也不会检查数据链路层丢弃的报文。</p><p>1）IP 地址。TCP&#x2F;IP 网络要进行通信，每一台主机都要预先分配一个唯一的 32 位地址作为该主机的标识符，这个主机必须使用该地址进行所有通信活动，这个地址也称为 IP 地址。IP 地址通常由网络标识 ID 和主机标识两部分组成，可以标识互联网络中任何一个网络中的任何主机。网络标识也称为网络地址，用于辨别子网，同一子网上的所有 TCP&#x2F;IP 主机的网络 ID 都相同。主机标识也称为主机地址，用于辨别每一个网络中的主机。IP 地址格式如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/d-Linux%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/2.png" class="" title="图片描述"><p>其中，网络 ID 是大于 1 位的二进制数，主机 ID 也是大于 1 位的二进制数。如计算中心网关地址 132.111.002.001 分解成协议所认识的地址就是：网络 ID（132.111）和主机 ID（002.001）</p><p>IP 地址分类如下：</p><ul><li>A 类地址：网络类别字段占 1 位，即第 0 位为 <code>0</code>，表示是 A 类地址，第 1<del>7 位表示网络地址，第 8</del>31 位表示主机地址。它所表示的范围为 0.0.0.0~127.255.255.255，即能够表示 126 个网络地址，16387064 个主机地址。A 类地址通常用于超大型网络场合。</li><li>B 类地址：网络类别字段占 2 位，即第 0、1 位为 <code>1 0</code> ，表示 B 类地址，第 2<del>15 位表示网络地址，第 16</del>31 位表示主机地址，它所能表示的范围为 128.0.0.0~191.255.255.255，即能够表示 16256 个网络地址，64576 个主机地址。B 类地址通常用于大型网络的场合。</li><li>C 类地址：网络类别字段占 3 位，即第 0、1、2 位为 <code>110</code> ，表示 C 类地址，第 3<del>23 位表示网络地址，第 24</del>31 位表示主机地址。它所能表示的范围 192.0.0.0~192.233.255.255，即能够表示 2064512 个网络地址，254 个主机地址。C 类地址通常用于校园网或企业网。</li><li>此外，还有 D 类和 E 类 IP 地址。 D 类地址用于多址广播地址，供特殊协议向选定的节点发送信息用。E 类地址暂时保留。</li></ul><p>2）子网掩码。通常将一个较大网络分为多个较小的网络，每个小网络使用不同的网络 ID ，这样的小网络称为子网。</p><p>在网络通信时，若想要找到子网，需要定义子网掩码。子网掩码与 IP 地址一样也是一个 32 位的值，将它与主机的 IP 地址做按位 “与” 运算，可以屏蔽一部分 IP 地址，从而确定出这个网络地址。子网掩码可概括两个功能：用于区分网络地址和主机地址；用于将网络分割为多个子网。</p><ol><li>TCP 协议</li></ol><p>TCP 协议是一种面向连接的、可靠的传输层协议。面向连接是指一次正常的 TCP 传输需要通过在 TCP 客户端和 TCP 服务端之间建立特定的虚电路连接来完成，这个过程通常称为“三次握手”，可靠的传输协议可避免数据传输错误。TCP 协议可以支持许多高层协议，它对高层协议的数据结构没有任何要求，对于 TCP 来说只是将这些传输的数据结构作为一种连续的数据流。</p><ol><li>UDP 协议</li></ol><p>UDP 协议也是常用的传输层协议，提供非面向连接的、不可靠的数据流传输服务。这种服务不确定报文是否到达，不对报文排序，也不进行流量控制，因此 UDP 报文可能出现丢失、重复和失序等现象。与 TCP 相同的特点，UDP 协议也可以通过端口号支持多路复用功能。UDP 是一种简单的协议机制，通信开销小，效率高，适合对于可靠性要求不高当需要快捷、低延迟通信的应用场合。</p><h2 id="0x02-配置Linux网络"><a href="#0x02-配置Linux网络" class="headerlink" title="0x02 配置Linux网络"></a>0x02 配置Linux网络</h2><p>在 Linux 系统中，TCP&#x2F;IP 网络是通过若干文本文件进行配置的，通过了解和修改这些配置文件就能够完成 Linux 联网功能。下面将逐个介绍 Linux 网络配置相关的文件。</p><ol><li>&#x2F;etc&#x2F;HOSTNAME 文件</li></ol><p>该文件包含系统的主机名称和完全的域名，如：<code>linux.cic.tsinghua.edu.cn</code>（Linux 为主机名，cic.tsinghua.edu.cn 为域名）</p><ol><li>&#x2F;etc&#x2F;host.conf 文件</li></ol><p>该文件指定如何解析主机名。Linux 通过解析器库获得主机名对应的 IP 地址，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">order <span class="built_in">bind</span>,hosts    <span class="comment"># 指定主机名查询顺序，这里优先使用 DNS 解析域名，然后查询 /etc/hosts 文件</span></span><br><span class="line">multi on    <span class="comment"># 表示 /etc/hosts 文件中指定的主机可以有多个地址</span></span><br><span class="line">nospoof on  <span class="comment"># 指不允许对该服务器进行 IP 欺骗</span></span><br></pre></td></tr></table></figure><ol><li>&#x2F;etc&#x2F;services 文件</li></ol><p>&#x2F;etc&#x2F;services 文件中包含了服务名和端口号之间的映射，不少系统程序要使用这个文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tcpmux 1/tcp    <span class="comment">#TCP port service multiplexer</span></span><br><span class="line"><span class="built_in">echo</span> 7/tcp</span><br><span class="line"><span class="built_in">echo</span> 7/udp</span><br><span class="line">discard 9/tcp sink null</span><br><span class="line">discard 9/udp sink null</span><br><span class="line">systatll/tcp <span class="built_in">users</span></span><br></pre></td></tr></table></figure><ol><li>&#x2F;etc&#x2F;sysconfig&#x2F;network 文件</li></ol><p>该文件用来指定服务器上的网络配置信息，包含控制与网络有关的文件和守护程序行为的参数，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=<span class="built_in">yes</span>      <span class="comment">#网络是否被配置</span></span><br><span class="line">HOSTNAME=machine1</span><br><span class="line">DOMAINNAME=cic.tsinghua.edu.cn  <span class="comment"># 分配给机器的域名</span></span><br><span class="line">GATEWAY=210.34.6.2  <span class="comment">#网关的 IP 地址</span></span><br><span class="line">FORWARD_IPV4=<span class="built_in">yes</span>    <span class="comment">#是否开启 IP 转发功能</span></span><br><span class="line">GATEWAYDEV=eth0     <span class="comment">#gw-dev表示网关的设备名</span></span><br></pre></td></tr></table></figure><ol><li>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ethN 文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=<span class="string">&quot;eth0&quot;</span></span><br><span class="line">IPADDR=<span class="string">&quot;192.168.2.1&quot;</span></span><br><span class="line">NETMASK=<span class="string">&quot;255.255.255.9&quot;</span></span><br><span class="line">NETWORK=<span class="string">&quot;192.168.2.0&quot;</span></span><br><span class="line">BROADCAST=<span class="string">&quot;192.168.2.255&quot;</span></span><br><span class="line">ONBOOT=<span class="string">&quot;yes&quot;</span></span><br><span class="line">BOOTPROTO=<span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure><ol><li>&#x2F;etc&#x2F;hosts 文件</li></ol><p>&#x2F;etc&#x2F;hosts 文件包含了 IP 地址和主机名之间的映射，还包括主机名的别名。IP 地址的设计使计算机容易识别，但却很难记住它们，为了解决这个问题，创建了 &#x2F;etc&#x2F;hosts 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 machanel localhost.localdomain localhost</span><br><span class="line">192.168.1.100 machine7</span><br><span class="line">192.168.1.101 otherpc otheralias</span><br></pre></td></tr></table></figure><ol><li>&#x2F;etc&#x2F;resolv.conf 文件</li></ol><p>该文件是由 DNS 客户端解析器（resolver 一个根据主机名解析 IP 地址的库）使用的配置文件，它包含主机的域名搜索顺序和 DNS 服务器的地址。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search cic.tsinghua.edu.cn</span><br><span class="line">nameserver 166.111.4.5</span><br><span class="line">nameserver 166.111.8.28</span><br></pre></td></tr></table></figure><ol><li>&#x2F;etc&#x2F;init.d&#x2F;network 主机地址、子网掩码和网关</li></ol><p>这个文件声明了 IP 地址、掩码、网络、广播地址和默认路由器的变量。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IPADDR=192.168.1.100</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">NETWORK=192.168.1.0</span><br><span class="line">BROADCAST=192.168.1.255</span><br><span class="line">GATEWAY=192.168.1.1</span><br></pre></td></tr></table></figure><h2 id="0x03-域名服务器DNS"><a href="#0x03-域名服务器DNS" class="headerlink" title="0x03 域名服务器DNS"></a>0x03 域名服务器DNS</h2><p>连接 TCP&#x2F;IP 的每个网络接口用一个唯一的 32 位的 IP 地址标识，但由于数字比较复杂，难以记忆，而且没有形象性，因而发明了域名系统，在这种情况下，可以使用易于理解和较为形象的名称作为一台计算机的标识。大多数情况下，数字地址和域名地址可以交替使用，但无论用数字地址或是域名进行网络应用时，总是以 IP 地址为基础进行的。在网络进行连接前，系统必须将域名地址转换成 IP 地址，这就是 DNS 的任务。</p><p>大多数 DNS 服务器都使用 Bind。DNS 提供了从名字到 IP 地址的映射关系，这种映射关系不必是一一映射，一个 IP 可以有多个域名，一个域名也可以对应多个 IP。</p><h2 id="0x04-Apache-服务器"><a href="#0x04-Apache-服务器" class="headerlink" title="0x04 Apache 服务器"></a>0x04 Apache 服务器</h2><p>Web 服务器是互联网上人马使用最多的一种服务器，它已经成了当今社会不可缺少的一种信息传播方式。目前市场上最流行的运行于 Linux 上的 Web 服务器是 Apache 服务器。</p><p>纵观 Apache，它为网络管理员提供了丰富多彩的功能，包括目录索引、目录别名、内容协商、可配置的 HTTP 错误报告、CGI 程序的 SetUID 执行、子进程资源管理、服务器端图像映射、重写 URL、URL 拼写检查以及联机手册 man 等。</p><h2 id="0x05-邮件服务器"><a href="#0x05-邮件服务器" class="headerlink" title="0x05 邮件服务器"></a>0x05 邮件服务器</h2><p>自从加州大学伯克利分校 U.C Berkeley 完成 sendmail 的最初版本以来，<code>sendmail</code> 受到了业界长久的重视，从 1983 年的 V5 版本一直到 1993 年改写的 V8 版本，都受到了人们的尊重。</p><p>sendmail 为 Linux 提供 SMTP 连接所需的服务，它对邮件信息进行分析并把它传送到目的地。sendmail 采用开放源代码的开发方式编写，其所需源码都可以免费得到并自由发布。它只提供了邮件路由功能，将发送留给管理员可以选择的本地代理。</p><h2 id="0x06-samba-服务器"><a href="#0x06-samba-服务器" class="headerlink" title="0x06 samba 服务器"></a>0x06 samba 服务器</h2><p>可以把 <code>samba</code> 当成是一个局域网络上的 file&#x2F;printer sever，它可以提供文件系统、打印机或其他信息，并与 <code>samba sever</code> 在同一个子网域的 <code>samba client</code> 共享。</p><p><code>samba</code> 是用来实现 SMB 的一种软件，它的工作原理是让 NETBIOS 和 SMB 这两个协议运行于 TCP&#x2F;IP 通信协议之上，并使用 NETBEUI 协议让 Linux 计算机可以在网络上被其他计算机看到。所以，通过 samba 能够使得 不同系统的计算机可以在网络上进行沟通和共享文件。</p><h2 id="0x07-Linux系统的文件安全"><a href="#0x07-Linux系统的文件安全" class="headerlink" title="0x07 Linux系统的文件安全"></a>0x07 Linux系统的文件安全</h2><p>Linux 文件系统是由文件和目录组成的树形结构，每个文件目录包括文件类型、文件的存取权限、文件名、文件所有者、文件大小、文件建立及修改的日期等内容。任何一项内容遭受未授权的修改，文件的安全性都将遭受到破坏。保护文件系统的安全性应该从以下几个方面入手：</p><ul><li>文件存取权限的设置：文件属性决定了文件的被访问权限。</li><li>设置用户 ID 和同组用户 ID 许可：用户 ID 许可设置和同组用户 ID 许可设置只给予可执行的目标文件。</li></ul><h2 id="0x08-用户口令安全"><a href="#0x08-用户口令安全" class="headerlink" title="0x08 用户口令安全"></a>0x08 用户口令安全</h2><p>每个 Linux 的用户都拥有一个账号，通过登录到这个账号才能有限制地使用系统，而保护自身文件安全的唯一屏障就是口令，一旦这道屏障被破坏，整个系统的安全便无法得到保证。</p><p>Linux 系统中的 <code>/etc/passwd</code> 文件包含了全部系统需要知道的关于每个用户的信息。</p><h2 id="0x09-防火墙技术"><a href="#0x09-防火墙技术" class="headerlink" title="0x09 防火墙技术"></a>0x09 防火墙技术</h2><ol><li>防火墙的概念</li></ol><p>防火墙是一个矛盾统一体，它既要限制信息的流通，又要保持信息的流通。因此，根据网络安全性总体需求，防火墙可以遵循以下两种基本原则之一实现：</p><ul><li>一切未被允许的都是禁止的</li><li>一切未被禁止的都是允许的</li></ul><p>由于以上两种防火墙原则在安全性和可使用性上各有侧重，很多防火墙系统唉两者之间都采用了一定的折中。</p><ol><li>防火墙的分类</li></ol><p>根据不同的防范方式和侧重点，防火墙主要分为分组过滤型和代理服务型。它们在网络性能、安全性和应用透明性等方面各有利弊。</p><p>1）分组过滤型防火墙。分组过滤型防火墙只是根据数据包的内容来判断是否允许数据包的传输。通常在网路层上通过对分组中的 IP 地址、TCP&#x2F;UDP 端口号以及协议状态等字段的检查来决定是否转发一个分组。</p><p>分组过滤型防火墙的基本原理：</p><ul><li>根据网络安全策略，在防火墙中事先设置分组过滤规则</li><li>根据分组过滤规则，对经过防火墙的分组流进行检查</li><li>分组过滤规则一定要按顺序排列。当一个分组到达时，按规则的排列顺序依次运用每个规则对分组进行检查。一旦分组与一个规则相匹配，则不再向下检查其他规则</li><li>如果一个分组与一个拒绝转发的规则相匹配，则该分组将被禁止通过</li><li>如果一个分组与一个允许转发的规则相匹配，则该分组将被允许通过</li><li>如果一个分组不与任何规则相匹配，则该分组将被禁止通过，这是遵循 “一切未被允许的都是禁止的”原则</li></ul><h2 id="0x0a-Linux-常用网络命令介绍"><a href="#0x0a-Linux-常用网络命令介绍" class="headerlink" title="0x0a Linux 常用网络命令介绍"></a>0x0a Linux 常用网络命令介绍</h2><p>计算机网络的主要优点是能够实现资源和信息的共享，并且用户可以远程访问信息，Linux 提供了一组强有力的网络命令来为用户服务，这些工具能够帮助用户登录到远程计算机上，传输文件和执行远程命令等。</p><ol><li><code>ftp</code> 命令</li></ol><p><code>ftp</code> 命令是标准文件传输协议的用户接口。能够运行用户传输 ASCII 文件和二进制文件。</p><ol><li><code>telnet</code> 命令</li></ol><p>用户使用 <code>telnet</code> 命令进行远程登陆。该命令运行用户使用 <code>telnet</code> 协议在远程计算机之间进行通信，用户可以通过网络在远程计算机上登录，就像登录到本地机器上执行命令一样。如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/d-Linux%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/3.png" class="" title="图片描述"><ol><li><code>rlogin</code> 命令</li></ol><p><code>rlogin</code> 是 remote login 的缩写。该命令与 <code>telnet</code> 命令类似，允许用户启动远程系统上的交互命令会话。如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/d-Linux%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/4.png" class="" title="图片描述"><ol><li><code>rsh</code> 命令</li></ol><p><code>rsh</code> 是 remote shell 的缩写。该命令在指定的远程主机上启动了一个 shell ，并执行用户在 <code>rsh</code> 命令行中指定的命令。如果用户没有给出要执行的命令，<code>rsh</code> 就用 <code>rlogin</code> 命令使用户登录到远程机上。</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/d-Linux%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/5.png" class="" title="图片描述"><ol><li><code>rcp</code> 命令</li></ol><p><code>rcp</code> 其实就通常使用的 <code>scp</code> 命令，是 remote file copy 的缩写。该命令用于在计算机之间复制文件。</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/d-Linux%20%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/6.png" class="" title="图片描述"><h2 id="0x0b-Linux-下-TCP-通信实例"><a href="#0x0b-Linux-下-TCP-通信实例" class="headerlink" title="0x0b Linux 下 TCP 通信实例"></a>0x0b Linux 下 TCP 通信实例</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//出错调用函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handle</span><span class="params">(std::string opt, std::string message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据errno值获取失败原因并打印到终端</span></span><br><span class="line">    <span class="built_in">perror</span>(opt.<span class="built_in">c_str</span>());</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock;</span><br><span class="line">    <span class="type">int</span> client_sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">socklen_t</span> client_addr_size;</span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断参数数量，Usage: &lt;port&gt;， 需要在命令行输入服务器接收消息的端口号</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Usage : &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;prot&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建socket 套接字</span></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;socket&quot;</span>, <span class="string">&quot;socket() error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化套接字结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//选择当前任意网卡</span></span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));<span class="comment">//设置接收消息的端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定端口</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;bind&quot;</span>, <span class="string">&quot;bind() error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听端口，设置等待队列数量为5</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;listen&quot;</span>, <span class="string">&quot;listen() error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印输出等待连接</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting Client....&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    client_addr_size = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line">    <span class="comment">//等待接收客户端建立连接</span></span><br><span class="line">    client_sock = <span class="built_in">accept</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;client_sock, &amp;client_addr_size);</span><br><span class="line">    <span class="keyword">if</span>(client_sock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;accept&quot;</span>, <span class="string">&quot;accept() error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//accept() 成功建立连接后，服务器就会得到客户端的 IP 地址和端口号。</span></span><br><span class="line">    <span class="comment">//打印客户端 IP 和端口号</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Client IP : &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(client_addr.sin_addr) &lt;&lt; <span class="string">&quot; , port : &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(client_addr.sin_port) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户端发送 &quot;hello world&quot; 消息，使用write 标准IO接口就可以</span></span><br><span class="line">    <span class="built_in">write</span>(client_sock, message, <span class="built_in">sizeof</span>(message));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭TCP连接</span></span><br><span class="line">    <span class="built_in">close</span>(client_sock);</span><br><span class="line">    <span class="comment">//关闭socket套接字</span></span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//出错调用函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handle</span><span class="params">(std::string opt, std::string message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据errno值获取失败原因并打印到终端</span></span><br><span class="line">    <span class="built_in">perror</span>(opt.<span class="built_in">c_str</span>());</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;<span class="comment">//socket套接字</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;<span class="comment">//服务器套接字结构体</span></span><br><span class="line">    <span class="type">char</span> message[<span class="number">64</span>];<span class="comment">//用于接收服务器消息的缓冲区</span></span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前参数数量，需要命令行参数 &lt;IP&gt; &lt;port&gt;</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Usage : &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;IP&gt; &lt;port&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建socket 套接字</span></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;socket&quot;</span>, <span class="string">&quot;socket() error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化服务器套接字结构体参数，设置对方的IP地址和端口号</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与服务器建立连接</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;connect&quot;</span>, <span class="string">&quot;connect() error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取服务器发送来的消息</span></span><br><span class="line">    str_len = <span class="built_in">read</span>(sock, message, <span class="built_in">sizeof</span>(message) <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str_len &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//read() 读取数据失败</span></span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;read&quot;</span>, <span class="string">&quot;read() error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将读取到的输出打印出来</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Recv Message : &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭socket 套接字</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x0c-Linux-下-UDP-通信实例"><a href="#0x0c-Linux-下-UDP-通信实例" class="headerlink" title="0x0c Linux 下 UDP 通信实例"></a>0x0c Linux 下 UDP 通信实例</h2><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//出错调用函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handle</span><span class="params">(std::string opt, std::string message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据errno值获取失败原因并打印到终端</span></span><br><span class="line">    <span class="built_in">perror</span>(opt.<span class="built_in">c_str</span>());</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">socklen_t</span> client_adr_sz;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, client_adr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为服务器程序使用时通过命令行参数指定接收消息的端口号，</span></span><br><span class="line">    <span class="comment">//所以当参数数量少于需求 2 时，程序结束并报错</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Usage : &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;port&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建socket 套接字，sock 用于后面发送和接收数据</span></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;socket&quot;</span>, <span class="string">&quot;UDP socket creation error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化套接字结构体，初始化服务器套接字结构体中的 IP 地址和端口号</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将socket套接字绑定固定端口进行消息接收</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(serv_sock, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;bind&quot;</span>, <span class="string">&quot;bind() error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UDP 方式不需要进行 listen 和 accept 操作，直接就可以通过 recvfrom 函数去接收套接字中收到的数据。</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//清空接收消息数据的缓存区</span></span><br><span class="line">        <span class="built_in">memset</span>(message, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">        <span class="comment">//计算客户端结构体大小，用于接收客户端数据结构</span></span><br><span class="line">        client_adr_sz = <span class="built_in">sizeof</span>(client_adr);</span><br><span class="line">        <span class="comment">//recvfrom() 调用不仅收到对方发送来的数据，还通过最后两个参数返回了对方的 IP 地址和端口号信息，用于返回数据使用。</span></span><br><span class="line">        str_len = <span class="built_in">recvfrom</span>(serv_sock, message, BUF_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;client_adr, &amp;client_adr_sz);</span><br><span class="line">        <span class="comment">//将收到的信息打印出来</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Recv Message : &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//通过recvfrom 返回的发送方的IP地址和端口号信息，使用 sendto 将收到的信息再次发送回去。</span></span><br><span class="line">        <span class="built_in">sendto</span>(serv_sock, message, str_len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;client_adr, client_adr_sz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束程序后关闭socket套接字</span></span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//出错调用函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_handle</span><span class="params">(std::string opt, std::string message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据errno值获取失败原因并打印到终端</span></span><br><span class="line">    <span class="built_in">perror</span>(opt.<span class="built_in">c_str</span>());</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">socklen_t</span> adr_sz;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_adr, from_adr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为客户端程序使用时通过命令行参数指定IP地址和端口号，</span></span><br><span class="line">    <span class="comment">//所以当参数数量少于需求 3 时，程序结束并报错</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Usage : &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;IP&gt; &lt;port&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建socket 套接字，sock 用于后面发送和接收数据</span></span><br><span class="line">    sock = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">error_handle</span>(<span class="string">&quot;socket&quot;</span>, <span class="string">&quot;socket() error.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化套接字结构体，初始化服务器套接字结构体中的 IP 地址和端口号</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从标准输入获取发送数据，保存到message缓存区</span></span><br><span class="line">        std::cin &gt;&gt; message;</span><br><span class="line">        <span class="comment">//判断如果输入是 &#x27;q&#x27; 或者 &#x27;Q&#x27; 则表示退出客户端程序</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="built_in">sendto</span>(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;serv_adr, <span class="built_in">sizeof</span>(serv_adr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清空接收数组</span></span><br><span class="line">        <span class="built_in">memset</span>(message, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">        <span class="comment">//计算返回套接字结构体字节长度</span></span><br><span class="line">        adr_sz = <span class="built_in">sizeof</span>(from_adr);</span><br><span class="line">        <span class="comment">//接收UDP返回数据</span></span><br><span class="line">        str_len = <span class="built_in">recvfrom</span>(sock, message, BUF_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;from_adr, &amp;adr_sz);</span><br><span class="line">        <span class="comment">//在接收数据尾部添加&#x27;0&#x27;结束符</span></span><br><span class="line">        message[str_len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将接收数据打印输出</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Recv Message : &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：Linux 操作系统实际上是一个网络操作系统，系统管理的很大部分工作其实都和网络有关。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP&amp;#x2F;IP 协议&lt;/li&gt;
&lt;li&gt;Linux 网络配置&lt;/li&gt;
&lt;li&gt;基本网络服务&lt;/li&gt;
&lt;li&gt;网络安全</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>3-操作系统进程控制及进程间通信概述</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/</id>
    <published>2023-12-25T16:00:00.000Z</published>
    <updated>2023-12-27T03:11:11.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：知识点</p><ul><li>Linux 临界资源概述</li><li>Linux 进程同步与互斥</li><li>Linux 进程间通信概述</li><li>Linux 进程间通信之管道方式</li></ul></blockquote><h2 id="0x01-临界资源"><a href="#0x01-临界资源" class="headerlink" title="0x01 临界资源"></a>0x01 临界资源</h2><p>两个以上的进程不能同时使用的资源称为临界资源。临界资源可能是一些独占设备，例如：打印机、播放器、摄像头等等硬件设备；也可能是一块共享内存、表格文件、链表等软件资源。</p><p>举例说明：假设有一个火车订票系统有两个终端程序在运行 T1 和 T2 ，如果不对临界资源进行特殊管理，则很可能出现 T1 和 T2 同时获取到同一张票的信息卖给了不同的乘客，然后车票余量还只减少了一张。出现这样的情况就是因为 T1 和 T2 在访问订票系统的临界资源时没用进行限制使用导致的。</p><h2 id="0x02-临界区"><a href="#0x02-临界区" class="headerlink" title="0x02 临界区"></a>0x02 临界区</h2><p>不论是硬件资源还是软件资源，多个进程必须互斥访问而不能同时访问，一旦同时访问就会出现问题。每个进程中访问临界资源的那段代码称为临界区。所以，如果能够保证各个进程在进入各自临界区是互斥的，那么就可以实现各个进程对临界资源的访问是互斥的。因此，每个进程在进入临界区之前，应该先对欲访问的临界资源进行检查，检查当前临界资源是否有进程在进行访问，如果当前存在进程访问（即占用临界资源），则当前该进程不能进入临界区；如果此刻没有其他进程正在访问和使用临界资源，则当前进程可以进入临界区对临界资源进行访问和使用，并设置正在访问标识来告诉其他进程此时临界资源正在被使用。（这样的操作就类似火车上的男女共用的单独卫生间，当有人在使用时，红灯亮起告诉所有人正在使用，当无人使用时绿灯亮起，表示当前所有人都可以进入）</p><p>进程在进入临界区前需要检查临界资源使用情况，能够访问临界资源后需要设置正在访问标识。在经常访问资源完成后退出临界资源的访问后，需要将访问标识恢复原样，这部分的代码称为退出区。进程中除了进入区、退出区、临界区，其余部分的代码称为剩余区，于是一个访问临界资源的进程可以被封为如下部分组成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入区</span><br><span class="line">临界区</span><br><span class="line">退出区</span><br><span class="line">剩余区</span><br></pre></td></tr></table></figure><h2 id="0x03-进程的互斥与同步"><a href="#0x03-进程的互斥与同步" class="headerlink" title="0x03 进程的互斥与同步"></a>0x03 进程的互斥与同步</h2><ol><li>进程互斥 进程互斥是指多个进程不能同时使用同一个临界资源，即两个或两个以上进程必须互斥地使用临界资源或者不能同时进入临界区。这是由于各个进程共享某些资源引起的。</li><li>进程同步 进程同步是指有协作关系的进程之间不断地调整它们之间的相对执行过程，以保证临界资源在不同进程中执行的顺序和合理利用。</li></ol><h2 id="0x04-Linux实现进程互斥和同步机制"><a href="#0x04-Linux实现进程互斥和同步机制" class="headerlink" title="0x04 Linux实现进程互斥和同步机制"></a>0x04 Linux实现进程互斥和同步机制</h2><p>Linux 操作系统下对于进程的互斥和同步控制主要有以下这三种方式：</p><ul><li>锁机制</li><li>信号量机制</li><li>信号量集</li></ul><h2 id="0x05-锁机制"><a href="#0x05-锁机制" class="headerlink" title="0x05 锁机制"></a>0x05 锁机制</h2><p>Linux 锁机制其实就是一种实现互斥的软件方式，即提供一对进程共享的锁变量，在进入临界区之前首先测试锁变量的状态，通过锁的状态了解到临界资源是否被占用。临界资源可用，则设置锁变量；临界资源被占用，则会根据锁的不同选择睡眠等待、自旋等待或者返回资源占用状态等。主要操作流程演示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加锁</span></span><br><span class="line">Lock w:</span><br><span class="line">&#123;</span><br><span class="line">    访问临界资源</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#访问完毕，开锁</span></span><br><span class="line">UnLock w;</span><br></pre></td></tr></table></figure><h2 id="0x06-信号量机制"><a href="#0x06-信号量机制" class="headerlink" title="0x06 信号量机制"></a>0x06 信号量机制</h2><p>在早先提出的一种广义锁机制或称为计数锁的同步机制，既能解决互斥又能解决同步，是一种非常有效的同步工具，后来加以改进形成了信号量同步机制。</p><p>申请和释放临界资源的方式通过 <code>wait()</code> 操作和 <code>signal()</code> 操作完成，有时候也称为 P 操作（荷兰语 Passeren 首字母）和 V 操作（Verhoong 的首字母）。</p><p>信号量也被叫做信号灯，是在信号量同步机制中用于实现进程的同步和互斥的有效数据结构。我们可以为每一类资源设置一个信号量，信号量有很多种类型的数据结构，如整型信号量、记录型信号量、AND 型信号量以及信号量集等。</p><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>整型信号量是信号量中最简单的类型，也是各种信号量类型中必须包含的类型。整型信号量的数值表示当前系统中可用的该类临界资源的数量。</p><p>如设置了整型信号量 s ，则 s 值的意义为：</p><ul><li><code>s&gt;0</code> ，表示系统中空闲的该类临界资源的个数；</li><li><code>s=0</code> ，表示系统中该类临界资源干好全部被占用，而且没有进程在等待临界资源；</li><li><code>s&lt;0</code> ，s 的绝对值表示当前系统中等待该临界资源的进程个数；</li></ul><p><code>wait(S)</code> 和 <code>Signal(S)</code> 可以简单被描述成如下的代码执行方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wait(S)</span></span><br><span class="line">    <span class="keyword">while</span>(s &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进程等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    s = s - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Signal(S)</span></span><br><span class="line">    <span class="comment">//发送信号</span></span><br><span class="line">    s = s + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>记录型信号量的数据结构由两部分组成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphone</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> s;<span class="comment">//整型信号</span></span><br><span class="line">    <span class="built_in">list</span> *l;<span class="comment">//进程链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphone</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure><p>在这个结构中，<code>s</code> 的值表示系统中可用的该类临界资源的数量，而 <code>l</code> 为进程链表指针，指向等待该资源的 PCB 队列。具体的操作如下图所示：</p><p>在记录型信号量机制中，s 的初值表示系统中该类资源的可用数目，因而又被成为资源信号量，每次对它进行 <code>wait()</code> 操作，即申请该类一个单位的临界资源，描述为 <code>s=s-1</code> ，当 <code>s&gt;=0</code> 条件满足时，表示在没用做减一操作前 <code>s&gt;=1</code> ，因此本进程可以继续执行；当 <code>s&gt;=0</code> 条件不满足时，表示操作前系统就没有空闲的该资源，因此进程应该调用 <code>block</code> 将该进程的 PCB 插入由指针 l 指向的阻塞队列。因此，该机制遵循了“让权等待”。</p><p>s 的绝对值表示在该信号量链表中已阻塞等待进程的数目。对信号量的每次 <code>signal()</code> 操作表示执行进程释放一个单位的该类临界资源，因此操作 <code>s=s+1</code> 表示资源数目加一。如果加一操作后发现 <code>s&lt;=0</code> 条件依然成立，这表示该信号链表中仍然有等待资源被阻塞的经常，所以还需要调用 <code>wakeup</code> 将第一个等待进程唤醒，其余进程继续等待；若 <code>s&lt;=0</code> 不成立，则表示系统中没用等待该类资源的进程，因此本进程只需要释放它所占用的该类资源继续执行即可。</p><h4 id="AND-型信号量"><a href="#AND-型信号量" class="headerlink" title="AND 型信号量"></a>AND 型信号量</h4><p>AND 同步机制的基本思想是将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完成后再一起释放，只要有一个资源尚未分配给进程，其他所有可能分配的资源都不会分配给它。具体描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1,S2,...,Sn)</span><br><span class="line">    <span class="keyword">if</span> S1&gt;=<span class="number">1</span> and S2 &gt;=<span class="number">1</span> ... and Sn &gt;=<span class="number">1</span> then</span><br><span class="line">        <span class="keyword">for</span> i: =<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">            Si:=Si<span class="number">-1</span>;</span><br><span class="line">        endfor</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        [将该进程放入阻塞队列]</span><br><span class="line">    endif</span><br><span class="line">Ssignal(S1,S2,...,Sn)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">        Si = Si + <span class="number">1</span>;</span><br><span class="line">        唤醒所有 Si 不满足而进入阻塞队列的进程</span><br><span class="line">    endfor</span><br></pre></td></tr></table></figure><h4 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h4><p>如果某进程一次需要 N 个某类资源时，就需要进行 N 次 <code>wait()</code> 操作，这使得系统效率非常低并且可能造成死锁。</p><p>信号量集机制的基本思想是在 AND 型信号量集的基础上进行扩充，进程对信号量 Si 的测试值为 ti （用于信号量判断），占用值为 di （用于信号量的增减）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1,S2,...,Sn)</span><br><span class="line">Ssignal(S1,d1;S2,d2;...;Sn,dn)</span><br></pre></td></tr></table></figure><p>一般“信号量集”的几种特定情况如下：</p><ul><li><code>Swait(S,d,d)</code> 表示每次申请 d 个资源，当少于 d 时不进行分配</li><li><code>Swait(S,1,1)</code> 表示互斥信号量</li><li><code>Swait(S,1,0)</code> 作为一个可控开关（当 <code>S&gt;=1</code> 时允许多个进程进入临界区；当 <code>S==0</code> 时禁止任何进程进入临界区）</li><li>“信号量集”未必成对使用 <code>Swait()</code> 和 <code>Ssignal()</code>，如一起申请，但可以不一起释放</li></ul><h2 id="0x07-进程间通信"><a href="#0x07-进程间通信" class="headerlink" title="0x07 进程间通信"></a>0x07 进程间通信</h2><p>我们应该都知道了，进程是一个程序的一次执行，是系统资源分配的最小单元。这里所说的进程一般是指运行在用户态的进程，而由于处于用户态的不同进程间是彼此隔离的，但是它们很可能需要相互发送一些信息，好让对方知道自己的进度等情况，像这样进程间传递信息就叫进程间通信。</p><p>Linux 进程间通信的方式有以下几种（这是固定的）：</p><ul><li>管道(Pipe)及有名管道(Named Pipe): 管道可用于具有”血缘”关系进程间(也就是父子进程或者兄弟进程)的通信。有名管道除具有管道所具有的功能外，还允许无”血缘”关系进程间的通信。</li><li>信号(Signal): 信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生。</li><li>信号量(Semaphore): 主要作为进程之间及同一进程的不同线程之间的同步和互斥手段。</li><li>共享内存(Shared Memory): 可以说这是最有效的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种通信方式需要依靠某种同步机制，如互斥锁和信号量等。</li><li>消息队列(Messge Queue): 消息队列是消息的链表，包括 <code>Posix 消息队列</code> 和 <code>System V 消息队列</code>。它克服了前两种通信方式中信息量有限的缺点，具有写权限的进程可以按照一定的规则向消息队列中添加消息;对消息队列具有读权限的进程则可以从消息队列中读取消息。</li><li>套接字(Socket): 这个绝对是一种更为一般的进程间通信机制，它可用于网络中不同机器之间的进程间通信，目前经常遇到的网络编程就会用到套接字通信。</li></ul><h2 id="0x08-管道"><a href="#0x08-管道" class="headerlink" title="0x08 管道"></a>0x08 管道</h2><p>管道是 Linux 中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入(其实我更愿意将管道比喻为农村浇地的管子)。Linux 的管道主要包括两种：无名管道和有名管道。这一节主要讲无名管道，首先介绍以下这两种管道。</p><ol><li>无名管道</li></ol><p>无名管道是 Linux 中管道通信的一种原始方法，如下图所示，它具有以下特点：</p><ul><li>它只能用于具有亲缘关系的进程之间的通信（也就是父子进程或者兄弟进程之间）；</li><li>它是一个半双工的通信模式，具有固定的读端和写端；</li><li>管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read()、write() 等函数。但它不是普通的文件，并不属于其他任何文件系统并且只存在于内存中。</li></ul><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/1.png" class="" title="图片描述"><ol><li>有名管道(FIFO)</li></ol><p>有名管道是对无名管道的一种改进，如下图所示，它具有以下特点：</p><ul><li>它可以使互不相关的两个进程间实现彼此通信；</li><li>该管道可以通过路径名来指出，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当做普通文件一样进行读写操作，使用非常方便；</li><li><code>FIFO</code> 严格地遵循先进先出规则，对管道及 <code>FIFO</code> 的读总是从开始处返回数据，对它们的写则是把数据添加到末尾，它们不支持如 <code>lseek()</code> 等文件定位操作。</li></ul><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/2.png" class="" title="图片描述"><h4 id="无名管道及系统调用"><a href="#无名管道及系统调用" class="headerlink" title="无名管道及系统调用"></a>无名管道及系统调用</h4><ol><li>管道创建与管道说明</li></ol><p>管道是基于文件描述符的通信方式，当一个管道建立时，它会创建两个文件描述符 <code>fd[0]</code> 和 <code>fd[1]</code>，其中 <code>fd[0]</code> 固定用于读管道，而 <code>fd[1]</code> 固定用于写管道，如下图所示，这样就构成了一个半双工的通道。</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/3.png" class="" title="图片描述"><p>管道关闭时只需要将这两个文件描述符关闭即可，可使用普通的 <code>close()</code> 函数逐个关闭各个文件描述符。</p><ol><li>管道创建函数</li></ol><p>创建管道可以用 <code>pipe()</code> 函数实现，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//所需头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span> <span class="comment">//函数原型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数参数：fd[2] 管道的两个文件描述符，函数调用之后可以直接操作这两个文件描述符</span></span><br><span class="line"><span class="comment">返回值：0 - 成功，-1 - 出错</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>管道读写说明</li></ol><p>用 <code>pipe()</code> 创建的管道两端处于同一个进程中，由于管道主要是用于在不同的进程间通信的，因此，在实际应用中没有太大意义。实际上，通常先是创建一个管道，再调用 <code>fork()</code> 函数创建一个子进程，该子进程会继承父进程所创建的管道，这时，父子进程管道的文件描述符对应关系如下图:</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/4.png" class="" title="图片描述"><p>此时的关系看似非常复杂，实际上却已经给不同进程之间的读写创造了很好的条件。父子进程分别拥有自己的读写通道，为了实现父子进程之间的读写，只需把无关的读端或写端的文件描述符关闭即可。将父进程的写端 <code>fd[1]</code> 和子进程的读端 <code>fd[0]</code> 关闭，则父子进程之间就建立起一条“子进程写入父进程读取”的通道。</p><p>同样，也可以将父进程的读端 <code>fd[0]</code> 和子进程的写端 <code>fd[1]</code> 关闭，则父子进程之间就建立起一条“父进程写入子进程读取”的通道。</p><p>另外，父进程还可以创建多个子进程，各个子进程都继承了相应的 <code>fd[0]</code> 和 <code>fd[1]</code> ，此时，只需要关闭相应的端口就可以建立各子进程之间的的通道。</p><ol><li>管道读写注意点</li></ol><ul><li>只有在管道的读端存在时，向管道写入数据才有意义。否则，向管道写入数据的进程将收到内核传来的 SIGPIPE 信号(通常为 Broken pipe 错误)。</li><li>向管道写入数据时，Linux 将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读取管道缓冲区中的数据，那么写进程将会一直阻塞。</li><li>父子进程在运行时，它们的先后次序并不能保证。因此，为了保证父子进程已经关闭了相应的文件描述符，可在两个进程中调用 sleep()函数。当然，最好还是采用进程之间的同步与互斥机制。</li></ul><h4 id="管道通信实验"><a href="#管道通信实验" class="headerlink" title="管道通信实验"></a>管道通信实验</h4><p>下面，我们通过一个小的实例代码来学习进程如何通过管道来通信的。在 VS code 窗口中创建新的文件 <code>pipe.c</code> ，然后添加如下代码内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_DATA_LEN    128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME      3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[MAX_DATA_LEN];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> data[] = <span class="string">&quot;Pipe Demo Program&quot;</span>;</span><br><span class="line">    <span class="type">int</span> real_read;</span><br><span class="line">    <span class="type">int</span> real_write;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span> *)buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pepe create error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程，关闭写描述符，通过sleep(3)等待父进程关闭相应的读描述符</span></span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        sleep(DELAY_TIME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子进程读取管道内容</span></span><br><span class="line">        real_read = read(pipe_fd[<span class="number">0</span>], buf, MAX_DATA_LEN);</span><br><span class="line">        <span class="keyword">if</span>(real_read &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child progress : read %d bytes from the pipe : &#x27;%s&#x27; \n&quot;</span>, real_read, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程，关闭读描述符，并通过睡眠3秒等待子进程关闭对应的写描述符</span></span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">        sleep(DELAY_TIME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写管道内容</span></span><br><span class="line">        real_write = write(pipe_fd[<span class="number">1</span>], data, <span class="built_in">strlen</span>(data));</span><br><span class="line">        <span class="keyword">if</span>(real_write != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent progress : write %d bytes to the pipe : &#x27;%s&#x27; \n&quot;</span>, real_write, data);</span><br><span class="line">        &#125;</span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//等待子进程结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完成后，如下图：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/5.png" class="" title="图片描述"><p>在 VS Code 平台下的终端窗口中输入以下命令进行编译和运行，观察程序最终结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc pipe.c -o pipe</span><br><span class="line">./pipe</span><br></pre></td></tr></table></figure><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/6.png" class="" title="图片描述"><h4 id="有名管道及其系统调用"><a href="#有名管道及其系统调用" class="headerlink" title="有名管道及其系统调用"></a>有名管道及其系统调用</h4><p>有名管道是对无名管道的一种改进，它具有以下特点：</p><ul><li>它可以使互不相关的两个进程间实现彼此通信；</li><li>该管道可以通过路径名来指出，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当做普通文件一样进行读写操作，使用非常方便；</li><li><code>FIFO</code> 严格地遵循先进先出规则，对管道及 <code>FIFO</code> 的读总是从开始处返回数据，对它们的写则是把数据添加到末尾，它们不支持如 <code>lseek()</code> 等文件定位操作。</li></ul><p>有名管道的创建可以使用函数 <code>mkfifo()</code>，该函数类似与文件中的 <code>open()</code> 操作，可以指定管道的路径和打开的模式。同时还可以在终端窗口使用命令来创建有名管道。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mknod</span> [管道名] p</span><br></pre></td></tr></table></figure><p>在管道创建成功后，就可以使用 <code>open()</code>、<code>write()</code> 和 <code>read()</code> 这些函数了。与普通文件的开发设置一样，对于为读而打开的管道可在 <code>open()</code> 中设置 <code>O_RDONLY</code>，对于为写而打开的管道可在 <code>open()</code> 中设置 <code>O_WRONLY</code>，在这里与普通文件不同的是阻塞问题。由于普通文件在读写时不会出现阻塞问题，而在管道的读写中却有阻塞的可能，这里的非阻塞标志可以在 <code>open()</code> 函数中设定为 <code>O_NONBLOCK</code>。</p><p>下面分别对阻塞打开和非阻塞打开的读写进行说明：</p><ol><li>对于读进程：</li></ol><ul><li>若该管道是阻塞打开，且当前 <code>FIFO</code> 内没有数据，则对读进程而言将一直阻塞到有数据写入。</li><li>若该管道是非阻塞打开，则不论 <code>FIFO</code> 内是否有数据，读进程都会立即执行读操作。即如果 <code>FIFO</code> 内没有数据，则读函数将立刻返回 0。</li></ul><ol><li>对于写进程</li></ol><ul><li>若该管道是阻塞打开，则写操作将一直阻塞到数据可以被写入。</li><li>若该管道是非阻塞打开而不能写入全部数据，则读操作进行部分写入或者调用失败。</li></ul><p>对于 <code>mkfifo()</code> 函数介绍如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/state.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">mode_t</span> mode)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">- filename: 要创建的管道，包含路径</span></span><br><span class="line"><span class="comment">- mode: O_RDONLY:读管道</span></span><br><span class="line"><span class="comment">        O_WRONLY:写管道</span></span><br><span class="line"><span class="comment">        O_RDWR:读写管道</span></span><br><span class="line"><span class="comment">        O_NONBLOCK:非阻塞</span></span><br><span class="line"><span class="comment">        O_CREAT:如果该文件不存在，那么就创建一个新的文件，并用第三个参数为其设置权限</span></span><br><span class="line"><span class="comment">        O_EXECL：如果使用O_CREAT时文件存在，那么可返回错误消息。这个参数可测试文件是否存在</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回值：成功返回 0 ，失败返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="有名管道实验"><a href="#有名管道实验" class="headerlink" title="有名管道实验"></a>有名管道实验</h4><p>对于有名管道的使用就不需要像无名管道那样使用 <code>fork()</code> 创建子进程来进行通信，有名管道是可以在没有亲属关系的进程之间进行通信的。所以在这个实验中，我们将要编写两个程序，通过执行这两个进程在工作过程中使用 <code>fifo</code> 通信来进行实验。这两个程序一个负责向管道种写数据，一个负责读数据。写数据的程序为 <code>fifo_write.c</code> ，读数据的代码文件为 <code>fifo_read.c</code>，具体如下：</p><p>在 VS Code 平台下创建 <code>fifo_write.c</code> 文件，如下图：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/7.png" class="" title="图片描述"><p>添加以下内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME    <span class="string">&quot;/tmp/demo_fifo&quot;</span>    <span class="comment">/* 有名管道名称 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_SIZE     PIPE_BUF     <span class="comment">/* 定义数据长度，使用 limits.h 中的 PIPE_BUF 长度 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buff[MAX_BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> nwrite;</span><br><span class="line"></span><br><span class="line">    fd = open(FIFO_NAME, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open fifo file error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从键盘获取输入的字符，将数据存入 buff</span></span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, MAX_BUFFER_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入需要向 FIFO 中发送的数据：(q/Q 退出)\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 判断退出条件 */</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buff, <span class="string">&quot;q&quot;</span>) || !<span class="built_in">strcmp</span>(buff, <span class="string">&quot;Q&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] write fifo 程序退出....&quot;</span>, getpid());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nwrite = write(fd, buff, <span class="built_in">strlen</span>(buff)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nwrite &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Write &#x27;%s&#x27; to FIFO\n&quot;</span>, buff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Write FIFO error...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VS Code 平台下创建 <code>fifo_read.c</code> 文件，如图：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/8.png" class="" title="图片描述"><p>添加内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME    <span class="string">&quot;/tmp/demo_fifo&quot;</span>    <span class="comment">/* 有名管道名称 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_SIZE     PIPE_BUF     <span class="comment">/* 定义数据长度，使用 limits.h 中的 PIPE_BUF 长度 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buff[MAX_BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> nread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断 FIFO 文件是否存在，如果不存在则创建 */</span></span><br><span class="line">    <span class="keyword">if</span>(access(FIFO_NAME, F_OK) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((mkfifo(FIFO_NAME, <span class="number">0666</span>) &lt; <span class="number">0</span>) &amp;&amp; (errno != EEXIST))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Cannot create fifo file\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(FIFO_NAME, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open fifo file error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从键盘获取输入的字符，将数据存入 buff</span></span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, MAX_BUFFER_SIZE);</span><br><span class="line">        nread = read(fd, buff, MAX_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buff, <span class="string">&quot;q&quot;</span>) || !<span class="built_in">strcmp</span>(buff, <span class="string">&quot;Q&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] read fifo 程序退出....&quot;</span>, getpid());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nread &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Read &#x27;%s&#x27; from FIFO\n&quot;</span>, buff);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Read FIFO error...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完代码后，在终端通过 <code>gcc</code> 进行编译，在执行的时候分为两个终端窗口来执行，首先执行管道读程序 <code>fifo_read</code>，然后在另一个窗口中启动管道写进程 <code>fifo_write</code>，具体结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc fifo_read.c -o fifo_read</span><br><span class="line">gcc fifo_write.c -o fifo_write</span><br></pre></td></tr></table></figure><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/9.png" class="" title="图片描述"><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/10.png" class="" title="图片描述"><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/11.png" class="" title="图片描述">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：知识点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 临界资源概述&lt;/li&gt;
&lt;li&gt;Linux 进程同步与互斥&lt;/li&gt;
&lt;li&gt;Linux 进程间通信概述&lt;/li&gt;
&lt;li&gt;Linux 进程间通信之管道方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockq</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>4-进程间通信方式之消息队列</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/4-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/4-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2023-12-25T16:00:00.000Z</published>
    <updated>2023-12-27T03:11:11.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：知识点</p><ul><li>Linux 消息队列方式原理介绍</li><li>Linux 消息队列相关 API 介绍</li></ul></blockquote><h2 id="0x01-Linux-消息队列"><a href="#0x01-Linux-消息队列" class="headerlink" title="0x01 Linux 消息队列"></a>0x01 Linux 消息队列</h2><p>消息队列 (也叫做报文队列)是 Unix 系统 V 版本中 3 种进程间通信机制之一。另外两种是信号量和共享内存。这些 IPC 机制使用共同的授权方法。只有通过系统调用将标志符传递给核心之后，进程才能存取这些资源。这种系统 IPC 对象使用的控制方法和文件系统非常类似。使用对象的引用标志符作为资源表中的索引。</p><p>消息队列就是一个消息的链表。就是把消息看作一个记录，并且这个记录具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读出消息。</p><p>Linux 采用消息队列的方式来实现消息传递。这种消息的发送方式是：发送方不必等待接收方检查它所收到的消息就可以继续工作下去，而接收方如果没有收到消息也不需等待。这种通信机制相对简单，但是应用程序使用起来就需要使用相对复杂的方式来应付了。新的消息总是放在队列的末尾，接收的时候并不总是从头来接收，可以从中间来接收。</p><p>消息队列是随内核持续的并和进程相关，只有在内核重起或者显示删除一个消息队列时，该消息队列才会真正被删除。因此系统中记录消息队列的数据结构 (struct ipc_ids msg_ids)位于内核中，系统中的所有消息队列都可以在结构 <code>msg_ids</code> 中中找到访问入口。</p><p><code>IPC</code> 标识符：每一个 <code>IPC</code> 目标都有一个唯一的 <code>IPC标识符</code> 。这里所指的 <code>IPC目标</code> 是指一个单独的消息队列、一个信号量集或者一个共享的内存段。系统内核使用此标识符在系统内核中指明 <code>IPC目标</code> 。</p><p><code>IPC关键字</code> ：想要获得唯一的标识符，则必须使用一个 <code>IPC关键字</code> 。客户端进程和服务器端进程必须双方都同意此关键字。这是建立一个客户机&#x2F;服务器框架的第一步。在 <code>System V IPC</code> 机制中，建立两端联系的路由方法是和 <code>IPC关键字</code> 直接相关的。通过在应用程序中设置关键字值，每一次使用的关键字都可以是相同的。一般情况下，可以使用 <code>ftok()</code> 函数为客户端和服务器端产生关键字值。</p><h2 id="0x02-Linux消息队列使用步骤"><a href="#0x02-Linux消息队列使用步骤" class="headerlink" title="0x02 Linux消息队列使用步骤"></a>0x02 Linux消息队列使用步骤</h2><ul><li>创建或打开消息队列。使用的函数是 <code>msgget()</code>，这里创建的消息队列的数量会受到系统消息队列数量的限制。</li><li>添加消息。使用的函数是 <code>msgsnd()</code>，它把消息添加到已打开的消息队列末尾。</li><li>读取消息。使用的函数是 <code>msgrcv()</code>，它把消息从消息队列中取走，与 <code>FIFO</code> 不同的是，这里可以取走指定的某一条消息。</li><li>控制消息队列。使用的函数是 <code>msgctl()</code>，它可以完成多项功能。</li></ul><h2 id="0x03-Linux消息队列相关-API-介绍"><a href="#0x03-Linux消息队列相关-API-介绍" class="headerlink" title="0x03 Linux消息队列相关 API 介绍"></a>0x03 Linux消息队列相关 API 介绍</h2><p>在 Linux 操作系统中，我们可以通过使用 <code>msgget()</code> 函数来创建和打开消息队列，具体描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">- key 消息队列键值，多个进程可以通过这个 ID 值来访问同一个消息队列，其中有个特殊值 `IPC_PRIVATE` 用于创建当前进程的私有消息队列</span></span><br><span class="line"><span class="comment">- msgflg 权限标志位</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功返回消息队列 ID， 失败返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>向已经被创建和打开的消息队列中发送数据，可以使用 <code>msgsnd()</code> 函数，具体描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">- msqid 消息队列的队列 ID</span></span><br><span class="line"><span class="comment">- msgp  执行消息结构的指针，该消息结构 `msgbuf` 通常如下：</span></span><br><span class="line"><span class="comment">        struct msgbuf&#123;</span></span><br><span class="line"><span class="comment">            long mtype; //消息类型</span></span><br><span class="line"><span class="comment">            char mtext[1];//消息正文</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">- msgsz 消息正文的字节数</span></span><br><span class="line"><span class="comment">- msgflg  如下：</span></span><br><span class="line"><span class="comment">        `IPC_NOWAIT`:若消息无法立即发生（当前消息队列已满，函数立即返回</span></span><br><span class="line"><span class="comment">        0：msgsnd() 调用阻塞知道发送成功为止</span></span><br><span class="line"><span class="comment">函数返回值：</span></span><br><span class="line"><span class="comment">    成功返回 0， 失败返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于消息队列的接收，在程序中可以通过调用 <code>msgrcv()</code> 来进行读取数据，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> <span class="type">int</span> msgtyp, <span class="type">int</span> msgflg)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">- msqid 消息队列的队列 ID</span></span><br><span class="line"><span class="comment">- msgp  消息缓冲区</span></span><br><span class="line"><span class="comment">- msgsz 正文字节数</span></span><br><span class="line"><span class="comment">- msgtyp 描述如下：</span></span><br><span class="line"><span class="comment">        0：接收消息队列中第一个消息</span></span><br><span class="line"><span class="comment">        大于0：接收消息队列中第一个类型为 msgtyp 的消息</span></span><br><span class="line"><span class="comment">        小于0：接收消息队列中第一个类型值不小于 msgtyp 绝对值且值最小的消息</span></span><br><span class="line"><span class="comment">- msgflg    描述如下：</span></span><br><span class="line"><span class="comment">        - MSG_NOERROR：若返回的消息比 msgsz 字节多，则消息就会截断到 msgsz 字节，且不会通知消息到进程</span></span><br><span class="line"><span class="comment">        - IPC_NOWAIT:若消息队列中没有相应类型的消息可以接收，则函数会立即返回</span></span><br><span class="line"><span class="comment">        - 0：函数调用阻塞等待接收到一条消息为止</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功返回 0， 失败返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除了上述 API 之外，还可以用 <code>msgctl()</code> 函数来对消息队列进行设置，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msgqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msgid_ds *buf)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">- msqid 消息队列的队列 ID</span></span><br><span class="line"><span class="comment">- cmd   执行操作，如下：</span></span><br><span class="line"><span class="comment">    - IPC_STAT：读取消息队列的数据结构 msgid_ds ，并将其存储到 buf 位置</span></span><br><span class="line"><span class="comment">    - IPD_SET：设置消息队列的数据结构 msgid_ds 中的 ipc_perm 值，这个值取自 buf 参数</span></span><br><span class="line"><span class="comment">    - IPC_RMID：从系统内核中删除消息队列</span></span><br><span class="line"><span class="comment">- buf：描述消息队列的 msqid_ds 结构类型的变量</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">    成功返回 0， 失败返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：知识点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 消息队列方式原理介绍&lt;/li&gt;
&lt;li&gt;Linux 消息队列相关 API 介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x01-Linux-消息队列&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>6-进程间通信方式之信号量通信</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/</id>
    <published>2023-12-25T16:00:00.000Z</published>
    <updated>2023-12-27T03:11:11.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>知识点：</p><ul><li>Linux 信号量通信原理介绍</li><li>Linux 信号量通信相关 API 介绍</li></ul></blockquote><h2 id="0x01-Linux-信号量概述"><a href="#0x01-Linux-信号量概述" class="headerlink" title="0x01 Linux 信号量概述"></a>0x01 Linux 信号量概述</h2><p>在 Linux 中，信号量本质上是一个计数器（不设置全局变量是因为进程间是相互独立的，而这不一定能看到，看到也不能保证++引用计数为原子操作）,用于多进程对共享数据对象的读取，它和管道有所不同，它不以传送数据为主要目的，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。</p><p>正如前面实验三章节内容的说明一样，在 Linux 系统下解决进程间临界资源竞争的问题，最有效的方式就是使用信号量。所以，信号量就是用来解决进程间的同步和互斥问题的一种进程间通信机制。</p><p>_信号量与信号的区别_：在 Linux 系统下，信号量名字是 <code>semaphore</code> ，而信号的名字为 <code>signal</code>。它们虽然都可以用来解决进程同步和互斥问题，但是所采用的的机制不一样。信号使用系统的信号处理机制，而信号量则最终是使用原子操作的 PV 来实现的。</p><h2 id="0x02-Linux-信号量工作原理"><a href="#0x02-Linux-信号量工作原理" class="headerlink" title="0x02 Linux 信号量工作原理"></a>0x02 Linux 信号量工作原理</h2><p>在多任务操作系统环境下，多个进程会同时运行，并且一些进程间可能会存在一定的关联。多个进程可能为了完成同一个任务相互协作，这就形成了进程间的同步关系。而且在不同进程间，为了争夺有限的系统资源（硬件或软件资源）会进入竞争状态，这就是进程间的互斥关系。</p><p>进程间的互斥关系与同步关系存在的根源在于临界资源。临界资源是在同一时刻只允许有限个（通常只有一个）进程可以访问（读）或修改（写）的资源，通常包括硬件资源（处理器、内存、存储器及其它外围设备等）和软件资源（共享代码段、共享结构和变量等）。访问临界资源的代码叫做临界区，临界区本身也会称为临界资源。</p><p>信号量是用来解决进程间的同步与互斥问题的一种进程间通信机制，包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作（P&#x2F;V 操作）。其中，信号量对应于某一种资源，取一个非负的整形值。信号量值（常用 <code>sem_id</code> 表示）指的是当前可用的该资源的数量，若等于 0 则意味着目前没有可用的资源。</p><p>PV 原子操作的具体定义如下:</p><ul><li>P 操作：如果有可用的资源（信号量值 &gt; 0），则此操作所在的进程占用一个资源（此时信号量值减 1，进入临界区代码）；如果没有可用的资源（信号量值 &#x3D; 0），则此操作所在的进程被阻塞直到系统将资源分配给该进程（进入等待队列，一直等到资源轮到该进程）。</li><li>V 操作：如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞进程；如果没有进程等待它，则释放一个资源（即信号量值加 1）。</li></ul><p>_二元信号量_：二元信号量（Binary Semaphore）是最简单的一种锁（互斥锁），它只用两种状态：占用与非占用。所以它的引用计数为 1。</p><h2 id="0x03-Linux-信号量相关-API-函数"><a href="#0x03-Linux-信号量相关-API-函数" class="headerlink" title="0x03 Linux 信号量相关 API 函数"></a>0x03 Linux 信号量相关 API 函数</h2><p>在 Linux 系统中，使用信号量通常分为以下 4 个步骤：</p><ul><li>创建信号量或获得在系统中已存在的信号量，此时需要调用 semget() 函数。不同进程通过使用同一个信号量键值来获得同一个信号量。</li><li>初始化信号量，此时使用 semctl() 函数的 SETVAL 操作。当使用二维信号量时，通常将信号量初始化为 1。</li><li>进行信号量的 PV 操作，此时，调用 semop() 函数。这一步是实现进程间的同步和互斥的核心工作部分。</li><li>如果不需要信号量，则从系统中删除它，此时使用 semctl() 函数的 IPC_RMID 操作。需要注意的是，在程序中不应该出现对已经被删除的信号量的操作：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    key：信号量的键值，多个进程可以通过它访问一个信号量，其中有个特殊值 IPC_PRIVATE ，用来创建当前进程私有信号量</span></span><br><span class="line"><span class="comment">    nsems：需要创建的信号量数目</span></span><br><span class="line"><span class="comment">    semflg：同 open() 函数的权限位相同，其中 IPC_CREAT 创建新的信号量，IPC_EXCL 创建新的唯一的信号量</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功：信号量标识符，在信号量其他函数中会用到    失败：返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, <span class="keyword">union</span> semun arg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    semid：semget() 函数反悔的信号量标识符，要操作的信号量</span></span><br><span class="line"><span class="comment">    semnum：信号量编号，当使用信号量集会用到，单个信号量操作取参数 0</span></span><br><span class="line"><span class="comment">    cmd：指定对信号量的各种操作，当使用单个信号量时，常用的操作如下：</span></span><br><span class="line"><span class="comment">        IPC_STAT：获得该信号量的 semid_ds 结构，并存放到第四个参数指定的位置中</span></span><br><span class="line"><span class="comment">        IPC_SETVAL：将信号量值设置为 arg 的 val 值</span></span><br><span class="line"><span class="comment">        IPC_GETVAL：返回信号量的当前值</span></span><br><span class="line"><span class="comment">        IPC_RMID：从系统中删除信号量（或者信号量集）</span></span><br><span class="line"><span class="comment">    arg：是 union semun 结构，有时需要执行定义</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功：根据 cmd 的值返回不同的值</span></span><br><span class="line"><span class="comment">    失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    semid：semget() 函数反悔的信号量标识符，要操作的信号量</span></span><br><span class="line"><span class="comment">    sops：指向信号量操作数组，</span></span><br><span class="line"><span class="comment">    nsops：操作数组 sops 中的操作个数，通常取 1 （一个操作）</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功：信号量标识符  失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="0x04-信号量基本用法"><a href="#0x04-信号量基本用法" class="headerlink" title="0x04 信号量基本用法"></a>0x04 信号量基本用法</h2><p>在 VS Code 平台下创建新的代码文件 <code>fork_demo.c</code> ，如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/1.png" class="" title="图片描述"><p>然后添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_TIME  3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_sem</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> init_val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    sem_union.val = init_val;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, sem_union) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;init semaphore error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_sem</span><span class="params">(<span class="type">int</span> sem_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// perror(&quot;Delete semaphore error.\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_p</span><span class="params">(<span class="type">int</span> sem_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;P error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_v</span><span class="params">(<span class="type">int</span> sem_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;P error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> sem_id;</span><br><span class="line">    <span class="comment">//创建信号量</span></span><br><span class="line">    sem_id = semget(ftok(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;a&#x27;</span>), <span class="number">1</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    init_sem(sem_id, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child progress [%d] will wait for som seconds...\n&quot;</span>, getpid());</span><br><span class="line">        sleep(DELAY_TIME);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child progress [%d] \n&quot;</span>, getpid());</span><br><span class="line">        sem_v(sem_id);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        sem_p(sem_id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent progress [%d] will wait for som seconds...\n&quot;</span>, getpid());</span><br><span class="line">        sem_v(sem_id);</span><br><span class="line">        del_sem(sem_id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VS Code 平台下的终端窗口使用 <code>gcc</code> 编译代码并执行，如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/2.png" class="" title="图片描述"><h2 id="0x05-信号量进程同步"><a href="#0x05-信号量进程同步" class="headerlink" title="0x05 信号量进程同步"></a>0x05 信号量进程同步</h2><p>接下来利用信号量同步机制创建两个进程交替进行输出计数，一个进程输出奇数，另一个输出偶数，交替输出组成联系数字排列。为了使得输出结果能够显示在同一个终端窗口，使其中的一个进程通过 <code>fork()</code> 创建新的进程并调用 <code>execl()</code> 函数去执行另一个可执行程序，最终达到我们想要的效果。具体如下：</p><p>在 VS Code 平台下创建新的代码文件偶数输出程序代码 <code>even_demo.c</code> ，如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/3.png" class="" title="图片描述"><p>然后添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该程序将仅输出奇数值，配合 even_demo 程序完成 0 - 20 的计数输出*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DELAY_TIME  3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_sem</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> init_value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从系统中删除信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_sem</span><span class="params">(<span class="type">int</span> sem_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_p</span><span class="params">(<span class="type">int</span> sem_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//V操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_v</span><span class="params">(<span class="type">int</span> sem_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ftok参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_ODD_KEY     <span class="string">&quot;./odd_dem_key&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_EVEN_KEY    <span class="string">&quot;./even_dem_key&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> sem_odd, sem_even;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个信号量</span></span><br><span class="line">    sem_even = semget(ftok(SEM_EVEN_KEY, <span class="string">&#x27;a&#x27;</span>), <span class="number">1</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    sem_odd = semget(ftok(SEM_ODD_KEY, <span class="string">&#x27;a&#x27;</span>), <span class="number">1</span>, <span class="number">0666</span>);</span><br><span class="line">    init_sem(sem_even, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execl(<span class="string">&quot;./odd_demo&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_p(sem_odd);    <span class="comment">//获取奇数程序信号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]====&gt; (%d)\n&quot;</span>, getpid(), i);</span><br><span class="line">        sem_v(sem_even);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_p(sem_even);</span><br><span class="line">    <span class="comment">// sleep(DELAY_TIME);</span></span><br><span class="line">    waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    del_sem(sem_even);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prograss even[%d] quit..\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_sem</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> init_val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    sem_union.val = init_val;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, sem_union) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;init semaphore error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_sem</span><span class="params">(<span class="type">int</span> sem_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// perror(&quot;Delete semaphore error.\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_p</span><span class="params">(<span class="type">int</span> sem_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;P error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_v</span><span class="params">(<span class="type">int</span> sem_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;P error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后继续新建代码文件 <code>odd_demo.c</code> ，这是用于输出奇数消息的程序，如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/4.png" class="" title="图片描述"><p>然后添加如下代码内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 该程序将仅输出奇数值，配合 even_demo 程序完成 0 - 20 的计数输出*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     DELAY_TIME  3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号量初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_sem</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> init_value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从系统中删除信号量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_sem</span><span class="params">(<span class="type">int</span> sem_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_p</span><span class="params">(<span class="type">int</span> sem_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//V操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_v</span><span class="params">(<span class="type">int</span> sem_id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ftok参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_ODD_KEY     <span class="string">&quot;./odd_dem_key&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEM_EVEN_KEY    <span class="string">&quot;./even_dem_key&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> sem_odd, sem_even;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个信号量</span></span><br><span class="line">    sem_odd = semget(ftok(SEM_ODD_KEY, <span class="string">&#x27;a&#x27;</span>), <span class="number">1</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    sem_even = semget(ftok(SEM_EVEN_KEY, <span class="string">&#x27;a&#x27;</span>), <span class="number">1</span>, <span class="number">0666</span>);</span><br><span class="line">    init_sem(sem_odd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    sem_v(sem_odd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_p(sem_even);    <span class="comment">//获取偶数信号量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]====&gt; (%d)\n&quot;</span>, getpid(), i);</span><br><span class="line">        sem_v(sem_odd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(DELAY_TIME);</span><br><span class="line">    del_sem(sem_odd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prograss odd[%d] quit..\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_sem</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> init_val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    sem_union.val = init_val;</span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, SETVAL, sem_union) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;init semaphore error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">del_sem</span><span class="params">(<span class="type">int</span> sem_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Delete semaphore error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_p</span><span class="params">(<span class="type">int</span> sem_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;P error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_v</span><span class="params">(<span class="type">int</span> sem_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>;</span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;P error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VS Code 平台下的终端窗口使用 <code>gcc</code> 编译代码并执行，如下图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc odd_demo.c -o odd_demo</span><br><span class="line">gcc even_demo.c -o even_demo</span><br><span class="line">./even_demo  <span class="comment"># 由于 odd_demo 程序在 eve_demo 中采用 execl 方式执行，所以不需要手动执行 odd_demo ，仅执行 even_demo 即可（从偶数 0 开始计数）</span></span><br></pre></td></tr></table></figure><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/5.png" class="" title="图片描述"><p>从上图中可以看到，两个进程之间交替进行，顺序很有规律，表示我们使用信号量的控制是有效的，在后面的共享内存通信中也会用到信号量作为进程之间的同步机制，所以这一章希望大家好好学习理解和掌握。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 信号量通信原理介绍&lt;/li&gt;
&lt;li&gt;Linux 信号量通信相关 API 介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x01-Linux-信号量概述&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>5-进程间通信方式之信号通信</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1/</id>
    <published>2023-12-25T16:00:00.000Z</published>
    <updated>2023-12-27T03:11:11.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：知识点</p><ul><li>Linux 信号概述</li><li>Linux 信号通信原理</li><li>Linux 信号相关 API 函数介绍</li></ul></blockquote><h2 id="0x01-Linux信号概述"><a href="#0x01-Linux信号概述" class="headerlink" title="0x01 Linux信号概述"></a>0x01 Linux信号概述</h2><p>信号机制是一种使用信号来进行进程之间传递消息的方法，信号的全称为软中断信号，简称软中断。关于 Linux 信号的特点可以概括如下几点：</p><ul><li>信号是在软件层次上对中断机制的一种模拟。在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。</li><li>信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上进程也不知道信号到底什么时候到达。</li><li>信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。它可以在任何时候发给某一个进程，而无需知道该进程的状态。如果该信号当前并未处于执行态(Running),则该信号由内核保存起来，直到该进程恢复执行再传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。</li><li>信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事件发生了。信号机制除了基本通知外，还可以传递附加信息。</li></ul><p>在 Linux 系统内核头文件 <code>signal.h</code> 中定义有 64 种信号，这些信号都是以 <code>SIG</code> 开头，且都被定义为正整数。除了通过查看 <code>signal.h</code> 头文件能够看到信号的名字和定义外，还可以在 Linux 系统下使用命令 <code>kill -l</code> 来查看信号的名字以及序号，信号都是从 1 开始编号的，不存子 0 号信号。具体如下图所示(由于实验环境采用虚拟容器，所以执行 <code>kill -l</code> 并不会有结果显示)：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1/1.png" class="" title="图片描述"><h2 id="0x02-Linux信号通信原理"><a href="#0x02-Linux信号通信原理" class="headerlink" title="0x02 Linux信号通信原理"></a>0x02 Linux信号通信原理</h2><p>要搞清楚信号通信的原理，就需要搞清楚信号的产生、传输以及响应。</p><p>信号时间产生其实就是信号的来源，对于 Linux 操作系统来说信号的主要来源可以归纳为以下两点：</p><ul><li>硬件来源。如我们按下了键盘上的按钮 或者出现其他硬件故障；</li><li>软件来源。最常用发送信号的系统函数有 kill()、raise()、alarm()、setitimer() 和 sigqueue()等，软件来源还包括一些非法运算等操作。</li></ul><p>而对于信号在产生之后，Linux 对每个信号都有一个缺省的动作，典型的缺省动作就是终止进程，当这个信号的进程收到信号后会根据这个信号的具体情况提供以下三种不同的处理方式：</p><ul><li>忽略信号。忽略信号即对信号不做处理，其中，有两个信号不能忽略：<code>SIGKILL</code> 和 <code>SIGSTOP</code>。</li><li>捕捉信号。定义信号处理函数，当信号发生时，执行响应的处理函数。</li><li>执行默认操作。Linux 对每种信号都规定了默认操作。</li></ul><p>对应部分系统定义的信号，Linux 系统都规定了一些默认操作作为信号的响应处理，如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1/2.png" class="" title="图片描述"><p>一个完整的信号生命周期可以分为 3 个重要阶段，这 3 个阶段由 4 个重要事件来刻画的；信号产生、信号在进程中注册、信号在进程中注销、执行信号处理函数。这里信号的产生、注册、注销等是指信号的内部实现机制，而不是信号的函数实现(不受我们的掌控)。因此信号注册与否与后面讲到的发送信号函数（如 <code>kill()</code> 等）及信号安装函数（如 <code>signal()</code> 等）无关，只与信号值有关。</p><p>相邻两个事件的时间间隔构成信号生命周期的一个阶段，如下图.注意这里的信号处理有多种方式，一般是由内核完成的，当然也可以由用户进程来完成。如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1/3.png" class="" title="图片描述"><p>信号的处理包括信号的发送、捕捉和处理，它们有各自相对应的常见函数：</p><ul><li>发生信号的函数: <code>kill()</code>、<code>raise()</code></li><li>捕捉信号的函数: <code>alarm()</code>、<code>pause()</code></li><li>处理信号的函数: <code>signal()</code>、<code>sigaction()</code></li></ul><h2 id="0x03-Linux-信号相关-API-函数介绍"><a href="#0x03-Linux-信号相关-API-函数介绍" class="headerlink" title="0x03 Linux 信号相关 API 函数介绍"></a>0x03 Linux 信号相关 API 函数介绍</h2><p>前面其实已经提到了很多 Linux 信号机制相关的函数。下面就分别镜像讲解和介绍。</p><p><code>kill()</code> 函数同咱们的 <code>kill</code> 系统命令一样（但不能真的认为 <code>kill()</code> 就是 <code>kill</code>），可以发送信号给进程或进程组（实际上，<code>kill</code> 系统命令只是 <code>kill()</code> 函数的一个用户接口）。这里需要注意的是，<code>kill()</code> 函数不仅可以终止进程（实际上是通过发出 <code>SIGKILL</code> 信号终止），也可以向进程发送其他信号。具体描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    - pid：要发送信号的进程号</span></span><br><span class="line"><span class="comment">        0   信号被发送给所有和当前进程在同一进程组的进程号</span></span><br><span class="line"><span class="comment">        -1  信号发给所有的进程表中的进程（除了进程号最大的进程之外）</span></span><br><span class="line"><span class="comment">        &lt;-1 信号发送给进程组好为 -pid 的每一个进程</span></span><br><span class="line"><span class="comment">    - sig：信号</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">    成功：0 失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>与 <code>kill()</code> 函数不同的是，<code>raise()</code> 函数允许进程向自身发送信号。具体描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数</span></span><br><span class="line"><span class="comment">    - sig：信号</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">    成功：0 失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>除了上面的信号发送函数，Linux 还定义了两个信号捕捉函数用来接收信号 <code>alarm()</code> 和 <code>pause()</code> 。</p><p><code>alarm()</code> 也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它就向进程发送 <code>SIGALARM</code> 信号。要注意的是，一个进程只能有一个闹钟时间，如果在调用 <code>alarm()</code> 之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。具体描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数</span></span><br><span class="line"><span class="comment">    seconds：指定秒数，系统经过 seconds 后会向该进程发送 SIGALRM 信号</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">    成功：如果调用此 alarm() 前已经设置好闹钟时间，则返回上一个闹钟剩余时间，否则返回 0</span></span><br><span class="line"><span class="comment">    失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>pause()</code> 函数用于将调用进程挂起直至捕捉到信号为止。这个函数很常用，通常可以用于判断信号是否已到。具体描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值</span></span><br><span class="line"><span class="comment">    出错返回 -1，并设置 errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Linux 信号处理的方法主要有以下两种：</p><ul><li>使用 <code>signal()</code> 函数</li><li>使用信号集函数组</li></ul><p>使用 <code>signal()</code> 函数处理时，只需指出要处理的信号和处理函数即可。它主要用于前 32 种非实时信号的处理，不支持信号传递信息。Linux 还支持一个更健壮更新的信号处理函数呢，它就是 <code>sigaction()</code>，Unix 环境编程等书籍其实都是推荐使用这个函数。具体函数介绍如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandle_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    signum：指定信号代码</span></span><br><span class="line"><span class="comment">    handler：SIG_IGN - 忽略该信号</span></span><br><span class="line"><span class="comment">            SIG_DFL - 采用系统默认方式处理信号</span></span><br><span class="line"><span class="comment">            自定义的信号处理函数指针</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功：之前的信号处理配置  失败；-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span> signo);  <span class="comment">//函数指针，指定信号处理函数，可以是 SIG_DFL（默认处理方式）和 SIG_IGN（忽略信号）</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;   <span class="comment">//信号集，指定在处理中屏蔽哪些信号</span></span><br><span class="line">    <span class="type">int</span> sa_flags;   <span class="comment">//信号标志位，包含对信号处理的各个选择项</span></span><br><span class="line">    <span class="type">void</span> (*sa_restore)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    signum  信号代码，可以是除了 SIGKILL SIGSTOP 之外的任何一个特定有效的信号</span></span><br><span class="line"><span class="comment">    act     执行结构体 sigaction 的一个实例指针，指定对特定信号的处理</span></span><br><span class="line"><span class="comment">    oldact  保存原来对相应信号的处理</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功：0 失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用信号集函数组处理信号时设计一系列的函数，这些函数按照先后的调用次序可分为以下几大模块：创建信号集、注册信号处理函数及检测信号。</p><p>其中，创建信号集主要用于处理用户感兴趣的一些信号，其函数包括以下几个：</p><ul><li><code>sigemptyset()</code>: 将信号集初始化为空</li><li><code>sigfillset()</code>: 将信号集初始化为包含所有已定义的信号集</li><li><code>sigaddset()</code>: 将指定信号加入到信号集中</li><li><code>sigdelset()</code>: 将指定信号从信号集中删除</li><li><code>sigismember()</code>: 查询指定信号是否在信号集中</li></ul><p>注册信号处理函数主要用于决定进程如何处理信号。这里要注意的是，信号集里的信号并不是真正可以处理的信号，只有当信号的状态处于非阻塞状态时才会真正起作用。因此，首先使用 <code>sigprocmask()</code> 函数检测并更改信号屏蔽字（信号屏蔽字是用来指定当前被阻塞的一组信号，它们不会被进程接收），然后使用 <code>sigaction()</code> 函数来定义进程接收到特定信号后的行为。</p><p>检测信号是信号处理的后续步骤，因为被阻塞的信号不会传递给进程，所以这些信号就处于“未处理”状态（也就是进程不清除它的存在）。<code>sigaction()</code> 函数允许进程检测“未处理”信号，并进一步决定对它们做何处理。</p><p>具体描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    set：信号集</span></span><br><span class="line"><span class="comment">    signum：信号代码</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功：0  失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在 <code>sigprocmask()</code> 中，若 <code>set</code> 是一个非空指针，则参数 <code>how</code> 表示函数的操作方式；若 <code>how</code> 为空，则表示忽略此操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oset)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    how：</span></span><br><span class="line"><span class="comment">        SIG_BLOCK   增加一个信号集到当前进程的阻塞集中</span></span><br><span class="line"><span class="comment">        SIG_UNBLOCK 从当前的阻塞集中删除一个信号集</span></span><br><span class="line"><span class="comment">        SIG_SETMASK 将当前的信号集设置为信号阻塞集</span></span><br><span class="line"><span class="comment">    set：指定信号集</span></span><br><span class="line"><span class="comment">    oset：信号屏蔽字</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功：0 失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">    set：要检测的信号集</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">    成功：0 失败：-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>处理信号总是遵循下图所示的过程：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/5-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1/4.png" class="" title="图片描述">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：知识点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 信号概述&lt;/li&gt;
&lt;li&gt;Linux 信号通信原理&lt;/li&gt;
&lt;li&gt;Linux 信号相关 API 函数介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0x01-Linu</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-25T01:28:27.249Z</published>
    <updated>2023-12-27T07:06:00.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="除了“设计模式”，你还应该知道什么"><a href="#除了“设计模式”，你还应该知道什么" class="headerlink" title="除了“设计模式”，你还应该知道什么"></a>除了“设计模式”，你还应该知道什么</h1><p>程序员内功之设计模式🔥</p><blockquote><p>推荐学习视频<a href="https://www.bilibili.com/video/BV1W7411M7vB">C++常用设计模式</a></p></blockquote><span id="more"></span><h1 id="设计模式从何而来"><a href="#设计模式从何而来" class="headerlink" title="设计模式从何而来"></a>设计模式从何而来</h1><p>四人组（Gang of Four)，简称<mark style="color:green;font-size:30px;">GoF</mark>.</p><p>GoF将模式的概念引入软件工程领域，这标志着<mark>软件模式</mark>的诞生。软件模式（Software Pattern是）是将模式的一半概念应用于软件开发领域，即<b>软件开发的总体指导思路或参照样板</b>.</p><p>需要了解软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等。</p><blockquote><p>“软件设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可充用代码，让代码更容易被他人理解并且保证代码可靠性。”</p><div style="text-align:right;font-weight:900;font-size:20px;">——软件设计模式的定义</div></blockquote><p>一句大白话就是：“<mark>在一定环境下，用固定套路解决问题</mark>”。</p><h1 id="软件设计模式的种类"><a href="#软件设计模式的种类" class="headerlink" title="软件设计模式的种类"></a>软件设计模式的种类</h1><p><strong>GoF提出的设计模式有23个，包括：</strong></p><ul><li><p><a href="./%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><mark><a href="/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之创建型模式">设计模式之创建型模式</a></mark></a>(Creational)：如何创建对象; </p><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p><ol><li><p>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p></li><li><p>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p></li><li><p>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</p></li><li><p>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p></li><li><p>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p></li></ol></li><li><p><a href="%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F.md"><mark><a href="/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之结构型模式">设计模式之结构型模式</a></mark></a>(Structional)：如何实现类或对象的组合；</p><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，前者采用<strong>继承机制</strong>来组织接口和类，后者釆用<strong>组合或聚合</strong>来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种：</p><ol><li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li><li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li></ol></li><li><p><a href="./%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.md"><mark><a href="/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之行为型模式">设计模式之行为型模式</a></mark></a>(Behavioral)：类或对象怎样交互以及怎么分配职责。</p><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p></li></ul><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式是 GoF <a href="http://c.biancheng.net/design_pattern/">设计模式</a>中最为庞大的一类，它包含以下 11 种模式。</p><ol><li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol><p>以上 11 种行为型模式，除了模板方法模式和<a href="http://c.biancheng.net/view/1402.html">解释器模式</a>是类行为型模式，其他的全部属于对象行为型模式。</p><p>设计模式目前的种类：GoF的23种 +“简答工厂模式” = <mark>24</mark>种 </p><h1 id="软件设计模式有什么用？"><a href="#软件设计模式有什么用？" class="headerlink" title="软件设计模式有什么用？"></a>软件设计模式有什么用？</h1><p><mark>有助于更加深入地理解面向对象思想</mark>，让你知道：</p><pre><code>1. 如何将代码分散在几个不同的类中2. 为什么要有“接口”3. 何为针对抽象编程4. 合适不应该使用继承5. 如何不修改源代码增加新功能6. 更好地阅读和理解现有类库与其他系统中的源代码</code></pre><h1 id="如何学好设计模式"><a href="#如何学好设计模式" class="headerlink" title="如何学好设计模式"></a>如何学好设计模式</h1><p>设计模式的基础是：<mark style="font-size:18px">多态</mark>，参考书上给的建议就是：</p><p>初学者：积累案例，不要盲目的背类图（我就是）</p><p>初级开发人员：多思考，多梳理，归纳总结，尊重事物的认知规律，注意临界点的突破，不要浮躁。</p><p>中级开发人员：合适的开发环境，寻找合适的设计模式来解决问题。多应用，对经典的组合设计模式，大量自由的运用，要不断地追求。</p><h1 id="关于语言"><a href="#关于语言" class="headerlink" title="关于语言"></a>关于语言</h1><p>语言是基础，学习设计模式之前一定要对自己现在使用和运用的语言加以了解；熟悉、掌握多态。</p><p>C++学习者建议可以读一遍《c++ Primer Plus》，尤其是面向对象部分</p><h1 id="设计模式总览"><a href="#设计模式总览" class="headerlink" title="设计模式总览"></a>设计模式总览</h1><h2 id="创建型模式（Creational）"><a href="#创建型模式（Creational）" class="headerlink" title="创建型模式（Creational）"></a>创建型模式（Creational）</h2><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gjvts4pq4ij30k207ljs6.jpg" alt="创建型模式" width="722" data-width="722" data-height="273"><h2 id="结构型模式-Structural"><a href="#结构型模式-Structural" class="headerlink" title="结构型模式(Structural)"></a>结构型模式(Structural)</h2><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjvtri85hgj31430gttfr.jpg" alt="结构型模式" width="722" data-width="1443" data-height="605"><h2 id="行为型模式（Behavioral）"><a href="#行为型模式（Behavioral）" class="headerlink" title="行为型模式（Behavioral）"></a>行为型模式（Behavioral）</h2><img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@782567680f7acccab170d2fe9b08cfa2726c7a22/2020/10/10/388b31a1de6af885d18daa816f9342f5.png" width="722px" height="auto" alt="行为型模式"/><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><table><thead><tr><th align="center">名称</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center">单一职责原则<br />（Single Responsibility Principle,SRP)<br />⭐️⭐️⭐️⭐️</td><td align="center">类的职责单一，对外只提供一种可能，而引起类变化的原因都应该只有一个。</td></tr><tr><td align="center">开闭原则<br />（Open-Closed Principle,OCP)<br />⭐️⭐️⭐️⭐️⭐️</td><td align="center"><strong>类的改动是通过增加代码进行的，而不是修改源代码</strong></td></tr><tr><td align="center">里氏代换原则<br />(Liskov Substitution Principle,LSP)<br />⭐️⭐️⭐️⭐️⭐️</td><td align="center">任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。</td></tr><tr><td align="center">依赖倒转原则<br />（Dependence Inversion Priciple,DIP)<br />⭐️⭐️⭐️⭐️⭐️</td><td align="center"><font color=red>依赖于抽象（接口），不要依赖具体的实现（类），也就是针对接口编程。</font></td></tr><tr><td align="center">接口隔离原则<br />（Interface Segregation Principle,ISP)<br />⭐️⭐️</td><td align="center"><strong>不应该强迫用户的程序依赖他们不需要的接口方法。一个接口只提供一种对外功能，不应该把所有操作都封装到一个接口中去。</strong></td></tr><tr><td align="center">合成复用原则<br />（Composite Reuse Principle，CRP)<br />⭐️⭐️⭐️⭐️</td><td align="center">如果使用继承，会导致父类的任何变化都可能影响到子类的行为，如果使用对象组合，就降低了这种依赖关系，对于继承和类，优先使用该组合。</td></tr><tr><td align="center">迪米特法则<br />（Law of Demeter,LoD)<br />⭐️⭐️⭐️</td><td align="center">一个对象应当对其他对象尽可能少的了解,从而降低各个对象之间的耦合,提高系统的可维护性。例如在一个程序中,各个模块之间相互调用时,通常会提供- -个统- -的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节, 这样当一个模块内部的实现发生改变时,不会影响其他模块的使用。( 黑盒原理)</td></tr></tbody></table><blockquote><p>借鉴了《Easy搞定设计模式》</p></blockquote>]]></content>
    
    
    <summary type="html">学习设计模式之前需要知道什么？</summary>
    
    
    
    <category term="A_内功" scheme="http://example.com/categories/A-%E5%86%85%E5%8A%9F/"/>
    
    <category term="B_设计模式" scheme="http://example.com/categories/A-%E5%86%85%E5%8A%9F/B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型模式" scheme="http://example.com/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之行为型模式</title>
    <link href="http://example.com/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-25T01:28:27.247Z</published>
    <updated>2023-12-27T08:02:55.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><blockquote><p>学习笔记之C++设计模式——创建型模式</p><p>📑 <a href="/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之结构型模式">设计模式之结构型模式</a> <br></p><p>📑 <a href="/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之创建型模式">设计模式之创建型模式</a></p></blockquote><p>总的来说，行为型模式就是用来对类或对象怎样交互和怎样分配职责进行描述。</p><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><div class="tag-plugin image"><div class="image-bg"><img src="../../../images/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/model.svg" fancybox="true"/></div></div><p><mark style="background:green;border-radius:10px;color:white;padding:0px 3px">AbstractClass（抽象类）：</mark>在抽象类中定义了一系列基本操作（PrimitiveOperations），这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法（Template Method），用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</p><p><mark style="background:green;border-radius:10px;color:white;padding:0px 3px">ConcreteClass（具体子类）：</mark>它是抽象类的子类，用于是现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中的已经实现的具体基本操作。</p><h2 id="模板方法案例"><a href="#模板方法案例" class="headerlink" title="模板方法案例"></a>模板方法案例</h2><div class="tag-plugin image"><div class="image-bg"><img src="../../../images/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/model_demo.svg" fancybox="true"/></div></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板方法.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 制作饮料</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 煮水</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BoilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;烧开水&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 冲泡 特殊接口</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 倒入杯中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PourinVup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加料 特殊接口</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddCondiments</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook 方法，决定某些算法步骤是否挂钩在算法中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">CustomWantsCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrepareBeverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">BoilWater</span>();</span><br><span class="line"><span class="built_in">Brew</span>();</span><br><span class="line"><span class="built_in">PourinVup</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CustomWantsCondiments</span>()) &#123;</span><br><span class="line"><span class="built_in">AddCondiments</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> Beverage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡豆&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;添加糖和牛奶&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> Beverage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;添加柠檬&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Beverage *pTea = <span class="keyword">new</span> Tea;</span><br><span class="line">pTea-&gt;<span class="built_in">PrepareBeverage</span>();</span><br><span class="line"><span class="keyword">delete</span> pTea;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Beverage *pCoffee = <span class="keyword">new</span> Tea;</span><br><span class="line">pCoffee-&gt;<span class="built_in">PrepareBeverage</span>();</span><br><span class="line"><span class="keyword">delete</span> pCoffee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><div style="background:black;font:conloas;color:white;">烧开水<br>冲泡茶叶<br>倒入杯中<br>添加柠檬<br>-----------------------<br>烧开水<br>冲泡茶叶<br>倒入杯中<br>添加柠檬<br>请按任意键继续. . .    </div>## 模板方法的优缺点<ol><li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</li><li>模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</li><li>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</li><li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则</li></ol><p>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li><p>具有统一的操作步骤或操作过程；</p></li><li><p>具有不同的操作细节；</p></li><li><p>存在多个具有同样操作步骤的应用场景，但某些具体的操作细节却各不相同</p></li></ol><blockquote><p>在抽象类中统一操作步骤，并规定好接口；让子类实现接口。这样可以吧各个具体的子类和操作步骤解耦合。</p></blockquote><hr><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为模式，其别名为动作(Action)模式或事务（Tranaction）模式。</p><p>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令模式.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Doctor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">treat_eye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;医生 治疗 眼科病&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">treat_nose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;医生 治疗 鼻科病&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandTreatEye</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CommandTreatEye</span>(Doctor *doctor) &#123;</span><br><span class="line">m_doctor = doctor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">treat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_doctor-&gt;<span class="built_in">treat_eye</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Doctor *m_doctor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandTreatNose</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CommandTreatNose</span>(Doctor *doctor) &#123;</span><br><span class="line">m_doctor = doctor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">treat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_doctor-&gt;<span class="built_in">treat_nose</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Doctor *m_doctor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 医生直接看病</span></span><br><span class="line">Doctor *doctor = <span class="keyword">new</span> Doctor;</span><br><span class="line">doctor-&gt;<span class="built_in">treat_eye</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> doctor;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过医疗指令来看病</span></span><br><span class="line"></span><br><span class="line">Doctor *doctorCmd = <span class="keyword">new</span> Doctor;</span><br><span class="line">CommandTreatEye * cmdEyeDoc = <span class="keyword">new</span> <span class="built_in">CommandTreatEye</span>(doctorCmd);</span><br><span class="line">cmdEyeDoc-&gt;<span class="built_in">treat</span>();</span><br><span class="line"><span class="keyword">delete</span> cmdEyeDoc;</span><br><span class="line"></span><br><span class="line">CommandTreatNose *cmdNoseDoc = <span class="keyword">new</span> <span class="built_in">CommandTreatNose</span>(doctorCmd);</span><br><span class="line">cmdNoseDoc-&gt;<span class="built_in">treat</span>();</span><br><span class="line"><span class="keyword">delete</span> cmdNoseDoc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> doctorCmd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><div style="background:black;font:conloas;color:white;">医生 治疗 眼科病<br>-----------------<br>医生 治疗 眼科病<br>医生 治疗 鼻科病<br>请按任意键继续. . .</div>> 命令模式的本质是对请求进行封装对应于一个命令，将发出命令的责任和执行命令的责任分割开。<h2 id="命令模式中的角色和职责"><a href="#命令模式中的角色和职责" class="headerlink" title="命令模式中的角色和职责"></a>命令模式中的角色和职责</h2><div class="tag-plugin image"><div class="image-bg"><img src="../../../images/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/cmd.svg" fancybox="true"/></div></div><hr><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><hr><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;行为型模式&quot;&gt;&lt;a href=&quot;#行为型模式&quot; class=&quot;headerlink&quot; title=&quot;行为型模式&quot;&gt;&lt;/a&gt;行为型模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;学习笔记之C++设计模式——创建型模式&lt;/p&gt;
&lt;p&gt;📑 &lt;a href=&quot;/A_%E5</summary>
      
    
    
    
    <category term="A_内功" scheme="http://example.com/categories/A-%E5%86%85%E5%8A%9F/"/>
    
    <category term="B_设计模式" scheme="http://example.com/categories/A-%E5%86%85%E5%8A%9F/B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之结构型模式</title>
    <link href="http://example.com/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-25T01:28:27.245Z</published>
    <updated>2023-12-27T08:02:45.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><blockquote><p> 学习笔记之C++设计模式——创建型模式</p><p>📑 <a href="/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之创建型模式">设计模式之创建型模式</a> <br></p><p>📑 <a href="/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之行为型模式">设计模式之行为型模式</a></p></blockquote><p>Proxy模式又叫做代理模式，是构造型的设计模式之一， 它可以为其他对象提供-种代理( Proxy )以控制对这个对象的访问。所谓代理，是指具有与代理元(被代理的对象)具有相同的接口的类，客户端必须通过代理与被代理的目标类交互，而代理一-般在交互的过程中 (交互前后) , 进行某些特别的处理。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><div class="tag-plugin image"><div class="image-bg"><img src="../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211126115058411.png" fancybox="true"/></div></div><p>通俗理解就和海外代购类似，由一个海外代购专门负责所有需要从其他国家购买的这个行为。</p><p>以下为代理模式案例及其代码：<div class="tag-plugin image"><div class="image-bg"><img src="../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/proxy_demo.png" fancybox="true"/></div></div></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理模式.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Item</span>(string kind, <span class="type">bool</span> fact) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;kind = kind;</span><br><span class="line"><span class="keyword">this</span>-&gt;fact = fact;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">getKind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> kind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getFact</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fact;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string kind;</span><br><span class="line"><span class="type">bool</span> fact;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象的购物方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shopping</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buy</span><span class="params">(Item *it)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KoeraShopping</span> : <span class="keyword">public</span> Shopping</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(Item *it)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;去韩国买了&quot;</span> &lt;&lt; it-&gt;<span class="built_in">getKind</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USAShopping</span> : <span class="keyword">public</span> Shopping</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(Item * it)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;去美国买了&quot;</span> &lt;&lt; it-&gt;<span class="built_in">getKind</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 海外代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OverseasProxy</span> : <span class="keyword">public</span> Shopping</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">OverseasProxy</span>(Shopping *shopping)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;shopping = shopping;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buy</span><span class="params">(Item *it)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;<span class="built_in">getFact</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;发现正品&quot;</span> &lt;&lt; endl;</span><br><span class="line">shopping-&gt;<span class="built_in">buy</span>(it);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------安检-----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;发现假货&quot;</span> &lt;&lt; it-&gt;<span class="built_in">getKind</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Shopping *shopping; <span class="comment">// 有一个购物方式</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Item <span class="title">it1</span><span class="params">(<span class="string">&quot;nike鞋子&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">Item <span class="title">it2</span><span class="params">(<span class="string">&quot;CET4证书&quot;</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Shopping *Koerashopping = <span class="keyword">new</span> KoeraShopping;</span><br><span class="line">Shopping *usaShopping = <span class="keyword">new</span> USAShopping;</span><br><span class="line"></span><br><span class="line">Shopping *overseaProxy = <span class="keyword">new</span> <span class="built_in">OverseasProxy</span>(usaShopping);</span><br><span class="line"></span><br><span class="line">overseaProxy-&gt;<span class="built_in">buy</span>(&amp;it1);</span><br><span class="line">overseaProxy-&gt;<span class="built_in">buy</span>(&amp;it2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代理模式的种类"><a href="#代理模式的种类" class="headerlink" title="代理模式的种类"></a>代理模式的种类</h2><h3 id="远程代理（Remote-Proxy）"><a href="#远程代理（Remote-Proxy）" class="headerlink" title="远程代理（Remote Proxy）"></a>远程代理（Remote Proxy）</h3><p>为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另外一台主机中，远程代理又称为大使（Ambassador）。</p><p>远程代理： 使得<b>客户端程序可以访问在远程主机上的对象</b>，远程主机可能具有更好的计算性能与处理速度，可以快速相应并处理客户端的请求。远程代理可以<b>将网络的细节隐藏起来，使得客户端不必考虑网络的存在</b>。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。</p><div class="tag-plugin image"><div class="image-bg"><img src="../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/RemoteProxy.png" fancybox="true"/></div></div><blockquote><p>如图所示: </p><p>客户端对象不能直接访问远程主机中的业务对象，只能采取间接访问的方式。远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端对象而言是透明的。客户端无须关心实现具体业务的是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。</p></blockquote><p>在基于<code>.NET</code>平台的分布式技术，例如DCOM（Distribute Component Object Mdoel， 分布式组件对象模型）、Web Service中，都应用了远程代理模式。</p><h3 id="虚拟代理（Virtual-Proxy）"><a href="#虚拟代理（Virtual-Proxy）" class="headerlink" title="虚拟代理（Virtual Proxy）"></a>虚拟代理（Virtual Proxy）</h3><p>如果需要创建一个资源消耗巨大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。虚拟代理(Virtual Proxy)也是一种常用的代理模式，<strong>对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理</strong>。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。</p><p>通常，在以下两种情况下可以考虑使用虚拟代理：</p><p><strong>(1) 由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象</strong>。通常在实现时可以结合多线程技术，一个线程用于显示代理对象，其他线程用于加载真实对象。这种虚拟代理模式可以应用在程序启动的时候，由于创建代理对象在时间和处理复杂度上要少于创建真实对象，因此，在程序启动时，可以用代理对象代替真实对象初始化，大大加速了系统的启动时间。当需要使用真实对象时，再通过代理对象来引用，而此时真实对象可能已经成功加载完毕，可以缩短用户的等待时间。</p><p><strong>(2) 当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理</strong>。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。为了节省内存，在第一次引用真实对象时再创建对象，并且该对象可被多次重用，在以后每次访问时需要检测所需对象是否已经被创建，因此在访问该对象时需要进行存在性检测，这需要消耗一定的系统时间，但是可以节省内存空间，这是一种用时间换取空间的做法。</p><p>无论是以上哪种情况，虚拟代理都是用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能。</p><h3 id="保护代理（Protect-Proxy）"><a href="#保护代理（Protect-Proxy）" class="headerlink" title="保护代理（Protect Proxy）"></a>保护代理（Protect Proxy）</h3><p>控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限</p><h3 id="缓冲代理（Cache-Proxy）"><a href="#缓冲代理（Cache-Proxy）" class="headerlink" title="缓冲代理（Cache Proxy）"></a>缓冲代理（Cache Proxy）</h3><p>为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果</p><p>缓冲代理(Cache Proxy)也是一种较为常用的代理模式，它<strong>为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而可以避免某些方法的重复执行，优化系统性能。</strong></p><h3 id="智能引用代理（Smart-Reference-Proxy）"><a href="#智能引用代理（Smart-Reference-Proxy）" class="headerlink" title="智能引用代理（Smart Reference Proxy）"></a>智能引用代理（Smart Reference Proxy）</h3><p>当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</p><h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><blockquote><p>装饰模式（decorator Pattern）: 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</p></blockquote><div class="tag-plugin image"><div class="image-bg"><img src="../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211126115029214.png" fancybox="true"/></div></div><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><div class="tag-plugin image"><div class="image-bg"><img src="../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/Decorator_Demo.png" fancybox="true"/></div></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰模式.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个抽象的构件，他是具体构件和抽象装饰类的父类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的构件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">iPhone</span> : <span class="keyword">public</span> Phone</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">iPhone</span>(string kind) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;kind = kind;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;秀出了 iPhone- &quot;</span> &lt;&lt; kind &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string kind;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的构件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mi</span> : <span class="keyword">public</span> Phone</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Mi</span>(string kind) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;kind = kind;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;秀出了 Mi-&quot;</span> &lt;&lt; kind &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string kind;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象的手机装饰类，必须包含抽象的构件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeCoratorPhone</span> : <span class="keyword">public</span> Phone</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DeCoratorPhone</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DeCoratorPhone</span>(Phone *phone) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;phone = phone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;phone-&gt;<span class="built_in">Show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Phone *phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeCoratorPhoneMo</span> : <span class="keyword">public</span> DeCoratorPhone &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DeCoratorPhoneMo</span>(Phone *phone) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;phone = phone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;phone-&gt;<span class="built_in">Show</span>();</span><br><span class="line"><span class="built_in">addMo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addMo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;装饰: 手机贴膜&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Phone *phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeCoratorPhoneKe</span> : <span class="keyword">public</span> DeCoratorPhone &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DeCoratorPhoneKe</span>(Phone *phone) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;phone = phone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;phone-&gt;<span class="built_in">Show</span>();</span><br><span class="line"><span class="built_in">addMo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addMo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;装饰: 手机装保护壳&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Phone *phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Phone *phone = <span class="literal">NULL</span>;</span><br><span class="line">DeCoratorPhone * hasMoPhone = <span class="literal">NULL</span>;</span><br><span class="line">DeCoratorPhone * hasKePhone = <span class="literal">NULL</span>;</span><br><span class="line">DeCoratorPhone * hasMoKePhone = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Iphone 13手机</span></span><br><span class="line">phone = <span class="keyword">new</span> <span class="built_in">iPhone</span>(<span class="string">&quot;iPhone 13&quot;</span>);</span><br><span class="line"><span class="comment">// 给普通iphone 加上贴膜</span></span><br><span class="line">hasMoPhone = <span class="keyword">new</span> <span class="built_in">DeCoratorPhoneMo</span>(phone);</span><br><span class="line"><span class="comment">// 给普通iphone 加上保护套</span></span><br><span class="line">hasKePhone = <span class="keyword">new</span> <span class="built_in">DeCoratorPhoneKe</span>(phone);</span><br><span class="line">hasMoPhone-&gt;<span class="built_in">Show</span>();</span><br><span class="line">hasKePhone-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给有皮套的iphone 加上贴膜</span></span><br><span class="line">hasMoKePhone = <span class="keyword">new</span> <span class="built_in">DeCoratorPhoneMo</span>(hasKePhone);</span><br><span class="line">hasMoKePhone-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> hasMoKePhone;</span><br><span class="line"><span class="keyword">delete</span> hasKePhone;</span><br><span class="line"><span class="keyword">delete</span> hasMoPhone;</span><br><span class="line"><span class="keyword">delete</span> phone;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">phone = <span class="keyword">new</span> <span class="built_in">Mi</span>(<span class="string">&quot;Mix 4&quot;</span>);</span><br><span class="line">hasMoPhone = <span class="keyword">new</span> <span class="built_in">DeCoratorPhoneMo</span>(phone);</span><br><span class="line">hasKePhone = <span class="keyword">new</span> <span class="built_in">DeCoratorPhoneKe</span>(phone);</span><br><span class="line">hasMoPhone-&gt;<span class="built_in">Show</span>();</span><br><span class="line">hasKePhone-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">hasMoKePhone = <span class="keyword">new</span> <span class="built_in">DeCoratorPhoneKe</span>(hasKePhone);</span><br><span class="line">hasMoKePhone-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> hasMoKePhone;</span><br><span class="line"><span class="keyword">delete</span> hasKePhone;</span><br><span class="line"><span class="keyword">delete</span> hasMoPhone;</span><br><span class="line"><span class="keyword">delete</span> phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><div style="background:black;font:conloas;color:white;">秀出了 iPhone- iPhone 13:<br>装饰: 手机贴膜<br>秀出了 iPhone- iPhone 13:<br>装饰: 手机装保护壳<br>秀出了 iPhone- iPhone 13:<br>装饰: 手机装保护壳<br>装饰: 手机贴膜<br>秀出了 Mi-Mix 4:<br>装饰: 手机贴膜<br>秀出了 Mi-Mix 4:<br>装饰: 手机装保护壳<br>秀出了 Mi-Mix 4:<br>装饰: 手机装保护壳<br>装饰: 手机装保护壳<br>请按任意键继续. . .</div>## 装饰模式的优缺点<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。</li><li>可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为。</li><li>可以对一个对象进行多次装饰。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无需改变，符合“开闭原则”。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>使用装饰模式进行系统设计时产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能。</li></ol><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li>动态、透明的方式给耽搁对象添加职责</li><li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。</li></ol><p>装饰器模式关注于在一个对象上动态的添加方法。然而代理模式关注于控制对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将院士对象作为一个参数创给装饰者的构造器。</p><hr><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>根据<span class="dimitt">迪米特法则<span>，如果两个类不必彼此直接通信，那么两个类就不应当发生直接的相互作用。</p><blockquote><p>一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。</p><p>例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个木块的内部实现细节，当一个模块内部的实现发生改变是，不会影响其他模块的使用。（黑盒原理）。</p></blockquote><p>Facade模式也叫外观模式。是有GoF提出的23中设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库、子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。</p><div class="tag-plugin image"><div class="image-bg"><img src="../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211126115120902.png" fancybox="true"/></div></div><p>Facade(外观角色): 为调用方，定义简单的调用接口</p><p>SubSystem(子系统角色): 功能提供者。指提供功能的类群（模块或子系统）。</p><p>更加具体的理解直接看代码就能明白。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外观模式.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">外观模式就是将复杂的子类系统抽象到同一个的接口进行管理</span></span><br><span class="line"><span class="comment">外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里定义四个字了系统</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystem1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Methor1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子系统方法一&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystem2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Methor2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子系统方法二&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystem3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Methor3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子系统方法三&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubSystem4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Methor4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子系统方法四&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 外观类，接口 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Facade</span>()</span><br><span class="line">&#123;</span><br><span class="line">one = <span class="keyword">new</span> SubSystem1;</span><br><span class="line">two = <span class="keyword">new</span> SubSystem2;</span><br><span class="line">three = <span class="keyword">new</span> SubSystem3;</span><br><span class="line">four = <span class="keyword">new</span> SubSystem4;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Facade</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> one;</span><br><span class="line"><span class="keyword">delete</span> two;</span><br><span class="line"><span class="keyword">delete</span> three;</span><br><span class="line"><span class="keyword">delete</span> four;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MethorA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;方法组A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">one-&gt;<span class="built_in">Methor1</span>();</span><br><span class="line">two-&gt;<span class="built_in">Methor2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MethorB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;方法组B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">three-&gt;<span class="built_in">Methor3</span>();</span><br><span class="line">four-&gt;<span class="built_in">Methor4</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">SubSystem1 *one;</span><br><span class="line">SubSystem2 *two;</span><br><span class="line">SubSystem3 *three;</span><br><span class="line">SubSystem4 *four;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Facade facade;</span><br><span class="line">facade.<span class="built_in">MethorA</span>();</span><br><span class="line">facade.<span class="built_in">MethorB</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><div style="background:black;font:conloas;color:white;">方法组A()<br>子系统方法一<br>子系统方法二<br>方法组B()<br>子系统方法三<br>子系统方法四<br>请按任意键继续. . .</div><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><div class="tag-plugin image"><div class="image-bg"><img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211128175348971.png" fancybox="true"/></div></div><p>外观模式较为简单，实现上述模式依次实现电视、灯、音响、麦克风、DVD、游戏机即可，在此基础上实现外观类Facade（家庭影院）即可。</p><h2 id="外观模式的优缺点"><a href="#外观模式的优缺点" class="headerlink" title="外观模式的优缺点"></a>外观模式的优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>他对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，<mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">客户端代码将变得很简单，预支关联的对象也很少。</mark></li><li>它实现了子系统与客户端之间的松耦合关系，这使得<mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</mark></li><li><mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">一个子系统的修改对其他子系统没有任何影响。</mark></li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</li></ol><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li>复杂系统需要简单入口使用。</li><li>客户端程序与多个子系统之间存在很大的依赖性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ol><hr><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><blockquote><p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><h2 id="适配器模式中的角色和职责"><a href="#适配器模式中的角色和职责" class="headerlink" title="适配器模式中的角色和职责"></a>适配器模式中的角色和职责</h2><div class="tag-plugin image"><div class="image-bg"><img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211128180531951.png" fancybox="true"/></div></div><ol><li>Target（目标抽象类）：目标抽象类定义客户所需接口，可以使一个抽象类或接口，也可以是具体类。</li><li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，他通过继承Target并关联一个Adaptee对象使二者产生联系。</li><li>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li></ol><p>根据对象适配器模式结构图，在对象适配器中，客户端需要调用<code>request()</code>方法，而适配者类Adaptee没有该方法，但是它所提供的<code>SpecificRequest()</code>方法确实客户端所需要的。为了是客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的<code>Request()</code>方法中调用适配者的<code>SpecificRequest()</code>方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式。</p><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><div class="tag-plugin image"><div class="image-bg"><img src="../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211128184458560.png" fancybox="true"/></div></div><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器模式.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// target</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V5</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">uesV5</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V220</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">useV220</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;用220V电压进行充电&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter 充电器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChargerAdapter</span> : <span class="keyword">public</span> V5</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">uesV5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;充电器对电压进行适配&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_p220V.<span class="built_in">useV220</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">V220 m_p220V;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">v5Adapter = <span class="keyword">new</span> ChargerAdapter;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (v5Adapter != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> v5Adapter;</span><br><span class="line">v5Adapter = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;手机进行充电&quot;</span> &lt;&lt; endl;</span><br><span class="line">v5Adapter-&gt;<span class="built_in">uesV5</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 5v 手机充电器</span></span><br><span class="line">V5 *v5Adapter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Phone iphone;</span><br><span class="line">iphone.<span class="built_in">charge</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><div style="background:black;font:conloas;color:white;">手机进行充电<br>充电器对电压进行适配<br>用220V电压进行充电<br>请按任意键继续. . .</div><h2 id="适配器模式的优缺点"><a href="#适配器模式的优缺点" class="headerlink" title="适配器模式的优缺点"></a>适配器模式的优缺点</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ol><li><mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">将目标类和适配者类解耦。</mark>通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。</li><li><mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">增加了类的透明性和复用性。</mark>将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li><li><mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">灵活性和扩展性都非常好。</mark>可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ol><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol><li>适配器中置换适配者类的某些方法比较麻烦。</li></ol><h2 id="适应场景"><a href="#适应场景" class="headerlink" title="适应场景"></a>适应场景</h2><ol><li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</li><li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ol><p>到此，设计模式之结构型模式。over~~~😀🌝</p><div class="tag-plugin image"><div class="image-bg"><img src="https://dl4.weshineapp.com/gif/20210717/aef09ea5e8400a6b49fece64c6c360fc.gif?f=micro_" fancybox="true"/></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构型模式&quot;&gt;&lt;a href=&quot;#结构型模式&quot; class=&quot;headerlink&quot; title=&quot;结构型模式&quot;&gt;&lt;/a&gt;结构型模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 学习笔记之C++设计模式——创建型模式&lt;/p&gt;
&lt;p&gt;📑 &lt;a href=&quot;/A_%E</summary>
      
    
    
    
    <category term="A_内功" scheme="http://example.com/categories/A-%E5%86%85%E5%8A%9F/"/>
    
    <category term="B_设计模式" scheme="http://example.com/categories/A-%E5%86%85%E5%8A%9F/B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之创建型模式</title>
    <link href="http://example.com/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-25T01:28:27.242Z</published>
    <updated>2023-12-27T08:02:39.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p> 学习笔记之C++设计模式——创建型模式</p><p>📑 <a href="/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之结构型模式">设计模式之结构型模式</a> <br></p><p>📑 <a href="/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之行为型模式">设计模式之行为型模式</a></p></blockquote><span id="more"></span><h1 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个水果抽象类。供具体水果实现，和工厂使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> : <span class="keyword">public</span> Fruit&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是苹果&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span> : <span class="keyword">public</span> Fruit &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是香蕉&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象的工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Fruit  * <span class="title">createFruit</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过具体的某一产品的工厂生产某种产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppleFactory</span> : <span class="keyword">public</span> AbstractFactory </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Fruit * <span class="title">createFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Apple;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BananaFactory</span> : <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Fruit * <span class="title">createFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Banana;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//来一个香蕉工厂</span></span><br><span class="line">AbstractFactory * bananaFactory = <span class="keyword">new</span> BananaFactory;</span><br><span class="line"><span class="comment">//给我来一个水果</span></span><br><span class="line">Fruit * banana = bananaFactory-&gt;<span class="built_in">createFruit</span>();</span><br><span class="line">banana-&gt;<span class="built_in">getName</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> bananaFactory;</span><br><span class="line"><span class="keyword">delete</span> banana;</span><br><span class="line"></span><br><span class="line">AbstractFactory * appleFactory = <span class="keyword">new</span> AppleFactory;</span><br><span class="line">Fruit * apple = appleFactory-&gt;createFruit;</span><br><span class="line">apple-&gt;<span class="built_in">getName</span>(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvttbzuvuj30ih0a2dhy.jpg" alt="工厂模式" width="665" data-width="665" data-height="362"><h2 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>不需要记住具体类名，甚至连具体参数都不用记忆。</li><li>实现了对象创建和使用的分离。</li><li>系统的可扩展性也就变得个非常好，无需修改接口和原类。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><p>增加系统中类的个数，复杂度和理解度增加。</p></li><li><p>增加了系统的抽象性和理解难度。</p></li></ol><h1 id="二、抽象工厂模式"><a href="#二、抽象工厂模式" class="headerlink" title="二、抽象工厂模式"></a>二、抽象工厂模式</h1><blockquote><p>工厂方法模式通过引入工厂等级结构,解决了简单工厂模式中工厂类职责太重的问题,但<mark>由于工厂方法模式中的每个工厂只生产-产品，可能会导致系统中存在大量的工厂类,势必会增加系统的开销</mark>。此时,我们可以考虑将一些相关的产品组成一个”产品族”, 由同-个工厂来统-生产,这就是我们本文将要学习的抽象工厂模式的基本思想。</p></blockquote><h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gjvttp6a05j30l90n2k08.jpg" alt="抽象工厂模式" width="765" data-width="765" data-height="830"><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//抽象产品类 供具体产地产品实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractApple</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractBanana</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractPear</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USAApple</span> : <span class="keyword">public</span> AbstractApple &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;美国苹果&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChinaApple</span> : <span class="keyword">public</span> AbstractApple &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;中国苹果&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JapanApple</span> : <span class="keyword">public</span> AbstractApple &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;日本苹果&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USABanana</span> : <span class="keyword">public</span> AbstractBanana &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;美国香蕉&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChinaBanana</span> : <span class="keyword">public</span> AbstractBanana &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;中国香蕉&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JapanBanana</span> : <span class="keyword">public</span> AbstractBanana &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;日本香蕉&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USAPear</span> : <span class="keyword">public</span> AbstractPear &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;美国鸭梨&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChinaPear</span> : <span class="keyword">public</span> AbstractPear &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;中国鸭梨&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JapanPear</span> : <span class="keyword">public</span> AbstractPear &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;日本鸭梨&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象的工厂类，供具体产品族的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractApple * <span class="title">creatApple</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractBanana * <span class="title">creatBanana</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractPear * <span class="title">creatPear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体的工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USAFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractApple * <span class="title">creatApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> USAApple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractBanana * <span class="title">creatBanana</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> USABanana;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractPear * <span class="title">creatPear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> USAPear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChinaFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractApple * <span class="title">creatApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ChinaApple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractBanana * <span class="title">creatBanana</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ChinaBanana;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractPear * <span class="title">creatPear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ChinaPear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JapanFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractApple * <span class="title">creatApple</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JapanApple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractBanana * <span class="title">creatBanana</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JapanBanana;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractPear * <span class="title">creatPear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JapanPear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//现在要准备一个 中国的苹果，中国的香蕉</span></span><br><span class="line">AbstractApple *AA = <span class="literal">NULL</span>;</span><br><span class="line">AbstractBanana *AB = <span class="literal">NULL</span>;</span><br><span class="line">AbstractPear *AP = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AbstractFactory *factory = <span class="literal">NULL</span>;</span><br><span class="line">factory = <span class="keyword">new</span> ChinaFactory;</span><br><span class="line"><span class="comment">//中国的苹果</span></span><br><span class="line">AA = factory-&gt;<span class="built_in">creatApple</span>();</span><br><span class="line"><span class="comment">//中国的香蕉</span></span><br><span class="line">AB = factory-&gt;<span class="built_in">creatBanana</span>();</span><br><span class="line">AP = factory-&gt;<span class="built_in">creatPear</span>();</span><br><span class="line">    </span><br><span class="line">AA-&gt;<span class="built_in">getName</span>();</span><br><span class="line">AB-&gt;<span class="built_in">getName</span>();</span><br><span class="line">AP-&gt;<span class="built_in">getName</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> AA;</span><br><span class="line"><span class="keyword">delete</span> AB;</span><br><span class="line"><span class="keyword">delete</span> AP;</span><br><span class="line">    <span class="keyword">delete</span> factory;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>抽象工厂模式不符合“开闭原则”</p></blockquote><h2 id="抽象工厂模式的优缺点"><a href="#抽象工厂模式的优缺点" class="headerlink" title="抽象工厂模式的优缺点"></a>抽象工厂模式的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>拥有工厂方法模式的优点</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li><li>增加新的产品族很方便，无需修改已有系统，符合“开闭原则”。</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>增加新的产品结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，带来较大的不便，违背了“开闭原则”。</li></ol><p>抽象模式的应用：可以自己写一个计算机产品相关</p><blockquote><p>简单工厂模式 + “开闭原则” &#x3D; 工厂方法模式</p><p>工厂方法模式 + “产品族” &#x3D; 抽象工厂模式</p><p>简单工厂模式（规模较小的模型）</p><p>工厂方法模式（中等）</p><p>抽象工厂模式（复杂的）</p></blockquote><p>借鉴了《Easy搞定设计模式》</p><h1 id="三-单例模式"><a href="#三-单例模式" class="headerlink" title="三 单例模式"></a>三 单例模式</h1><blockquote><p>保证一个类、只有一个实例存在，同时提供能对该实例加以访问的的全局访问方法。</p></blockquote><h2 id="三个要点："><a href="#三个要点：" class="headerlink" title="三个要点："></a>三个要点：</h2><p>一是某个类只能有一个实例；</p><p>二是它必须自行创建这个实例；</p><p>三是它必须自行向整个系统提供这个实例。</p><div class="tag-plugin image"><div class="image-bg"><img src="../../../images/创建型模式/UML类图.png" fancybox="true"/></div></div><h2 id="角色和职责"><a href="#角色和职责" class="headerlink" title="角色和职责"></a>角色和职责</h2><p>Singleton（单例）：在单例类的内部实现只生成一个实例，同时是他提供一个静态的getInstance()方法，让客户可以访问他的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个<code>Singleton</code>类型的静态对象，作为外部共享的唯一实例。</p><h2 id="单例模式的使用步骤"><a href="#单例模式的使用步骤" class="headerlink" title="单例模式的使用步骤"></a>单例模式的使用步骤</h2><ol><li>构造函数私有化</li><li>提供一个全局的静态方法（全局访问点） 来获取单例对象。</li><li>在类中定义一个静态指针，指向本类的变量的静态变量指针</li></ol><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>主要就是为了只让类只有一个实例而把构造函数私有化。定义一个全局的静态实例。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">三个步骤：</span></span><br><span class="line"><span class="comment">1.构造函数私有化（为了不让在类的外部再创建多余的实例）</span></span><br><span class="line"><span class="comment">2.提供一个全局的静态类指针指向唯一实例</span></span><br><span class="line"><span class="comment">3.提供一个全局的静态函数获取实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 静态类函数 返回静态实例</span></span><br><span class="line"><span class="function"><span class="type">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//不让类的外部创建实例</span></span><br><span class="line"><span class="built_in">Singleton</span>() &#123;</span><br><span class="line">Singleton *single = <span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton <span class="title">getsingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> Singleton * instance; <span class="comment">//指向本类的唯一实例指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//静态类变量在类外初始化</span></span><br><span class="line">Singleton*Singleton::instance = <span class="keyword">new</span> Singleton;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过getInstance()获取实例</span></span><br><span class="line">Singleton * s1 = Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>在程序执行期间再去判断是否需要实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//提供一个返回实例的方法</span></span><br><span class="line"><span class="function"><span class="type">static</span> Singleton1 * <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不确定程序在编译期间是否需要实例</span></span><br><span class="line">        <span class="comment">// 如果是多线程下，需要在这里加锁</span></span><br><span class="line"><span class="keyword">if</span> (instance1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">instance1 = <span class="keyword">new</span> Singleton1;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Singleton1&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> instance1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton1</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> Singleton1 *instance1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//懒汉式的初始化方式 饿汉式在初始化时已经指向了singleton</span></span><br><span class="line">Singleton1 * Singleton1::instance1 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p> 针对单例模式去判断是否是同一实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Singleton *s1 = Singleton::<span class="built_in">getinstace</span>();</span><br><span class="line">Singleton *s2 = Singleton::<span class="built_in">getinstace</span>();</span><br><span class="line"><span class="keyword">if</span> (s1 == s2 )</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 == s2&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 != s2&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="单例模式的应用——打印机"><a href="#单例模式的应用——打印机" class="headerlink" title="单例模式的应用——打印机"></a>单例模式的应用——打印机</h2><p>用单例模式实现一个打印机程序，用以记录打印的次数和内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Printer * <span class="title">getinstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打印的内容为：&quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">sequence++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打印机今天使用了&quot;</span> &lt;&lt; sequence &lt;&lt; <span class="string">&quot;次&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义一个类去析构单例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Garbo</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">~<span class="built_in">Garbo</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (instance != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> Garbo garbo; <span class="comment">// 在静态区域开辟一个对象，Garbo</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sequence;</span><br><span class="line"><span class="type">static</span> Printer * instance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Printer::sequence = <span class="number">0</span>;</span><br><span class="line">Printer *Printer::instance = <span class="keyword">new</span> Printer;</span><br><span class="line">Printer::Garbo Printer::garbo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//三个peple使用打印机</span></span><br><span class="line">Printer * p1 = Printer::<span class="built_in">getinstance</span>();</span><br><span class="line">p1-&gt;<span class="built_in">print</span>(<span class="string">&quot;亿封简历&quot;</span>);</span><br><span class="line"></span><br><span class="line">Printer *p2 = Printer::<span class="built_in">getinstance</span>();</span><br><span class="line">p2-&gt;<span class="built_in">print</span>(<span class="string">&quot;一份工作汇报&quot;</span>);</span><br><span class="line"></span><br><span class="line">Printer *p3 = Printer::<span class="built_in">getinstance</span>();</span><br><span class="line">p3-&gt;<span class="built_in">print</span>(<span class="string">&quot;离职申请&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上就是几种常见的创建型设计模式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 学习笔记之C++设计模式——创建型模式&lt;/p&gt;
&lt;p&gt;📑 &lt;a href=&quot;/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/&quot; title=&quot;设计模式之结构型模式&quot;&gt;设计模式之结构型模式&lt;/a&gt; &lt;br&gt;&lt;/p&gt;
&lt;p&gt;📑 &lt;a href=&quot;/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/&quot; title=&quot;设计模式之行为型模式&quot;&gt;设计模式之行为型模式&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_内功" scheme="http://example.com/categories/A-%E5%86%85%E5%8A%9F/"/>
    
    <category term="B_设计模式" scheme="http://example.com/categories/A-%E5%86%85%E5%8A%9F/B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核及进程概述</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-12-25T01:28:27.210Z</published>
    <updated>2023-12-27T03:11:11.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：本章知识点</p><ul><li>Linux 内核结构</li><li>Linux 进程概述</li><li>Linux 系统对进程的创建、切换、结束操作</li></ul></blockquote><span id="more"></span><h2 id="0x01-Linux-内核概述"><a href="#0x01-Linux-内核概述" class="headerlink" title="0x01 Linux 内核概述"></a>0x01 Linux 内核概述</h2><p>事实上，在 Linux 操作系统中设计到真正的操作系统的功能部分其实都是放在 Linux 内核中的。Linux 内核其实就是 Linux 操作系统中最重要的部分。Linux 内核是硬件和软件之间的中间层，将应用程序的请求传递给硬件并充当底层驱动程序，对系统中的各个设备和组件进行寻址等等一些了功能。</p><p>目前，对于 Linux 内核的研究主要分为以下三部分功能：</p><ul><li>内核的硬件设备管理功能：从应用程序的角度来说，内核可以被认为是一台被抽象的计算机。当内核寻址硬盘，必须确定使用哪个路径能够从硬盘上将数据读取到内存中，这其中涉及到的数据位置、路径及读取数据的指令都是由内核完成的，而对于上层应用程序仅仅需要调用内核的一个接口函数即可完成。从某方面来说，应用程序与硬件本身没有联系，仅仅与内核有联系，内核是应用程序所知道的层次结构中最底。</li><li>内核的进程管理功能：当若干应用程序在系统中同时运行时，Linux 内核又需要充当资源管理程序，将可用共享资源（ CPU 时间、磁盘空间、网络连接等等）合理分配给各个系统进程使用，同时还能保证系统的完整性。</li><li>内核面向系统接口功能：Linux 内核会面向系统提供一系列的接口函数供应用程序来调用。应用程序通过调用 Linux 内核的一系列系统接口能够使得 Linux 系统帮助应用程序完成一系列功能。</li></ul><p>另外，为了更简单理解 Linux 操作系统的功能原理，我们选择早期版本的 Linux 内核作为代码参考，这样可能有效避免很多代码结构优化的代码内容的干扰。目前主流研究 Linux 内核的早期版本都选择的是 Linux 0.12 版本，因为这一版本的整体代码量大约仅有 2 万行，并且在这一版本中的 Linux 内核的大部分主要功能已经都齐全了，后期的 Linux 内核主要完善各个功能协调、硬件适配、平台适配等等方面（最新的 Linux 6.1 版本代码量已经突破 2700 万行）</p><p>Linux 内核对于操作系统来说其实是单内核模式，这样对于操作系统所提供的服务流程主要为：应用主程序使用指定的参数值执行系统调用指令（ <code>int 0x80</code> )，使得 CPU 从用户态切换到了内核态，然后操作系统根据具体的参数值调用特定的服务程序，而这些服务程序在完成了对应的执行操作后，操作系统再次使得 CPU 从内核态切换回到用户态，从而返回到应用程序中继续执行。因此，可以将 Linux 内核简单概括为三个层次：调用服务程序的主程序层、执行系统调用的服务层和支持系统调用的底层函数。具体如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/0.png" class="" title="图片描述"><h2 id="0x02-Linux-内核结构及任务管理功能"><a href="#0x02-Linux-内核结构及任务管理功能" class="headerlink" title="0x02 Linux 内核结构及任务管理功能"></a>0x02 Linux 内核结构及任务管理功能</h2><p>Linux 内核其实主要由 5 个模块构成，分别是：</p><ul><li>进程调度模块</li><li>内存管理模块</li><li>文件系统模块</li><li>进程间通信模块</li><li>网络接口模块</li></ul><p>这几个模块之间的依赖关系如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/1.png" class="" title="图片描述"><p>由上图能够看出来，所有的模块都与进程调度模块存在依赖关系。因为它们都需要依靠进程调度模块完成程序的挂起（暂停）或者进行运行的状态管理。通常，一个模块会在等待硬件操作期间挂起，在操作完成过后继续执行。</p><p>结合 Linux 0.12 内核源代码，可以将内核中的主要模块绘制成如下图所示的框图结构：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/2.png" class="" title="图片描述"><h2 id="0x03-进程的定义"><a href="#0x03-进程的定义" class="headerlink" title="0x03 进程的定义"></a>0x03 进程的定义</h2><p>进程是操作系统中最基本、最重要的概念之一。进程的概念最早是 20 世纪 60 年代初期由 MIT （美国麻省理工学院）研制的 multics 系统和 IBN 的 TSS&#x2F;360 系统中命名的。从那时候开始，操作系统中有了进程的概念：</p><ul><li>进程是程序的一次执行</li><li>进程是可以和其他进程并发执行的计算</li><li>进程就是一个程序在给定活动空间和初始条件下，在一个处理机上的执行过程</li><li>进程是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位</li><li>进程是动态的、有生命周期的活动。内核可以创建一个进程，最终将由内核终止该进程使其消亡</li></ul><p>我们知道程序是由代码经过编译器编译之后称为可执行文件，而进程则是由程序文件执行过程中存在的，具体区别如下：</p><ul><li>程序是今天的概念，是可以作为一种软件资源长期保存，而进程是程序的一次执行过程，是动态的概念</li><li>进程是一个能够独立运行的单位，能够与其他进程并发执行。进程在程序执行过程中作为资源申请和调度的单位存在，通常的程序是不能够作为独立运行的单位而并发执行的。</li><li>程序和进程不存在一一对应的关系。一个程序运行一次便会创造一个进程，多次运行就会创造多个进程。</li><li>各个进程在并发执行的过程中产生相互制约的关系，造成各自运行的不可预测，而程序是静态的，不存在这种异步特征。</li></ul><h2 id="0x04-进程的特征"><a href="#0x04-进程的特征" class="headerlink" title="0x04 进程的特征"></a>0x04 进程的特征</h2><p>目前概括，进程具有如下特征：</p><ul><li>动态性：进程是进程实体的执行过程。因此，动态性是进程最基本的特性。进行由创建而产生，调度而执行，因得不到资源而挂起执行，因为撤销而消亡，由此可见，进程是有一定的生命周期的。</li><li>并发性：这是指多个进程实体，共存于内存中并在一段时间内同时执行。并发性是进程的重要特征，同时也是操作系统的重要特征。</li><li>独立性：进程是一个能够独立运行的基本单位，同时也是系统中独立获得资源和调度管理的基本单位。</li><li>异步性：进程按照各自独立的、不可预知的速度向前运行，这样的话，多个进程同时运行时是按照异步方式运行。这一特征导致程序执行的不可预测性及不可再现性。因此，在操作系统中必须采取某些措施来保证各个进程之间能够协调运行。</li><li>结构特征：从结构上看，进程实体是由程序段、数据段以及进程控制块组成，所以可以简单将这三部分称为进程映像。</li></ul><h2 id="0x05-Linux-进程控制"><a href="#0x05-Linux-进程控制" class="headerlink" title="0x05 Linux 进程控制"></a>0x05 Linux 进程控制</h2><p>前面已经说明了程序是一个可执行的文件，而进程才是一个执行中的程序实例。通过 CPU 时间片轮转的调度方式，在 Linux 操作系统上能够同时运行多个进程。</p><p>所有的现代操作系统都能够同时运行很多个进程，实际上系统中也仅有一个处理器，那么在一个时间点实际上只有一个进程真正运行在处理器上。但是我们用户在计算机上感觉到真的是同时有很多进程都在运行，并且感觉不到他们之间有什么切换和停滞。</p><p>造成这样的现象，实际上是因为 Linux 内核与处理器建立了多任务的错觉，同时运行的多任务处理实际上是操作系统在运行时通过快速任务切换和调度使得我们无法感觉到任务执行的前后顺序。</p><p>对于早期的 Linux 0.12 版本的内核来说，最多能够接受 64 个进程的同时存在。其中除了内核自己建立的并运行起来的第一个进程之外，其他进程都是由系统调用 <code>fork</code> 创建的进程，被创建的进程称为子进程，创建该进程的进程称为父进程。内核程序使用进程标识号( <code>PID</code> ) 来标记识别每一个进程。进程由可执行的指令代码、数据以及堆栈区组成。进程中的代码和数据部分分别存放在对应执行文件的代码段、数据段。每个进程只能执行自己的代码和访问自己的数据和堆栈区域。进程之间的通信需要通过系统调用来进行。对于一个 CPU 的系统，同一时刻也仅有一个进程正在运行。Linux 内核通过调度程序分时处理各个进程运行。</p><h2 id="0x06-Linux-中进程表介绍"><a href="#0x06-Linux-中进程表介绍" class="headerlink" title="0x06 Linux 中进程表介绍"></a>0x06 Linux 中进程表介绍</h2><p>在 Linux 操作系统中，Linux 内核实际上通过进程表来对系统中的进程进行管理，每个进程在进程表中都占有一项。在 Linux 系统中，进程表实际上就是一个 <code>task_struct</code> 数据结构的指针。这个数结构十分重要。</p><p>Linux 内核中设计到进程和程序的所有管理和算法都围绕着一个名为 <code>task_struct</code> 的数据结构建立，该数据结构的定义位于 Linux 内核代码中 <code>include/Linux/sched.h</code> 头文件中。在具体讲解 Linux 对于进程管理之前必须先了解一下这个重要的数据结构。</p><p><code>task_struct</code> 中包含了很多数据成员，具体代码定义内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 任务(进程)数据结构，或称为进程描述符 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don&#x27;t touch */</span></span><br><span class="line"><span class="comment">/* 硬编码字段 */</span></span><br><span class="line">    <span class="type">long</span> state;                     <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">                                    <span class="comment">/* 任务运行状态 -1 不可运行，0 可运行(就绪)， &gt;0 已停止 */</span></span><br><span class="line">    <span class="type">long</span> counter;                   <span class="comment">/* 任务运行时间计数(递减)(滴答数)，运行时间片 */</span></span><br><span class="line">    <span class="type">long</span> priority;                  <span class="comment">/* 优先级 */</span></span><br><span class="line">    <span class="type">long</span> signal;                    <span class="comment">/* 信号位图 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span>    <span class="comment">/* 信号执行属性结构,对应信号将要执行的操作和标志信息 */</span></span><br><span class="line">    <span class="type">long</span> blocked;                   <span class="comment">/* 进程信号屏蔽码(对应信号位图) */</span> <span class="comment">/* bitmap of masked signals */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line"><span class="comment">/* 可变字段 */</span></span><br><span class="line">    <span class="type">int</span> exit_code;                  <span class="comment">/* 退出码 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code;       <span class="comment">/* 代码段地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end_code;         <span class="comment">/* 代码段长度（字节数） */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end_data;         <span class="comment">/* 代码段加数据段的长度 （字节数）*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> brk;              <span class="comment">/* 总长度(字节数) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_stack;      <span class="comment">/* 堆栈段地址 */</span></span><br><span class="line">    <span class="type">long</span> pid;                       <span class="comment">/* 进程标识号(进程号) */</span></span><br><span class="line">    <span class="type">long</span> pgrp;                      <span class="comment">/* 进程组号 */</span></span><br><span class="line">    <span class="type">long</span> session;                   <span class="comment">/* 会话号 */</span></span><br><span class="line">    <span class="type">long</span> leader;                    <span class="comment">/* 会话首领 */</span></span><br><span class="line">    <span class="type">int</span> groups[NGROUPS];            <span class="comment">/* 进程所属组号（一个进程可属于多个组） */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * pointers to parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment">     * older sibling, respectively.  (p-&gt;father can be replaced with</span></span><br><span class="line"><span class="comment">     * p-&gt;p_pptr-&gt;pid)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_pptr</span>;</span>     <span class="comment">/* 指向父进程的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_cptr</span>;</span>     <span class="comment">/* 指向最新子进程的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_ysptr</span>;</span>    <span class="comment">/* 指向比自己后创建的相邻进程的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_osptr</span>;</span>    <span class="comment">/* 指向比自己早创建的相邻进程的指针 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> uid;             <span class="comment">/* 用户id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> euid;            <span class="comment">/* 有效用户id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> suid;            <span class="comment">/* 保存的设置用户id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> gid;             <span class="comment">/* 组id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> egid;            <span class="comment">/* 有效组id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sgid;            <span class="comment">/* 保存的设置组id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> timeout;          <span class="comment">/* 内核定时超时值 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> alarm;            <span class="comment">/* 报警定时值(滴答数) */</span></span><br><span class="line">    <span class="type">long</span> utime;                     <span class="comment">/* 用户态运行时间(滴答数) */</span></span><br><span class="line">    <span class="type">long</span> stime;                     <span class="comment">/* 内核态运行时间(滴答数) */</span></span><br><span class="line">    <span class="type">long</span> cutime;                    <span class="comment">/* 子进程用户态运行时间 */</span></span><br><span class="line">    <span class="type">long</span> cstime;                    <span class="comment">/* 子进程内核态运行时间 */</span></span><br><span class="line">    <span class="type">long</span> start_time;                <span class="comment">/* 进程开始运行时刻 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span>   <span class="comment">/* 进程资源使用统计数组 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;                 <span class="comment">/* per process flags, defined below */</span></span><br><span class="line">                                        <span class="comment">/* 各进程的标志 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> used_math;           <span class="comment">/* 是否使用了协处理器的标志 */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">    <span class="type">int</span> tty;        <span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line">                    <span class="comment">/* 进程使用tty终端的子设备号。-1表示没有使用 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> umask;           <span class="comment">/* 文件创建属性屏蔽位 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span>           <span class="comment">/* 当前工作目录i节点结构指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span>          <span class="comment">/* 根目录i节点结构指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span>    <span class="comment">/* 执行文件i节点结构指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">library</span>;</span>       <span class="comment">/* 被加载库文件i节点结构指针 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> close_on_exec;    <span class="comment">/* 执行时关闭文件句柄位图标志 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span>    <span class="comment">/* 文件结构指针表，最多32项。表项号即是文件描述符的值 */</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span>      <span class="comment">/* 局部描述符表, 0 - 空，1 - 代码段cs，2 - 数据和堆栈段ds&amp;ss */</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span>          <span class="comment">/* 进程的任务状态段信息结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于数据量这么庞大、如此复杂的数据结构，短时间内弄清楚是很困难的，我们可以将这个结构中的内容分为几个部分来逐个理解弄清楚。虽然数据结构内数据量巨大，但是主要可以分为以下几部分进行理解：</p><ul><li>表示进程状态和执行信息，待决信号、使用的二进制格式、进程 ID （PID）、父进程及其他相关进程的指针、优先级以及程序执行</li><li>有关已经分配的虚拟内存的信息。</li><li>进程身份或者权限，用户 ID 、组 ID 等等。</li><li>使用的文件包含程序代码的二进制文件、以及进程所处理的所有文件的文件系统信息。</li><li>线程信息记录该进程特定于 CPU 的运行时间数据。</li><li>在于其他应用程序协作时所需的进程间通信有关的信息。</li><li>该进程所用到的信号处理程序，用于响应到来的信号。</li></ul><p>下面，先将其中重要的几个成员变量进行讲解说明。</p><h4 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h4><p><code>task_struct</code> 结构中的 <code>state</code> 成员变量表示的就是该进程当前的状态，在 Linux 内核中，进程主要分为以下几种状态：</p><ul><li><code>TASK_RUNNING</code> ：表示进程处于可运行状态。但是可运行状态并不意味着实际分配了 CPU 资源。这样的状态其实对应的就是进程的就绪状态，意味着当系统调度器选中该进程时能够立刻执行它。</li><li><code>TASK_INTERRUPTIBLE</code> ：该状态是针对等待某个事件或其他资源的睡眠进程设置的。处于这种状态下的进程在得到内核对于信号后会立刻将状态改变成 <code>TASK_RUNNING</code> 状态以恢复正常运行。</li><li><code>TASK_UNINTERRUPTIBLE</code> ：这种状态表示是接收到内核指示而停用的睡眠进程。这样的进程不能够由外部信号唤醒，只能由内核亲自唤醒。</li><li><code>TASK_STOPPED</code> ：该状态表示进程特意停止运行，例如：由调度器指示而暂停的进程。</li><li><code>TASK_TRACED</code> ：这种状态实际上并不是有进程本身运行过程中出现的，是当进程处于被调试的时候用来与常规进程区分而设计的进程状态。</li></ul><h4 id="counter-字段"><a href="#counter-字段" class="headerlink" title="counter 字段"></a><code>counter</code> 字段</h4><p><code>counter</code> 主要用来保存进程在暂时停止本次运行之前还能够执行的时间滴答数，即在正常情况下还需要经过多少个系统时钟周期才会切换到另一个进程。调度程序会使用进程的该成员值来选择下一个要执行的进程。因此， <code>counter</code> 可以看做是一个进程的动态特性。在一个进程刚被创建时，<code>counter</code> 的初始值为 <code>priority</code>。</p><h4 id="priority"><a href="#priority" class="headerlink" title="priority"></a><code>priority</code></h4><p>结合前面对 <code>counter</code> 的描述，<code>priority</code> 的作用就是为了给 <code>counter</code> 赋值。在 Linux 0.12 版本中这个初值设定为 15 ，表示设定初始值为 15 个时间滴答数。</p><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a><code>signal</code></h4><p><code>signal</code> 字段表示进程当前接收到信号的位图，总共 32 位，每一位代表一种系统信号类型。因此，Linux 内核中最多也仅有 32 种信号。在每个系统调用处理后，系统会使用该信号位图对信号进行预处理。</p><h4 id="sigaction-数组"><a href="#sigaction-数组" class="headerlink" title="sigaction 数组"></a><code>sigaction</code> 数组</h4><p>该数值类型为 <code>struct sigaction</code> ，该结构数组用来保存处理各个信号所用的操作和属性，数组每一项对应一个信号。具体结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);    <span class="comment">/* 对应某信号指定要采取的行动 */</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;           <span class="comment">/* 对信号的屏蔽码，在信号程序执行时将阻塞对这些信号的处理 */</span></span><br><span class="line">    <span class="type">int</span> sa_flags;               <span class="comment">/* 改变信号处理过程的信号集 */</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);<span class="comment">/* 恢复函数指针，由函数库Libc提供，用于清理用户态堆栈 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="blocked"><a href="#blocked" class="headerlink" title="blocked"></a><code>blocked</code></h4><p>该字段表示进程当前不想要处理的信号的阻塞位图。与 <code>signal</code> 字段类似，每一位表示一种对应被阻塞的信号。</p><h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a><code>exit</code></h4><p>这一字段用来保存程序终止时的退出码。在子进程结束后父进程能够查询子进程的这个退出码。</p><h4 id="start-code"><a href="#start-code" class="headerlink" title="start_code"></a><code>start_code</code></h4><p>该字段用来保存进程代码在 CPU 线性地址空间中的开始地址，在 Linux 0.12 内核中这个数值是 64 MB 的整数倍。</p><h4 id="end-code"><a href="#end-code" class="headerlink" title="end_code"></a><code>end_code</code></h4><p>该字段保存着进程代码的字节长度值。</p><h4 id="end-data"><a href="#end-data" class="headerlink" title="end_data"></a><code>end_data</code></h4><p>该字段保存进程的代码程度 + 数据长度的总字节长度值。</p><h4 id="brk"><a href="#brk" class="headerlink" title="brk"></a><code>brk</code></h4><p>这个字段也是进程代码和数据的总字节长度（指针值），但是还包括未初始化的数据区 <code>BSS</code> 。这是 <code>brk</code> 在一个进程开始执行的初始值。通过修改这个指针的数值，内核可以为进程添加和释放动态分配的内存（通常通过调用 <code>malloc</code> 函数来调用 <code>brk</code> 系统调用实现）。</p><h4 id="start-stack"><a href="#start-stack" class="headerlink" title="start_stack"></a><code>start_stack</code></h4><p>该字段指向进程逻辑地址空间中堆栈的起始处。</p><h4 id="pid"><a href="#pid" class="headerlink" title="pid"></a><code>pid</code></h4><p>顾名思义，保存进程标识号，用来唯一表示进程。</p><h4 id="pgrp"><a href="#pgrp" class="headerlink" title="pgrp"></a><code>pgrp</code></h4><p>指进程所属进程组号</p><h4 id="session"><a href="#session" class="headerlink" title="session"></a><code>session</code></h4><p>进程的会话号，所属会话的进程号</p><h4 id="leader"><a href="#leader" class="headerlink" title="leader"></a><code>leader</code></h4><p>进程所属会话的首进程号。</p><h4 id="group-NGROUPS"><a href="#group-NGROUPS" class="headerlink" title="group[NGROUPS]"></a><code>group[NGROUPS]</code></h4><p>进程所属各个组的组号数组，一个进程可以属于多个组</p><h4 id="p-pptr-、-p-cptr-、-p-ysptr-、-p-isptr"><a href="#p-pptr-、-p-cptr-、-p-ysptr-、-p-isptr" class="headerlink" title="p_pptr 、 p_cptr 、 p_ysptr 、 p_isptr"></a><code>p_pptr</code> 、 <code>p_cptr</code> 、 <code>p_ysptr</code> 、 <code>p_isptr</code></h4><p>这几个字段均为 <code>task_struct</code> 数据结构指针。其中：</p><ul><li><code>p_pptr</code> 是指向父进程任务结构的指针</li><li><code>p_cptr</code> 是指向最新子进程任务结构的指针</li><li><code>p_ysptr</code> 是指向比自己后创建的相邻进程的指针</li><li><code>p_isptr</code> 是指向比自己早创建的相邻进程的指针</li></ul><p>以上这四个指针的关系如下图所示，通过这样的成员指针数据，内核很容易就能通过一个进程的任务结构获取到其他与这个进程有关系的进程的任务结构对象。</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/3.png" class="" title="图片描述"><h4 id="uid-、-euid-、-suid-、-gid-、-egid-、-sgid"><a href="#uid-、-euid-、-suid-、-gid-、-egid-、-sgid" class="headerlink" title="uid 、 euid 、 suid 、 gid 、 egid 、 sgid"></a><code>uid</code> 、 <code>euid</code> 、 <code>suid</code> 、 <code>gid</code> 、 <code>egid</code> 、 <code>sgid</code></h4><p>这几个成员字段都属于进程用户相关标识号，其中：</p><ul><li><code>uid</code>：保存拥有这个进程的用户标识号（用户 ID ）</li><li><code>euid</code>：有效用户标识号，表示访问文件的权限</li><li><code>suid</code> ：文件保存的用户标识号，当执行文件的设置用户 ID 标志置一时， <code>suid</code> 中把保存执行文件的 uid ，否则保存进程的 <code>euid</code></li><li><code>gid</code> ：指用户所属的组标识号（组 ID ），指明了用于该进程的用户组</li><li><code>egid</code> ：有效组 ID ，用于指明该组用户访问文件的权限</li><li><code>sgid</code> ：保存的用户 ID ，当执行文件的设置组 ID 标志置一时，<code>sgid</code> 中保存执行文件的 <code>gid</code> ；否则，保存进程的 <code>egid</code> 。</li></ul><h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a><code>timeout</code></h4><p>记录内核定时超时的值。</p><h4 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a><code>alarm</code></h4><p>用于进程的报警定时值。如果进程使用系统调用 <code>alarm()</code> 设置过该字段，则内核会把该函数以秒为单位的参数转换成滴答值存放到这个字段中，</p><h4 id="rlim-数组"><a href="#rlim-数组" class="headerlink" title="rlim 数组"></a><code>rlim</code> 数组</h4><p><code>rlim</code> 数组成员主要作为 Linux 提供资源限制的参数，该数组成员类型为 <code>struct rlimit</code> ，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rlim_cur;</span><br><span class="line">    <span class="type">int</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体类型中：</p><ul><li><code>rlim_cur</code> ：表示进程当前的资源限制，也称为软件限制。</li><li><code>rlim_max</code> ：表示进程当前最大可允许的限制范围，称为硬件限制。</li></ul><p>操作系统能够调用 <code>setrlimit()</code> 函数来增减当前的资源限制具体数值，但是依旧不能够超过 <code>rlim_max</code> 指定的值。对应的，<code>getrlimits()</code> 能够用来检查当前限制的具体数值。</p><p>在内核中，对于 <code>rlim</code> 变量的数组位置是与资源类型相关的，这是 Linux 内核中预定义的常数，在 Linux 0.12 版本中还仅有 6 中资源类型，后面发展到现在已经多达 15 种类型了，具体可以使用 <code>man</code> 手册查看 <code>setrlimit</code> 。这里简单列出 Linux 0.12 版本中定义的几种类型，其定义位置位于内核源代码的 <code>include/sys/resource.h</code> 头文件中，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_CPU      0       <span class="comment">/* CPU time in ms */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_FSIZE    1       <span class="comment">/* Maximum filesize */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_DATA     2       <span class="comment">/* max data size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_STACK    3       <span class="comment">/* max stack size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_CORE     4       <span class="comment">/* max core file size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_RSS      5       <span class="comment">/* max resident set size */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> notdef</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_MEMLOCK  6       <span class="comment">/* max locked-in-memory address space*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_NPROC    7       <span class="comment">/* max number of processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_OFILE    8       <span class="comment">/* max number of open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIM_NLIMITS    6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIM_INFINITY   0x7fffffff</span></span><br></pre></td></tr></table></figure><p>实际上，在 Linux 操作系统下，我们还能够通过 <code>cat</code> 命令来查看当前系统中设置的各个资源限制数值。打开终端窗口，输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/self/limits</span><br></pre></td></tr></table></figure><p>显示结果如下：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/4.png" class="" title="图片描述"><h4 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h4><p>这个结构体中其他字段也都是用来描述进程在执行过冲中的一些状态会用到的值，具体的内容等到我们用到的时候再来描述，这里就不再一一叙述了。</p><h2 id="0x07-进程运行状态"><a href="#0x07-进程运行状态" class="headerlink" title="0x07 进程运行状态"></a>0x07 进程运行状态</h2><p>一个进程在生存期内，可以处于不同的状态并且相互转换，这样的状态称为进程状态。进程的当前状态保存在刚刚我们描述过的字段 <code>state</code> 中。当进程正在等待系统中的资源而处于等待状态时，称为睡眠等待状态。在 Linux 系统中，睡眠等待状态分为可中断和不可中断的等待状态。进程具体状态转换关系如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/5.png" class="" title="图片描述"><p>其中，需要重点描述几个不同的进程运行状态：</p><ul><li>运行状态 <code>TASK_RUNNING</code> 当进程正在被 CPU 执行，或已经准备就绪随时可以由调度程序执行，则该进程的当前状态就是出于运行状态。如果此时进程没有被 CPU 执行，则进程当前状态为就绪运行状态。另外，进程可以在用户态运行也可以在内核态运行。当进程正在执行用户自己的代码时，可以看做处于用户态运行；而当进程在内核代码中运行时则看做出于内核态运行。像上图描述的那样，当进程因为等待系统资源而进入睡眠状态后，系统资源准备就绪后就会唤醒进程从而使进程状态转换成就绪态。</li><li>可中断睡眠状态 <code>TASK_INTERRUPTIBLE</code> 当进程处于可中断等待（睡眠）状态时，系统不会调度该进程执行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，都可以唤醒进程转换到就绪状态。</li><li>不可中断睡眠状态 <code>TASK_UNINTERRUPTIBLE</code> 这个状态与可中断睡眠状态最大的不同就是不会因为收到信号而被唤醒，除此之外，其他状态均与可中断睡眠状态类似。处于该状态的进程只能被使用 <code>wake_up()</code> 函数明确唤醒才能转换成可运行的就绪状态。该状态通常在进程需要不受干扰地等待或者所等待事件会快就会发生的时候使用。</li><li>暂停状态 <code>TASK_STOPPED</code> 当进程收到信号 <code>SIGSTOP</code> 、 <code>SIGTSTP</code> 、 <code>SIGTTIN</code> 、 <code>SIGTTOU</code> 时就会进入暂停状态。这时候可以通过将信号 <code>SIGONT</code> 发送给进程使得其将状态转换成可运行状态。进程在调试期间接收到任何信号都能进入该状态。</li><li>僵死状态 <code>TASK_ZOMBIE</code> 当进程已经停止运行，但是这个进程的父进程还没有调用系统函数去询问其状态时，该进程会处于僵死状态。为了让父进程能够给获取其运行的信息，此时子进程的任务数据结构信息需要持续保留着，以供父进程随时调用，当父进程调用函数查看了该进程的运行信息后，该进程的任务数据结构就会被释放。</li></ul><p>当一个进程的运行时间片用完，系统就会使用调度程序强制切换到其他进程去执行。另外，如果进程在内核态运行时需要等待系统的某个资源，此时该进程会调用 <code>sleep_on()</code> 或者 <code>interruptible_sleep_on()</code> 主动放弃 CPU 的使用权，而使得调度程序去调度其他进程获取 CPU 资源进行执行，当前进程在调用函数后会转入睡眠状态等待合适的时候再恢复执行。</p><h2 id="0x08-进程初始化"><a href="#0x08-进程初始化" class="headerlink" title="0x08 进程初始化"></a>0x08 进程初始化</h2><p>在 Linux 内核代码中，在 <code>boot/</code> 目录中，引导程序将内核从磁盘上加载到内存中，并使得系统进入保护模式下运行以后，就开始执行系统初始化程序 <code>init/main.c</code> ，该程序首先确定如何分配使用系统物理内存，如何调用内核各部分的初始化函数分别对内存管理、中断处理、块设备和字符设备、进程管理以及硬盘和软盘硬件进行初始化处理。在完成这些初始化操作后，系统各部分将处于可运行状态，此后程序把自己设定为 0 号进程并运行，之后再使用 <code>fork()</code> 调用首次创建 1 号进程。在 1 号进程中，程序将继续进行应用环境的初始化并执行 <code>shell</code> 登录程序。而 0 号进程则会在系统空闲时被调度执行，此时 0 号进程只执行 <code>pause()</code> 系统调用，其中又回去执行调度函数。</p><p>其中，内核移动程序到 0 号进程中去执行这个过程宏 <code>move_to_user_mode (include/asm/system.h)</code> 完成，它将 <code>main.c</code> 程序执行流从内核态移动到了用户态的进程 0 中继续运行。在移动之前，系统在对调度程序的初始化过程（<code>sched_init()</code>）中，首先对进程 0 的运行环境进行设置，其中包括人工预先设置好的进程 0 的数据结构各字段的值（<code>include/linux/sched.h</code>）、在全局描述符表中添入进程 0 的任务状态段（<code>TSS</code>）描述符和局部描述符表（<code>LDT</code>）的段描述符，并把它们分别加载到任务寄存器 <code>tr</code> 和局部描述符表寄存器 <code>ldr</code> 中。</p><p>内核初始化是一个特殊的过程，内核初始化代码其实就是进程 0 的代码。从进程 0 数据结构中设置的初始数据可以知道，进程 0 的代码段和数据段的基地址都是 0 ，段最大字节长度限制在 640KB 。与之相比较，内核代码的代码段和数据段的基地址也都是 0 ，而段长度限制为 16MB ，因此进程 0 的代码段和数据段是包含在内核代码段和数据段中。内核初始程序 <code>main.c</code> 就是进程 0 的代码，只是在真正成为进程 0 之前，系统正在以内核态特权级 0 运行着 <code>main.c</code> 程序。</p><p>宏 <code>move_to_user_mode</code> 的功能就是把运行特权级从内核态的 0 级变换成用户态的 3 级，但是仍然继续执行原来的代码指令流。在变换当前程序到 0 号进程的过程中，宏 <code>move_to_user_mode</code> 使用了中断返回指令造成特权级改变的方法。使用这种方法进行控制权转移是由 CPU 保护机制造成的。 CPU 允许低级别代码通过调用门或中断、陷阱门来调用或转移到高级别代码中运行，但反之则不行。因此内核采用这种模拟 <code>IRET</code> 返回低级别代码的方式。该方法的主要思想是在堆栈中构筑中断返回指令需要的内容，把返回地址的段选择符设置成任务 0 代码段选择符，之后执行中断返回指令 <code>iret</code> 将导致 CPU 从特权级 0 跳转到外层的特权级 3 上运行。具体如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/6.png" class="" title="图片描述"><p>宏 <code>move_to_user_mode</code> 首先往内核堆栈中压入进程 0 堆栈端（即数据段）选择符和内核堆栈指针，然后压入标志寄存器内容，最后压入进程 0 代码段选择符和执行中断返回后需要执行的下一条指令的偏移地址。该偏移位置是 <code>iret</code> 后的下一条指令。</p><p>当执行 <code>iret</code> 指令时， CPU 把返回地址送入 CS:EIP 中，同时弹出堆栈中标志寄存器内容。由于 CPU 判断出目的代码段的特权级为 3 ，与当前内核态的 0 级不同，于是 CPU 会把堆栈中的堆栈段选择符和堆栈指针弹出到 SS:ESP 中。由于特权级发生了变化，段寄存器 DS 、 ES 、 FS 以及 GS 的值变得无效，此时 CPU 会把这些段寄存器清零，因此在执行了 <code>iret</code> 指令后需要重新加载这些寄存器。这之后，系统就开始以特权级 3 运行在进程 0 的代码上，所使用的用户态堆栈还是原来移动之前使用的堆栈，而内核态的堆栈则被指定为其任务数据结构所在的页面的顶端开始（ <code>PAGE_SIZE + (long)&amp;init_task</code> ）。之后在创建新进程时，需要复制进程 0 的任务数据结构，包括用户堆栈指针，因此要求进程 0 的用户态堆栈在创建进程 1 之前保持“干净”状态。</p><p>对于进程的初始化，我们进行理解和掌握即可，这部分的具体操作都是由 Linux 内核自动完成的，当我们真正进入到 Linux 操作系统的用户态下后，进程的初始化已经完成，Linux 操作系统的 0 号进程已经运行起来了。我们自己的程序此时在 Linux 操作系统下运行时会自然而然由 0 号进程进行创建并执行。</p><h2 id="0x09-创建新进程"><a href="#0x09-创建新进程" class="headerlink" title="0x09 创建新进程"></a>0x09 创建新进程</h2><p>Linux 内核中创建新进程使用 <code>fork()</code> 系统调用。所有内核中管理的进程都是通过复制进程 0 而得到的，所以在 Linux 系统下运行的进程最初都是由进程 0 产生的子进程。</p><p>在创建新进程的过程中，系统首先在任务数组中找出一个还没有被任何进程使用的空项，如果 Linux 系统下管理的进程已经达到所能管理限制值后（在 Linux 0.12 版本内核中设定的进程数量最大值为 64 ），则 <code>fork()</code> 系统调用会因为任务数组表中没有可用空项而出错返回，然后系统为新建进程在主内存区中申请一页内存来存放其人任务数据结构信息，并且复制当前进程任务数据结构中所有内容作为新进程任务数据结构的模板，为了防止这个还未处理完成的新建进程被调度函数执行，此时应该立刻将新进程状态置位不可中断的等待状态（<code>TASK_UNINTERRUPTIBLE</code>)</p><p>复制任务数据结构完成后，接着就是对其进行修改，把当前进程设置为新的进程的父进程，清除信号位图并复位新进程各统计值，并设置初始运行时间片值为 15 个时间滴答数（ 150ms ），接着将根据当前进程设置任务状态段（TSS）中各寄存器的值。由于创建进程时新进程返回值应为 0 ，使用需要设置为 <code>tss.eax = 0</code> ，新建进程内核态堆栈指针 <code>tss.esp0</code> 被设置成新进程任务数据结构所在内存页面的顶端，而堆栈段 <code>tss.ss0</code> 被设置成内核数据段选择符， <code>tss.ldt</code> 被设置成局部表描述符在 GDT 中的索引值，若当前进程使用了协处理器，则还需要把协处理器的完整状态保存到新进程的 <code>tss.i387</code> 结构中。</p><p>之后系统设置新进程的代码段和数据段基地址、限制长度，并复制当前进程内存分页管理的页表。需要注意的是，此时系统并不为新进程分配实际的物理内存页面，而是让它共享父进程的内存页面。只有当父进程或者新进程中任意一个进行了写内存操作时，系统才会为执行写操作的进程分配相关的独立使用的内存页面，这种处理方式称为写时复制技术。</p><p>随后，如果父进程中有文件是打开的，则应该将对应文件的打开次数加 1 。紧接着在 GDT 中设置新任务的 TSS 和 LDT 描述符项，其中基地址信息指向新进程任务结构中的 <code>tss</code> 和 <code>ldt</code> ，最后再将新任务设置成可运行状态并返回新进程号。</p><p>这里尤其需要注意：创建一个新进程和加载运行一个执行程序文件是两个不同的概念。当创建子进程时，它完全是复制了父进程的代码段和数据区，并会在其中执行子进程部分的代码。而执行存储设备上的程序时，一般会在子进程中运行 <code>exec()</code> 系统调用来进行操作。在进入 <code>exec()</code> 后，子进程原来的代码区和数据区都会被清除掉（释放掉），然后将该进程运行新程序时，由于此时内核还没有从存储设备上将该程序代码加载近来，所以 CPU 会立刻产生代码页面不存在的异常（<code>Fault</code>），此时内存管理程序就会从存储设备上找到对应程序代码加载到内存中，然后 CPU 重新执行引起异常的指令，此时新程序的代码才真正被执行起来。</p><p>整体流程如下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/7.png" class="" title="图片描述"><h2 id="0x0a-进程调度"><a href="#0x0a-进程调度" class="headerlink" title="0x0a 进程调度"></a>0x0a 进程调度</h2><p>在 Linux 内核中，进程调度主要是为了选择系统中即将要运行的进程，通过调度来回切换进程运行能够给人感觉上多进程同步运行的效果。这种选择运行机制是多任务操作系统的基础，可以将 Linux 内核的调度程序看作在所有处于运行状态的进程之间分配 CPU 运行时间的管理代码。通过前面对 Linux 系统的描述可以知道 Linux 进程是抢占式的，不过被抢占的进程仍然处于 TAK_RUNNING 状态，只不过暂时没有被 CPU 运行。进程的抢占发生在进程处于用户态执行阶段，在内核态执行时是不能够被抢占的。</p><p>为了能够使得进程有效地使用系统资源，又能使进程有较快的响应时间，就需要对进程的切换调度采用一定的调度策略。</p><h4 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h4><p>Linux 内核中的 <code>schedule()</code> 函数首先扫描进程数组，通过比较每个就绪态（ TASK_RUNNING ）进程的运行时间递减滴答计数 <code>counter</code> 的值来确定当前哪个进程运行的时间最少，<code>counter</code> 的数值越大表示剩余的运行时间越大，于是就选中该进程并使用进程切换宏函数来进行切换到该进程到 CPU 进行运行。</p><p>如果此时所有处于 <code>TASK_RUNNING</code> 状态进程的时间片都已经用完，系统就会根据每个进程的优先权值 <code>priority</code> 对系统中所有进程（包括正在睡眠的进程）重新计算每个任务需要运行的时间片值 <code>counter</code> ，Linux 0.12 版本内核中对时间片值的计算公式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter = (counter / 2) + priority</span><br></pre></td></tr></table></figure><p>通过这样的方式，正在睡眠的进程被唤醒时就会具有较高的时间片值 <code>counter</code> ，然后通过 <code>schedule()</code> 函数重新扫描进程数组中所有处于 <code>TASK_RUNNING</code> 状态的进程，并重复上述过程，直到选择出下一个切换执行的进程，最后调用 <code>switch_to()</code> 宏来执行实际的切换进程操作。</p><p>如果此时没有其他进程可以运行，则系统会选择 0 号进程运行，在 Linux 0.12 版本内核中，进程 0 会调用 <code>pause()</code> 将自己设置成可中断的睡眠状态并再次调用 <code>schedule()</code> ，不过在调度进程运行时，<code>schedule()</code> 并不在意进程 0 处于什么状态，只要系统空闲就会调用 0 号进程运行。</p><p>具体流程图下图所示：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/8.png" class="" title="图片描述"><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>每当选择出一个新的可执行的进程时， <code>schedule()</code> 函数就会调用定义在 Linux 内核源代码中的 <code>include/asm/system.h</code> 中的 <code>switch_to()</code> 宏执行实际进程切换操作。该宏会把 CPU 的当前进程状态（上下文）替换成新进程的状态。在进行切换之前，<code>switch_to()</code> 宏会先检查要切换到的进程是否就是当前进程，如果是则调出流程（什么也不做），直接退出；否则，就先将内核全局变量 <code>current</code> 设置成新任务的指针，然后长跳转到新任务的任务状态段 <code>TSS</code> 组成的地址处，造成 CPU 执行任务切换操作。此时，CPU 会把所有寄存器的状态保存到当前任务寄存器 <code>TR</code> 中 <code>TSS</code> 段选择符所指向的当前进程任务数据结构的 <code>tss</code>结构中，然后把新任务状态段选择符所指向的新任务数据结构中 <code>tss</code> 结构中的寄存器信息恢复到 CPU 中，系统就正式开始执行新的进程。这个过程如下图所描述：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/9.png" class="" title="图片描述"><h2 id="0x0b-终止进程"><a href="#0x0b-终止进程" class="headerlink" title="0x0b 终止进程"></a>0x0b 终止进程</h2><p>当一个进程结束了运行或在半途中止了运行，那么 Linux 内核就需要释放这个进程所占用的系统资源，这包括进程运行时打开的文件、申请的内存等。</p><p>当一个用户程序调用 <code>exit()</code> 系统调用时，就会执行内核函数 <code>do_exit()</code> ，这个函数首先会释放进程代码段和数据段占用的内存页面，关闭进程当前打开着的所有文件，对进程使用的当前工种目录、根目录和运行程序的 i 节点进行同步操作。如果进程还存在有子进程，这会让 <code>init</code> 进程作为所有子进程的父进程。如果进程是一个会话头进程并且有控制终端，则释放控制终端，并向属于该会话的所有进程发送挂断信号 <code>SIGHUP</code> ，这通常会终止该会话中的所有进程，然后把进程状态设置为僵死状态 <code>TASK_ZOMBIE</code> ，并向其原父进程发送 <code>SIGCHLD</code> 信号，通知其某个子进程已经终止。最后调用 <code>do_exit()</code> 函数去执行其他进程，由此可见在进程被终止时，它的任务数据结构仍然保留着，因为其父进程还需要使用其中的信息。</p><p>在子进程执行期间，父进程通常使用 <code>wait()</code> 或 <code>waitpid()</code> 函数等待其某个子进程终止。当等待的子进程被终止并处于僵死状态时，父进程就会把子进程运行所使用的时间累加到自己的进程中，最终释放已终止子进程任务数据结构所占用的内存页面，并设置空子进程在任务数组中占用的指针项。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：本章知识点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux 内核结构&lt;/li&gt;
&lt;li&gt;Linux 进程概述&lt;/li&gt;
&lt;li&gt;Linux 系统对进程的创建、切换、结束操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="内核" scheme="http://example.com/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux操作系统原理剖析——操作系统概述</title>
    <link href="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2023-12-18T01:37:30.801Z</published>
    <updated>2023-12-27T03:11:11.973Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：本章知识点</p><ul><li>什么是操作系统</li><li>操作系统有哪些功能</li><li>操作系统的发展历史</li><li>操作系统的分类</li><li>操作系统的结构组成</li><li>Linux <strong>操作系统介绍</strong></li></ul></blockquote><h2 id="0x01-什么是操作系统"><a href="#0x01-什么是操作系统" class="headerlink" title="0x01 什么是操作系统"></a>0x01 什么是操作系统</h2><p>众所周知，计算机系统是有计算机硬件和计算机软件组成的，而计算机硬件主要是指大家所熟知的中央处理器（CPU）、硬盘、内存、主板、显卡等等，而计算机软件其实是分层次的，在计算机硬件上运行的计算机软件最底层其实就是操作系统。如下图所示，是计算机系统层次结构图：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.png" class="" title="操作系统层次结构图"><p>可以说操作系统就是直接运行在计算机硬件裸机上的第一层软件，是操作系统为上层应用提供了计算机硬件的操作接口和基础功能，并将计算机硬件外设的数据信号等获取到的数据传递给上层应用。</p><h2 id="操作系统有哪些功能"><a href="#操作系统有哪些功能" class="headerlink" title="操作系统有哪些功能"></a>操作系统有哪些功能</h2><p>知道了操作系统在计算机系统中所处的位置后，就应该明白操作系统的主要目的就是为了方便用户使用计算机系统和提高计算机系统资源利用率而诞生的软件系统。</p><p>操作系统的主要功能可用概况为以下两方面：</p><ul><li>提供人机接口</li><li>管理计算机资源</li></ul><h3 id="人机接口"><a href="#人机接口" class="headerlink" title="人机接口"></a>人机接口</h3><p>提供人机接口其实就是运行在计算机硬件上的操作系统为用户的使用提供了方式和方法。最简单的方式就是我们开发人员在计算机上基于操作系统进行软件的开发和使用，从而实现了程序的开发运行。</p><p>大家都知道，像 C 、C++ 一类的编译性语言编写的程序在真正运行起来之前是需要进行代码编译、链接后才能运行的。其中，代码编译是将高级语言编译成简单的二进制文件，而引入链接后就需要用到操作系统下的库的概念（尤其是动态库链接），最后到真正运行程序时，程序其实是在操作系统的基础上才运行起来的。</p><p>现在，我们大家来简单练习一个最基本的程序员入门程序 “hello world!” 。大家基于现在的 Ubuntu 操作系统环境，在终端窗口下使用 <code>vim</code> 编辑器编写代码，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hello.c</span><br></pre></td></tr></table></figure><p>在打开的 VI 窗口中，使用 <code>i</code> 切换到输入状态，然后编写入如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在填写完代码内容后，按下 <code>Esc</code> 切换到正常模式，输入 <code>:wq</code> 保存内容退出 Vi 编辑器，然后通过以下命令完成 C 代码的编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅进行编译操作，不进行链接</span></span><br><span class="line">gcc -c hello.c -o hello.o</span><br><span class="line"><span class="comment"># 完成链接操作，产生可执行文件</span></span><br><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><p>此时，产生的 <code>hello</code> 可执行文件就是基于 Ubuntu（Linux）操作系统的可以运行的程序，如果简单脱离这个操作系统，这个程序是无法运行起来的。我们可以通过 <code>file</code> 命令来查看这个文件的基本属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file hello</span><br></pre></td></tr></table></figure><p>结果如下：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/2.png" class="" title="图片描述"><p>通过这样简单的一个程序的编译、运行练习，大家应该明白操作系统所提供的人机接口是什么了吧？其实人机接口主要就是为了给人们提供与计算机进行交互的接口功能。</p><h3 id="管理计算机资源"><a href="#管理计算机资源" class="headerlink" title="管理计算机资源"></a>管理计算机资源</h3><p>计算机系统的资源总的来说分为硬件资源和软件资源，硬件资源有处理器、存储器、外设等；软件资源则大部分指程序和数据。</p><p>操作系统提供了大量用于管理这些资源的功能。具体如下：</p><ul><li>处理器资源管理：处理器调度、进程控制、进程通信、进程同步</li><li>存储管理：内存分配、地址转换、内存保护、内存扩充</li><li>设备管理：设备分配、缓冲管理、设备驱动、设备无关性</li><li>文件管理：文件存储空间管理、目录管理、文件操作、文件权限控制</li></ul><p>下面通过一个简单的输入、输出程序来演示操作系统管理设备的功能，构建实现一个 <code>input</code> 的程序，创建源文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim input.c</span><br></pre></td></tr></table></figure><p>在源文件中添加如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please Input message: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your input message : \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完成代码后，使用编译器进行编译和运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc input.c -o input</span><br><span class="line">./input</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/3.png" class="" title="图片描述"><p>从这个程序的运行过程中能够看出，当程序执行开始，屏幕上会显示我们想要打印的字符串数据，这里就用到了操作系统的输出设备管理功能，将数据发送给显卡进行显示；然后我们通过键盘输入了消息数据，操作系统管理的输入设备（键盘）获取到我们敲击键盘的事件消息后拼成了最终输入的消息数据送给运行的应用程序，然后应用程序最终重新将获取到的数据打印显示到了屏幕上。具体流程参考如下：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/4.png" class="" title="图片描述"><h2 id="0x03-操作系统的分类"><a href="#0x03-操作系统的分类" class="headerlink" title="0x03 操作系统的分类"></a>0x03 操作系统的分类</h2><p>从一开始的裸机到单任务处理的单片机，最后发展成为如今的多任务并发处理的现代计算机，计算机系统发展迅速，而在计算机系统中十分重要的操作系统也发展形成了多种类不同的操作系统。</p><p>由于应对的场景不同，操作系统根据处理多任务的不同方式可以分为：</p><ul><li>分时操作系统：目前大部分桌面操作系统都属于分时操作系统，其中最主要的区别就是多任务分时共享计算机的处理资源。目前所见到的 Windows、Ubuntu、MacOS 等桌面操作系统都属于分时操作系统。</li><li>实时操作系统：实时操作系统针对工业和需要及时处理数据消息而设计的操作系统，有及时性、可靠性等特点。这类型操作系统多指嵌入式操作系统，有 rtos、uCosII 等等。</li></ul><h2 id="0x04-操作系统的结构组成"><a href="#0x04-操作系统的结构组成" class="headerlink" title="0x04 操作系统的结构组成"></a>0x04 操作系统的结构组成</h2><p>操作系统是一个大型的软件系统，是由许多独立功能的程序模块组成的，这些程序模块共同构成了一个完整的操作系统。大部分的操作系统都可以被分为这样两种结构：层次结构和微内核结构。</p><ol><li>层次结构 层次结构操作系统的设计思想主要是按照操作系统各个模块的功能和相互之间的依存关系而设计。而操作系统应该分为多少层，各个层应该在什么位置其实都是层次结构操作系统的设计关键点。处于最底层的程序模块往往成为操作系统的内核。这部分程序模块的功能包括系统中断处理程序、各个外设驱动程序、高优先级处理频率高的程序模块（如时钟管理程序、进程调度程序、低级通信模块、内存管理模块等等）。一般情况下，为了整个操作系统的效率，系统内核部分会在计算机系统工作过程中常驻内存中持续运行。</li><li>微内核结构 与层次结构相对的就是微内核结构。微内核结构的操作系统其实就是把操作系统中的基本功能模块组织为操作系统的微内核，而其他功能模块尽量做到内核以外，通过调用内核来实现。微内核机构是具有如下优点：</li></ol><ul><li>简化内核代码维护工作：微内核代码量少，结构简单易于维护。当需要增加操作系统功能时，通常情况下仅需要在内核以外进行即可；</li><li>建构灵活：在微内核上可以开发实现多种类型的操作系统。例如：在微内核结构上提供一组 Unix 服务程序，那么操作系统对于用户来说就是 Unix 系统，而提供一组 Windows 服务程序则就像是 Windows 系统一样。</li><li>安全性高：由于大部分的功能模块都是处于内核以外的部分运行实现，其实类似高级用户一样的层次，则相对于操作系统来说更安全，大部分功能模块产生的漏洞不会影响到系统内核部分。</li><li>方便移植：由于硬件相关的部分都包含在微内核中，当需要进行系统移植时，只需要修改微内核代码以适应不同的硬件平台即可进行系统移植，而对于操作系统中各个功能模块以及更上层的应用层来说不需要做任何改变。</li></ul><h2 id="Linux-操作系统介绍"><a href="#Linux-操作系统介绍" class="headerlink" title="Linux 操作系统介绍"></a>Linux 操作系统介绍</h2><p>经过对操作系统的介绍，详细大家对于计算机系统中的操作系统应该有了一定的概念。本课程重点研究的操作系统是 Linux 操作系统，现在就简单介绍一下关于 Linux 操作系统。前面实现练习操作的 Ubuntu 桌面操作系统就是一个基于 Linux 内核实现的 Linux 桌面操作系统。</p><p>Linux 系统有两种不同的含义：</p><ul><li>一方面单指 Linus Torvalds 维护的开源代码 Unix 类操作系统的内核 Linux；</li><li>另一方面指的是以 Linux 内核为基础的整个操作系统，所以这种方式表示的 Linux 指的是包含内核、系统工具、完整的开发环境和应用的类 Unix 操作系统；</li></ul><p>Linux 现在是个人计算机和工作站上的 Unix 类操作系统。按照层次结构的观点，在同一种硬件平台上，Linux 可以提供和 Unix 相同的服务，即相同的用户级和程序员级接口。Linux 绝不是简化版的 Unix，相反，Linux 是强有力和具有创新意义的 Unix 操作系统，不仅继承了 Unix 的特征，而且在许多方面超过了 Unix 。作为 Unix 类操作系统，Linux 操作系统具有如下基本特征：</p><ul><li>是真正的多用户、多任务操作系统</li><li>符合 POSIX 标准的操作系统</li><li>提供具有内置安全措施的分层的文件系统</li><li>提供 shell 命令解释程序和编程语言</li><li>提供强大的管理功能，包括远程管理功能</li><li>具有内核的编程接口</li><li>具有图形用户接口</li><li>具有大量有用的实用程序和通信、联网工具</li><li>具有面向屏幕的编辑软件</li></ul><h2 id="Linux的内核特征"><a href="#Linux的内核特征" class="headerlink" title="Linux的内核特征"></a>Linux的内核特征</h2><p>Linux 操作系统的核心稳定而且高效，以独占的方式执行最底层任务，保证其他程序的正常运行是整个系统的核心和独特的性质。</p><p>1、接口特色</p><p>按照 POSIX 标准，可以运行 Unix 程序的系统就是 Unix，使用 Linux 系统也属于 Unix 的一种。为此，Linux 系统提供了和一般 Unix 系统相同的标准界面，包括程序级和用户级的。</p><p>2、功能特色</p><p>Linux 核心最早运行在 Intel 80386 系统 PC 机上，如今，Linux 已经能够正常运行在 Apple、DEC alpha、MIPS、Motorola 等等一系列计算机上。同时，一些改进的嵌入式 Linux 核心也可以运行在手机、家电等设备上。Linux 系统支出多种硬件设备，并且由于 Linux 系统下的驱动程序的开发方式相比 Windows 等其他操作系统更为简单，所以越来越多的硬件厂商也针对 Linux 操作系统提供设备驱动。此外，Linux 的内存管理采用多级分页的方式；使用专用文件系统 Ext2 可以提供方便有效的文件共享及保护机制；内置 TCP&#x2F;IP 协议栈也提供了各种高效的网络功能，包括基本的进程间通信、网络文件服务等等。</p><h2 id="Linux的版本查看"><a href="#Linux的版本查看" class="headerlink" title="Linux的版本查看"></a>Linux的版本查看</h2><p>Linux 内核采用的是双树系统，一棵树是稳定树，主要用于发行；另一棵树是非稳定树或者开发树，用于产品开发、改进。Linux 版本序号的形式为 x.y.z ，对于稳定树来说，y 是偶数；而对于开发树拉说，y 是相比稳定树大一的奇数。</p><p>我们可以在 Linux 操作系统的终端窗口下通过命令来获取当前操作系统的版本号，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure><p>结果显示如下：</p><img src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/5.png" class="" title="图片描述">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：本章知识点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是操作系统&lt;/li&gt;
&lt;li&gt;操作系统有哪些功能&lt;/li&gt;
&lt;li&gt;操作系统的发展历史&lt;/li&gt;
&lt;li&gt;操作系统的分类&lt;/li&gt;
&lt;li&gt;操作系统的结构组成&lt;/li&gt;
&lt;li&gt;Linux &lt;stro</summary>
      
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Linux" scheme="http://example.com/categories/A-OS/Linux/"/>
    
    <category term="Linux操作系统原理剖析" scheme="http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="《Linux操作系统原理剖析》" scheme="http://example.com/tags/%E3%80%8ALinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【RPC】ALPC 调用详解（翻译|TODO）</title>
    <link href="http://example.com/A_OS/Windows/RPC/%E3%80%90RPC%E3%80%91ALPC/"/>
    <id>http://example.com/A_OS/Windows/RPC/%E3%80%90RPC%E3%80%91ALPC/</id>
    <published>2023-12-06T06:00:49.632Z</published>
    <updated>2023-12-06T10:16:19.403Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：ALPC 调用过程</p><p>学习rpc调用过程看到了csandker 的这篇文章，学习记录一下吧，供大家参考 <a href="https://csandker.io/2022/05/24/Offensive-Windows-IPC-3-ALPC.html">Offensive Windows IPC Internals 3: ALPC · csandker.io</a></p></blockquote><span id="more"></span><p>补一张作者画的图，是alpc的客户端和服务端创建及交互的过程。</p><img src="/A_OS/Windows/RPC/%E3%80%90RPC%E3%80%91ALPC/ALPC_Message_Flow.svg" class="" title="alpc">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：ALPC 调用过程&lt;/p&gt;
&lt;p&gt;学习rpc调用过程看到了csandker 的这篇文章，学习记录一下吧，供大家参考 &lt;a href=&quot;https://csandker.io/2022/05/24/Offensive-Windows-IPC-3-ALPC.html&quot;&gt;Offensive Windows IPC Internals 3: ALPC · csandker.io&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="A_OS" scheme="http://example.com/categories/A-OS/"/>
    
    <category term="Windows" scheme="http://example.com/categories/A-OS/Windows/"/>
    
    <category term="RPC" scheme="http://example.com/categories/A-OS/Windows/RPC/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
    <category term="RPC" scheme="http://example.com/tags/RPC/"/>
    
    <category term="ALPC" scheme="http://example.com/tags/ALPC/"/>
    
  </entry>
  
  <entry>
    <title>【汇编】调用约定</title>
    <link href="http://example.com/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <id>http://example.com/B_Code/%E6%B1%87%E7%BC%96/%E3%80%90%E6%B1%87%E7%BC%96%E3%80%91%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</id>
    <published>2023-12-05T16:00:00.000Z</published>
    <updated>2023-12-15T01:31:32.900Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>概述：各种调用约定下的汇编入参方式</p><p>参考文章：<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/argument-passing-and-naming-conventions?view=msvc-170">自变量传递和命名约定 | Microsoft Learn</a></p></blockquote><h2 id="fastcall"><a href="#fastcall" class="headerlink" title="__fastcall"></a>__fastcall</h2><p><strong><code>__fastcall</code></strong> 调用约定指定尽可能在寄存器中传递函数的自变量。 此调用约定仅适用于 x86 体系结构。 以下列表显示此调用约定的实现。</p><p>Expand table</p><table><thead><tr><th align="left">元素</th><th align="left">实现</th></tr></thead><tbody><tr><td align="left">参数传递顺序</td><td align="left">在自变量列表中按从左到右的顺序找到的前两个 <code>DWORD</code> 或更小自变量将在 ECX 和 EDX 寄存器中传递；所有其他自变量在堆栈上从右向左传递。</td></tr><tr><td align="left">堆栈维护职责</td><td align="left">已调用函数会弹出显示堆栈中的参数。</td></tr><tr><td align="left">名称修饰约定</td><td align="left">At 符号 (@) 是名称的前缀；参数列表中的字节数（在十进制中）前面的 at 符号是名称的后缀。</td></tr><tr><td align="left">大小写转换约定</td><td align="left">不执行任何大小写转换。</td></tr><tr><td align="left">类、结构和并集</td><td align="left">被视为“多字节”类型（无论大小）并在堆栈上传递。</td></tr><tr><td align="left">枚举和枚举类</td><td align="left">如果它们的基础类型是通过寄存器传递的，则通过寄存器传递。 例如，如果基础类型是大小为 8、16 或 32 位的 <code>int</code> 或 <code>unsigned int</code>。</td></tr></tbody></table><h2 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h2><p><strong>特定于 Microsoft</strong><strong><code>__thiscall</code></strong> 的调用约定用于 x86 体系结构上的 C++ 类成员函数。 它是成员函数使用的默认调用约定，该约定不使用变量参数（<code>vararg</code> 函数）。</p><p>在 <strong><code>__thiscall</code></strong> 下，被调用方清理堆栈，这对于 <code>vararg</code> 函数是不可能的。 自变量将从右到左推送到堆栈中。 指针 <strong><code>this</code></strong> 通过注册 ECX 传递，而不是在堆栈上传递。</p><p>在 ARM、ARM64 和 x64 计算机上，**<code>__thiscall</code>** 由编译器接受和忽略。 这是因为它们默认使用基于寄存器的调用约定。</p><p>使用 <strong><code>__thiscall</code></strong> 的原因之一是在类中成员函数默认使用 **<code>__clrcall</code>**。 在这种情况下，可以使用 <strong><code>__thiscall</code></strong> 确保各个成员函数可以从本机代码调用。</p><p>采用 <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/clr-common-language-runtime-compilation?view=msvc-170"><code>/clr:pure</code></a> 进行编译时，除非另有规定，否则所有函数和函数指针都是 **<code>__clrcall</code>**。 <strong><code>/clr:pure</code></strong> 和 <strong><code>/clr:safe</code></strong> 编译器选项在 Visual Studio 2015 中已弃用，并且在 Visual Studio 2017 中不受支持。</p><p><code>vararg</code> 成员函数使用 <strong><code>__cdecl</code></strong> 调用约定。 所有函数参数都推送在堆栈上，**<code>this</code>** 指针放在最后一个堆栈上。</p><p>由于此调用约定仅适用于 C++，因此它没有 C 名称修饰方案。</p><p>在非静态类成员函数外行定义时，仅在声明中指定调用约定修饰符。 无需在行外定义上再次指定它。 编译器使用在定义点声明期间指定的调用约定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;概述：各种调用约定下的汇编入参方式&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://learn.microsoft.com/zh-cn/cpp/cpp/argument-passing-and-naming-conventions?vie</summary>
      
    
    
    
    <category term="B_Code" scheme="http://example.com/categories/B-Code/"/>
    
    <category term="汇编" scheme="http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"/>
    
    
    <category term="汇编" scheme="http://example.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
