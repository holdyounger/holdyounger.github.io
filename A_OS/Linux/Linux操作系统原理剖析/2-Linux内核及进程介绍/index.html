
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1" theme-name="Stellar" theme-version="1.28.1">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv="x-dns-prefetch-control" content="on">
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f9fafb">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  
  <title>【原理剖析】Linux内核及进程概述 - oone</title>

  
    <meta name="description" content="概述：本章知识点  Linux 内核结构 Linux 进程概述 Linux 系统对进程的创建、切换、结束操作">
<meta property="og:type" content="article">
<meta property="og:title" content="【原理剖析】Linux内核及进程概述">
<meta property="og:url" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="oone">
<meta property="og:description" content="概述：本章知识点  Linux 内核结构 Linux 进程概述 Linux 系统对进程的创建、切换、结束操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/0.png">
<meta property="og:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/1.png">
<meta property="og:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/2.png">
<meta property="og:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/3.png">
<meta property="og:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/4.png">
<meta property="og:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/5.png">
<meta property="og:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/6.png">
<meta property="og:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/7.png">
<meta property="og:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/8.png">
<meta property="og:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/9.png">
<meta property="article:published_time" content="2023-12-25T01:28:27.210Z">
<meta property="article:modified_time" content="2024-01-09T08:57:10.852Z">
<meta property="article:author" content="mingming">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="内核">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/0.png">
  
  
  
  <meta name="keywords" content="Linux,内核">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="oone" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.28.1">

  
    <link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/88082435?v=4">
  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post"><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://avatars.githubusercontent.com/u/88082435?v=4" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">oone</div><div class="sub normal cap">固执无罪，梦想无价</div><div class="sub hover cap" style="opacity:0"> Coding For Knowledge</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewbox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"/><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"/></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="文档" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="AboutMe" href="/more/" style="color:#FA6400"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewbox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/A_%E5%86%85%E5%8A%9F/A_POC%E6%8E%A2%E7%B4%A2/Exchange/%E3%80%90CVE-2020-0688%E3%80%91exchange%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"><span class="title">【CVE-2020-0688】exchange远程代码执行漏洞复现</span></a><a class="item title" href="/B_%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E3%80%90%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E3%80%91%E8%80%83%E5%89%8D%E6%95%B4%E7%90%86/"><span class="title">【软件设计师】考前整理</span></a><a class="item title" href="/diary/%E7%81%B5%E9%AD%82/"><span class="title">灵魂</span></a><a class="item title" href="/diary/%E9%87%8A%E6%80%80/"><span class="title">释怀</span></a><a class="item title" href="/A_OS/Windows/%E3%80%90ntdll%E3%80%91ntdll/"><span class="title">【todo】【ntdll】ntdll导出接口</span></a><a class="item title" href="/A_OS/Windows/API/CreateProcess/"><span class="title"><strong>WINAPI</strong><span class="dot"></span>【todo】【API】CreateProcess 使用及调用流程</span></a><a class="item title" href="/A_%E5%86%85%E5%8A%9F/A_POC%E6%8E%A2%E7%B4%A2/SQL%E6%B3%A8%E5%85%A5/%E3%80%90SQL%E6%B3%A8%E5%85%A5%E9%98%B2%E5%BE%A1%E3%80%91index/"><span class="title">【SQL注入防御】</span></a><a class="item title" href="/E_%E6%89%8B%E5%86%8C/Git/Git%20emoji%E6%89%8B%E5%86%8C/"><span class="title">git emoji手册</span></a><a class="item title" href="/A_OS/Windows/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Exchange-2016/"><span class="title">【环境搭建】Exchange Server 2016 CU21</span></a><a class="item title" href="/B_Code/CSharp/%E3%80%90.Net%E3%80%91%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A2%E7%B4%A2/"><span class="title">【.Net】反序列化漏洞探索</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/A-OS/">A_OS</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/A-OS/Linux/">Linux</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/">Linux操作系统原理剖析</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2023-12-25T01:28:27.210Z">2023-12-25</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-01-09T08:57:10.852Z">2024-01-09</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>【原理剖析】Linux内核及进程概述</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><blockquote>
<p>概述：本章知识点</p>
<ul>
<li>Linux 内核结构</li>
<li>Linux 进程概述</li>
<li>Linux 系统对进程的创建、切换、结束操作</li>
</ul>
</blockquote>
<span id="more"></span>



<h2 id="0x01-Linux-内核概述"><a href="#0x01-Linux-内核概述" class="headerlink" title="0x01 Linux 内核概述"></a>0x01 Linux 内核概述</h2><p>事实上，在 Linux 操作系统中设计到真正的操作系统的功能部分其实都是放在 Linux 内核中的。Linux 内核其实就是 Linux 操作系统中最重要的部分。Linux 内核是硬件和软件之间的中间层，将应用程序的请求传递给硬件并充当底层驱动程序，对系统中的各个设备和组件进行寻址等等一些了功能。</p>
<p>目前，对于 Linux 内核的研究主要分为以下三部分功能：</p>
<ul>
<li>内核的硬件设备管理功能：从应用程序的角度来说，内核可以被认为是一台被抽象的计算机。当内核寻址硬盘，必须确定使用哪个路径能够从硬盘上将数据读取到内存中，这其中涉及到的数据位置、路径及读取数据的指令都是由内核完成的，而对于上层应用程序仅仅需要调用内核的一个接口函数即可完成。从某方面来说，应用程序与硬件本身没有联系，仅仅与内核有联系，内核是应用程序所知道的层次结构中最底。</li>
<li>内核的进程管理功能：当若干应用程序在系统中同时运行时，Linux 内核又需要充当资源管理程序，将可用共享资源（ CPU 时间、磁盘空间、网络连接等等）合理分配给各个系统进程使用，同时还能保证系统的完整性。</li>
<li>内核面向系统接口功能：Linux 内核会面向系统提供一系列的接口函数供应用程序来调用。应用程序通过调用 Linux 内核的一系列系统接口能够使得 Linux 系统帮助应用程序完成一系列功能。</li>
</ul>
<p>另外，为了更简单理解 Linux 操作系统的功能原理，我们选择早期版本的 Linux 内核作为代码参考，这样可能有效避免很多代码结构优化的代码内容的干扰。目前主流研究 Linux 内核的早期版本都选择的是 Linux 0.12 版本，因为这一版本的整体代码量大约仅有 2 万行，并且在这一版本中的 Linux 内核的大部分主要功能已经都齐全了，后期的 Linux 内核主要完善各个功能协调、硬件适配、平台适配等等方面（最新的 Linux 6.1 版本代码量已经突破 2700 万行）</p>
<p>Linux 内核对于操作系统来说其实是单内核模式，这样对于操作系统所提供的服务流程主要为：应用主程序使用指定的参数值执行系统调用指令（ <code>int 0x80</code> )，使得 CPU 从用户态切换到了内核态，然后操作系统根据具体的参数值调用特定的服务程序，而这些服务程序在完成了对应的执行操作后，操作系统再次使得 CPU 从内核态切换回到用户态，从而返回到应用程序中继续执行。因此，可以将 Linux 内核简单概括为三个层次：调用服务程序的主程序层、执行系统调用的服务层和支持系统调用的底层函数。具体如下图所示：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/0.png" class title="图片描述" data-fancybox="true">

<h2 id="0x02-Linux-内核结构及任务管理功能"><a href="#0x02-Linux-内核结构及任务管理功能" class="headerlink" title="0x02 Linux 内核结构及任务管理功能"></a>0x02 Linux 内核结构及任务管理功能</h2><p>Linux 内核其实主要由 5 个模块构成，分别是：</p>
<ul>
<li>进程调度模块</li>
<li>内存管理模块</li>
<li>文件系统模块</li>
<li>进程间通信模块</li>
<li>网络接口模块</li>
</ul>
<p>这几个模块之间的依赖关系如下图所示：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/1.png" class title="图片描述" data-fancybox="true">

<p>由上图能够看出来，所有的模块都与进程调度模块存在依赖关系。因为它们都需要依靠进程调度模块完成程序的挂起（暂停）或者进行运行的状态管理。通常，一个模块会在等待硬件操作期间挂起，在操作完成过后继续执行。</p>
<p>结合 Linux 0.12 内核源代码，可以将内核中的主要模块绘制成如下图所示的框图结构：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/2.png" class title="图片描述" data-fancybox="true">

<h2 id="0x03-进程的定义"><a href="#0x03-进程的定义" class="headerlink" title="0x03 进程的定义"></a>0x03 进程的定义</h2><p>进程是操作系统中最基本、最重要的概念之一。进程的概念最早是 20 世纪 60 年代初期由 MIT （美国麻省理工学院）研制的 multics 系统和 IBN 的 TSS&#x2F;360 系统中命名的。从那时候开始，操作系统中有了进程的概念：</p>
<ul>
<li>进程是程序的一次执行</li>
<li>进程是可以和其他进程并发执行的计算</li>
<li>进程就是一个程序在给定活动空间和初始条件下，在一个处理机上的执行过程</li>
<li>进程是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位</li>
<li>进程是动态的、有生命周期的活动。内核可以创建一个进程，最终将由内核终止该进程使其消亡</li>
</ul>
<p>我们知道程序是由代码经过编译器编译之后称为可执行文件，而进程则是由程序文件执行过程中存在的，具体区别如下：</p>
<ul>
<li>程序是今天的概念，是可以作为一种软件资源长期保存，而进程是程序的一次执行过程，是动态的概念</li>
<li>进程是一个能够独立运行的单位，能够与其他进程并发执行。进程在程序执行过程中作为资源申请和调度的单位存在，通常的程序是不能够作为独立运行的单位而并发执行的。</li>
<li>程序和进程不存在一一对应的关系。一个程序运行一次便会创造一个进程，多次运行就会创造多个进程。</li>
<li>各个进程在并发执行的过程中产生相互制约的关系，造成各自运行的不可预测，而程序是静态的，不存在这种异步特征。</li>
</ul>
<h2 id="0x04-进程的特征"><a href="#0x04-进程的特征" class="headerlink" title="0x04 进程的特征"></a>0x04 进程的特征</h2><p>目前概括，进程具有如下特征：</p>
<ul>
<li>动态性：进程是进程实体的执行过程。因此，动态性是进程最基本的特性。进行由创建而产生，调度而执行，因得不到资源而挂起执行，因为撤销而消亡，由此可见，进程是有一定的生命周期的。</li>
<li>并发性：这是指多个进程实体，共存于内存中并在一段时间内同时执行。并发性是进程的重要特征，同时也是操作系统的重要特征。</li>
<li>独立性：进程是一个能够独立运行的基本单位，同时也是系统中独立获得资源和调度管理的基本单位。</li>
<li>异步性：进程按照各自独立的、不可预知的速度向前运行，这样的话，多个进程同时运行时是按照异步方式运行。这一特征导致程序执行的不可预测性及不可再现性。因此，在操作系统中必须采取某些措施来保证各个进程之间能够协调运行。</li>
<li>结构特征：从结构上看，进程实体是由程序段、数据段以及进程控制块组成，所以可以简单将这三部分称为进程映像。</li>
</ul>
<h2 id="0x05-Linux-进程控制"><a href="#0x05-Linux-进程控制" class="headerlink" title="0x05 Linux 进程控制"></a>0x05 Linux 进程控制</h2><p>前面已经说明了程序是一个可执行的文件，而进程才是一个执行中的程序实例。通过 CPU 时间片轮转的调度方式，在 Linux 操作系统上能够同时运行多个进程。</p>
<p>所有的现代操作系统都能够同时运行很多个进程，实际上系统中也仅有一个处理器，那么在一个时间点实际上只有一个进程真正运行在处理器上。但是我们用户在计算机上感觉到真的是同时有很多进程都在运行，并且感觉不到他们之间有什么切换和停滞。</p>
<p>造成这样的现象，实际上是因为 Linux 内核与处理器建立了多任务的错觉，同时运行的多任务处理实际上是操作系统在运行时通过快速任务切换和调度使得我们无法感觉到任务执行的前后顺序。</p>
<p>对于早期的 Linux 0.12 版本的内核来说，最多能够接受 64 个进程的同时存在。其中除了内核自己建立的并运行起来的第一个进程之外，其他进程都是由系统调用 <code>fork</code> 创建的进程，被创建的进程称为子进程，创建该进程的进程称为父进程。内核程序使用进程标识号( <code>PID</code> ) 来标记识别每一个进程。进程由可执行的指令代码、数据以及堆栈区组成。进程中的代码和数据部分分别存放在对应执行文件的代码段、数据段。每个进程只能执行自己的代码和访问自己的数据和堆栈区域。进程之间的通信需要通过系统调用来进行。对于一个 CPU 的系统，同一时刻也仅有一个进程正在运行。Linux 内核通过调度程序分时处理各个进程运行。</p>
<h2 id="0x06-Linux-中进程表介绍"><a href="#0x06-Linux-中进程表介绍" class="headerlink" title="0x06 Linux 中进程表介绍"></a>0x06 Linux 中进程表介绍</h2><p>在 Linux 操作系统中，Linux 内核实际上通过进程表来对系统中的进程进行管理，每个进程在进程表中都占有一项。在 Linux 系统中，进程表实际上就是一个 <code>task_struct</code> 数据结构的指针。这个数结构十分重要。</p>
<p>Linux 内核中设计到进程和程序的所有管理和算法都围绕着一个名为 <code>task_struct</code> 的数据结构建立，该数据结构的定义位于 Linux 内核代码中 <code>include/Linux/sched.h</code> 头文件中。在具体讲解 Linux 对于进程管理之前必须先了解一下这个重要的数据结构。</p>
<p><code>task_struct</code> 中包含了很多数据成员，具体代码定义内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 任务(进程)数据结构，或称为进程描述符 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don&#x27;t touch */</span></span><br><span class="line"><span class="comment">/* 硬编码字段 */</span></span><br><span class="line">    <span class="type">long</span> state;                     <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">                                    <span class="comment">/* 任务运行状态 -1 不可运行，0 可运行(就绪)， &gt;0 已停止 */</span></span><br><span class="line">    <span class="type">long</span> counter;                   <span class="comment">/* 任务运行时间计数(递减)(滴答数)，运行时间片 */</span></span><br><span class="line">    <span class="type">long</span> priority;                  <span class="comment">/* 优先级 */</span></span><br><span class="line">    <span class="type">long</span> signal;                    <span class="comment">/* 信号位图 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span>    <span class="comment">/* 信号执行属性结构,对应信号将要执行的操作和标志信息 */</span></span><br><span class="line">    <span class="type">long</span> blocked;                   <span class="comment">/* 进程信号屏蔽码(对应信号位图) */</span> <span class="comment">/* bitmap of masked signals */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line"><span class="comment">/* 可变字段 */</span></span><br><span class="line">    <span class="type">int</span> exit_code;                  <span class="comment">/* 退出码 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code;       <span class="comment">/* 代码段地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end_code;         <span class="comment">/* 代码段长度（字节数） */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end_data;         <span class="comment">/* 代码段加数据段的长度 （字节数）*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> brk;              <span class="comment">/* 总长度(字节数) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_stack;      <span class="comment">/* 堆栈段地址 */</span></span><br><span class="line">    <span class="type">long</span> pid;                       <span class="comment">/* 进程标识号(进程号) */</span></span><br><span class="line">    <span class="type">long</span> pgrp;                      <span class="comment">/* 进程组号 */</span></span><br><span class="line">    <span class="type">long</span> session;                   <span class="comment">/* 会话号 */</span></span><br><span class="line">    <span class="type">long</span> leader;                    <span class="comment">/* 会话首领 */</span></span><br><span class="line">    <span class="type">int</span> groups[NGROUPS];            <span class="comment">/* 进程所属组号（一个进程可属于多个组） */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * pointers to parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment">     * older sibling, respectively.  (p-&gt;father can be replaced with</span></span><br><span class="line"><span class="comment">     * p-&gt;p_pptr-&gt;pid)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_pptr</span>;</span>     <span class="comment">/* 指向父进程的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_cptr</span>;</span>     <span class="comment">/* 指向最新子进程的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_ysptr</span>;</span>    <span class="comment">/* 指向比自己后创建的相邻进程的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_osptr</span>;</span>    <span class="comment">/* 指向比自己早创建的相邻进程的指针 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> uid;             <span class="comment">/* 用户id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> euid;            <span class="comment">/* 有效用户id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> suid;            <span class="comment">/* 保存的设置用户id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> gid;             <span class="comment">/* 组id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> egid;            <span class="comment">/* 有效组id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sgid;            <span class="comment">/* 保存的设置组id */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> timeout;          <span class="comment">/* 内核定时超时值 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> alarm;            <span class="comment">/* 报警定时值(滴答数) */</span></span><br><span class="line">    <span class="type">long</span> utime;                     <span class="comment">/* 用户态运行时间(滴答数) */</span></span><br><span class="line">    <span class="type">long</span> stime;                     <span class="comment">/* 内核态运行时间(滴答数) */</span></span><br><span class="line">    <span class="type">long</span> cutime;                    <span class="comment">/* 子进程用户态运行时间 */</span></span><br><span class="line">    <span class="type">long</span> cstime;                    <span class="comment">/* 子进程内核态运行时间 */</span></span><br><span class="line">    <span class="type">long</span> start_time;                <span class="comment">/* 进程开始运行时刻 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span>   <span class="comment">/* 进程资源使用统计数组 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;                 <span class="comment">/* per process flags, defined below */</span></span><br><span class="line">                                        <span class="comment">/* 各进程的标志 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> used_math;           <span class="comment">/* 是否使用了协处理器的标志 */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">    <span class="type">int</span> tty;        <span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line">                    <span class="comment">/* 进程使用tty终端的子设备号。-1表示没有使用 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> umask;           <span class="comment">/* 文件创建属性屏蔽位 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span>           <span class="comment">/* 当前工作目录i节点结构指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span>          <span class="comment">/* 根目录i节点结构指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span>    <span class="comment">/* 执行文件i节点结构指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">library</span>;</span>       <span class="comment">/* 被加载库文件i节点结构指针 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> close_on_exec;    <span class="comment">/* 执行时关闭文件句柄位图标志 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span>    <span class="comment">/* 文件结构指针表，最多32项。表项号即是文件描述符的值 */</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span>      <span class="comment">/* 局部描述符表, 0 - 空，1 - 代码段cs，2 - 数据和堆栈段ds&amp;ss */</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span>          <span class="comment">/* 进程的任务状态段信息结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于数据量这么庞大、如此复杂的数据结构，短时间内弄清楚是很困难的，我们可以将这个结构中的内容分为几个部分来逐个理解弄清楚。虽然数据结构内数据量巨大，但是主要可以分为以下几部分进行理解：</p>
<ul>
<li>表示进程状态和执行信息，待决信号、使用的二进制格式、进程 ID （PID）、父进程及其他相关进程的指针、优先级以及程序执行</li>
<li>有关已经分配的虚拟内存的信息。</li>
<li>进程身份或者权限，用户 ID 、组 ID 等等。</li>
<li>使用的文件包含程序代码的二进制文件、以及进程所处理的所有文件的文件系统信息。</li>
<li>线程信息记录该进程特定于 CPU 的运行时间数据。</li>
<li>在于其他应用程序协作时所需的进程间通信有关的信息。</li>
<li>该进程所用到的信号处理程序，用于响应到来的信号。</li>
</ul>
<p>下面，先将其中重要的几个成员变量进行讲解说明。</p>
<h4 id="state"><a href="#state" class="headerlink" title="state"></a><code>state</code></h4><p><code>task_struct</code> 结构中的 <code>state</code> 成员变量表示的就是该进程当前的状态，在 Linux 内核中，进程主要分为以下几种状态：</p>
<ul>
<li><code>TASK_RUNNING</code> ：表示进程处于可运行状态。但是可运行状态并不意味着实际分配了 CPU 资源。这样的状态其实对应的就是进程的就绪状态，意味着当系统调度器选中该进程时能够立刻执行它。</li>
<li><code>TASK_INTERRUPTIBLE</code> ：该状态是针对等待某个事件或其他资源的睡眠进程设置的。处于这种状态下的进程在得到内核对于信号后会立刻将状态改变成 <code>TASK_RUNNING</code> 状态以恢复正常运行。</li>
<li><code>TASK_UNINTERRUPTIBLE</code> ：这种状态表示是接收到内核指示而停用的睡眠进程。这样的进程不能够由外部信号唤醒，只能由内核亲自唤醒。</li>
<li><code>TASK_STOPPED</code> ：该状态表示进程特意停止运行，例如：由调度器指示而暂停的进程。</li>
<li><code>TASK_TRACED</code> ：这种状态实际上并不是有进程本身运行过程中出现的，是当进程处于被调试的时候用来与常规进程区分而设计的进程状态。</li>
</ul>
<h4 id="counter-字段"><a href="#counter-字段" class="headerlink" title="counter 字段"></a><code>counter</code> 字段</h4><p><code>counter</code> 主要用来保存进程在暂时停止本次运行之前还能够执行的时间滴答数，即在正常情况下还需要经过多少个系统时钟周期才会切换到另一个进程。调度程序会使用进程的该成员值来选择下一个要执行的进程。因此， <code>counter</code> 可以看做是一个进程的动态特性。在一个进程刚被创建时，<code>counter</code> 的初始值为 <code>priority</code>。</p>
<h4 id="priority"><a href="#priority" class="headerlink" title="priority"></a><code>priority</code></h4><p>结合前面对 <code>counter</code> 的描述，<code>priority</code> 的作用就是为了给 <code>counter</code> 赋值。在 Linux 0.12 版本中这个初值设定为 15 ，表示设定初始值为 15 个时间滴答数。</p>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a><code>signal</code></h4><p><code>signal</code> 字段表示进程当前接收到信号的位图，总共 32 位，每一位代表一种系统信号类型。因此，Linux 内核中最多也仅有 32 种信号。在每个系统调用处理后，系统会使用该信号位图对信号进行预处理。</p>
<h4 id="sigaction-数组"><a href="#sigaction-数组" class="headerlink" title="sigaction 数组"></a><code>sigaction</code> 数组</h4><p>该数值类型为 <code>struct sigaction</code> ，该结构数组用来保存处理各个信号所用的操作和属性，数组每一项对应一个信号。具体结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);    <span class="comment">/* 对应某信号指定要采取的行动 */</span></span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;           <span class="comment">/* 对信号的屏蔽码，在信号程序执行时将阻塞对这些信号的处理 */</span></span><br><span class="line">    <span class="type">int</span> sa_flags;               <span class="comment">/* 改变信号处理过程的信号集 */</span></span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);<span class="comment">/* 恢复函数指针，由函数库Libc提供，用于清理用户态堆栈 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="blocked"><a href="#blocked" class="headerlink" title="blocked"></a><code>blocked</code></h4><p>该字段表示进程当前不想要处理的信号的阻塞位图。与 <code>signal</code> 字段类似，每一位表示一种对应被阻塞的信号。</p>
<h4 id="exit"><a href="#exit" class="headerlink" title="exit"></a><code>exit</code></h4><p>这一字段用来保存程序终止时的退出码。在子进程结束后父进程能够查询子进程的这个退出码。</p>
<h4 id="start-code"><a href="#start-code" class="headerlink" title="start_code"></a><code>start_code</code></h4><p>该字段用来保存进程代码在 CPU 线性地址空间中的开始地址，在 Linux 0.12 内核中这个数值是 64 MB 的整数倍。</p>
<h4 id="end-code"><a href="#end-code" class="headerlink" title="end_code"></a><code>end_code</code></h4><p>该字段保存着进程代码的字节长度值。</p>
<h4 id="end-data"><a href="#end-data" class="headerlink" title="end_data"></a><code>end_data</code></h4><p>该字段保存进程的代码程度 + 数据长度的总字节长度值。</p>
<h4 id="brk"><a href="#brk" class="headerlink" title="brk"></a><code>brk</code></h4><p>这个字段也是进程代码和数据的总字节长度（指针值），但是还包括未初始化的数据区 <code>BSS</code> 。这是 <code>brk</code> 在一个进程开始执行的初始值。通过修改这个指针的数值，内核可以为进程添加和释放动态分配的内存（通常通过调用 <code>malloc</code> 函数来调用 <code>brk</code> 系统调用实现）。</p>
<h4 id="start-stack"><a href="#start-stack" class="headerlink" title="start_stack"></a><code>start_stack</code></h4><p>该字段指向进程逻辑地址空间中堆栈的起始处。</p>
<h4 id="pid"><a href="#pid" class="headerlink" title="pid"></a><code>pid</code></h4><p>顾名思义，保存进程标识号，用来唯一表示进程。</p>
<h4 id="pgrp"><a href="#pgrp" class="headerlink" title="pgrp"></a><code>pgrp</code></h4><p>指进程所属进程组号</p>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a><code>session</code></h4><p>进程的会话号，所属会话的进程号</p>
<h4 id="leader"><a href="#leader" class="headerlink" title="leader"></a><code>leader</code></h4><p>进程所属会话的首进程号。</p>
<h4 id="group-NGROUPS"><a href="#group-NGROUPS" class="headerlink" title="group[NGROUPS]"></a><code>group[NGROUPS]</code></h4><p>进程所属各个组的组号数组，一个进程可以属于多个组</p>
<h4 id="p-pptr-、-p-cptr-、-p-ysptr-、-p-isptr"><a href="#p-pptr-、-p-cptr-、-p-ysptr-、-p-isptr" class="headerlink" title="p_pptr 、 p_cptr 、 p_ysptr 、 p_isptr"></a><code>p_pptr</code> 、 <code>p_cptr</code> 、 <code>p_ysptr</code> 、 <code>p_isptr</code></h4><p>这几个字段均为 <code>task_struct</code> 数据结构指针。其中：</p>
<ul>
<li><code>p_pptr</code> 是指向父进程任务结构的指针</li>
<li><code>p_cptr</code> 是指向最新子进程任务结构的指针</li>
<li><code>p_ysptr</code> 是指向比自己后创建的相邻进程的指针</li>
<li><code>p_isptr</code> 是指向比自己早创建的相邻进程的指针</li>
</ul>
<p>以上这四个指针的关系如下图所示，通过这样的成员指针数据，内核很容易就能通过一个进程的任务结构获取到其他与这个进程有关系的进程的任务结构对象。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/3.png" class title="图片描述" data-fancybox="true">

<h4 id="uid-、-euid-、-suid-、-gid-、-egid-、-sgid"><a href="#uid-、-euid-、-suid-、-gid-、-egid-、-sgid" class="headerlink" title="uid 、 euid 、 suid 、 gid 、 egid 、 sgid"></a><code>uid</code> 、 <code>euid</code> 、 <code>suid</code> 、 <code>gid</code> 、 <code>egid</code> 、 <code>sgid</code></h4><p>这几个成员字段都属于进程用户相关标识号，其中：</p>
<ul>
<li><code>uid</code>：保存拥有这个进程的用户标识号（用户 ID ）</li>
<li><code>euid</code>：有效用户标识号，表示访问文件的权限</li>
<li><code>suid</code> ：文件保存的用户标识号，当执行文件的设置用户 ID 标志置一时， <code>suid</code> 中把保存执行文件的 uid ，否则保存进程的 <code>euid</code></li>
<li><code>gid</code> ：指用户所属的组标识号（组 ID ），指明了用于该进程的用户组</li>
<li><code>egid</code> ：有效组 ID ，用于指明该组用户访问文件的权限</li>
<li><code>sgid</code> ：保存的用户 ID ，当执行文件的设置组 ID 标志置一时，<code>sgid</code> 中保存执行文件的 <code>gid</code> ；否则，保存进程的 <code>egid</code> 。</li>
</ul>
<h4 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a><code>timeout</code></h4><p>记录内核定时超时的值。</p>
<h4 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a><code>alarm</code></h4><p>用于进程的报警定时值。如果进程使用系统调用 <code>alarm()</code> 设置过该字段，则内核会把该函数以秒为单位的参数转换成滴答值存放到这个字段中，</p>
<h4 id="rlim-数组"><a href="#rlim-数组" class="headerlink" title="rlim 数组"></a><code>rlim</code> 数组</h4><p><code>rlim</code> 数组成员主要作为 Linux 提供资源限制的参数，该数组成员类型为 <code>struct rlimit</code> ，具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> rlim_cur;</span><br><span class="line">    <span class="type">int</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体类型中：</p>
<ul>
<li><code>rlim_cur</code> ：表示进程当前的资源限制，也称为软件限制。</li>
<li><code>rlim_max</code> ：表示进程当前最大可允许的限制范围，称为硬件限制。</li>
</ul>
<p>操作系统能够调用 <code>setrlimit()</code> 函数来增减当前的资源限制具体数值，但是依旧不能够超过 <code>rlim_max</code> 指定的值。对应的，<code>getrlimits()</code> 能够用来检查当前限制的具体数值。</p>
<p>在内核中，对于 <code>rlim</code> 变量的数组位置是与资源类型相关的，这是 Linux 内核中预定义的常数，在 Linux 0.12 版本中还仅有 6 中资源类型，后面发展到现在已经多达 15 种类型了，具体可以使用 <code>man</code> 手册查看 <code>setrlimit</code> 。这里简单列出 Linux 0.12 版本中定义的几种类型，其定义位置位于内核源代码的 <code>include/sys/resource.h</code> 头文件中，具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_CPU      0       <span class="comment">/* CPU time in ms */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_FSIZE    1       <span class="comment">/* Maximum filesize */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_DATA     2       <span class="comment">/* max data size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_STACK    3       <span class="comment">/* max stack size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_CORE     4       <span class="comment">/* max core file size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_RSS      5       <span class="comment">/* max resident set size */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> notdef</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_MEMLOCK  6       <span class="comment">/* max locked-in-memory address space*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_NPROC    7       <span class="comment">/* max number of processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIMIT_OFILE    8       <span class="comment">/* max number of open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIM_NLIMITS    6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLIM_INFINITY   0x7fffffff</span></span><br></pre></td></tr></table></figure>

<p>实际上，在 Linux 操作系统下，我们还能够通过 <code>cat</code> 命令来查看当前系统中设置的各个资源限制数值。打开终端窗口，输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/self/limits</span><br></pre></td></tr></table></figure>

<p>显示结果如下：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/4.png" class title="图片描述" data-fancybox="true">

<h4 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h4><p>这个结构体中其他字段也都是用来描述进程在执行过冲中的一些状态会用到的值，具体的内容等到我们用到的时候再来描述，这里就不再一一叙述了。</p>
<h2 id="0x07-进程运行状态"><a href="#0x07-进程运行状态" class="headerlink" title="0x07 进程运行状态"></a>0x07 进程运行状态</h2><p>一个进程在生存期内，可以处于不同的状态并且相互转换，这样的状态称为进程状态。进程的当前状态保存在刚刚我们描述过的字段 <code>state</code> 中。当进程正在等待系统中的资源而处于等待状态时，称为睡眠等待状态。在 Linux 系统中，睡眠等待状态分为可中断和不可中断的等待状态。进程具体状态转换关系如下图所示：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/5.png" class title="图片描述" data-fancybox="true">

<p>其中，需要重点描述几个不同的进程运行状态：</p>
<ul>
<li>运行状态 <code>TASK_RUNNING</code> 当进程正在被 CPU 执行，或已经准备就绪随时可以由调度程序执行，则该进程的当前状态就是出于运行状态。如果此时进程没有被 CPU 执行，则进程当前状态为就绪运行状态。另外，进程可以在用户态运行也可以在内核态运行。当进程正在执行用户自己的代码时，可以看做处于用户态运行；而当进程在内核代码中运行时则看做出于内核态运行。像上图描述的那样，当进程因为等待系统资源而进入睡眠状态后，系统资源准备就绪后就会唤醒进程从而使进程状态转换成就绪态。</li>
<li>可中断睡眠状态 <code>TASK_INTERRUPTIBLE</code> 当进程处于可中断等待（睡眠）状态时，系统不会调度该进程执行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，都可以唤醒进程转换到就绪状态。</li>
<li>不可中断睡眠状态 <code>TASK_UNINTERRUPTIBLE</code> 这个状态与可中断睡眠状态最大的不同就是不会因为收到信号而被唤醒，除此之外，其他状态均与可中断睡眠状态类似。处于该状态的进程只能被使用 <code>wake_up()</code> 函数明确唤醒才能转换成可运行的就绪状态。该状态通常在进程需要不受干扰地等待或者所等待事件会快就会发生的时候使用。</li>
<li>暂停状态 <code>TASK_STOPPED</code> 当进程收到信号 <code>SIGSTOP</code> 、 <code>SIGTSTP</code> 、 <code>SIGTTIN</code> 、 <code>SIGTTOU</code> 时就会进入暂停状态。这时候可以通过将信号 <code>SIGONT</code> 发送给进程使得其将状态转换成可运行状态。进程在调试期间接收到任何信号都能进入该状态。</li>
<li>僵死状态 <code>TASK_ZOMBIE</code> 当进程已经停止运行，但是这个进程的父进程还没有调用系统函数去询问其状态时，该进程会处于僵死状态。为了让父进程能够给获取其运行的信息，此时子进程的任务数据结构信息需要持续保留着，以供父进程随时调用，当父进程调用函数查看了该进程的运行信息后，该进程的任务数据结构就会被释放。</li>
</ul>
<p>当一个进程的运行时间片用完，系统就会使用调度程序强制切换到其他进程去执行。另外，如果进程在内核态运行时需要等待系统的某个资源，此时该进程会调用 <code>sleep_on()</code> 或者 <code>interruptible_sleep_on()</code> 主动放弃 CPU 的使用权，而使得调度程序去调度其他进程获取 CPU 资源进行执行，当前进程在调用函数后会转入睡眠状态等待合适的时候再恢复执行。</p>
<h2 id="0x08-进程初始化"><a href="#0x08-进程初始化" class="headerlink" title="0x08 进程初始化"></a>0x08 进程初始化</h2><p>在 Linux 内核代码中，在 <code>boot/</code> 目录中，引导程序将内核从磁盘上加载到内存中，并使得系统进入保护模式下运行以后，就开始执行系统初始化程序 <code>init/main.c</code> ，该程序首先确定如何分配使用系统物理内存，如何调用内核各部分的初始化函数分别对内存管理、中断处理、块设备和字符设备、进程管理以及硬盘和软盘硬件进行初始化处理。在完成这些初始化操作后，系统各部分将处于可运行状态，此后程序把自己设定为 0 号进程并运行，之后再使用 <code>fork()</code> 调用首次创建 1 号进程。在 1 号进程中，程序将继续进行应用环境的初始化并执行 <code>shell</code> 登录程序。而 0 号进程则会在系统空闲时被调度执行，此时 0 号进程只执行 <code>pause()</code> 系统调用，其中又回去执行调度函数。</p>
<p>其中，内核移动程序到 0 号进程中去执行这个过程宏 <code>move_to_user_mode (include/asm/system.h)</code> 完成，它将 <code>main.c</code> 程序执行流从内核态移动到了用户态的进程 0 中继续运行。在移动之前，系统在对调度程序的初始化过程（<code>sched_init()</code>）中，首先对进程 0 的运行环境进行设置，其中包括人工预先设置好的进程 0 的数据结构各字段的值（<code>include/linux/sched.h</code>）、在全局描述符表中添入进程 0 的任务状态段（<code>TSS</code>）描述符和局部描述符表（<code>LDT</code>）的段描述符，并把它们分别加载到任务寄存器 <code>tr</code> 和局部描述符表寄存器 <code>ldr</code> 中。</p>
<p>内核初始化是一个特殊的过程，内核初始化代码其实就是进程 0 的代码。从进程 0 数据结构中设置的初始数据可以知道，进程 0 的代码段和数据段的基地址都是 0 ，段最大字节长度限制在 640KB 。与之相比较，内核代码的代码段和数据段的基地址也都是 0 ，而段长度限制为 16MB ，因此进程 0 的代码段和数据段是包含在内核代码段和数据段中。内核初始程序 <code>main.c</code> 就是进程 0 的代码，只是在真正成为进程 0 之前，系统正在以内核态特权级 0 运行着 <code>main.c</code> 程序。</p>
<p>宏 <code>move_to_user_mode</code> 的功能就是把运行特权级从内核态的 0 级变换成用户态的 3 级，但是仍然继续执行原来的代码指令流。在变换当前程序到 0 号进程的过程中，宏 <code>move_to_user_mode</code> 使用了中断返回指令造成特权级改变的方法。使用这种方法进行控制权转移是由 CPU 保护机制造成的。 CPU 允许低级别代码通过调用门或中断、陷阱门来调用或转移到高级别代码中运行，但反之则不行。因此内核采用这种模拟 <code>IRET</code> 返回低级别代码的方式。该方法的主要思想是在堆栈中构筑中断返回指令需要的内容，把返回地址的段选择符设置成任务 0 代码段选择符，之后执行中断返回指令 <code>iret</code> 将导致 CPU 从特权级 0 跳转到外层的特权级 3 上运行。具体如下图所示：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/6.png" class title="图片描述" data-fancybox="true">

<p>宏 <code>move_to_user_mode</code> 首先往内核堆栈中压入进程 0 堆栈端（即数据段）选择符和内核堆栈指针，然后压入标志寄存器内容，最后压入进程 0 代码段选择符和执行中断返回后需要执行的下一条指令的偏移地址。该偏移位置是 <code>iret</code> 后的下一条指令。</p>
<p>当执行 <code>iret</code> 指令时， CPU 把返回地址送入 CS:EIP 中，同时弹出堆栈中标志寄存器内容。由于 CPU 判断出目的代码段的特权级为 3 ，与当前内核态的 0 级不同，于是 CPU 会把堆栈中的堆栈段选择符和堆栈指针弹出到 SS:ESP 中。由于特权级发生了变化，段寄存器 DS 、 ES 、 FS 以及 GS 的值变得无效，此时 CPU 会把这些段寄存器清零，因此在执行了 <code>iret</code> 指令后需要重新加载这些寄存器。这之后，系统就开始以特权级 3 运行在进程 0 的代码上，所使用的用户态堆栈还是原来移动之前使用的堆栈，而内核态的堆栈则被指定为其任务数据结构所在的页面的顶端开始（ <code>PAGE_SIZE + (long)&amp;init_task</code> ）。之后在创建新进程时，需要复制进程 0 的任务数据结构，包括用户堆栈指针，因此要求进程 0 的用户态堆栈在创建进程 1 之前保持“干净”状态。</p>
<p>对于进程的初始化，我们进行理解和掌握即可，这部分的具体操作都是由 Linux 内核自动完成的，当我们真正进入到 Linux 操作系统的用户态下后，进程的初始化已经完成，Linux 操作系统的 0 号进程已经运行起来了。我们自己的程序此时在 Linux 操作系统下运行时会自然而然由 0 号进程进行创建并执行。</p>
<h2 id="0x09-创建新进程"><a href="#0x09-创建新进程" class="headerlink" title="0x09 创建新进程"></a>0x09 创建新进程</h2><p>Linux 内核中创建新进程使用 <code>fork()</code> 系统调用。所有内核中管理的进程都是通过复制进程 0 而得到的，所以在 Linux 系统下运行的进程最初都是由进程 0 产生的子进程。</p>
<p>在创建新进程的过程中，系统首先在任务数组中找出一个还没有被任何进程使用的空项，如果 Linux 系统下管理的进程已经达到所能管理限制值后（在 Linux 0.12 版本内核中设定的进程数量最大值为 64 ），则 <code>fork()</code> 系统调用会因为任务数组表中没有可用空项而出错返回，然后系统为新建进程在主内存区中申请一页内存来存放其人任务数据结构信息，并且复制当前进程任务数据结构中所有内容作为新进程任务数据结构的模板，为了防止这个还未处理完成的新建进程被调度函数执行，此时应该立刻将新进程状态置位不可中断的等待状态（<code>TASK_UNINTERRUPTIBLE</code>)</p>
<p>复制任务数据结构完成后，接着就是对其进行修改，把当前进程设置为新的进程的父进程，清除信号位图并复位新进程各统计值，并设置初始运行时间片值为 15 个时间滴答数（ 150ms ），接着将根据当前进程设置任务状态段（TSS）中各寄存器的值。由于创建进程时新进程返回值应为 0 ，使用需要设置为 <code>tss.eax = 0</code> ，新建进程内核态堆栈指针 <code>tss.esp0</code> 被设置成新进程任务数据结构所在内存页面的顶端，而堆栈段 <code>tss.ss0</code> 被设置成内核数据段选择符， <code>tss.ldt</code> 被设置成局部表描述符在 GDT 中的索引值，若当前进程使用了协处理器，则还需要把协处理器的完整状态保存到新进程的 <code>tss.i387</code> 结构中。</p>
<p>之后系统设置新进程的代码段和数据段基地址、限制长度，并复制当前进程内存分页管理的页表。需要注意的是，此时系统并不为新进程分配实际的物理内存页面，而是让它共享父进程的内存页面。只有当父进程或者新进程中任意一个进行了写内存操作时，系统才会为执行写操作的进程分配相关的独立使用的内存页面，这种处理方式称为写时复制技术。</p>
<p>随后，如果父进程中有文件是打开的，则应该将对应文件的打开次数加 1 。紧接着在 GDT 中设置新任务的 TSS 和 LDT 描述符项，其中基地址信息指向新进程任务结构中的 <code>tss</code> 和 <code>ldt</code> ，最后再将新任务设置成可运行状态并返回新进程号。</p>
<p>这里尤其需要注意：创建一个新进程和加载运行一个执行程序文件是两个不同的概念。当创建子进程时，它完全是复制了父进程的代码段和数据区，并会在其中执行子进程部分的代码。而执行存储设备上的程序时，一般会在子进程中运行 <code>exec()</code> 系统调用来进行操作。在进入 <code>exec()</code> 后，子进程原来的代码区和数据区都会被清除掉（释放掉），然后将该进程运行新程序时，由于此时内核还没有从存储设备上将该程序代码加载近来，所以 CPU 会立刻产生代码页面不存在的异常（<code>Fault</code>），此时内存管理程序就会从存储设备上找到对应程序代码加载到内存中，然后 CPU 重新执行引起异常的指令，此时新程序的代码才真正被执行起来。</p>
<p>整体流程如下图所示：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/7.png" class title="图片描述" data-fancybox="true">

<h2 id="0x0a-进程调度"><a href="#0x0a-进程调度" class="headerlink" title="0x0a 进程调度"></a>0x0a 进程调度</h2><p>在 Linux 内核中，进程调度主要是为了选择系统中即将要运行的进程，通过调度来回切换进程运行能够给人感觉上多进程同步运行的效果。这种选择运行机制是多任务操作系统的基础，可以将 Linux 内核的调度程序看作在所有处于运行状态的进程之间分配 CPU 运行时间的管理代码。通过前面对 Linux 系统的描述可以知道 Linux 进程是抢占式的，不过被抢占的进程仍然处于 TAK_RUNNING 状态，只不过暂时没有被 CPU 运行。进程的抢占发生在进程处于用户态执行阶段，在内核态执行时是不能够被抢占的。</p>
<p>为了能够使得进程有效地使用系统资源，又能使进程有较快的响应时间，就需要对进程的切换调度采用一定的调度策略。</p>
<h4 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h4><p>Linux 内核中的 <code>schedule()</code> 函数首先扫描进程数组，通过比较每个就绪态（ TASK_RUNNING ）进程的运行时间递减滴答计数 <code>counter</code> 的值来确定当前哪个进程运行的时间最少，<code>counter</code> 的数值越大表示剩余的运行时间越大，于是就选中该进程并使用进程切换宏函数来进行切换到该进程到 CPU 进行运行。</p>
<p>如果此时所有处于 <code>TASK_RUNNING</code> 状态进程的时间片都已经用完，系统就会根据每个进程的优先权值 <code>priority</code> 对系统中所有进程（包括正在睡眠的进程）重新计算每个任务需要运行的时间片值 <code>counter</code> ，Linux 0.12 版本内核中对时间片值的计算公式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter = (counter / 2) + priority</span><br></pre></td></tr></table></figure>

<p>通过这样的方式，正在睡眠的进程被唤醒时就会具有较高的时间片值 <code>counter</code> ，然后通过 <code>schedule()</code> 函数重新扫描进程数组中所有处于 <code>TASK_RUNNING</code> 状态的进程，并重复上述过程，直到选择出下一个切换执行的进程，最后调用 <code>switch_to()</code> 宏来执行实际的切换进程操作。</p>
<p>如果此时没有其他进程可以运行，则系统会选择 0 号进程运行，在 Linux 0.12 版本内核中，进程 0 会调用 <code>pause()</code> 将自己设置成可中断的睡眠状态并再次调用 <code>schedule()</code> ，不过在调度进程运行时，<code>schedule()</code> 并不在意进程 0 处于什么状态，只要系统空闲就会调用 0 号进程运行。</p>
<p>具体流程图下图所示：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/8.png" class title="图片描述" data-fancybox="true">

<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>每当选择出一个新的可执行的进程时， <code>schedule()</code> 函数就会调用定义在 Linux 内核源代码中的 <code>include/asm/system.h</code> 中的 <code>switch_to()</code> 宏执行实际进程切换操作。该宏会把 CPU 的当前进程状态（上下文）替换成新进程的状态。在进行切换之前，<code>switch_to()</code> 宏会先检查要切换到的进程是否就是当前进程，如果是则调出流程（什么也不做），直接退出；否则，就先将内核全局变量 <code>current</code> 设置成新任务的指针，然后长跳转到新任务的任务状态段 <code>TSS</code> 组成的地址处，造成 CPU 执行任务切换操作。此时，CPU 会把所有寄存器的状态保存到当前任务寄存器 <code>TR</code> 中 <code>TSS</code> 段选择符所指向的当前进程任务数据结构的 <code>tss</code>结构中，然后把新任务状态段选择符所指向的新任务数据结构中 <code>tss</code> 结构中的寄存器信息恢复到 CPU 中，系统就正式开始执行新的进程。这个过程如下图所描述：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/2-Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D/9.png" class title="图片描述" data-fancybox="true">

<h2 id="0x0b-终止进程"><a href="#0x0b-终止进程" class="headerlink" title="0x0b 终止进程"></a>0x0b 终止进程</h2><p>当一个进程结束了运行或在半途中止了运行，那么 Linux 内核就需要释放这个进程所占用的系统资源，这包括进程运行时打开的文件、申请的内存等。</p>
<p>当一个用户程序调用 <code>exit()</code> 系统调用时，就会执行内核函数 <code>do_exit()</code> ，这个函数首先会释放进程代码段和数据段占用的内存页面，关闭进程当前打开着的所有文件，对进程使用的当前工种目录、根目录和运行程序的 i 节点进行同步操作。如果进程还存在有子进程，这会让 <code>init</code> 进程作为所有子进程的父进程。如果进程是一个会话头进程并且有控制终端，则释放控制终端，并向属于该会话的所有进程发送挂断信号 <code>SIGHUP</code> ，这通常会终止该会话中的所有进程，然后把进程状态设置为僵死状态 <code>TASK_ZOMBIE</code> ，并向其原父进程发送 <code>SIGCHLD</code> 信号，通知其某个子进程已经终止。最后调用 <code>do_exit()</code> 函数去执行其他进程，由此可见在进程被终止时，它的任务数据结构仍然保留着，因为其父进程还需要使用其中的信息。</p>
<p>在子进程执行期间，父进程通常使用 <code>wait()</code> 或 <code>waitpid()</code> 函数等待其某个子进程终止。当等待的子进程被终止并处于僵死状态时，父进程就会把子进程运行所使用的时间累加到自己的进程中，最终释放已终止子进程任务数据结构所占用的内存页面，并设置空子进程在任务数组中占用的指针项。</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/A_%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">设计模式之创建型模式</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/A_OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">【原理剖析】Linux操作系统原理剖析——操作系统概述</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">mingming</a> 使用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1">Stellar 1.28.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">
<widget class="widget-wrapper user-card ghuser"><div class="widget-body ds-ghinfo" api="https://api.github.com/users/holdyounger"><div class="avatar"><img no-lazy type="img" id="avatar_url" src="https://avatars.githubusercontent.com/u/88082435?v=4" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></div><p class="username" ff="title" type="text" id="name">&nbsp;</p><p class="bio" type="text" id="bio">&nbsp;</p><div class="buttons"><a class="btn" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/holdyounger?tab=followers"><span class="title" type="text" id="followers">0</span><span class="desc">followers</span></a><a class="btn" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/holdyounger?tab=following"><span class="title" type="text" id="following">0</span><span class="desc">following</span></a><a class="btn" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/holdyounger?tab=repositories"><span class="title" type="text" id="public_repos">0</span><span class="desc">repos</span></a></div><a class="follow" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/holdyounger"><svg aria-hidden="true" role="img" class="color-icon-primary" viewbox="0 0 16 16" width="1em" height="1em" fill="currentColor" style="display:inline-block;user-select:none;vertical-align:text-bottom;overflow:visible"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>Follow</a></div></widget>




<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewbox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-Linux-%E5%86%85%E6%A0%B8%E6%A6%82%E8%BF%B0"><span class="toc-text">0x01 Linux 内核概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-Linux-%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-text">0x02 Linux 内核结构及任务管理功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">0x03 进程的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">0x04 进程的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-Linux-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">0x05 Linux 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-Linux-%E4%B8%AD%E8%BF%9B%E7%A8%8B%E8%A1%A8%E4%BB%8B%E7%BB%8D"><span class="toc-text">0x06 Linux 中进程表介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#state"><span class="toc-text">state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#counter-%E5%AD%97%E6%AE%B5"><span class="toc-text">counter 字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#priority"><span class="toc-text">priority</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#signal"><span class="toc-text">signal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigaction-%E6%95%B0%E7%BB%84"><span class="toc-text">sigaction 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#blocked"><span class="toc-text">blocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exit"><span class="toc-text">exit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start-code"><span class="toc-text">start_code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#end-code"><span class="toc-text">end_code</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#end-data"><span class="toc-text">end_data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#brk"><span class="toc-text">brk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start-stack"><span class="toc-text">start_stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pid"><span class="toc-text">pid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pgrp"><span class="toc-text">pgrp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session"><span class="toc-text">session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#leader"><span class="toc-text">leader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#group-NGROUPS"><span class="toc-text">group[NGROUPS]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p-pptr-%E3%80%81-p-cptr-%E3%80%81-p-ysptr-%E3%80%81-p-isptr"><span class="toc-text">p_pptr 、 p_cptr 、 p_ysptr 、 p_isptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uid-%E3%80%81-euid-%E3%80%81-suid-%E3%80%81-gid-%E3%80%81-egid-%E3%80%81-sgid"><span class="toc-text">uid 、 euid 、 suid 、 gid 、 egid 、 sgid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timeout"><span class="toc-text">timeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alarm"><span class="toc-text">alarm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rlim-%E6%95%B0%E7%BB%84"><span class="toc-text">rlim 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5"><span class="toc-text">其他字段</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-text">0x07 进程运行状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x08-%E8%BF%9B%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">0x08 进程初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x09-%E5%88%9B%E5%BB%BA%E6%96%B0%E8%BF%9B%E7%A8%8B"><span class="toc-text">0x09 创建新进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x0a-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">0x0a 进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="toc-text">调度程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-text">进程切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x0b-%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-text">0x0b 终止进程</span></a></li></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewbox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>

<widget class="widget-wrapper timeline"><div class="widget-header dis-select"><span class="name">近期动态</span></div><div class="widget-body fs14"><div class="tag-plugin timeline ds-timeline" api="https://api.github.com/repos/holdyounger/ScopeBlog/issues?per_page=8"></div></div></widget>
</div></aside><div class="float-panel blur">
  <button type="button" style="display:none" class="laptop-only rightbar-toggle mobile" onclick="sidebar.rightbar()">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewbox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type="button" style="display:none" class="mobile-only leftbar-toggle mobile" onclick="sidebar.leftbar()">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewbox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.28.1" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
<script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
<script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    var mermaid_config = {
      startOnLoad: true,
      theme:
        "" == "auto" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "neutral",
      logLevel: 3,
      themeVariables: {
        darkMode: true
      },
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: "linear"
      },
      gantt: {
        axisFormat: "%Y/%m/%d"
      },
      sequence: {
        actorMargin: 50
      }
    }
    mermaid.initialize(mermaid_config);
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
