[{"title":"Retmote Registry 服务","path":"/OS/Windows/服务/RemoteRegistry/","content":"Remote Registry是什么服务？ Remote Registry,翻译为”远程注册表”,如果远程的计算机连接到了你的计算机那么他可以通过字符界面或者其他方式远程修改注册表.这是一个相当严重的漏洞,可以为黑客入侵提供早期的方便(修改某些项目便于入侵,比如操作系统版本). [toc] 开启 Remote Regustiy 服务默认情况下，Windows 7 禁用远程注册表服务（可能是出于安全原因）。 方法1 ui打开windows服务，在服务中修改 Remote Registry 服务的启动类型为手动，然后启动 Remote Registry 服务。 方法2 命令行 要从命令行启用它，请键入以下内容： 1sc \\\\computername config remoteregistry start= auto 确保 &#x3D; 符号和 auto 之间有一个空格，如果您在本地计算机上执行此操作，您可以删除 \\computername 部分，您也可以将“remoteregistry”替换为另一个服务来启用或禁用它。 启用该服务后，您可以重新启动计算机，或者立即使用以下命令启动它： 1sc \\\\computername start remoteregistry 使用ps工具 1sc start remoteregistry start= auto 启动服务并将其设置为自动 不需要启动服务 Remote Registry服务可以关闭吗？因此关闭这个服务没有什么害处,而益处很多.强烈建议关闭,并且禁用.另外系统中没有其他服务是依赖或者跟此服务有关联的，所以禁用之后不会对其他服务产生影响。 Remote Registry服务关闭方法： 1、按住键盘的“Win+R”快捷组合键，打开“运行”对话命令窗口，输入“services.msc”命令，点击“确定”；，如图： 2、打开服务界面后找到“Remote Registry”选项，并左键双击打开其属性对话窗口； 3、在打开的“Remote Registry 的属性”对话窗口中，在启动类型选项中选择“禁用”选项，再点击“应用”–“停止”–“确定”按钮保存设置即可解决问题。 以上就是Remote Registry服务的详细介绍了，小编强烈建议关闭此服务，因为注册表是一台电脑的核心数据库，我们必须保证自己核心数据库的安全。","tags":["windows","registry","注册表"],"categories":["OS","Windows","服务"]},{"title":"pdm用法整理","path":"/Code/Python/pdm用法/","content":"来了！划时代的 Python 包管理工具 – PDM - 知乎 初始化 PDM ：1pdm init 查看帮助1pdm -h 切换python环境当你在初始化 pdm 项目时，就已经选定了当前的 Python 版本和可用的 Python 版本范围，后面如果想更改，可以使用 use 命令，但版本要受之前设定的版本范围约束。 假设允许范围是 python 3.9+，当前使用的是 python 3.10，可以直接切换过去。 1pdm use python3.9","categories":["Code","Python"]},{"title":"Windows权限(Privilege Constants)","path":"/OS/Windows/权限与会话/Privilege constants/","content":"windows 提权时常用的 Constants 微软官方文档：Privilege Constants (Winnt.h) - Win32 apps | Microsoft Learn 介绍Constants Constant&#x2F;value Description SE_ASSIGNPRIMARYTOKEN_NAMETEXT(“SeAssignPrimaryTokenPrivilege”) Required to assign the primary token of a process. User Right: Replace a process-level token. SE_AUDIT_NAMETEXT(“SeAuditPrivilege”) Required to generate audit-log entries. Give this privilege to secure servers. User Right: Generate security audits. SE_BACKUP_NAMETEXT(“SeBackupPrivilege”) Required to perform backup operations. This privilege causes the system to grant all read access control to any file, regardless of the access control list (ACL) specified for the file. Any access request other than read is still evaluated with the ACL. This privilege is required by the RegSaveKey and RegSaveKeyExfunctions. The following access rights are granted if this privilege is held: READ_CONTROLACCESS_SYSTEM_SECURITYFILE_GENERIC_READFILE_TRAVERSEUser Right: Back up files and directories. If the file is located on a removable drive and the “Audit Removable Storage” is enabled, the SE_SECURITY_NAME is required to have ACCESS_SYSTEM_SECURITY. SE_CHANGE_NOTIFY_NAMETEXT(“SeChangeNotifyPrivilege”) Required to receive notifications of changes to files or directories. This privilege also causes the system to skip all traversal access checks. It is enabled by default for all users. User Right: Bypass traverse checking. SE_CREATE_GLOBAL_NAMETEXT(“SeCreateGlobalPrivilege”) Required to create named file mapping objects in the global namespace during Terminal Services sessions. This privilege is enabled by default for administrators, services, and the local system account. User Right: Create global objects. SE_CREATE_PAGEFILE_NAMETEXT(“SeCreatePagefilePrivilege”) Required to create a paging file. User Right: Create a pagefile. SE_CREATE_PERMANENT_NAMETEXT(“SeCreatePermanentPrivilege”) Required to create a permanent object. User Right: Create permanent shared objects. SE_CREATE_SYMBOLIC_LINK_NAMETEXT(“SeCreateSymbolicLinkPrivilege”) Required to create a symbolic link. User Right: Create symbolic links. **SE_CREATE_TOKEN_NAME**TEXT(“SeCreateTokenPrivilege”) Required to create a primary token. User Right: Create a token object. You cannot add this privilege to a user account with the “Create a token object” policy. Additionally, you cannot add this privilege to an owned process using Windows APIs.Windows Server 2003 and Windows XP with SP1 and earlier: Windows APIs can add this privilege to an owned process. **SE_DEBUG_NAME**TEXT(“SeDebugPrivilege”) Required to debug and adjust the memory of a process owned by another account. User Right: Debug programs. **SE_DELEGATE_SESSION_USER_IMPERSONATE_NAME**TEXT(“SeDelegateSessionUserImpersonatePrivilege”) Required to obtain an impersonation token for another user in the same session. User Right: Impersonate other users. SE_ENABLE_DELEGATION_NAMETEXT(“SeEnableDelegationPrivilege”) Required to mark user and computer accounts as trusted for delegation. User Right: Enable computer and user accounts to be trusted for delegation. SE_IMPERSONATE_NAMETEXT(“SeImpersonatePrivilege”) Required to impersonate. User Right: Impersonate a client after authentication. SE_INC_BASE_PRIORITY_NAMETEXT(“SeIncreaseBasePriorityPrivilege”) Required to increase the base priority of a process. User Right: Increase scheduling priority. SE_INCREASE_QUOTA_NAMETEXT(“SeIncreaseQuotaPrivilege”) Required to increase the quota assigned to a process. User Right: Adjust memory quotas for a process. **SE_INC_WORKING_SET_NAME**TEXT(“SeIncreaseWorkingSetPrivilege”) Required to allocate more memory for applications that run in the context of users. User Right: Increase a process working set. **SE_LOAD_DRIVER_NAME**TEXT(“SeLoadDriverPrivilege”) Required to load or unload a device driver. User Right: Load and unload device drivers. **SE_LOCK_MEMORY_NAME**TEXT(“SeLockMemoryPrivilege”) Required to lock physical pages in memory. User Right: Lock pages in memory. **SE_MACHINE_ACCOUNT_NAME**TEXT(“SeMachineAccountPrivilege”) Required to create a computer account. User Right: Add workstations to domain. SE_MANAGE_VOLUME_NAMETEXT(“SeManageVolumePrivilege”) Required to enable volume management privileges. User Right: Manage the files on a volume. SE_PROF_SINGLE_PROCESS_NAMETEXT(“SeProfileSingleProcessPrivilege”) Required to gather profiling information for a single process. User Right: Profile single process. SE_RELABEL_NAMETEXT(“SeRelabelPrivilege”) Required to modify the mandatory integrity level of an object. User Right: Modify an object label. **SE_REMOTE_SHUTDOWN_NAME**TEXT(“SeRemoteShutdownPrivilege”) Required to shut down a system using a network request. User Right: Force shutdown from a remote system. SE_RESTORE_NAMETEXT(“SeRestorePrivilege”) Required to perform restore operations. This privilege causes the system to grant all write access control to any file, regardless of the ACL specified for the file. Any access request other than write is still evaluated with the ACL. Additionally, this privilege enables you to set any valid user or group SID as the owner of a file. This privilege is required by the RegLoadKey function. The following access rights are granted if this privilege is held: WRITE_DACWRITE_OWNERACCESS_SYSTEM_SECURITYFILE_GENERIC_WRITEFILE_ADD_FILEFILE_ADD_SUBDIRECTORYDELETEUser Right: Restore files and directories. If the file is located on a removable drive and the “Audit Removable Storage” is enabled, the SE_SECURITY_NAME is required to have ACCESS_SYSTEM_SECURITY. SE_SECURITY_NAMETEXT(“SeSecurityPrivilege”) Required to perform a number of security-related functions, such as controlling and viewing audit messages. This privilege identifies its holder as a security operator. User Right: Manage auditing and security log. SE_SHUTDOWN_NAMETEXT(“SeShutdownPrivilege”) Required to shut down a local system. User Right: Shut down the system. SE_SYNC_AGENT_NAMETEXT(“SeSyncAgentPrivilege”) Required for a domain controller to use the Lightweight Directory Access Protocol directory synchronization services. This privilege enables the holder to read all objects and properties in the directory, regardless of the protection on the objects and properties. By default, it is assigned to the Administrator and LocalSystem accounts on domain controllers. User Right: Synchronize directory service data. SE_SYSTEM_ENVIRONMENT_NAMETEXT(“SeSystemEnvironmentPrivilege”) Required to modify the nonvolatile RAM of systems that use this type of memory to store configuration information. User Right: Modify firmware environment values. SE_SYSTEM_PROFILE_NAMETEXT(“SeSystemProfilePrivilege”) Required to gather profiling information for the entire system. User Right: Profile system performance. SE_SYSTEMTIME_NAMETEXT(“SeSystemtimePrivilege”) Required to modify the system time. User Right: Change the system time. SE_TAKE_OWNERSHIP_NAMETEXT(“SeTakeOwnershipPrivilege”) Required to take ownership of an object without being granted discretionary access. This privilege allows the owner value to be set only to those values that the holder may legitimately assign as the owner of an object. User Right: Take ownership of files or other objects. **SE_TCB_NAME**TEXT(“SeTcbPrivilege”) This privilege identifies its holder as part of the trusted computer base. Some trusted protected subsystems are granted this privilege. User Right: Act as part of the operating system. **SE_TIME_ZONE_NAME**TEXT(“SeTimeZonePrivilege”) Required to adjust the time zone associated with the computer’s internal clock. User Right: Change the time zone. SE_TRUSTED_CREDMAN_ACCESS_NAMETEXT(“SeTrustedCredManAccessPrivilege”) Required to access Credential Manager as a trusted caller. User Right: Access Credential Manager as a trusted caller. SE_UNDOCK_NAMETEXT(“SeUndockPrivilege”) Required to undock a laptop. User Right: Remove computer from docking station. **SE_UNSOLICITED_INPUT_NAME**TEXT(“SeUnsolicitedInputPrivilege”) Required to read unsolicited input from a terminal device. User Right: Not applicable. 用法value不同，对应的操作和权限也不同，本文列举了有关 Privilege Constants 的一些使用方式。 LookupPrivilegeValue1234567891011BOOL EnablePrivilege()&#123; LUID PrivilegeRequired ; BOOL bRes = FALSE; bRes = LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;PrivilegeRequired); // ... return bRes;&#125; 使用 AdjustTokenPrivileges 修改权限123456789101112131415161718192021222324252627inline BOOL CToolhelp::EnablePrivilege(PCTSTR szPrivilege, BOOL fEnable) &#123; // Enabling the debug privilege allows the application to see // information about service applications BOOL fOk = FALSE; // Assume function fails HANDLE hToken; // Try to open this process&#x27;s access token if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123; // Attempt to modify the given privilege TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegeValue(NULL, szPrivilege, &amp;tp.Privileges[0].Luid); tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL); fOk = (GetLastError() == ERROR_SUCCESS); // Don&#x27;t forget to close the token handle CloseHandle(hToken); &#125; return(fOk);&#125;// usage","categories":["OS","Windows","权限与会话"]},{"title":"AD域","path":"/OS/Windows/安全/AD域/","content":"AD域AD域（Active Directory Domain）是一种Windows Server的组织单元，用于管理计算机、用户、组织和其他资源。它提供了一种集中式的管理方式，可以让管理员轻松地管理网络中的资源。AD域支持以下功能： 用户和计算机管理：可以使用AD域来管理网络中的用户和计算机，包括创建、删除、修改用户和计算机的属性等。 组织管理：可以使用AD域来管理网络中的组织，包括创建、删除、修改组织的属性等。 权限管理：可以使用AD域来管理网络中的权限，包括授予用户访问资源的权限等。 网络服务管理：可以使用AD域来管理网络中的服务，包括打印服务、邮件服务等。 数据备份和恢复：可以使用AD域来备份和恢复网络中的数据，以防止数据丢失。","categories":["OS","Windows","安全"]},{"title":"DCSYNC攻击防护","path":"/OS/Windows/安全/DCSYNC攻击/","content":"DCSYNC攻击DCSYNC攻击是一种利用DC（域控制器）之间的同步过程来实现的攻击。攻击者可以利用这个过程来获取域管理员的权限，从而对域中的计算机和用户进行攻击。为了防护DCSYNC攻击，可以采取以下措施： 1. 安装最新的安全补丁：确保所有的DC都安装了最新的安全补丁，以防止攻击者利用已知的漏洞进行攻击。 2. 启用安全策略：启用安全策略，例如限制管理员的权限，以防止攻击者利用管理员权限进行攻击。 3. 使用防火墙：使用防火墙来限制DC之间的通信，以防止攻击者利用通信过程进行攻击。 4. 启用IPsec：启用IPsec来加密DC之间的通信，以防止攻击者截获通信内容。 5. 启用身份验证：启用身份验证，例如使用Kerberos，以防止攻击者冒充域用户进行攻击。 6. 定期审计：定期审计DC之间的通信，以及域用户的活动，以发现可能的攻击行为。 相关补充域控制器域控制器（Domain Controller，DC）是一台服务器，管理网络和身份安全，有效地充当用户验证和授权进入域内 IT 资源的门卫。域控制器在微软目录服务术语中尤其重要，它是一台计算机，存储和管理域内的用户和计算机信息，以及网络上的其他信息。它负责为域内的用户和计算机提供身份验证和授权服务，并维护域内的安全性。 KerberosKerberos是一种网络认证协议，用于在网络上验证用户的身份。它使用一种称为“票据”的概念来实现身份验证，其中包含用户的身份信息和服务器的身份信息。当用户请求访问服务器时，它会向票据发行机（KDC）发送请求，请求一个票据。KDC会根据用户的身份信息和服务器的身份信息生成一个票据，并将其发送给用户。用户将票据发送给服务器，服务器会验证票据的有效性，并根据票据中的信息授予用户访问权限。","categories":["OS","Windows","安全"]},{"title":"windbg 分析实战","path":"/OS/Windows/Windbg/分析实战/","content":"!Process 输出1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071: kd&gt; !process fffffa800c5c8060 3PROCESS fffffa800c5c8060 SessionId: 0 Cid: 06fc Peb: 7fffffd4000 ParentCid: 025c DirBase: 1f8dfb000 ObjectTable: fffff8a0020a44e0 HandleCount: 281. Image: svchost.exe VadRoot fffffa800c5c8570 Vads 128 Clone 0 Private 2532. Modified 992. Locked 0. DeviceMap fffff8a001b400b0 Token fffff8a0020ac060 ElapsedTime 00:06:27.486 UserTime 00:00:00.046 KernelTime 00:00:00.093 QuotaPoolUsage[PagedPool] 94704 QuotaPoolUsage[NonPagedPool] 32760 Working Set Sizes (now,min,max) (4303, 50, 345) (17212KB, 200KB, 1380KB) PeakWorkingSetSize 4717 VirtualSize 57 Mb PeakVirtualSize 57 Mb PageFaultCount 6769 MemoryPriority BACKGROUND BasePriority 8 CommitCharge 2766 THREAD fffffa800c5d0060 Cid 06fc.0700 Teb: 000007fffffde000 Win32Thread: fffff900c075cc10 WAIT: (UserRequest) UserMode Non-Alertable fffffa800c3d96a0 SynchronizationEvent THREAD fffffa800c482060 Cid 06fc.0704 Teb: 000007fffffdc000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Alertable fffffa800c471060 SynchronizationTimer fffffa800c42d200 SynchronizationTimer fffffa800c467680 SynchronizationEvent fffffa800c48b440 SynchronizationEvent fffffa800c47f1f0 SynchronizationEvent fffffa800c534060 SynchronizationEvent fffffa800c556060 SynchronizationEvent fffffa800c5212f0 SynchronizationEvent fffffa800c5213f0 SynchronizationEvent fffffa800c41f5d0 SynchronizationTimer fffffa800c4595d0 SynchronizationTimer fffffa800c592240 SynchronizationEvent fffffa800c593b00 ProcessObject fffffa800c459550 SynchronizationEvent fffffa800c59b400 SynchronizationEvent fffffa800c3f6810 SynchronizationEvent fffffa800c5a1120 SynchronizationEvent fffffa800c5b5120 SynchronizationEvent fffffa800c482610 SynchronizationTimer fffffa800c466060 SynchronizationEvent fffffa800c59b060 SynchronizationEvent fffffa800c3ec2d0 SynchronizationEvent fffffa800c466240 SynchronizationEvent THREAD fffffa800c4ad370 Cid 06fc.0708 Teb: 000007fffffda000 Win32Thread: fffff900c07cac10 WAIT: (UserRequest) UserMode Non-Alertable fffffa800cbdf3e0 SynchronizationEvent THREAD fffffa800c4a2060 Cid 06fc.0714 Teb: 000007fffff9e000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800c4a9110 NotificationEvent THREAD fffffa800c537370 Cid 06fc.0718 Teb: 000007fffff9c000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa80075eb840 NotificationEvent THREAD fffffa800c54c370 Cid 06fc.0724 Teb: 000007fffff9a000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800c556140 NotificationEvent THREAD fffffa800c54a060 Cid 06fc.072c Teb: 000007fffffd6000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800c5386b0 SynchronizationEvent fffffa800c521370 NotificationEvent fffffa800c521140 NotificationEvent fffffa800c54a5b0 NotificationEvent fffffa800c543760 NotificationEvent THREAD fffffa800c51e060 Cid 06fc.0734 Teb: 000007fffff96000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800b2f8600 SynchronizationEvent fffffa800c5341d0 SynchronizationEvent fffffa800c556620 SynchronizationEvent fffffa800c583780 SynchronizationEvent fffffa800c5ce280 SynchronizationEvent fffffa800cbcf660 SynchronizationEvent THREAD fffffa800c41e380 Cid 06fc.0754 Teb: 000007fffff94000 Win32Thread: 0000000000000000 WAIT: (WrLpcReply) UserMode Non-Alertable fffffa800c41e748 Semaphore Limit 0x1 THREAD fffffa800c41f060 Cid 06fc.075c Teb: 000007fffff90000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c5b53c0 QueueObject THREAD fffffa800c466300 Cid 06fc.0760 Teb: 000007fffff8e000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Alertable fffffa800c3ec060 SynchronizationEvent THREAD fffffa800c461060 Cid 06fc.0764 Teb: 000007fffff8c000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800c41f790 SynchronizationEvent fffffa800c41f810 NotificationEvent THREAD fffffa8007c92060 Cid 06fc.00a0 Teb: 000007fffffd8000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c3d9500 QueueObject THREAD fffffa800780e640 Cid 06fc.19f0 Teb: 000007fffff98000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c3d9500 QueueObject THREAD fffffa80078fe650 Cid 06fc.1010 Teb: 000007fffff92000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c3d9500 QueueObject THREAD fffffa8007ebdb50 Cid 06fc.12e4 Teb: 000007fffff8a000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800d8a88c0 SynchronizationEvent THREAD fffffa8008228b50 Cid 06fc.0e3c Teb: 000007fffff88000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c3d9500 QueueObject THREAD fffffa8007800b50 Cid 06fc.0440 Teb: 000007fffff86000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c3d9500 QueueObject 这是Windows Debugger（WinDbg）中!process命令的输出，提供了关于特定进程的信息。第一行显示了进程的ID，即fffffa800c5c8060。第二行显示了进程的会话ID，即0。第三行显示了调用进程的ID，即025c。第四行显示了进程在内存中的基地址，即1f8dfb000。第五行显示了进程的对象表，即ffff8a0020a44e0。第六行显示了进程的句柄数，即281。第七行显示了进程的图像，即svchost.exe。第八行显示了进程的虚拟地址根，即ffffa800c5c8570。第九行显示了进程中的VAD（虚拟地址目录）数，即128。第十行显示了进程是否为克隆进程，即0。第十一行显示了进程是否为私有进程，即2532。第十二行显示了进程的修改计数，即992。第十三行显示了进程的锁定计数，即0。第十四行显示了进程的设备映射，即ffff8a001b400b0。第十五行显示了进程的令牌，即ffff8a0020ac060。第十六行显示了进程的运行时间，即00:06:27.486。第十七行显示了进程的用户时间，即00:00:00.046。第十八行显示了进程的内核时间，即00:00:00.093。第十九行显示了进程的配额池使用情况，即94704用于页面池和32760用于非页面池。第二十行显示了进程的工作集大小，即4303用于现在、50用于最小和345用于最大。第二十一行显示了进程的峰值工作集大小，即4717。第二十二行显示了进程的虚拟大小，即57 MB。第二十三行显示了进程的峰值虚拟大小，也是57 MB。第二十四行显示了进程的页面故障次数，即6769。第二十五行显示了进程的内存优先级，即BACKGROUND。第二十六行显示了进程的基本优先级，即8。第二十七行显示了进程的提交量，即2766。最后一部分输出显示了进程的线程。每个线程都用一行表示，包括线程ID、Cid（连接ID）、Teb（线程环境块）和等待类型和等待的对象。","categories":["OS","Windows","Windbg"]},{"title":"windows进程间通信整理","path":"/OS/Windows/IPC/windows进程间通信/","content":"概述：windows进程间通信的各种方式 12345678910111213141516171819graph LRA(windows进程间通信) --&gt; B[&quot;管道(pipe)&quot;]A --&gt; C[&quot;邮件槽(Mailslots)&quot;]A --&gt; D[&quot;文件映射(fileMapping)&quot;]A --&gt; E[&quot;信号量(Semaphore)&quot;]A --&gt; F[&quot;信号(signal)&quot;]A --&gt; G[&quot;套接字(Socket)&quot;]A --&gt; H[&quot;动态库(dll)&quot;]A --&gt; I[&quot;组件对象模型(COM)&quot;]B --&gt; B1[&quot;匿名管道(Anonymous pipe)&quot;]B --&gt; B2[&quot;命名管道(named pipe)&quot;]D --&gt; D1[&quot;共享内存(shared memory)&quot;]F --&gt; F1[&quot;windows没有信号这个概念，但是会提供类似功能的api，比如杀死进程。linux下的kill信号，windows下提供TerminateProcess&quot;]H --&gt; H1[&quot;地址无关代码：两个进程无法通过同一个dll进行数据交换&quot;]","tags":["IPC","windows"],"categories":["OS","Windows","IPC"]},{"title":"Win32多线程——线程同步之信号量（Semaphores）","path":"/OS/Windows/多线程/线程同步之信号量Seamphorse/","content":"概述： semaphores 的说明和使用 微软官方文档： Semaphore Objects - Win32 apps | Microsoft Learn Semaphores是解决各种 producer&#x2F;consumer问题的关键要素。这种问题会存有一个缓冲区，可能在同一时间内被读出数据或被写入数据。 理论可以证明,mutex 是 semaphore 的一种退化。如果你产生一个semaphore 并令最大值为1,那就是一个 mutex。也因此, mutex又常被称为binary semaphore。在许多系统中, semaphores 常被使用, 因为 mutexes可能并不存在。在Win32中semaphores 被使用的情况就少得多，因为 mutex 存在的缘故。 创建 semaphorecreateSemaphoreA 函数 (winbase.h) - Win32 apps | Microsoft Learn 123456HANDLE CreateSemaphore(\tLPSECURITY_ATTRIBUTES lpAttributes,\t// 安全属性, 可以设置NULL\tLONG lInitialCount,\t// 初始值, [0, lMaximumCount]\tLONG lMaximumCount,\t// 最大值, 这也就是在同一时间内能够锁住semaphore之线程的最多个数\tLPCTSTR lpName // 名称, 其他线程或进程可以根据名称引用该信号量; NULL则产生无名称信号量); 如果成功就传回一个handle, 否则传回NULL. 不论哪一种情况,GetLastError()都会传回一个合理的结果. 如果指定的semaphore名称已经存在,则该函数还是成功的, GetLastError()会传回ERROR_ALREADY_EXISTS. 获得 semaphore 通过信号量名，获得信号量对象句柄 OpenSemaphoreW function (synchapi.h) - Win32 apps | Microsoft Learn 12345HANDLE OpenSemaphoreW( [in] DWORD dwDesiredAccess, // 访问权限，一般传入 SEMAPHORE_ALL_ACCESS [in] BOOL bInheritHandle, // 信号量句柄继承性，一般传入TRUE即可 [in] LPCWSTR lpName // 名称，不同进程中个线程可以通过名称来确保它们访问同一个信号量); semaphore的现值代表的意义是目前可用的资源数, 如果semaphore的现值为1, 表示还有一个锁定动作可以成功; 如果现值为5, 就表示还有五个锁定动作可以成功. 每当一个锁定动作成功, semaphore的现值就会减1. 你可以使用任何一种 Wait() 函数(例如 WaitForSingleObject() )要求锁定一个semaphore. 因此, 如果semaphore的现值不为0, Wait() 函数会立刻返回.一个线程可以反复调用 Wait() 函数以产生新的锁定. 这和mutex绝不相同：拥有mutex的线程不论再调用多少次 Wait() 函数, 也不会被阻塞住。一旦semaphore的现值降到0, 就表示资源已经耗尽. 此时, 任何线程如果调用Wait…()函数, 必然要等待, 直到某个锁定被解除为止. 解除 semaphore 释放信号量 ReleaseSemaphore function (synchapi.h) - Win32 apps | Microsoft Learn 注：传入的句柄必须有 SEMAPHORE_MODIFY_STATE 权限，参考 同步对象安全性和访问权限 - Win32 apps | Microsoft Learn 12345BOOL ReleaseSemaphore( [in] HANDLE hSemaphore, // 信号量的句柄 [in] LONG lReleaseCount, // 表示增加个数，必须大于0且不超过最大资源数量 [out, optional] LPLONG lpPreviousCount // 可以用来传出先前的资源计数，设为NULL表示不需要传出); ReleaseSemaphore函数会触发WaitForSingleObject函数。ReleaseSemaphore函数用于释放一个信号量对象的计数，而WaitForSingleObject函数用于等待一个信号量对象的计数。当ReleaseSemaphore函数被调用时，它会将信号量对象的计数增加，并且如果有一个线程正在等待这个信号量对象的计数，那么这个线程就会被唤醒。因此，ReleaseSemaphore函数会触发WaitForSingleObject函数。 补充说明为什么 semaphore 要有一个初值CreateSemaphore()的第二个参数是lInitialCount, 它的存在理由和CreateMutex()的bInitialOwner参数的存在理由是一样的. 如果你把初值设定为0, 你的线程就可以在产生semaphore之后进行所有必要的初始化工作. 待初始化工作完成后, 调用 ReleaseSemaphore()就可以把现值增加到其最大可能值. Demo 多线程同步1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt; #include &lt;process.h&gt; #include &lt;windows.h&gt; long g_nNum;unsigned int __stdcall Fun(void* pPM);const int THREAD_NUM = 10;//信号量与关键段 HANDLE g_hThreadParameter;CRITICAL_SECTION g_csThreadCode;int main()&#123; printf(&quot; 经典线程同步 信号量Semaphore &quot;); printf(&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) -- &quot;); //初始化信号量和关键段 g_hThreadParameter = CreateSemaphore(NULL, 0, 1, NULL);//当前0个资源，最大允许1个同时访问 InitializeCriticalSection(&amp;g_csThreadCode); HANDLE handle[THREAD_NUM]; g_nNum = 0; int i = 0; while (i &lt; THREAD_NUM) &#123; handle[i] = (HANDLE)_beginthreadex(NULL, 0, Fun, &amp;i, 0, NULL); WaitForSingleObject(g_hThreadParameter, INFINITE);//等待信号量&gt;0 ++i; &#125; WaitForMultipleObjects(THREAD_NUM, handle, TRUE, INFINITE); //销毁信号量和关键段 DeleteCriticalSection(&amp;g_csThreadCode); CloseHandle(g_hThreadParameter); for (i = 0; i &lt; THREAD_NUM; i++) CloseHandle(handle[i]); return 0;&#125;unsigned int __stdcall Fun(void* pPM)&#123; int nThreadNum = *(int*)pPM; ReleaseSemaphore(g_hThreadParameter, 1, NULL);//信号量++ Sleep(50);//some work should to do EnterCriticalSection(&amp;g_csThreadCode); ++g_nNum; Sleep(0);//some work should to do printf(&quot;线程编号为%d 全局资源值为%d &quot;, nThreadNum, g_nNum); LeaveCriticalSection(&amp;g_csThreadCode); return 0;&#125;","tags":["windows","多线程","semaphores"],"categories":["OS","Windows","多线程"]},{"title":"TEB (线程环境块)","path":"/OS/Windows/Windbg/TEB(线程环境块)/","content":"概述：TEB（Thread Environment Block，线程环境块）指线程环境块，该结构体包含进程中运行线程的各种信息，进程中的每个线程都对应着一个TEB结构体。不同OS中TEB结构体的形态略微有点不同 微软官方文档： 线程环境块 (调试说明) - Win32 apps | Microsoft Learn TEB (winternl.h) - Win32 apps | Microsoft Learn [toc] TEB 结构体定义MSDN123456789101112typedef struct _TEB &#123; PVOID Reserved1[12]; PPEB ProcessEnvironmentBlock; PVOID Reserved2[399]; BYTE Reserved3[1952]; PVOID TlsSlots[64]; BYTE Reserved4[8]; PVOID Reserved5[26]; PVOID ReservedForOle; PVOID Reserved6[4]; PVOID TlsExpansionSlots;&#125; TEB, *PTEB; Windows XP SP312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667nt!_TEB +0x000 NtTib : _NT_TIB +0x01c EnvironmentPointer : Ptr32 Void +0x020 ClientId : _CLIENT_ID +0x028 ActiveRpcHandle : Ptr32 Void +0x02c ThreadLocalStoragePointer : Ptr32 Void +0x030 ProcessEnvironmentBlock : Ptr32 _PEB +0x034 LastErrorValue : Uint4B +0x038 CountOfOwnedCriticalSections : Uint4B +0x03c CsrClientThread : Ptr32 Void +0x040 Win32ThreadInfo : Ptr32 Void +0x044 User32Reserved : [26] Uint4B +0x0ac UserReserved : [5] Uint4B +0x0c0 WOW32Reserved : Ptr32 Void +0x0c4 CurrentLocale : Uint4B +0x0c8 FpSoftwareStatusRegister : Uint4B +0x0cc SystemReserved1 : [54] Ptr32 Void +0x1a4 ExceptionCode : Int4B +0x1a8 ActivationContextStack : _ACTIVATION_CONTEXT_STACK +0x1bc SpareBytes1 : [24] UChar +0x1d4 GdiTebBatch : _GDI_TEB_BATCH +0x6b4 RealClientId : _CLIENT_ID +0x6bc GdiCachedProcessHandle : Ptr32 Void +0x6c0 GdiClientPID : Uint4B +0x6c4 GdiClientTID : Uint4B +0x6c8 GdiThreadLocalInfo : Ptr32 Void +0x6cc Win32ClientInfo : [62] Uint4B +0x7c4 glDispatchTable : [233] Ptr32 Void +0xb68 glReserved1 : [29] Uint4B +0xbdc glReserved2 : Ptr32 Void +0xbe0 glSectionInfo : Ptr32 Void +0xbe4 glSection : Ptr32 Void +0xbe8 glTable : Ptr32 Void +0xbec glCurrentRC : Ptr32 Void +0xbf0 glContext : Ptr32 Void +0xbf4 LastStatusValue : Uint4B +0xbf8 StaticUnicodeString : _UNICODE_STRING +0xc00 StaticUnicodeBuffer : [261] Uint2B +0xe0c DeallocationStack : Ptr32 Void +0xe10 TlsSlots : [64] Ptr32 Void +0xf10 TlsLinks : _LIST_ENTRY +0xf18 Vdm : Ptr32 Void +0xf1c ReservedForNtRpc : Ptr32 Void +0xf20 DbgSsReserved : [2] Ptr32 Void +0xf28 HardErrorsAreDisabled : Uint4B +0xf2c Instrumentation : [16] Ptr32 Void +0xf6c WinSockData : Ptr32 Void +0xf70 GdiBatchCount : Uint4B +0xf74 InDbgPrint : UChar +0xf75 FreeStackOnTermination : UChar +0xf76 HasFiberData : UChar +0xf77 IdealProcessor : UChar +0xf78 Spare3 : Uint4B +0xf7c ReservedForPerf : Ptr32 Void +0xf80 ReservedForOle : Ptr32 Void +0xf84 WaitingOnLoaderLock : Uint4B +0xf88 Wx86Thread : _Wx86ThreadState +0xf94 TlsExpansionSlots : Ptr32 Ptr32 Void +0xf98 ImpersonationLocale : Uint4B +0xf9c IsImpersonating : Uint4B +0xfa0 NlsCache : Ptr32 Void +0xfa4 pShimData : Ptr32 Void +0xfa8 HeapVirtualAffinity : Uint4B +0xfac CurrentTransactionHandle : Ptr32 Void +0xfb0 ActiveFrame : Ptr32 _TEB_ACTIVE_FRAME +0xfb4 SafeThunkCall : UChar +0xfb5 BooleanSpare : [3] UChar 各变量说明“_TEB” 是一个Windows内核对象的结构体，用于描述一个线程的状态和信息。它包含了线程的一些基本信息，例如线程的堆栈指针、环境变量、堆栈大小等。以下是 “_TEB” 结构体中的一些常用变量及其说明： *NtTeb: 指向当前线程的 “_TEB” 结构体的指针。 StackBase: 指向线程的堆栈起始地址。 StackLimit: 指向线程的堆栈结束地址。 StackReserveSize: 指定线程的堆栈大小。 EnvironmentPointer: 指向线程的环境变量的指针。 ThreadLocalStoragePointer: 指向线程的线程局部存储空间的指针。 *ProcessEnvironmentBlock: 指向进程的环境变量的指针。 BasePriority: 指定线程的优先级。 UniqueThreadID: 指定线程的唯一ID。 IdealProcessor: 指定线程的理想处理器。 IdealProcessorGroup: 指定线程的理想处理器组。 ThreadLocale: 指定线程的本地化信息。 ActiveStackAddress: 指向线程当前活跃的堆栈地址。 TlsSlots: 指向线程的线程局部存储空间的指针数组。 TlsExpansionSlots: 指定线程的线程局部存储空间的扩展槽数量。 Reserved: 保留字段。 Reserved2: 保留字段。 这些变量可以用于查看和分析线程的状态和信息。您可以使用Windows调试工具中的 “dt” 命令查看这些变量的值和相关信息，例如： 1dt nt!_TEB &lt;teb_object&gt; 其中 ““ 是线程的 “_TEB” 结构体的实例，例如 “fffffa800cd85b00”。这将显示线程的名称、大小、当前线程等信息。您可以根据需要进一步查看和分析这些信息。 重要成员在用户模式调试中起着重要作用的成员有2个，如下： 123+0x000 NtTib : _NT_TIB………………………………………………………………………………+0x030 ProcessEnvironmentBlock : Ptr32 _PEB ProcessEnvironmentBlock成员：先看Offset 30处的ProcessEnvironmentBlock成员，它是指向PEB（Process Environment Block，进程环境块）结构体指针。PEB是进程环境块，每个进程对应1个PEB结构体。 NtTib成员TEB结构体的第一个成员为_NT_TIB结构体（TIB是Thread Information Block的简称，意为“线程信息块”），_NT_TIB结构体的定义如下所示： 123456789101112131415typedef struct _NT_TIB //sizeof 1ch&#123; 00h struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; //SEH链入口 04h PVOID StackBase; //堆栈基址 08h PVOID StackLimit; //堆栈大小 0ch PVOID SubSystemTib; union &#123; PVOID FiberData; 10h DWORD Version; &#125;; 14h PVOID ArbitraryUserPointer; 18h struct _NT_TIB *Self; //本NT_TIB结构自身的线性地址&#125;NT_TIB; typedef NT_TIB *PNT_TIB; ExceptionList成员指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，它用于Windows OS的SEH。Self成员是_NT_TIB结构体的自引用指针，也是TEB结构体的指针（因为TEB结构体的第一个成员就是_NT_TIB结构体）。那么我们如何在用户模式下访问到TEB结构体呢？只有访问它才能使用相应信息。","categories":["OS","Windows","Windbg"]},{"title":"windbg内核调试","path":"/OS/Windows/Windbg/windbg内核调试/","content":"概述： 参考：WinDbg (内核模式) 入门 - Windows drivers | Microsoft Learn","categories":["OS","Windows","Windbg"]},{"title":"netsh 抓包","path":"/网络通信/抓包/netsh抓包/","content":"概述：windows系统下使用 netsh 命令抓包 步骤1 打开管理员命令行win -&gt; 输入 cmd -&gt; 以管理员身份运行 2 输入以下命令开始抓包1netsh trace start capture=YES report=YES persistent=YES 运行成功后，如下所示 3 运行 零信任客户端连接tac，直到复现敲门失败情况 4 回到 cmd 界面键入并回车以下命令： 1netsh trace stop 回车后稍等一会，界面上会输出以下内容，将图示路径文件收集即可。 格式转换1etl2pcapng.exe nettrace.etl nettrace.cap","categories":["网络通信","抓包"]},{"path":"/网络通信/SOCKET相关函数(CC++)/","content":"Windows 下 Socket相关 一、socket()函数 创建套接字Windows 不把套接字作为普通文件对待，而是返回 SOCKET 类型的句柄。 1SOCKET socket(int af, int type, int protocol); 实例，创建TCP套接字： 1SOCKET sock = socket(AF_INET, SOCK_STREAM, 0); //创建TCP套接字 二、bind()1int bind(SOCKET sock, const struct sockaddr *addr, int addrlen); //Windows sock 为 socket 文件描述符addr 为 sockaddr 结构体变量的指针addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。 12345678910// 创建套接字\tSOCKET servSock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);\t// 绑定套接字\tstruct sockaddr_in sockAddr;\tmemset (&amp;sockAddr, 0, sizeof(sockAddr)); // 每个套接字都用0填充\tsockAddr.sin_family = PF_INET; // 使用IPv4地址\tsockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);\tsockAddr.sin_port = htons(1234);\t// 端口\tbind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); sockaddr结构体1234struct sockaddr&#123; sa_family_t sin_family; //地址族（Address Family），也就是地址类型 char sa_data[14]; //IP地址和端口号&#125;; sockaddr_in 结构体123456struct sockaddr_in&#123; sa_family_t sin_family; //地址族（Address Family），也就是地址类型 uint16_t sin_port; //16位的端口号 struct in_addr sin_addr; //32位IP地址 char sin_zero[8]; //不使用，一般用0填充&#125;; sin_family 和socket()的第一个参数的含义相同，取值也要保持一致。 sin_prot 为端口号。uint16_t 的长度为两个字节，理论上端口号的取值范围为 065536，但 01023 的端口一般由系统分配给特定的服务程序，例如 Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在 1024~65536 之间分配端口号。端口号需要用 htons() 函数转换，后面会讲解为什么。 sin_addr 是 struct in_addr 结构体类型的变量，下面会详细讲解。 sin_zero[8]是多余的8个字节，没有用，一般使用 memset() 函数填充为 0。上面的代码中，先用 memset() 将结构体的全部字节填充为 0，再给前3个成员赋值，剩下的 sin_zero 自然就是 0 了。 in_addr 结构体sockaddr_in 的第3个成员是 in_addr 类型的结构体，该结构体只包含一个成员，如下所示： 123struct in_addr&#123; in_addr_t s_addr; //32位的IP地址&#125;; in_addr_t 在头文件 &lt;netinet&#x2F;in.h&gt; 中定义，等价于 unsigned long，长度为4个字节。也就是说，s_addr 是一个整数，而IP地址是一个字符串，所以需要** inet_addr() **函数进行转换，例如： 12unsigned long ip = inet_addr(&quot;127.0.0.1&quot;);printf(&quot;%ld &quot;, ip); 运行结果：16777343 三、connect() 函数参数与bind()相同。 1int connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen); //Windows 四、listen() 函数通过 listen() 函数可以让套接字进入被动监听状态，它的原型为： 1int listen(SOCKET sock, int backlog); //Windows sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。 被动监听：是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 **ECONNREFUSED **错误，对于 Windows，客户端会收到 **WSAECONNREFUSED **错误。注意：listen()只是让套接字处于监听状态，并没有接收请求。接收请求需要使用accept()函数。 五、accept() 函数当套接字处于监听状态时，可以通过 accept()函数来接收客户端请求。它的原型为： 1SOCKET accept(SOCKET sock, struct sockaddr *addr, int *addrlen); //Windows 它的参数与 listen() 和 connect() 是相同的：sock为服务器端套接字，addr为 sockaddr_in 结构体变量，addrlen为参数 addr 的长度，可由 sizeof() 求得。","categories":["网络通信"]},{"title":"IO多路复用","path":"/网络通信/IO多路复用/","content":"最近面试，岗位是安全开发岗。问了较多的网络相关函数。其中关于io多路复用的问题，由于工作中涉及的比较少，回答的一塌糊涂。知耻而后勇，专门整理一遍记录一下这个知识点吧 主要是之前还专门写过一遍笔记用来记录当时的学习情况，还写的挺详细！！！ 【一文搞懂】FD_SET的使用_欧恩意的博客-CSDN博客 [toc] IO多路复用概念顾名思义，就是可以多个可以重复使用的io（输入\\输出）。 多路：核心需求是要用尽可能少的线程来处理尽可能多的连接，这里的多路是指需要处理的众多连接。 复用：核心需求是要求使用尽可能少的线程，尽可能减少系统开销去处理尽可能多的连接，那么这个复用是指利用有限的资源。也就是说利用有限的资源去处理尽可能多的任务。例如：在阻塞IO中，一个连接需要一个线程去处理，但是在IO多路复用的模型中，则可以使用一个线程去处理多个任务。 参考及引用： Linux – IO Multiplexing – Select vs Poll vs Epoll – Developers Area Chapter 6. I&#x2F;O Multiplexing: The select and poll Functions - Shichao’s Notes select &#x2F; poll &#x2F; epoll: practical difference for system architects | UlduzSoft 【并发】IO多路复用select&#x2F;poll&#x2F;epoll介绍_哔哩哔哩_bilibili","tags":["IO复用","wanlguo"],"categories":["网络通信"]},{"title":"域名解析相关经验","path":"/网络通信/DNS/域名解析经验整理/","content":"整理记录排查网络问题事的域名解析相关问题 [toc] 基础知识点A 和 AAAAA 和 AAAA 都是DNS记录，它们的作用是将域名解析到IP地址。具体来说，A记录将域名解析到IPv4地址，而AAAA记录将域名解析到IPv6地址。 因此，主要的区别在于 A 记录用于IPv4，而 AAAA 记录用于IPv6。 相关工具设置域名工具 常见方式是在网卡的配置界面设置 dns 服务器，在高级页面可以配置多个 DNS 服务器。但是，在特殊环境： 如使用 netsh 命令设置的静态 dns 服务器等与用户手动添加的 dns 一样时，可能会出现 dns 解析异常的问题。 quicksetdns_sec工具:QuickSetDNS - 快速修改 DNS 服务器工具 - 小众软件","tags":["网络","DNS","域名"],"categories":["网络通信","DNS"]},{"title":"查看浏览器DNS缓存","path":"/网络通信/DNS/查看浏览器DNS缓存/","content":"概述：本文主要介绍如何在浏览器查看DNS缓存，同时罗列了DNS查询的一些顺序 [toc] DNS 缓存与解析DNS 缓存分类1、浏览器缓存浏览器会根据一定频率缓存DNS记录； 2、本地DNS缓存如果浏览器缓存中找不到解析记录，就会去询问操作系统中的缓存； 3、本地HOSTS文件HOSTS是记录域名与IP地址一一映射关系的本地文件，Windows系统中位于 C:\\Windows\\System32\\drivers\\etc 4、路由器DNS缓存我们常用的路由器也带有自动缓存功能，路由器DNS被篡改会造成域名劫持，将访问网址定位到另外一个服务器； 5、递归服务器缓存递归服务器在将解析结果告知客户端的同时，将记录缓存下来，当下次请求同一个域名时，直接会将记录返回，而无需再进行全球查询。 DNS 解析顺序DNS解析顺序是 “先查缓存，再递归解析”，查询顺序为：浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存 -&gt; 递归服务器缓存 -&gt; 递归查询 以 www.baidu.com 这个域名为例进行查询，具体流程如下： 1. 搜索浏览器自带的DNS缓存 当收到访问请求后，浏览器首先会查询浏览器自身的DNS缓存，这个缓存时间比较短（chrome:&#x2F;&#x2F;net-internals&#x2F;#dns 这里可以查询缓存的dns记录），且只能容纳 1000条缓存，如果缓存中有对应条目，返回结果，解析到此结束。 在chrome打开 chrome://net-internals/#dns 如上所示，浏览器解析到了 www.baidu.com 的ip 2. 查询操作系统缓存和hosts本地文件 如果浏览器缓存中没有找到对应条目（ipconfig/displaydns可以查看），操作系统也会有一个域名解析的过程，浏览器会先搜索操作系统的DNS缓存中是否有这个域名解析记录，如果有返回结果，解析结束。 此外，电脑本地文件HOSTS中可以设定域名到IP地址的指向关系。如果HOSTS文件中保存有该域名的记录，浏览器会首先使用这个IP地址，并将其结果缓存下来，缓存时间同样受域名失效时间和缓存空间大小决定。 3. 查询路由器缓存 如果浏览器和操作系统中没有域名解析记录，就会查询路由器中的DNS缓存，如果路由器DNS缓存中有解析条目，直接返回结果，解析结束。 4. 递归解析服务器缓存 如果本机和路由器DNS缓存中没有该域名的解析记录，浏览器就会向递归服务器发起请求，如果递归服务器缓存有该域名解析条目，返回结果，解析结束。 5. 查询根域名服务器 如果递归服务器缓存中没有结果，就会委托递归服务器发起全球查询，首先递归服务器会向根域名服务器发起解析请求。根域名服务器告知.com顶级域名服务器地址。 6. 查询顶级域名服务器 递归服务器向.com顶级域名服务器发起DNS请求，.com顶级服务器告知example.com所属权威域名服务器地址。 7. 查询权威域名服务器 递归服务器向example.com的权威域名服务器地址发起请求，权威服务器告知www.example.com所对应的IP地址。 8. 返回解析结果 得到www.example.com的IP地址后，递归服务器将结果告知客户端，客户端对该IP地址发起访问。整个DNS解析流程到此结束。","tags":["DNS","缓存"],"categories":["网络通信","DNS"]},{"title":"DNS用的是TCP协议还是UDP协议","path":"/网络通信/DNS/DNS协议/","content":"概述: 关于 DNS 使用的是 TCP 还是 UDP 的说明 DNS缓存问题可以看这篇文章 【查看浏览器DNS缓存】 [toc] DNS概述DNS占用53号端口，同时使用TCP和UDP协议。 📌 那么DNS在什么情况下使用这两种协议？ DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。 DNS区域传输的时候使用TCP协议： 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。 TCP是一种可靠连接，保证了数据的准确性。 🎃 域名解析时使用UDP协议： 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。 DNS为什么用TCP和UDPDNS同时占用UDP和TCP端口53是公认的，这种单个应用协议同时使用两种传输协议的情况在TCP&#x2F;IP栈也算是个另类。但很少有人知道DNS分别在什么情况下使用这两种协议。 先简单介绍下TCP与UDP TCP是一种面向连接的协议，提供可靠的数据传输，一般服务质量要求比较高的情况，使用这个协议。UDP—用户数据报协议，是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 TCP与UDP的区别：UDP和TCP协议的主要区别是两者在如何实现信息的可靠传递方面不同。TCP协议中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。 与TCP不同，UDP协议并不提供数据传送的保证机制。如果在从发送方到接收方的传递过程中出现数据报的丢失，协议本身并不能做出任何检测或提示。因此，通常人们把UDP协议称为不可靠的传输协议。相对于TCP协议，UDP协议的另外一个不同之处在于如何接收突发性的多个数据报。不同于TCP，UDP并不能确保数据的发送和接收顺序。事实上，UDP协议的这种乱序性基本上很少出现，通常只会在网络非常拥挤的情况下才有可能发生。 既然UDP是一种不可靠的网络协议，那么还有什么使用价值或必要呢？ 其实不然，在有些情况下UDP协议可能会变得非常有用。因为UDP具有TCP所望尘莫及的速度优势。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。反观UDP由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。 DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 为什么既使用TCP又使用UDP？首先了解一下TCP与UDP传送字节的长度限制： UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。 区域传送时使用TCP，主要有一下两点考虑： 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 TCP是一种可靠的连接，保证了数据的准确性。 域名解析时使用UDP协议：客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。 UDP UDP 与 TCP 的主要区别在于 UDP 不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP 在许多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。ICQ 短消息使用 UDP 协议发送消息。 许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。 TCPTCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。记住，较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。 为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。 TCP与UDP的选择如果比较UDP包和TCP包的结构，很明显UDP包不具备TCP包复杂的可靠性与控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。） 很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是当然的选择。当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择，如：DNS交换。把SNMP建立在UDP上的部分原因是设计者认为当发生网络阻塞时，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点连接将会用于绝大多数的网络应用。 TCPTCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来。三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。 UDPUDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP&#x2F;IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包（如图2所示）。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。HTTP是用TCP协议传输的。 TCP协议与UDP协议的区别TCP基于面向连接的协议，数据传输可靠，传输速度慢，适用于传输大量数据，可靠性要求高的场合。 UDP协议面向非连接协议，数据传输不可靠，传输速度快，适用于一次只传送少量数据、对可靠性要求不高的应用环境。 面向连接的TCP“面向连接”就是在正式通信前必须要与对方建立起连接。比如你给别人打电话，必须等线路接通了、对方拿起话筒才能相互通话。 TCP协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高的数据通信系统往往使用TCP协议传输数据。 面向非连接的UDP协议“面向非连接“就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。这与现在风行的手机短信非常相似：你在发短信的时候，只需要输入对方手机号就OK了。 UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境 UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。 TCP协议与UDP协议支持的应用协议TCP支持的应用协议主要有：Telnet、FTP、SMTP 等；UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。 TCP和UDP都是位于OSI模型中的传输层中。 📢 TCP优点：面向连接的,具有实时性,就象打电话一样,两者必须建立连接.它保证你所传输的东西是准确到达的,并且收方要给你一个收到或没有\\收到的回复,所以它具有安全性的特点..📢 UDP优点：面向无连接的,就象给某人寄信一样,对方不需要在邮局等着你的信到.所以说,它没有保障性,不能确保你一定能收到信,不象TCP那样,,但是 它比TCP好的一点,就是速度快,因为他不需要双方交流是否收到,对发的东西有一个确认的过程.","tags":["DNS","UDP","TCP"],"categories":["网络通信","DNS"]},{"title":"DDoS攻击","path":"/网络安全/DDoS攻击/","content":"概述：DDoS() 技术鉴赏 [toc] DDoS说明 DDoS(Distributed Denial of Service)即分布式拒绝服务攻击,是一种通过大量占用目标服务器资源的方式,使服务暂时中断或停止,无法对正常用户提供服务的攻击手段。 DDoS攻击的主要特征包括: 分布式 - 利用大量分布在不同地点的攻击源进行攻击。 流量泛滥 - 通过发送大量流量淹没目标服务器的带宽或资源。常见的有UDP flood、ICMP flood等。 资源耗尽 - 占用目标服务器的关键系统资源,如连接数、线程数等。如SYN flood攻击。 攻击增强 - 通过各种方式增强攻击流量和效果。如IP地址欺骗。 多向量组合 - 综合使用各种类型的攻击手段,对目标发起多维攻击。 防御DDoS攻击的主要手段包括: 增加带宽 - 提高流量承载能力。 使用DDoS防护服务 - 由服务提供商过滤攻击流量。 限制连接和请求 - 加强对高流量源的访问控制。 丢弃无效流量 - 通过技术手段识别并丢弃攻击流量。 扩展关键系统资源 - 提高关键资源池容量。 服务降级 - 在被攻击时暂时停止非核心服务。 服务分散 - 通过CDN等方式分散服务,避免单点故障。 合理限速 - 对源IP访问频率和流量进行控制。 DDoS防御需要综合运用各种技术手段,从网络、服务和应用层进行防护,最大程度减轻攻击影响。","tags":["网络安全","DDoS"],"categories":["网络安全"]},{"title":"密钥分配","path":"/立志博览群书/《计算机网络 第7版》/第7章 网络安全/7.5 密钥分配/","content":"密钥分配由于密码算法是公开的，网路的安全性就完全基于密钥的安全保护上。因此在密码学中出现了一个重要的分支——密钥管理。密钥管理包括：密钥的产生、分配、注入、验证和使用。本节只讨论密钥的分配。 密钥分配（或密钥分发）是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。 例如，可以派非常可靠的信使携带密钥分配给互相通信的各用户。这种方法称为网外分配方式。但随着用户的增多和网络流量的增大，密钥更换频繁（密钥必须定期更换才能做到可靠），派信使的办法已不再使用，而应采用网内分配方式，即对密钥自动分配。","tags":["密钥管理","对称密钥","公钥"],"categories":["立志博览群书","《计算机网络 第7版》","第7章 网络安全"]},{"title":"第7章 网络安全","path":"/立志博览群书/《计算机网络 第7版》/第7章 网络安全/index/","content":"本章只是对计算机网络安全问题进行初步的介绍。 本章最重要的内容是： 计算机完了过面临的安全性威胁和计算机网络安全的主要问题","tags":["网络安全","防火墙","对称密钥","公钥","ssl","tls","系统安全","数字签名与鉴别"],"categories":["立志博览群书","《计算机网络 第7版》","第7章 网络安全"]},{"title":"热补丁支持","path":"/立志博览群书/《深入理解Windows操作系统》/3-13-热补丁支持/","content":"[TOC] 补丁定义补丁是指衣服、被褥上为遮掩破洞而钉补上的小布块。明白了吗？ 现在也指对于大型软件系统(如微软操作系统)在使用过程中暴露的问题（一般由黑客或病毒设计者发现）而发布的解决问题的小程序。就像衣服烂了就要打补丁一样，人编写程序不可能十全十美的，所以软件也免不了会出现BUG，而补丁是专门修复这些BUG做的因为原来发布的软件存在缺陷，发现之后另外编制一个小程序使其完善，这种小程序俗称补丁。补丁是由软件的原来作者制作的，可以访问网站下载补丁。 补丁一般都是 .exe 文件 微软补丁微软的Windows操作系统比较大，比较复杂。因此总有考虑不周的地方。有些病毒或者黑客就利用微软的漏洞进行攻击。微软发现漏洞后就发布一些补丁程序。 我们得到微软的补丁程序后安装到计算机上就叫打补丁。 什么是微软补丁？ 微软发布的系统补丁有两种类型：Hotfix 和 Service Pack，下面介绍它们之间的区别和联系。 hotfix 是微软针对某一个具体的系统漏洞或安全问题而发布的专门解决程序，Hotfix的程序文件名有严格的规定，一般格式为“产品名-KBXXXXXX-处理器平台-语言版本.exe”。现在一个例子来详细说明：微软针对震荡病毒而发布的Hotfix程序名为“Win2K-KB835732-X86-CHS.exe”，我们知道这个补丁是针对Win2000系统的，其知识库编号为 835732，应用于 X86 处理器平台，语言版本为简体中文。 Hotfix 是针对某一个具体问题而发布的解决程序，因此它会经常发布，数量非常大。用户想要知道目前已经发布了哪些Hotfix程序是一件非常麻烦的事。因此微软将这些Hotfix补丁全部打包成一个程序提供给用户安装，这就是Service Pack，简称SP。Service Pack包含了发布日期以前所有的Hotfix程序，因此只要安装了它，就可以保证自己不会漏掉一个Hotfix程序。而且发布时间晚的Service Pack程序会包含以前的Service Pack，例如 SP3会包含SP1、SP2的所有补丁。 热补丁支持 重新引导一台机器以便把最新的补丁都应用上，这对于服务器来说可能会意味着一段显著的宕机时间，这也正是为什么Windows要支持运行时刻的补丁方法，称为热补丁（hot patch，或简化为hotpatch）。与之相反的是冷补丁（coldpatch），它要求一次重新引导。热补丁并非只是简单地允许文件可在执行过程中被覆盖;相反地，它包括了一系列可能会被请求执行的复杂操作（这些操作也可能会组合起来）。 热补丁执行操作下表列出了这些操作： 操作 含义 用途 映像文件改名称（Rename Image) 替换磁盘上一个正在被其他应用程序使用的DLL，或者替换磁盘上一个已经被内核加载到系统中的驱动程序 当一个用户模式的库需要完整地被替换的时候，内核可以检测到哪些进程和服务正在引用该库，将它们卸载出内存，然后更新DLL，再重新启动这些程序和服务（通过重启管理器[restart manager]来完成）。当一个驱动程序需要被替换的时候，内核可以卸载该驱动程序（该驱动程序要求有一个卸载例程），更新驱动程序，然后重新加载替换后的驱动程序 对象交换（Object Swap） 以原子操作的方式更改对象目录名字空间中的一个对象 当一个文件（往往是已知的DLL）需要被原子凡事修改名称，但不影响任何可能正在使用该文件的进程时（所以，这些进程可以立即使用新的文件，且仍然使用老的句柄，但不要求应用程序重新启动） 补丁函数代码（Patch Function Code） 将一个映像文件中的一个或多个函数的代码替换为新的版本 如果在运行时刻一个DLL或驱动程序不能被替换或修改名称，则该映像中的函数可以直接被打上补丁。对于一个包含了新代码的热补丁DLL，当老的函数被调用时，它会跳转到新的代码中。 刷新系统DLL（Refresh System DLL） 重新为Ntdll.dll加载内存映射区对象 Windows的系统原生库Ntdll.dll只在系统引导过程中被加载一次，以后只是被简单地复制到每个新进程的地址空间中。如果它呗热补丁了，那么，系统必须刷新这一内存区对象，以便加载新的版本 特性运行时刻卸载 热补丁文件的构成除了包括要替换的函数部分，还包括一个Update.exe的程序以及一个额外的.hp热补丁文件。 Update.exe：完成该补丁的提取工作，也执行相应的更新过程。 .hp热补丁文件：此文件包含一个特殊的PE头，称为.HOT1。该PE头包含了一个数据结构，描述了该文件中出现的各种补丁描述符（patch descriptor）。每一个补丁描述述符指明了在原始文件中需要被补丁的偏移位置、一个验证机制（它可以包含一份老数据的简单比较、一个校验和，或者一个散列值），以及待补丁的新数据。内核将解析这些描述符，并且执行恰当的修改动作。若是被保护的进程（protected process，有关进程的更多信息，参见《深入理解Windows操作系统》第5章），或者其他经过数字签名的二进制映像，在这些情况下，热补丁也必须被经过数字签名，以避免针对敏感文件或进程执行“伪造的”补丁。 在编译时刻对热补丁的支持，是通过在每个函数的开始处加入7个额外的字节来做到的。其中5个字节被看做前一个函数的结束部分，2个字节被看作函数前缀（function prolog）部分，也就是函数的开始。 限制使用热补丁也存在一些限制： 与安全软件的不兼容。像安全软件类的第三方应用程序可能会阻止这样的补丁；补丁也可能与第三方应用程序的操作系统不兼容 补丁要修改一个文件的导出表或导入表 补丁要改变数据结构，修正无限循环，或者包含内联的汇编代码","tags":["《深入理解Windows操作系统》","Windows"],"categories":["立志博览群书","《深入理解Windows操作系统》"]},{"title":"OSI参考模型","path":"/立志博览群书/《深入理解Windows操作系统》/7-1-OSI参考模型/","content":"OSI 参考模型是一个理想化的方案。这么说是因为很少有系统是完全按照它来实现（关于这一点可以后续再讨论），但是它通常被用来作为网络原理讨论的框架。 一台机器上的每一层都假设它在跟另一台机器上的同一层“通话”。在同一层次上，两台机器“说”的是同一种语言或协议。 每一次网络传输必须都要向下传输，通过客户机器的每一层，再传输到网络上，然后再目标机器上向上传递，直至到达某一可以理解和执行该请求的层。 在 OSI 模型中，每一层的目的是：向更高的层提供服务，并且对如何在低层上实现这些服务进行抽象。 以下内容为 OSI 七层中每一层的介绍: 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层","tags":["《深入理解Windows操作系统》","网络编程","Windows"],"categories":["立志博览群书","《深入理解Windows操作系统》"]},{"title":"返回值类型的规范","path":"/立志博览群书/《Windows核心编程》/1-1-返回值类型的规范/","content":"参照 Windows 对程序错误的处理中，函数常用返回值的设置，作为C++开发，也应该参照这一标准。 当调用一个 Windows 函数时，它首先要检验传递给它的的各个参数的有效性，然后再设法 执行任务。如果传递了一个无效参数，或者由于某种原因无法执行这项操作，那么操作系统就 会返回一个值，指明该函数在某种程度上运行失败了。表 1 - 1列出了大多数 Windows 函数使用 的返回值的数据类型 Windows 函数常用的返回值类型 数据类型 表示失败的值 void 该函数的运行不可能失败。Windows 函数的返回值类型很少是 void bool 如果函数运行失败，那么返回值是0，否则返回的是非0值。最好对返回值进行测试，以确定它是0还是非0。不要测试返回值是否为TRUE HANDLE 如果函数运行失败，则返回值通常是 NULL，否则返回值为 HANDLE，用于标识你可以操作的一个对象。注意，有些函数会返回一个句柄值 INVALID_ HANDLE_VALUE，它被定义为 -1。函数的Platform SDK 文档将会清楚地说明该函数运行失败时返回的是 NULL 还是 INVALID_HANDLE_VALID PVOID 如果函数运行失败，则返回值是 NULL，否则返回PVOID，以标识数据块的内存地址 LONG&#x2F;DWORD 这是个难以处理的值。返回数量的函数通常返回LONG或DWORD。如果由于某种原因，函数无法对想要进行计数的对象进行计数，那么该函数通常返回 0或-1（根据函数而定）。如果调用的函数反悔了LONG&#x2F;DWORD，那么需要阅读相应的函数说明，以确保能正确检查潜在的错误。 一个 Windows 函数返回的错误代码对了解该函数为什么会运行失败尝尝很有用。 从系统内部来讲，当一个Windows函数检测到一个错误时，它会使用一个称为线程本地存储器（thread-local storage）的机制，将相应的错误代码号码与调用的线程关联起来。这将使线程能够互相独立运行，而不会影响各自的错误代码。当函数返回时，它的返回值就能指明一个错误已经发生。若要确定这是个什么错误，则需要调用 GetLastError 函数： 1DWORD GetLastError","tags":["《Windows核心编程》","规范"],"categories":["立志博览群书","《Windows核心编程》"]},{"title":"<3> 确定对象使用前初始化","path":"/立志博览群书/《Efficient C++》/3_确定对象使用前初始化/","content":"[toc] 未初始化的对象在初始化对象的值方面，C++ 似乎相当善变。如下面示例代码，g_var 为全局变量，自动初始化为 0，而 a 是一个随机值。p 的成员变量有时候被初始化为 0，有时候不会，从运行结果来看两次都已经初始化为 0。 而其他变成语言中用一个 “无初值对象” 是不存在的，这很重要。 1234567891011121314151617181920212223// initObj.h#ifndef __INITOBJ_H__#define __INITOBJ_H__#include &lt;iostream&gt;int g_var;class Point&#123;public: Point() &#123;&#125; ~Point() &#123;&#125; int x() &#123; return xp; &#125; int y() &#123; return yp; &#125;private: int xp; int yp;&#125;;#endif // __INITOBJ_H__ 123456789101112131415// initObj.cpp#include &quot;initObj.h&quot;int main()&#123; int a; std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; &quot;g_var = &quot; &lt;&lt; g_var &lt;&lt; std::endl; Point p; std::cout &lt;&lt; &quot;Point::x = &quot; &lt;&lt; p.x() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Point::y = &quot; &lt;&lt; p.y() &lt;&lt; std::endl; return 0;&#125; C++初始化通常如果你使用类 C 语法部分而未初始化可能招致运行期成本，那么就不保证发生初始化。一旦进入纯 C++ 部分，规则有些变化。这就很好地解释了为什么数组不保证其内容被初始化，而 vector 却能保证初始化。 基础数据类型初始化12345678910111213141516// baseData.cpp#include &lt;iostream&gt;int main()&#123; int x = 0; // 手动初始化 int 类型对象 const char * text = &quot;shiyanlou&quot;; // 手动初始化指针字符串 double d; // 通过读取输入方式初始化 std::cout &lt;&lt; &quot;请输入：&quot;; std::cin &gt;&gt; d; std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; std::endl; std::cout &lt;&lt; &quot;text = &quot; &lt;&lt; text &lt;&lt; std::endl; std::cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; std::endl; return 0;&#125; 类初始化至于内置类型以外的任何其他对象，初始化责任落在了构造函数。规则很简单，确保每一个构造函数都将对象的每一个成员初始化。 这个规则很简单，重要的是别混淆了赋值和初始化。 1234567891011121314151617181920212223// initClass.h#ifndef __INITCLASS_H__#define __INITCLASS_H__#include &lt;iostream&gt;#include &lt;list&gt;class PhoneNumber &#123; &#125;;class ABEntry&#123; // ABEntry = “Address Book Entry”public: ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones);private: std::string theName; std::string theAddress; std::list&lt;PhoneNumber&gt; thePhones; int numTimesConsulted;&#125;;#endif // __INITCLASS_H__ 1234567891011121314151617// initClass.cpp#include &quot;initClass.h&quot;ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones)&#123; theName = name; // 这些都是赋值而非初始化 theAddress = address; thePhones = phones; numTimesConsulted = 0;&#125;int main()&#123; return 0;&#125; 这将产生具有你期望的值的 ABEntry 对象，但这仍然不是最好的方法。C++ 的规则规定，对象的数据成员在进入构造函数的主体之前被初始化。在 ABEntry 构造函数中，theName、theAddress 和 thePhones 没有被初始化，它们只是被赋值。初始化发生在进入 ABEntry 构造函数正文之前，即自动调用它们的默认构造函数时进行的。在进入 ABEntry 构造函数的主体之前，已经进行了初始化。这对于 numTimesConsulted 不是这样，因为它是一个内置类型。对它来说，不能保证它在被赋值之前就被初始化了。 初始化列表ABEntry 构造函数的一个较佳写法是使用初始化列表进行初始化。 初始化列表使用方法1234567891011121314151617181920212223// initList.h#ifndef __INITLIST_H__#define __INITLIST_H__#include &lt;iostream&gt;#include &lt;list&gt;class PhoneNumber &#123; &#125;;class ABEntry&#123; // ABEntry = “Address Book Entry”public: ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones);private: std::string theName; std::string theAddress; std::list&lt;PhoneNumber&gt; thePhones; int numTimesConsulted;&#125;;#endif // __INITLIST_H__ 12345678910111213141516// initList.cpp#include &quot;initList.h&quot;ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones) : theName(name), // 以下使用初始化列表，从冒号（:）后开始 theAddress(address), thePhones(phones), numTimesConsulted(0)&#123;&#125; // 构造函数中为空int main()&#123; return 0;&#125; 示例代码中构造函数与在构造函数中赋值的最终结果相同，但它往往更有效率。基于赋值的版本首先调用默认构造函数来初始化 theName、theAddress 和 thePhones，然后立即在默认构造的基础上分配新的值。因此，所有在这些默认构造中进行的工作都被浪费了。成员初始化列表的方法避免了这个问题，因为初始化列表中的参数被用作各种数据成员的构造器参数。在这个例子中，theName 是由 name 拷贝构造的，theAddress 是由 address 复制构造的，thePhones 是由 phones 拷贝构造的。 对大多数类型而言，比起先调用默认构造函数然后再调用拷贝赋值操作符，单只调用一次赋值构造函数是比较高效的，有时甚至高效得多。对于内置型对象如 numTimesConsulted，其初始化和赋值的成本相同，但为了一致性最好也通过成员初值列来初始化。同样道理，甚至当你想要默认构造一个成员变量，你都可以使用成员初值列，只要指定 0 或者空作为初始化实参即可。 123456ABEntry::ABEntry() : theName(), // 调用 thenName 默认构造函数 theAddress(), // 调用 theAddress 默认构造函数 thePhones(), // 调用 thePhones 默认构造函数 numTimesConsulted(0) // 初始化为 0&#123;&#125; 初始化说明当用户定义类型的数据成员在成员初始化列表中没有初始化时，编译器会自动调用这些数据成员的默认构造器，所以有些程序员认为上述方法是多余的是可以理解的，但是如果有一个总是在初始化列表中列出每个数据成员的策略，就可以避免记住哪些数据成员在被省略后可能会被未初始化。例如，由于 numTimesConsulted 是一个内置的类型，如果没有在初始化列表中遗漏没有初值时就会导致不明确行为。 有些情况下即使面对的成员变量属于内置类型（其初始化与赋值的成本相同），也一定得使用初值列。是的，如果成员变量是常量或引用时，它们就一定需要初值，不能被赋值。为避免需要记住成员变量何时必须在成员初值列中初始化，何时不需要，最简单的做法就是：总是使用成员初值列。这样做有时候绝对必要，且又往往比赋值更高效。 许多类拥有多个构造函数，每个构造函数有自己的成员初值列。如果这种类存在许多成员变量或基类，多份成员初值列的存在就会导致不受欢迎的重复（在初值列内）和无聊的工作（对程序员而言）。这种情况下可以合理地在初值列中遗漏那些 “赋值表现像初始化一样好” 的成员变量，改用它们的赋值操作，并将那些赋值操作移往某个函数（通常是私有的），供所有构造函数调用。这种做法在 “成员变量的初值系由文件或数据库读入” 时特别有用。然而，比起经由赋值操作完成的 “伪初始化”（pseudo-initialization），通过成员初值列完成的 “真正初始化” 通常更加可取。 C++ 有着十分固定的 “成员初始化顺序”。顺序总是相同：基类更早于其子类被初始化，而类的成员变量总是以其声明次序被初始化。回头看看 ABEntry，其 theName 成员永远最先被初始化，然后是 theAddress，再是 thePhones，最后是 numTimesConsulted。即使它们在成员初值列中以不同的顺序出现（很不幸那是合法的），也不会有任何影响。为避免你或你的检查代码的人迷惑，并避免某些可能存在的晦涩错误，当你在成员初值列中条列各个成员时，最好总是以其声明次序为次序。 初始化静态对象静态（static）对象寿命从被构造出来直到程序结束为止，因此栈和堆对象都被排除。包括全局对象、命名空间内的对象、类、函数和文件内被声明静态的对象。函数内的静态对象称为局部静态对象（因为它们对函数而言是局部的），其他静态对象称为非局部静态对象。程序结束时静态对象会被自动销毁，也就是它们的析构函数会在 main() 结束时被自动调用。 初始化顺序如下示例代码，我们关心的问题涉及至少两个源码文件，每一个内含至少一个非局部静态对象（也就是说该对象是全局或位于命名空间内，抑或在类内或源码文件内被声明为静态）。真正的问题是：如果某编译单元内的某个非局部静态对象的初始化动作使用了另一编译单元内的某个非局部静态对象，它所用到的这个对象可能尚未被初始化，因为 C++ 对 “定义于不同编译单元内的非局部静态对象” 的初始化次序并无明确定义。 12345678910111213141516171819202122232425262728293031// FileSystem.h#ifndef __FILESYSTEM_H__#define __FILESYSTEM_H__/** 假设有一个 FileSystem 类，它让互联网上的文件看起来好像位于本机。 由于这个类使文件系统看起来像个单一文件系统，你可能会产出一个特殊对象， 位于全局或命名空间作用域内，像是单一文件系统。 */#include &lt;iostream&gt;class FileSystem&#123;public: FileSystem() &#123;&#125; ~FileSystem() &#123;&#125; // ... std::size_t numDisks() const; // 其中一个成员函数 // ...&#125;;/** FileSystem 对象绝不是一个稀松平常无关痛痒的对象， 因为你的客户如果在 theFileSystem 对象构造完成前就使用它，会得到惨重的灾情。 */// 预留给用户使用的对象extern FileSystem tfs;#endif // __FILESYSTEM_H__ 123456789101112131415// Directory.h#ifndef __DIRECTORY_H__#define __DIRECTORY_H__#include &lt;iostream&gt;#include &quot;FileSystem.h&quot;class Directory&#123;public: Directory(const FileSystem &amp;fs); ~Directory();&#125;;#endif // __DIRECTORY_H__ 12345678910111213141516// Director.cpp#include &quot;Directory.h&quot;/** 假设某些客户建立了一个 Directory 类用以处理文件系统内的目录。 很自然他们的类会用上 theFileSystem 对象 */Directory::Directory(const FileSystem &amp;tfs)&#123; std::size_t disks = tfs.numDisks(); // 使用 tfs 对象 // ...&#125;Directory::~Directory()&#123;&#125; 12345678910// main.cpp#include &quot;FileSystem.h&quot;#include &quot;Directory.h&quot;int main()&#123; // 假设创建一个目录来存放临时文件 Directory tempDir(tfs); // 临时文件存放目录 return 0;&#125; 现在，初始化次序的重要性显现出来了：除非 tfs 在 tempDir 之前先被初始化，否则 tempDir 的构造函数会用到尚未初始化的 tfs。但 tfs 和 tempDir 是不同的人在不同的时间于不同的源码文件建立起来的，它们是定义于不同编译单元内的非局部静态对象。如何能够确定 tfs 会在 tempDir 之前先被初始化？ C++ 对 “定义于不同的编译单元内的非局部静态对象” 的初始化相对次序并无明确定义。这是有原因的：决定它们的初始化次序相当困难，根本无解。在其最常见形式，也就是多个编译单元内的非局部静态对象经由 “模板隐式具现化” 形成（而后者自己可能也是经由 “模板隐式具现化” 形成），不但不可能决定正确的初始化次序，甚至往往不值得寻找 “可决定正确次序” 的特殊情况。 单例模式幸运的是一个小小的设计便可完全消除这个问题。唯一需要做的是：将每个 非局部静态对象搬到自己的专属函数内（该对象在此函数内被声明为静态）。这些函数返回一个引用指向它所含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说，非局部静态对象被局部静态对象替换了。设计模式的迷哥迷妹们想必认出来了，这是单例模式的一个常见实现手法。 这个手法的基础在于：C++ 保证，函数内的局部静态对象会在该函数被调用期间首次遇上该对象之定义式时被初始化。所以如果你以 “函数调用”（返回一个引用指向局部静态对象）替换直接访问非局部静态对象，你就获得了保证，保证你所获得的那个引用将指向一个历经初始化的对象。更棒的是，如果你从未调用非局部静态对象的 “仿真函数”，就绝不会引发构造和析构成本；真正的非局部静态对象可没这等便宜！ 1234567891011121314// FileSystem.cpp#include &quot;FileSystem.h&quot;// 该函数替换 tfs 对象，在类中是静态的，FileSystem&amp; tfs()&#123; static FileSystem tfs; // 定义并初始化非局部静态对象 return tfs; // 返回对象引用&#125;std::size_t FileSystem::numDisks() const&#123; return 0;&#125; 12345678910111213141516// Director.cpp#include &quot;Directory.h&quot;/** 假设某些客户建立了一个 Directory 类用以处理文件系统内的目录。 很自然他们的类会用上 theFileSystem 对象 */Directory::Directory(const FileSystem &amp;tfs)&#123; std::size_t disks = tfs.numDisks(); // 使用 tfs 对象 // ...&#125;Directory::~Directory()&#123;&#125; 这么修改之后，这个系统程序的客户完全像以前一样地用它，唯一不同的是他们现在使用 tfs() 和 tempDir() 函数，而不再是 tfs 和 tempDir 对象。也就是说他们使用函数返回的 “指向静态对象” 的引用，而不再使用对象自身。 这种结构下的返回引用函数往往十分单纯：第一行定义并初始化一个局部静态对象，第二行返回它。这样的单纯性往往使用内联函数，尤其如果它们被频繁调用的话（见实验《透彻内联》）。但是从另一个角度看，这些函数 “内含静态对象” 的事实使它们在多线程系统中带有不确定性。再说一次，任何一种非常量静态对象，不论它是局部或非局部，在多线程环境下往往都会很麻烦。处理这个麻烦的一种做法是：在程序的单线程启动阶段手工调用所有返回引用函数，这可消除与初始化有关的 “竞速条件（race conditions）”。 为避免在对象初始化之前过早地使用它们，你需要做三件事： 手动初始化内置型非成员变量。 使用初始化列表初始化成员变量。 在初始化顺序不确定情况下加强设计。","tags":["Efficent C++"],"categories":["立志博览群书","《Efficient C++》"]},{"title":"<4> 了解C++默认创建并调用的函数","path":"/立志博览群书/《Efficient C++》/4-了解C++默认创建并调用的函数/","content":"[toc] 编译器创建的函数空类： 1class Empty&#123;&#125;; 编译器默认添加的函数： 12345678910// defaultFunc.hclass Empty&#123;public: // 当程序中未定义以下函数时编译器默认添加 Empty() &#123; &#125; // 默认构造函数 Empty(const Empty&amp; rhs) &#123; &#125; // 拷贝构造函数 ~Empty() &#123; &#125; // 析构函数 Empty&amp; operator=(const Empty&amp; rhs) &#123; &#125; // 拷贝赋值操作符函数&#125;; 拷贝构造函数与拷贝赋值操作符函数拷贝构造函数和拷贝赋值操作符函数，编译器创建的版本只是单纯地将来源对象的每一个非静态成员变量拷贝到目标对象。如下模板类 NamedObject，它允许你将一个名称和类型为 T 的对象产生关联。 123456789101112131415161718192021222324// copy.h#ifndef __COPY_H__#define __COPY_H__#include &lt;iostream&gt;template&lt;typename T&gt;class NamedObject&#123;public: /** 由于其中声明了一个构造函数，编译器于是不再为它创建默认构造函数。 这很重要，意味如果你用心设计一个类，其构造函数要求实参， 你就无须担心编译器会毫无挂虑地为你添加一个无实参构造函数（即默认构造函数）而遮盖掉你的版本。 */ NamedObject(const char *name, const T&amp; value) : nameValue(name), objectValue(value) &#123;&#125; NamedObject(const std::string&amp; name, const T&amp; value) : nameValue(name), objectValue(value) &#123;&#125;private: std::string nameValue; T objectValue;&#125;;#endif // __COPY_H__ 1234567891011121314// main.cpp#include &quot;copy.h&quot;int main()&#123; /** NamedObject 既没有声明拷贝构造函数，也没有声明拷贝赋值操作符函数， 所以编译器会为它创建那些函数（如果它们被调用的话）。 现在，看看拷贝构造函数的用法 */ NamedObject&lt;int&gt; no1(&quot;Smallest Prime Number&quot;, 2); NamedObject&lt;int&gt; no2(no1); return 0;&#125; 编译器拒绝创建拷贝赋值操作符函数的情况编译器为 NamedObject&lt;int&gt; 所产生的拷贝赋值操作符函数，其行为基本上与拷贝构造函数如出一辙，但一般而言只有当生出的代码合法且有适当机会证明它有意义，其表现才会如我先前所说。万一两个条件有一个不符合，编译器会拒绝为类产生拷贝赋值操作符函数。 编译器拒绝创建拷贝赋值操作符函数情况： 成员函数为引用类型。 成员函数为常量。","categories":["立志博览群书","《Efficient C++》"]},{"title":"《Efficient C++》 导读","path":"/立志博览群书/《Efficient C++》/Readme/","content":"导读目录 2_const关键字 3_确定对象使用前初始化 4-了解C++默认创建并调用的函数","tags":["C++","《Efficient C++》"],"categories":["立志博览群书","《Efficient C++》"]},{"title":"《Linux命令行与shell脚本编程大全》 导读","path":"/立志博览群书/《Linux命令行与shell脚本编程大全.第3版》/Readme/","content":"导读目录","tags":["linux","《Linux命令行与shell脚本编程大全》"],"categories":["立志博览群书","《Linux命令行与shell脚本编程大全.第3版》"]},{"title":"<2> const 关键字","path":"/立志博览群书/《Efficient C++》/2_const关键字/","content":"[toc] const 修饰指针变量对于指针，你可以指定指针本身是否为常量，也可以指定指针所指向的内容是常量，或两者都是，或两者都不是。 1234567891011121314151617// constPointer.h#ifndef __CONSTPOINTER_H__#define __CONSTPOINTER_H__#include &lt;iostream&gt;char greeting[] = &quot;Hello&quot;;class Widget&#123;&#125;;void f1(const Widget *pw); // f1 获取一个指针指向常量的 Widget 对象void f2(Widget const *pw); // f2 相同#endif // __CONSTPOINTER_H__ 12345678910111213141516171819// constPointer.cpp#include &quot;constPointer.h&quot;int main()&#123; char *p1 = greeting; // 非常量指针, 非常量数据 const char *p2 = greeting; // 非常量指针, 常量数据 char const *p3 = greeting; // 非常量指针, 常量数据 char * const p4 = greeting; // 常量指针, 非常量数据 const char * const p5 = greeting; // 常量指针, 常量数据 std::cout &lt;&lt; &quot;p1 = &quot; &lt;&lt; p1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;p2 = &quot; &lt;&lt; p2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;p3 = &quot; &lt;&lt; p3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;p4 = &quot; &lt;&lt; p4 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;p5 = &quot; &lt;&lt; p5 &lt;&lt; std::endl; return 0;&#125; 总结：如果 const 出现在星号的左边，那么被指针指向的内容就是常量；如果 const 出现在星号的右边，那么指针本身就是常量；如果 const 出现在星号两边，则表示指针和指针指向的内容都是常量。 迭代器中的 constSTL 的迭代器是以指针为模型的，所以一个迭代器的行为很想一个和 T* 指针。声明一个迭代器的常数就像声明一个指针的常量（即声明一个 T* 常量指针）。迭代器不允许指向不同的内容，但它指向的内容可以被修改。如果你想要一个迭代器指向不能被修改的东西（即 STL 类似于一个 const T* 指针），则需要一个 const_itrerator。 12345678910// constIterator.h#ifndef __CONSTITERATOR_H__#define __CONSTITERATOR_H__#include &lt;iostream&gt;#include &lt;vector&gt;std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;#endif // __CONSTITERATOR_H__ 123456789101112131415161718192021222324252627282930// constIterator.cpp#include &quot;constIterator.h&quot;int main()&#123; // 1. 指针为非常量，内容为非常量 std::vector&lt;int&gt;::iterator iter1 = vec.begin(); *iter1 = 10; // 正确 ++iter1; // 正确 // 2. 指针为常量，内容为非常量 const std::vector&lt;int&gt;::iterator iter2 = vec.begin(); *iter2 = 10; // 正确， 修改指针所指内容 ++iter2; // 错误，iter2 为常量指针，不能修改 // 3. 指针为非常量，内容为常量 std::vector&lt;int&gt;::const_iterator iter3 = vec.begin(); *iter3 = 10; // 错误， *iter3 表示指针所指内容为常量，不能修改 ++iter3; // 正确，指针非常量，可以改变 // 4. 指针为常量，内容为常量 const std::vector&lt;int&gt;::const_iterator iter4 = vec.begin(); *iter4 = 10; // 错误， *iter4 表示指针所指内容为常量，不能修改 ++iter4; // 错误，iter4 为常量指针，不能修改 // 5. 等效于 std::vector&lt;int&gt;::const_iterator iter5 = vec.begin(); auto iter5 = vec.cbegin(); return 0;&#125; const 修饰函数返回值在成员函数上使用 const 的目的是为了确定哪些成员函数可以在 const对象上调用。这样的成员函数很重要，原因有二。首先，它们使一个类的接口更容易理解。知道哪些函数可以修改一个对象，哪些不可以，是很重要的。第二，它们使我们有可能与常量对象一起工作。这是编写高效代码的一个关键方面，提高 C++ 程序性能的基本方法之一是通过引用到常量来传递对象。这种技术只有在有常量成员函数的情况下才是可行的，可以用它来处理产生的常量限定的对象。 关于 const 修饰成员函数主要讲以下三个知识点： const 修饰的成员函数可以被重载。 关于 ”二进制位常量性“ 与 ”逻辑常量性“。 避免重载而导致重复代码。 const 修饰成员变量可以被重载12345678910111213141516171819202122232425262728// overloadConst.h#ifndef __OVERLOADCONST_H__#define __OVERLOADCONST_H__#include &lt;iostream&gt;class TextBlock &#123;public: TextBlock(std::string t) : text(t) &#123;&#125; ~TextBlock() &#123;&#125; const char&amp; operator[](std::size_t position) const &#123; std::cout &lt;&lt; &quot;const char&amp; operator[](std::size_t position) const&quot; &lt;&lt; std::endl; return text[position]; &#125; char&amp; operator[](std::size_t position) &#123; std::cout &lt;&lt; &quot;char&amp; operator[](std::size_t position)&quot; &lt;&lt; std::endl; return text[position]; &#125;private: std::string text;&#125;;#endif // __OVERLOADCONST_H__ 123456789101112131415161718192021222324252627// overloadConst.cpp#include &quot;overloadConst.h&quot;// 在函数中, ctb 是常量void print(const TextBlock&amp; ctb)&#123; // 调用 const TextBlock::operator[] std::cout &lt;&lt; ctb[0] &lt;&lt; std::endl; // ctb[0] = &#x27;x&#x27;; // 错误，不能修改一个常量&#125;int main()&#123; // 调用 TextBlock::operator[] TextBlock tb(&quot;Hello&quot;); std::cout &lt;&lt; tb[0] &lt;&lt; std::endl; // 正确，只读一个非常量 tb[0] = &#x27;x&#x27;; // 正确，修改一个非常量 // 调用 const TextBlock::operator[] const TextBlock ctb(&quot;World&quot;); std::cout &lt;&lt; ctb[0] &lt;&lt; std::endl; // 正确，只读一个常量 // ctb[0] = &#x27;x&#x27;; // 错误，不能修改一个常量 print(tb); return 0;&#125; 通过重载 operator[] 并赋予不同版本的返回值类型，你可以对常量和非常量 TextBlocks 进行不同的处理。 常量对象在实际程序中最常出现的是通过指针或引用到常量的结果。例如示例代码中的 void print(const TextBlock&amp; ctb) 函数。 请注意，main() 函数中 ctb[0] = &#39;x&#39;; 的错误只与被调用的 operator[] 的返回类型有关；对 operator[] 本身的调用都是正常的。错误是由于试图对 const char&amp; 进行赋值。 operator[] 的返回数据类型是 char&amp;，不是 char。如果 operator[] 如果只返回一个 char，是不会被编译通过的，因为修改内置数据类型的函数的返回值是不合法的。即使它是合法的，C++ 按值返回对象的事实将意味着一个 tb.text[0] 的副本会被修改，而不是 tb.text[0] 本身。 二进制位常量性与逻辑常量性一个成员函数为常量意味着什么？有两个普遍的概念：“二进制位常量性”（也称为 “物理常量性”）和 “逻辑常量性”。 二进制位常量性”二进制位常量性“ 阵营认为，当且仅当一个成员函数不修改对象的任何数据成员（不包括静态成员）时，它才是常量，也就是说它不修改对象内部的任何比特位。比特恒定性的好处是，它很容易被检测到违规行为，编译器只需查看对数据成员的赋值。事实上，逐位不变性是 C++ 对不变性的定义，而且一个常量成员函数不允许修改其所在对象的任何非静态数据成员。 遗憾的是，许多不怎么规范的成员函数都通过了二进制位常量性测试。特别是，一个修改了 “指针所指向的内容” 的成员函数经常不算是常量成员。但如果对象中只有指针，那么称该函数是 “二进制位常量性”，编译器也不会有异议。例如下面的示例代码所示，假设有一个类似于 TextBlock 的类，它将其数据存储为 char* 类型而不是 string类型，因为它需要通过一个不认识 string 对象的 C API 进行交互。 12345678910111213141516171819202122232425// bitwise.h#ifndef __BITWISE_H__#define __BITWISE_H__#include &lt;iostream&gt;#include &lt;cstring&gt;class CTextBlock&#123;public: CTextBlock(std::string txt); ~CTextBlock(); // 二进制位常量性声明，实际并不合适 char&amp; operator[](std::size_t position) const &#123; return pText[position]; &#125;private: void release();private: char *pText;&#125;;#endif // __BITWISE_H__ 1234567891011121314151617181920212223242526272829303132333435// bitwise.cpp#include &quot;bitwise.h&quot;CTextBlock::CTextBlock(std::string txt) : pText(NULL)&#123; release(); int len = txt.length(); pText = new char[len + 1]; memset(pText, 0, len + 1); memcpy(pText, txt.data(), len);&#125;CTextBlock::~CTextBlock()&#123; release();&#125;void CTextBlock::release()&#123; if(pText != NULL) &#123; delete pText; pText = NULL; &#125;&#125;int main()&#123; const CTextBlock cctb(&quot;Hello&quot;); char *pc = &amp;cctb[0]; std::cout &lt;&lt; &quot;before modified: pc = &quot; &lt;&lt; *pc &lt;&lt; std::endl; *pc = &#x27;J&#x27;; std::cout &lt;&lt; &quot;after modified: pc = &quot; &lt;&lt; *pc &lt;&lt; std::endl; return 0;&#125; CTextBlock 类（不恰当地）将 operator[] 声明为一个常量成员函数，尽管该函数返回的是对对象内部数据的引用。注意到 operator[] 的实现并没有以任何方式修改 pText。因此，编译器会很乐意为 operator[] 生成代码。 但是我们却发现在 main() 函数中 *pc = &#39;J&#39;; 对返回值进行了修改，*pc 可是调用 operator[] 后的返回值。 逻辑常量性出现上面 “二进制位常量性” 示例代码中问题后出现了 “逻辑常量性” 派。 一个常量成员函数可能会修改它所调用的对象中的比特位，但只是以客户端检测不到的方式。例如，当你的 CTextBlock 类被请求后，可能想缓存文本块的长度。 12345678910111213141516171819// logic.h#ifndef __LOGIC_H__#define __LOGIC_H__#include &lt;iostream&gt;#include &lt;cstring&gt;class CTextBlock&#123;public: std::size_t length() const;private: char *pText; std::size_t textLength; // 最近一次计算文本区块长度 bool lengthIsValid; // 目前长度是否有效&#125;;#endif // __LOGIC_H__ 123456789101112// logic.cpp#include &quot;logic.h&quot;std::size_t CTextBlock::length() const&#123; if (!lengthIsValid) &#123; // 错误，const 成员函数内不能给 textLength 和 lengthIsValid 赋值 textLength = std::strlen(pText); lengthIsValid = true; &#125; return textLength;&#125; length() 的实现不是 “二进制位常量性”，因为 textLength 和 lengthIsValid 都可能被修改。这两个数据被修改对 const CTextBlock 对象而言虽然可接受，但编译器不同意。 解决办法也很简单，利用 C++ 的一个与 const 相关的摆动场：mutable（可变的）。mutable 释放掉非静态成员变量的 “二进制位常量性” 约束。 12345678910111213141516171819// logic.h#ifndef __LOGIC_H__#define __LOGIC_H__#include &lt;iostream&gt;#include &lt;cstring&gt;class CTextBlock&#123;public: std::size_t length() const;private: char *pText; mutable std::size_t textLength; // 最近一次计算文本区块长度 mutable bool lengthIsValid; // 目前长度是否有效&#125;;#endif // __LOGIC_H__ 避免常量和非常量成员重复mutable 是一个很好的解决方案，它解决了二进制位常量性非我所欲的问题，但它并没有解决所有与常量相关的困难。例如，假设 TextBlock（和 CTextBlock）中的 operator[] 不仅返回对相应字符的引用，它还执行边界检查，记录访问信息，甚至可能进行数据完整性验证。把所有这些放在常量和非常量的 operator[] 函数中（不要担心，现在有隐式内联长度的函数–见实验《透彻内联》）会产生这种怪异的现象。 12345678910111213141516171819202122232425262728293031// avoidDuplication.h#ifndef __AVOIDDUPLICATION_H__#define __AVOIDDUPLICATION_H__#include &lt;iostream&gt;#include &lt;cstring&gt;class TextBlock&#123;public: const char&amp; operator[](std::size_t position) const &#123; // 边界检查 // 日志数据访问 // 验证数据完整性 return text[position]; &#125; char&amp; operator[](std::size_t position) &#123; // 边界检查 // 日志数据访问 // 验证数据完整性 return text[position]; &#125;private: std::string text;&#125;;#endif // __AVOIDDUPLICATION_H__ 看到上面示例代码，你能说代码重复，以及随之而来的编译时间、维护和代码漏洞等问题吗？当然，我们可以把所有的边界检查等代码移到一个单独的成员函数中（私有的），两个版本的 operator[] 都会调用。但你仍然会重复调用该函数，并且你仍然有重复的返回语句代码。 你真正想做的是实现一次 operator[] 功能并使用它两次。也就是说，你想让一个版本的 operator[] 调用 const operator[]。这就使得我们需要去除常量性。 去重复代码作为一般规则，转型是一个糟糕的想法，在实验《尽量少类型转换》整个实验来讨论这个问题，但代码重复也不是什么好事。在这种情况下，const operator[] 所做的与 operator[] 所做的事情相同，只有常量版本返回值类型受到常量约束。在这种情况下，将返回值中的 const 转型是安全的。因为不论调用 operator[] 还是 const operator[] 都一定首先有个非常量对象，否则就不能够调用非常量函数。所以用 operator[] 调用 const operator[] 是一个避免代码重复的安全做法，即使过程中需要一个转型动作。 12345678910111213141516171819202122232425262728// safeCast.h#ifndef __TEXTBLOCK_H__#define __TEXTBLOCK_H__#include &lt;iostream&gt;#include &lt;cstring&gt;class TextBlock&#123;public: const char&amp; operator[](std::size_t position) const &#123; // 边界检查 // 日志数据访问 // 验证数据完整性 return text[position]; &#125; char&amp; operator[](std::size_t position) &#123; return const_cast&lt;char&amp;&gt;(static_cast&lt;const TextBlock&amp;&gt;(*this)[position]); &#125;private: std::string text;&#125;;#endif // __TEXTBLOCK_H__ 如示例代码所示，代码有两个转型，而不是一个。第一次用来为 *this 添加 const 使得 operator[] 可以调用 const operator[]，第二次则是从 const operator[] 的返回值中去除常量性。 示例代码中使用 operator[] 调用 const operator[]，但如果只是单纯的调用会递归调用自己，那么代码会一直重复调用。为了避免无穷递归，调用时必须明确指出调用的是 const operator[]。 C++ 缺乏直接的语法可以去调用，因此将 *this 从其原始类型 TextBlock&amp; 转型为 const TextBlock&amp;。 使用 static_cast 添加常量性，强制进行了一次安全转型；再使用 const_cast 去除常量性。 const 修饰成员函数","tags":["C++","《Efficient C++》"],"categories":["立志博览群书","《Efficient C++》"]},{"title":"友元","path":"/立志博览群书/《C++ primer plus》/第11章 使用类/友元/","content":"[toc] 友元C++ 提供了另外一种形式的访问权限：友元。友元有3种： 友元函数 友元类 友元成员函数 通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。 为何需要友元 在为类重载二元运算符时（带两个参数的运算符）常常需要友元。将 Time 对象乘以实数就属于这种情况。 下面的语句： 1A = B * 2.75； 将被转换成： 1A = B.operator*(2.75); 但下面的语句又如何呢? 1A = 2.75 * B; 从概念上说，2.75*B 与 B*2.75 相同，但第一个表达式不对应于成员函数，因为2.75不是 Timer 类型的对象。记住，左侧的操作数应是调用对象，但2.75不是对象。因此，编译器不能使用成员函数调用来替换该表达式。 解决这个难题的一种方式是，告知每个人（包括程序员自己），只能按 B*2.75 的格式编写，不能写成2.75*B。这是一种对服务器友好-客户警惕的（server-friendly, client-beware)解决方案，与OOP无关。 当然，上述的问题也有解决方案——非成员函数。非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显式参数。这样，编译器能够将下面的表达式: 1A = 2.75 * B; 与下面的非成员函数调用匹配： 1A = operator*(2.75,B); 该函数的原型如下： 1Time operator*(double m, const Time &amp;t); 对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数。而原来的成员函数可以访问类的私有成员，它们被称为友元函数。 创建友元创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字 friend: 1friend Time operator*(double m, const Time &amp; t); 该原型意味着下面两点： 虽然 operator*() 函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用； 虽然 operator*() 函数不是成员函数，但它与成员函数的访问权限相同。 第二步是编写函数定义。因为它不是成员函数，所以不要使用 Time:: 限定符。另外，不要在定义中使用关键字 friend，定义如下： 12345678Time operator*(double m,const Tlme &amp; t)// frlend not ued in definition&#123; Time result; long totalminutes = t.hours * m * 60 + t.minutes * m; result.hours = totalminutes/60; result.minutes = totalminutes % 60; return result;&#125; 总之，类的友元函数是非成员函数，其访问权限与成员函数相同。","tags":["《C++ primer plus》","友元","friend"],"categories":["立志博览群书","《C++ primer plus》","第11章 使用类"]},{"title":"三黑豆浆","path":"/杂记/食物/三黑豆浆/","content":"配料表 黑豆 25克 黑米 20克 黑芝麻 15克 核桃 25克 冰糖 15克 凉水 800ml","tags":["粥类","熬夜","豆浆"],"categories":["杂记","食物"]},{"title":"C++ 枚举","path":"/立志博览群书/《C++ primer plus》/enum/","content":"[toc] 枚举C++的枚举工具提供了另一种创建符号常量的方式，这种方式可以代替const。还允许定义新类型，但必须按严格的限制执行。使用enum的句法与struct类似。 enum color &#123; red, orange, blue, green, red, black&#125; 这条语句定义了一个名为color的新类型，它的取值范围为red, orange, blue, green, red, black，称为符号常量，同时将0~5分别对应于red~black。在默认情况下，0对应的是red,5对应的是black,其他以此类推。 声明与使用1234color cor1; //定义了一个类型为color的变量cor1//枚举变量的赋值cor1 = red; //正常赋值cor1 = 20; //非法，20不是枚举变量 由此可以看出，枚举变量的赋值受到限制，与程序员的定义有关。 对枚举而言，它的操作符只有赋值运算符=，这就意味着枚举变量不能执行++、--、+、—等等号以外的操作。 枚举量是整形，可被提升为int类型，但int类型不能自动转换为枚举类型 枚举可以进行强制类型转换，但不确定其结果，如cor1 = spectrum(100); 如果只打算使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称 enum &#123;red,orange&#125;； 设置枚举的值可以使用赋值运算符显式地来设置枚举量的值： 1enum bits &#123;one = 1, two = 2, three = 3&#125;; 但是，指定的值必须是整数。也可以只显式的设置其中一部分的值，默认情况下，枚举的 第一个常量始终是从0开始的，这一点需要注意。 1enum digits &#123;zero, one = 0, two, three = 1&#125;; 这里，zero和one的枚举量都为0,two和three都是1。 除了可以将int类型的值赋值给枚举量，还可以使用long和long long类型的值。 枚举的取值范围现在有指定了枚举量的枚举如下所示： 123enum bits(one = 1, two = 2,four = 4,eight = 8&#125;;bits myflag;myflag = bits(6); 问： 上述赋值是否合法 合法，虽然`6`不是枚举量，但它位于枚举定义的取值范围内。 关于取值范围的定义（参考C++ primer 第六版）： 1enum bigstep(firat,second = 100, third&#125;; 首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。例如，定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0∶否则，采用与寻找上限方式相同的方式，但加上负号。 例如，如果最小的枚举量为-6，而比它小的、最大的2的幂是-8（加上负号），因此下限为-7。选择用多少空间来存储枚举由编译器决定。对于取值范围较小的枚举，使用一个字节或更少的空间∶而对于包含 long类型值的枚举，则使用4个字节。 应用实例1234567891011121314151617#include &lt;iostream&gt;#include &quot;main.h&quot;using namespace std;enum myFlag &#123;\tone,\ttwo = 0,\tthree,\tfour = 1&#125;;int main()&#123;\tcout &lt;&lt; three &lt;&lt; endl;\tmyFlag flag = myFlag(0);\tcout &lt;&lt; flag &lt;&lt; endl;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 输出结果： 10 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; enum color &#123; red=1, green, blue &#125;; enum color favorite_color; /* 用户输入数字来选择颜色 */ printf(&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;); scanf(&quot;%u&quot;, &amp;favorite_color); /* 输出结果 */ switch (favorite_color) &#123; case red: printf(&quot;你喜欢的颜色是红色&quot;); break; case green: printf(&quot;你喜欢的颜色是绿色&quot;); break; case blue: printf(&quot;你喜欢的颜色是蓝色&quot;); break; default: printf(&quot;你没有选择你喜欢的颜色&quot;); &#125; return 0;&#125; 请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1 你喜欢的颜色是红色 枚举进阶1. 位运算支持 在使用枚举时结合到 2进制 的强大，对枚举值自由的进行异或运算。 举例一： 1234567enum AttributeTargets&#123; Assembly = 0x0001, Class = 0x0002, Struct = 0x0004 ...&#125;; 举例二： 但是在 123456enum FileAccess&#123; Read = 0x1, Write = 0x2, ReadWrite = Read | Write&#125;; 2. 0值为简单枚举提供一个 0 值枚举量，可以考虑将其命名为 None。如果这个名对于特定的枚举不合适的时候，可以自行找一个准确的。 123456enum Compression&#123; None = 0, GZip, Deflate&#125;; 3. 用枚举代替define 在合适的情况下尽量使用枚举类型，而不是静态常量或 “#define” 值 。枚举 类型是一个具有一个静态常量集合的结构体。如果遵守这些规范，定义枚举类型，而不是带 有静态常量的结构体，您便会得到额外的编译器和反射支持，在调试代码时也能更加直观。 Good: 1234567enum Color&#123; Red, Green, Blue&#125;; bad: 1234567const int RED = 0;const int GREEN = 1;const int BLUE = 2;#define RED 0#define GREEN 1#define BLUE 2","tags":["《C++ primer plus》","enum"],"categories":["立志博览群书","《C++ primer plus》"]},{"title":"声网参赛经历记录——白板插件开发(前端)","path":"/杂记/声网参赛分享/","content":"[toc] # 比赛创意最开始讨论的结果时做一个会议记录相关的插件，结合声望原本提供的白板插件功能，可以实时的进行展示，多人操作、互动，音视频通话。区别于现有会议模式的一点就是，除了音视频通话，还可以在通话的同时，在白板上进行操作，类似于Web上 在线文档、在线会议、在线画板 三者功能集一身的一款白板插件，当然这里在线白板的功能是由声望的 SDK 提供了这个能力，在线文档的这些具体的在线同步的逻辑还是要以声望提供的为基准。 1. 最终结果最终由于我们人力有限，并且都是兼职参加比赛，所以完成上是大打折扣。 调用了讯飞的实时语音识别接口实现了插件的 语音转写 功能，可以进行多人语音识别到插件内部 可以对会议内容和识别记录进行 一键导出 的功能 最后呢，由于实现的功能过于单调，又新增了一个 Markdown 的编辑器，插件启动后可以编辑，但是这个内容是不同步的。 # 技术总结总结一下我个人在比赛中学习和使用到的一些技术，由于我本人是 C++客户端 开发，之前虽然也有学习过VUE和前端知识，但是 VUE3 的改动还是挺大，使用起来颇有些不太习惯的地方。主要的前端框架以及代码功能都是由我比赛的队友去完成的。我负责后台数据相关的一些工作。主要面向于音视频录制、存储、发送等，以及调用语音识别接口。 AgoraRTC(声网的sdk，提供实时音视频服务) IatRecorder(讯飞封装的一个语音识别接口) Vue 前端三剑客（js、h5、CSS）这三个在调试过程中占比很大 # 实现实现部分主要讲关于音频传输、录音、实时语音转写这三点： 音频传输音频传输方面。声网有现成的demo提供学习，使用起来相对比较简单。 API-Examples-Web&#x2F;Demo&#x2F;selfRendering at main · AgoraIO&#x2F;API-Examples-Web","tags":["声网","比赛","RTC","音视频","前端"],"categories":["杂记"]},{"title":"临时文件","path":"/杂记/临时笔记/","content":"[toc] 人文环境的形成是常年累月的积淀，是人的改造与自然的打磨巧妙结合形成的，因此也蕴含了独特的精神力量和难得的物质底色。从物质文化和精神文化两个角度来看，对人文环境中的建筑进行设计所受到的牵制较多。纵向看，有历史文化的影响；横向看，有地域因素的制约；另一个方面，观者的审美角度、使用者的生活习惯，以及人们道德规范的约束都是人文环境中对建筑消隐的重要因素。在这种情况下，做到“消隐”，需要设计师考虑各方面的因素，从而做出更能突出建筑特，又能达到“消隐”目的的设计方案。以下结合三个相对典型的案例进行具体的分析。 建筑设计环节需要考虑的因素除了人文环境、造价、风格之外，也应考虑到建筑技术对建筑设计的提升。不仅如此，建筑技术可以说是建筑创作中重要的一个环节，其最终体现在建筑的空间形态上，建筑形态是否优美、是否达到了效果，又可以直接反馈出建筑技术的使用情况。建筑技术的要素包括材料、结构、施工等不同的类别，从选材到施工，每一个技术环节都有其对应的使用环境，充分利用这一特定环境，从而有效地利用建筑技术对每个环节进行改造和提升。这也能充分体现环境整体观的理念。 社会访谈： 一名工程师眼中的新时代及启示深入访谈一个自己的长辈，请其介绍职业经历和人生阅历，并通过这个切入点，以小见大介绍其对国家发展的看法感受，记述其访谈内容及对自己未来的启示。 访谈对象：访谈对象：同学的舅舅 性别：男 年龄：48 职业：结构工程师 单位：中建一局某分公司 职务：工程师 从业年数：22 访谈时间：2022.11.26 访谈形式：电话 访谈内容： 您是如何找到这份工作的？ 当时工作还是包分配的，毕业后我选择了去中建。 就您的工作而言，您最喜欢什么？最不喜欢什么？ 喜欢的是自己和大家一起努力工作之后，出现的问题被解决，工程一日日逐渐被完成，最终被交付的那种喜悦。 不喜欢工作中的与人打交道，在工作中会产生内耗，需要处理好复杂的人际关系。还有就是工作常年在外，全国各地地跑，和家人是聚少离多。不过工作这么些年，也习惯了，有空间就会回家看看家人，这两年因为疫情的原因，回去的更少了。在单位，就是想着怎么把工作干好。保质保量完成建设任务。 您的职位是什么？你的主要职责是什么？ 目前是项目部的工程师，主要职责就是负责工程上的项目进行监工以及项目部规划等内容。 大学期间可以做的准备有什么？ 学好自己的专业知识，尽量拓展知识面。这个岗位对专业的对口性一般要求不高，但是不论是经济类、管理类还是工程类的专业，还是需要认真学习的，它虽然要求的面广，但你总得有一方面是要有核心竞争力的。尽量多学习其他知识，做到“见多识广”，因为这个岗位会遇到很多人，很多不同种类的项目，这样工作起来思维会比较快，沟通也会变得容易些。 有侧重的锻炼自己的沟通、写作、表达能力。多参加社团活动，和一些有意义的比赛，历练自己。 在行业内，先从什么样的工作岗位做起，能学到最多的知识，最有益于发展？ 先应聘资料员或质检员、施工员,能利用在校学到的知识,工作起来顺手,工作后通过自学尽快掌握各种工程软件的应用,掌握后根据自己的爱好,可转行预算员、技术员、测量员等. 工作地点在哪里？主要工作场所是什么？有哪些特征？ 工作地点有工地，项目部。主要场所是项目部。忙的时候来回奔波，也会加班赶工期。 您在做这份工作时，日常面临的问题是什么，什么最有挑战性？ 这个很多，比如刚开始工作的时候，要慢慢适应工厂的环境;还要和同事打好关系等等。特别是厂里的一些老师傅在我们正式上岗前经行培训的时候，老师傅传授了一些我们在学校里没见过的加工方法，我们只能从头学起。我想说的是学校里的教材之类的不能太过相信，有些老旧的教材的内容已经逐渐被淘汰，因此要不断地学习，要关注行业发展动态。 在您的工作领域里初级职位和略高级别职位的薪水一般是什么水平？ 收入还可以，包括基本工资+年底奖金。主要还是根据工程难度，工期长短，以及工作地点等因素影响。初级平均可以拿到8000左右，年底5~20万不等。 在这个职位上，如果想获得成功必须拥有并保持什么样的能力？ 需要有坚实的基础学科知识，更需要有不断学习的能力，去挑战的新的建设需求。其次的话就是有一定的与人交往的能力。 目前还缺乏的必须改进的能力有哪些？ 需要的技能：CAD及各种计算软件，比如PKPM、YJK、3D3S、MIDAS等（至少学会一到两种，各软件有相通之处）。 您认为什么样的个人品质、性格和能力对做好这份工作来讲是重要的？ 能坚持下去，有创新思想，常与人沟通交流，通过工作不断积累自己的经验。 您认为做好这份工作应该具备哪些知识、技能和经验？ 要掌握一些基本的专业知识，比如制图（包括CAD)，金属加工的技艺，还有就是一些行业规定，行业语言等，之后当然要考取这种证书来表明已经掌握了这些内容。当然，经验也是很重要的，特别是出现一些课本上或平时没出现过的情况时，经验显得尤为重要。 目前，行业内要求从事这份工作的人应该有什么准备？ 首先梳理自己已有的专业知识能力，客观地评价自己的优势和劣势，尽可能做到扬长补短。其次有目的地提前锁定一些目标实习单位，有针对性地进行一些关注和调研，做到有的放矢。最后可以阅读一些人际交往或社交礼仪的知识，力求在细节方面也做到位，也可以向往届师兄师姐讨教实习的一些鲜活的经验，以利于较快地适应角色和心态的转变。 学校中的哪些课程对这个行业比较有帮助？ 总的来说是有帮助的，但是大家都知道，书上的知识永远赶不上技术的发展，所有如果你向在这个行业有好的发展的话，就不能局限于书本上的东西，要多动手，这样能学到的东西比你课程上所能学到的多很多。 行业内，单位对刚进入该领域工作的员工一般会提供哪些培训？ 每一个新进入的员工都会进行一系列相关的培训，内容主要是对新来员工培训相关技能，让员工能够更好的将学校中所学到的知识更好的转化为想用的技能。除了部门自己组织的学习以外，公司每年都会组织一些培训，让大家更好的了解当前行业的新技术，新动态。正式进入工作岗位后，要求每个人都有一定的技能，能够独立面对一些问题，在技术方面要求会比较多。在深造方面，公司是比较支持大家进行更加高层的学习。 这个行业存在的困难及前景如何？ 目前这一行业工作较为辛苦，有很多人难以坚持下来，现有的人员构成并不是非常合理，尽管做这个方面的人相当多，但是很缺少能够独当一面的优秀人才，总的来说就是，高层然才比较欠缺，低层人员泛滥。所以，对于每一个想要在此行业有所发展的人来说，机遇和挑战是同时并存的。","categories":["杂记"]},{"title":"安装PEM文件","path":"/杂记/安装PEM文件/","content":"概述： windows和Linux安装PEM文件步骤 [toc] 如何安装PEM证书更新：2023-05-29 21:11 PEM证书是一种常见的证书文件格式，通常用于加密、验证和身份认证等。在运行应用程序或服务时，有时需要将PEM证书安装到系统或设备中，并确保其正确配置。本文将介绍如何安装PEM证书。 1. 下载PEM证书文件首先，您需要有PEM证书文件。它可以是自签名证书、客户端或服务器证书、根证书或中间证书。您可以从许多来源获取PEM证书文件，例如： 证书颁发机构 (CA) 厂商提供的PEM证书 自己创建的PEM证书文件 确保您已经获得PEM证书文件并将其下载到计算机的本地文件夹中。 2. 安装PEM证书文件2.1 在Linux系统上安装PEM证书如果您想在Linux系统上安装PEM证书，可以使用以下步骤： 12sudo cp server.crt /usr/local/share/ca-certificates/sudo update-ca-certificates 在上述命令中，“server.crt”是您的PEM证书文件名。通过将PEM证书文件复制到“&#x2F;usr&#x2F;local&#x2F;share&#x2F;ca-certificates&#x2F;”目录，您可以将PEM证书添加到系统的可信证书列表中。接下来，运行“sudo update-ca-certificates”命令以更新证书列表并使其生效。 2.2 在Windows系统上安装PEM证书 方式一 如果您想在Windows系统上安装PEM证书，可以使用以下步骤： 双击PEM证书文件，打开证书向导。 在弹出窗口中，选择“安装证书”选项，并单击“下一步”。 选择“计算机帐户”选项，并单击“下一步”。 在“选择存储位置”窗口中，选择“受信任的根证书颁发机构”选项，并单击“下一步”。 单击“下一步”以确认选项，并单击“完成”以完成证书安装。 现在，您的PEM证书已经安装在您的Windows系统中。 方式二 1打开控制面板 -&gt; 网络设置 -&gt; Internet选项 -&gt; 内容 -&gt; 证书 -&gt; 导入 然后选择你需要安装的证书导入即可。 方式三 打开“开始”菜单，搜索“mmc”并打开“Microsoft Management Console”。 点击“文件”菜单，选择“添加&#x2F;删除管理单元”。 在“可用的管理单元”列表中，选择“证书”并点击“添加”。 选择“计算机帐户”并点击“下一步”。 选择“本地计算机”并点击“完成”。 在“控制台根证书存储”下，右键点击“受信任的根证书颁发机构”并选择“所有任务” &gt; “导入”。 点击“下一步”，浏览到您的Pem证书文件并选择它。 点击“下一步”，选择“将所有证书都放置在下列存储中”并点击“浏览”。 选择“受信任的根证书颁发机构”并点击“确定”。 点击“下一步”并完成证书安装。 3. 使用PEM证书文件一旦您已经安装了PEM证书，您可以开始使用它。通常，您需要在应用程序或服务的配置文件中指定PEM证书的路径或名称。以下是一些示例： 1234567ssl_certificate /path/to/your/cert.pem;// For Node.js serverconst server = https.createServer(&#123; key: fs.readFileSync(&#x27;server.key&#x27;), cert: fs.readFileSync(&#x27;server.cert&#x27;)&#125;); 以Nginx Web服务器和Node.js服务器为例，您可以将PEM证书文件路径或名称指定为“ssl_certificate”或“cert”选项的值。 结论在本文中，您已了解如何安装PEM证书文件并在应用程序或服务中使用它们。无论您要在哪个平台上安装PEM证书，都需要按照相应的步骤来执行。","tags":["证书","PEM"],"categories":["杂记"]},{"title":"自然辩证法","path":"/杂记/自然辩证法/","content":"参考链接：2019自然辩证法课后思考题及答案_文档之家 [toc] 第一章 自然辩证法（byself）1.如何理解朴素唯物主义自然观、机械唯物主义自然观和辩证唯物主义自然观的辩证关系？（1）古代朴素自然观以直观性、思辨性和猜测性的方式从整体把握认识自然界的本源和发展，但缺乏系统的、以实验为基础的科学依据，尤其是将非物质性的东西当做限于物质世界的独立存在，并认为物质世界是它的派生物，为唯心主义的产生提供了借口，最终导致人类认识的分化。 （2）机械唯物主义自然观的核心是自然界绝对不变，虽然在实证科学的基础上继承和坚持了古代朴素唯物主义的思想，但是不懂得一般与个别、运动和静止等的辩证关系，以一种片面的、孤立的和静止的方法观察自然界，挤不动的自然界的辩证法，自然不能吧唯物主义坚持到底。 （3）辩证唯物主义自然克服了以往哲学自然观的缺陷，坚持了物质世界的客观实在性的唯物主义一元论原则，突出了物质世界的整体性和矛盾性，提示了物质世界的普遍联系，强调了人类起源于自然界、依赖于自然并在把握自然界发展规律的基础上能移动地和改造自然，强调了人与自然界的和谐统一。 2.如何理解系统自然观、人工自然观和生态自然观的辩证关系？第一，它们都围绕人与自然界关系的主题，丰富和发展了马克思注意自然观的本体论、认识论和方法论；它们都坚持人类与自然界、人工自然界和天然自然界、人与生态系统的辩证统一，都为实现可持续发展和生态文明建设奠定了理论基础。 第二，它们在研究人与自然界关系的各方面各有其侧重点；系统自然观为正确认识和处理人与自然地关系提供了新的思维方式，人工自然观突出并反思了人的主体性和创造性；自然生态馆站在人类文明的立场，强调了人与自然界的协调与发展。 第三，它们在研究人与自然界的关系方面相互关联；系统自然观通过系统思维方式，为人工自然观和生态自然观提供了方法论基础；人工自然观通过突出人的主体性和实践性，为系统自然观和生态自然观提供了认识论前提；生态自然观通过强调人与自然界的统一性、协调性关系为系统自然观和人工自然观指明了发展方向和目标。 3.如何认识生态自然观和生态文明建设之间的辩证关系？生态文明是人类文明的一种形式。它以尊重和维护生态环境为主旨，以可持续发展为根据，以未来人类的继续发展为着眼点。人类对生态文明的探索，是对人与自然和谐关系的表现。生态文明与生态自然观有着紧密的联系，生态文明是生态自然观的应有之义，生态自然观对现今世界生态文明发展及实践有着广泛的指导意义。生态文明的提出，是人们对可持续发展问题认识深化的必然结果。人类通过遵守可持续性、共同性和公平性等原则，通过实施节能减排和发展低碳经济，构建和谐社会和建设生态文明，实现人类社会与生态系统的协调发展；人与生态系统的协调发展仍应以人类为主体，仍应包括改造自然的内容，注重保护生态环境和防灾减灾；生态自然界是天然自然界和人工自然界的统一，是人类文明发展的目标，生态文明的提出，是人们对可持续发展问题认识深化的必然结果。生态自然观指出，人与自然都是生态系统中不可或缺的重要组成部分，人与自然是相互依存、和谐共处、共同促进的关系。人类的发展应该是人与社会、人与环境、当代人与后代人的协调发展。人类的发展不仅要讲究代内公平，而且要讲究代际之间的公平，不能以当代人的利益为中心，甚至为了当代人的利益而不惜牺牲后代人的利益。而必须讲究生态文明，牢固树立起可持续发展的生态文明观。 4.如何理解“绿水青山就是金山银山”？简单的来说，”绿水青山就是金山银山”就是指生态可持续发展。蓝天白云、青山绿水是人类赖以生存的环境，是社会长远发展的最大本钱，生态优势可以变成经济优势、发展优势，形成了一种浑然一体、和谐统一的关系。因此保护绿水青山，才能保住人们赖以生存的生态环境，从而赢得长远的经济可持续发展。 习近平总书记关于绿水青山就是金山银山的辩证论是生态环境生产力理论生动、朴实和富含哲理的印证：“绿水青山可以源源不断地带来金山银山，绿水青山本身就是金山银山，我们种的常青树就是摇钱树，生态优势变成经济优势。” “如果能够把这些生态环境优势转化为生态农业、生态工业、生态旅游等生态经济的优势，那么绿水青山也就变成了金山银山。”当然，绿水青山和金山银 山之间也有矛盾，绿水青山是真正的金不换，“绿水青山可带来金山银山，但金山银山却买不到绿水青山”。 因此，当绿水青山和金山银山之间有不可调和的矛盾时，我们宁要绿水青山，不要金山银山。要像对待生命一样对待生态环境，统筹山水林田湖草系统治理，实行最严格的生态环境保护制度，形成绿色发展方式和生活方式，坚定走生产发展、生活富裕、生态良好的文明发展道路，建设美丽中国。 绿水青山就是金山银山的理念，一头是人类赖以生存的自然环境，另一头牵着财富生产；一头连着生态环境，另一头是人类活动的产物。从人与自然是生命共同体出发，将生态环境内化为生产力的内生变量与价值目标，蕴含着尊重自然、顺应自然、保护自然，谋求人与自然和谐发展的生态理念和价值诉求。 揭示了生态环境与生产力之间的辩证统一关系，突破了把保护生态与发展生产力对立起来的僵化思维，内含了保护、改善与建设生态环境和保护与发展生产力的有机统一，鲜活地概括了有中国气派、中国风格和中国话语特色的绿色发展内涵，是中国化马克思主义理论的光辉典范。 第一章 自然辩证法1.如何理解朴素唯物主义自然观、机械唯物主义自然观和辩证唯物主义自然观的辩证关系？朴素唯物主义自然观是古代自然哲学家们以科学技术为基础，概括和总结自然界及其与人类的关系形成的总的观点。它是马克思主义自然观形成的最初思想渊源。它具有①整体性和直观性，②思辨性和臆测性，③自发性和不彻底性。朴素唯物主义自然观的思想渊源是原始宗教神话自然观，其理论基础是自然哲学。朴素唯物主义自然观具有一定的缺陷：①不能彻底地坚持唯物主义，具有唯心主义因素，如泰勒斯的”水本原说”②不能满足民众的需要，掺杂着宿命和迷信等因素。③不能科学地说明自然界。 机械唯物主义自然观是近代自然科学家们以近代科学技术为基础，概括和总结自然界及其与人类的关系形成的总的观点。它是马克思主义自然观形成的重要思想渊源。它具有①机械性②不彻底性③形而上学性。机械唯物主义自然观①为辩证唯物主义自然观的形成创造了条件。他以近代自然科学为基础，强调自然界存在的客观性，物质性和发展的规律性，传承了朴素唯物主义自然观的思想传统。③为辩证唯物主义自然观的形成提供了前提。它所培植的崇尚理性的科学精神促进了辩证唯物主义自然观的形成。 辩证唯物主义自然观是马克思恩格斯以近代科学技术为基础，概括和总结自然界及其与人类关系形成的总的观点。它是马克思主义自然观形成的重要标志。辩证唯物主义自然观具有①实践性②历史性③辩证性④批判性。辩证唯物主义自然观“扬弃”了机械唯物主义自然观，在更高层次上实现了向古希腊朴素唯物主义自然观的回归。 三种自然观的发展本质是人类认识的发展，辩证唯物主义自然观是对朴素唯物主义自然观的否定之否定，是对机械唯物主义自然观的否定。任何一种自然观的产生都脱离不了当时科学的发展水平，也离不开人们的认识水平。而更先进的自然观对科学的发展又具有指导性意义。这个发展是螺旋上升的，在我们的认识中还会进行补充和丰富，在运动中发展自己。 2.如何理解系统自然观、人工自然观和生态自然观的辩证关系？P42 3.如何认识生态自然观和生态文明建设之间的辩证关系？生态文明是人类文明的一种形式。它以尊重和维护生态环境为主旨，以可持续发展为根据，以未来人类的继续发展为着眼点。人类对生态文明的探索，是对人与自然和谐关系的表现。生态文明与生态自然观有着紧密的联系，生态文明是生态自然观的应有之义，生态自然观对现今世界生态文明发展及实践有着广泛的指导意义。生态文明的提出，是人们对可持续发展问题认识深化的必然结果。人类通过遵守可持续性、共同性和公平性等原则，通过实施节能减排和发展低碳经济，构建和谐社会和建设生态文明，实现人类社会与生态系统的协调发展；人与生态系统的协调发展仍应以人类为主体，仍应包括改造自然的内容，注重保护生态环境和防灾减灾；生态自然界是天然自然界和人工自然界的统一，是人类文明发展的目标，生态文明的提出，是人们对可持续发展问题认识深化的必然结果。生态自然观指出，人与自然都是生态系统中不可或缺的重要组成部分，人与自然是相互依存、和谐共处、共同促进的关系。人类的发展应该是人与社会、人与环境、当代人与后代人的协调发展。人类的发展不仅要讲究代内公平，而且要讲究代际之间的公平，不能以当代人的利益为中心，甚至为了当代人的利益而不惜牺牲后代人的利益。而必须讲究生态文明，牢固树立起可持续发展的生态文明观。 4.如何理解“绿水青山就是金山银山”？“绿水青山就是金山银山”的重要思想，触及到了一个人类社会发展的大难题，即：金山银山是人的物质追求，绿水青山是人赖以生存的自然条件，这两者都是人生存和发展所需要的，而这两者对于人来说又很难兼得。自工业革命以来，人类以牺牲绿水青山来实现自己的物质追求，曾经创造了前所未有的文明奇迹。但是，这种不可持续的经济增长方式造成了许多灾难性的后果，促使人们在对传统的增长方式和发展理论进行反思的同时，开始重新研究发展理论，重新研究发展中人与自然的关系。 以我国为例，我们在过去实行的是“先增长后治污”模式，在“两座山”问题上实际上是采取了“为了金山银山可以暂时牺牲绿水青山”的做法;后来认识到这样做不仅不可持续，而且治污的代价要大于增长获得的收益，于是许多地方提出了“宁要绿水青山，不要金山银山”的口号，即下决心改变“先增长后治污”的模式，优化环境，保护生态。这样的口号，这样的做法，虽然也讲“可持续发展”，但实际上是把“可持续”与“发展”割裂开来，这不利于生产力的发展。 “绿水青山就是金山银山”，则以“就是”一词把“绿水青山”和“金山银山”辩证地连接起来，以积极的而不是悲观的态度阐明了这两者之间的关系，讲清楚了发展中人与自然的辩证统一关系绿水青山就是金山银山”这一重要思想，所表达的则是环境、生态应该是社会生产力内部的一个有机组成部分。也就是说，习近平把环境、生态纳入了社会生产力的范畴。这种态度就是马克思主义的态度，这种认识就是马克思主义的认识。。 因此，我们说习近平关于“绿水青山就是金山银山”的重要思想，以一种新颖的发展理念，坚持和发展了马克思主义创始人以积极乐观的态度认识和处理发展中人与自然关系问题的科学思想。 5.简述辩证唯物主义自然观战胜机械论自然观的历史必然性。机械论自然观的产生有其历史的必然性和合理性，但它用孤立的，静止的，片面的观点去看待世界，否认事物的联系和发展变化，否认事物的内部矛盾。实践是检验真理的唯一标准，机械论自然观的这些特点与近代自然科学已经相悖，应当摒弃。人类社会的大趋势是发展，在目前的历史环境下，机械论自然观的存在只会阻碍这种发展，所以必将被适应当前自然科学的辩证唯物主义自然观所取代，这是历史必然性。 P28 第二章 科学技术观（byself）6.如何理解18.19世纪科学技术发展与马克思恩格斯科学技术思想产生的关系？p45 从18世纪60年代起始于英国的第一头次技术革命和继之而来的产业革命，既向科学提出了新的要求，也为科学提供了新的事实，更为科学提供了新的交流方法，从而使科学在19世纪获得了长足的进步，取得了影响深远的一些重要发现，为辩证唯物主义自然观的产生提供了丰富的物质基础 19世纪的自然科学成就为辩证唯物主义自然观产生提供了科学前提。如在天文学上，1755年康德和拉普拉斯（1796年）分别提出的关于太阳系起源的星去假设。在地质学上，英国科学家莱伊尔1830年发表“地球演化学说”，在物理学上焦耳发现能量转化和守恒定律，从而动摇了形而上学的基础，在化学上1824年由维等人合成尿素，在生物上，1838年施旺提出细胞是生命 的基本结构单位，1958年达尔文创立特种起源论，对于这些重要的发现，恩格斯经过反复研究，从自然观的高度提出了运动形式及其相互转化的学说。恩格斯关于运动形式的学说把蕴含在当时诸多科学发现中的思想精华作了概念性升华，从而提供了一种观察研究自然的哲学方式 综上所述，辩证唯物主义自然观的产生反映了科学技术发展的历史必然性。 7.怎样认识马克思恩格斯的科学技术思想在马克思主义理论体系中的重要地位？马克思主义理论体系，是关于全世界无产阶级和全人类彻底解放的学说。它由马克思主义哲学、马克思主义政治经济学和科学社会主义三大部分组成，是马克思、恩格斯在批判地继承和吸收人类关于自然科学、思维科学、社会科学优秀成果的基础上于19世纪40年代创立的，并在实践中不断地丰富、发展和完善的无产阶级思想的科学体系。 马克思恩格斯科学技术思想表明了科学技术是推动社会发展的革命力量，通过对科学技术的理解、科学的分类、科学技术与哲学的关系、科学技术是生产力、科学技术的生产动因、科学技术的社会功能、科学技术与社会制度、科学与技术的相互关系、科学技术异化等方面观点的阐述，极大的丰富和发展了马克思主义理论，有助于指导我们正确分析科学技术及其发展的理论和现实问题。 8.马恩与国外学者关于科技的本质区别p51-559.如何理解科学技术一体化的特征？在人类历史上，科学与技术经历了几次分合。科学与技术源起于人类的社会生产实践，本来是内在统一的，但随着生产力的发展，出现了脑力劳动与体力劳动的分工，一部分人从单纯的体力劳动中分化出来，专门从事政治、宗教、艺术、哲学等活动，科学与技术从此分道扬镳，科学活动由学者们承担，技术研究则由工匠们掌握。在古代，科学对技术的影响甚微，无论是自然经济条件下的农业技术，还是工匠的手工业技术，都是凭经验掌握和积累的，那时几乎没有以科学的应用为特征的技术，而只有手艺、技能——尽管这些经验可能发展到惊人的水平。 从15世纪下半叶近代自然科学产生以后，直到19世纪的上半叶，科学的实际应用才逐步显现效能。正如马克思所说：只有在资本主义条件下，才第一次产生了只有用科学方法才能解决的实际问题，才第一次达到使科学的应用成为可能和必要的那样一种规模，科学获得了成为致富手段的使用，发明成为一种特殊的职业，科学成为生产过程的因素，生产过程成为科学的应用。15世纪以后，科学实验活动融入科学研究20科学成就是在技术基础上的“技术科学化”的结果，技术可以产生科学，“技术科学化”表明:技术是科学发展的动力 ，科学需要推动技术前进；技术为科学的发展提供研究手段，特别是科学实 10.为什么说科学发展表现为继承与创新的统一？（p62）11.怎样认识技术发展的动力？对技术具有双刃剑作用的看法？技术发展史不断证明,技术像一把双刃剑,既有有益于人类发展的一面,也有危害人类利益的一面。一方面，技术的进步推动了生产力内部各要素的变革，促进了产业结构的调整、经济形式的变化和经济增长方式的变化，实现了经济转型；变革了生产关系，增进了人类自由而全面的发展，推动人类社会进入发展的新阶段；将人类从繁重的劳动中解放出来，对人类的生活方式产生了深刻的影响。另一方面，技术的进步也产生了一些道德和伦理问题，如克隆人的伦理问题、基因治疗和基因增强的伦理问题、网络伦理问题、核伦理问题等。 因此，必须以人民为中心，大力发展事关国计民生的科学技术；必须以先进的文化来引导，协调科学文化与人文文化的冲突；必须改变单纯有利于经济增长的倾向，走经济增长与环境保护双赢之路；必须客观全面评价科学技术的风险和收益，指定恰当的科学技术公共政策。 第二章 科学技术观1.如何理解18、19世纪科学技术发展与马克思、恩格斯科学技术思想产生的关系？18、19世纪，天文学、地理学、物理学、化学、解剖学、生物学等都有了长足的发展，特别是能量守恒与转化定律、细胞学说和生物进化论三大发现，使自然科学的发展进入了一个新时期，两次科技革命使人类进入了工业文明时代。马克思、恩格斯在总结和概括19世纪科学技术成果的基础上，形成了以辩证唯物主义为理论基础的科学技术思想。 2.怎样认识马克思、恩格斯的科学技术思想在马克思主义理论体系中的地位？马克思主义科学技术观是基于马克思、恩格斯的科学技术思想，对科学基础机器发展规律的概括和总结，是马克思主义关于科学技术的本体论和认识论。 从辩证唯物主义和历史唯物主义的基本立场出发，在总体上把握马克思、恩格斯的科学技术思想；马克思主义认为科学是一般生产力，技术是现实生产力；科学是认识世界，技术是改造世界。现代科学和技术形成既有区别又有联系的体系结构。 3.马克思、恩格斯和国外学者关于科学技术本质的分析有何主要差异？（1）马克思、恩格斯关于技术本质特征的分析 马克思、恩格斯认为技术在本质上体现了“人类对自然的实践关系”，技术是人的本质力量的对象化。 第一，劳动资料延长了人的自然的肢体。 第二，工艺学在本质上揭示出人对自然的能动关系。 第三，技术的发展引起生产关系的变革。 （2）国外学者对技术本质特征的研究 欧美技术哲学存在工程学的和人文主义的两种技术研究路线；日本的技术论在技术的本质问题上形成了“方法技能说”、“劳动手段说”、“知识应用说”等观点。这些观点各有特色，但大都表现出对技术理解的单一性。 我们需要用马克思主义科学技术观进行分析评价。马克思主义认为，技术是人类为满足自身的需要，在实践活动中根据实践经验或科学原理所创造发明的各种手段和方式方法的总和。主要体现在两个方面：一是技术活动，狭义的技术是指人类在利用自然、改造自然的劳动过程中所掌握的方法和手段；广义的技术是指人类改造自然、改造社会和改造人类自身的方法和手段。二是技术成果，包括技术理论、技能技巧、技术工艺与技术产品（物质设备）。 技术在本质上体现了人对自然的实践关系，是人的本质力量的展现，属于直接生产力，是自然性和社会性、物质性和精神性、中立性与价值性、主体性和客体性、跃迁性和积累性的统一。 4.如何理解科学技术一体化的特征？（1）现代科学的体系结构由学科结构和知识结构组成 学科结构由基础科学、技术科学、工程科学构成。知识结构由科学事实、科学概念、科学定律、科学假说、科学理论构成。现代科学的体系结构表现出现代科学的发展过程，其中学科结构形成立体的架构，知识结构各要素渗透在学科结构相对应的要素之中。基础科学、技术科学、工程科学都是系统化的知识，都会经过一个由科学事实到科学理论的形成过程。 （2）现代技术的体系结构由门类结构和形态结构组成 门类结构由实验技术、基本技术和产业技术构成。 形态结构由经验形态的技术、实体形态的技术和知识形态的技术构成。 现代技术的体系结构表现出现代技术的发展过程，其中门类结构是立体的架构，形态结构的各要素同样渗透咋门类结构相对应的要素当中。实验技术、基本技术和产业技术都包含经验技能，都使用工具机器，都蕴含了知识。 现代科学技术体系结构的研究表明，科学技术在各自的发展中，不但日益多样化和系统化，而且越来越呈现出科学技术一体化的特征。 5.为什么说科学发展表现为继承与创新的统一？继承：市科学技术发展中的量变，它可使科学知识延续、扩大和加深。科学是个开放系统，它在时间上有继承性，在空间上有积累性。只有继承已发现的科学事实、已有理论中的正确东西，科学才能发展、不断完善。 创新：是人类对自然的认识出现新的飞跃，引起科学发展中的质变。创新是继承的必然趋势和目的。 在科学技术的发展模式及动力问题上，马克思主义认为科学发展在纵向上表现为渐进与飞跃的统一，在横向上表现为分化与综合的统一，在总体趋势上表现为继承与创新的统一。 技术的发展由社会需要、技术目的及科学进步等多种因素共同推动。其中社会需求与技术发展水平之间的矛盾是技术发展的基本动力，技术目的和技术手段之间的矛盾是技术发展的直接动力，科学进步是技术发展的重要推动力。 6.怎样认识技术发展的动力？马克思主义认为，技术的发展由社会需要、技术目的以及科学进步等多种因素共同推动。 （1）社会需求与技术发展水平之间的矛盾是技术发展的基本动力 任何技术，最早都源于人类的需要。正是为了生存发展的需要，人类起初模仿自然，进而进行创造，发明了各种技术。同时，文化对技术发展具有明显的张力作用。先进的思想文化会推动技术的发展，而落后的思想文化则会制约和阻碍技术的发展，包括影像技术决策、技术研发以及技术成果的产业化各方面。 （2）技术目的和技术手段之间的矛盾是技术发展的直接动力 技术目的就是在技术实践过程中在观念上预先建立的技术结果的主观形象，是技术实践的内在要求，影响并贯穿技术实践的全过程。技术手段即实现技术目的中介因素，包括实现技术目的的工具和实用工具的形式。技术目的的提出和实现，必须依赖于与之相匹配的技术手段。技术手段是实现技术目的的中介和保证，它包括达到技术功能要求所使用的工具以及应用工具的方式。 （3）科学进步是技术发展的重要推动力 19世纪中期以后，科学走到了技术前面，成为技术发展的理论向导。科学革命导致技术革命，技术发展对科学进步的依赖程度越来越高，技术已成为科学的应用。尤其是当今社会的发展，已形成了科学技术一体化的双向互动过程。 第三章 科学技术方法论1.如何理解马克思主义科学技术方法论与科学研究中的具体方法的关系？马克思主义的科学技术方法论是以辩证唯物主义立场、观点为基础，吸取具体科学技术研究中的基本方法，并对其进行概括和升华的方法论。 科学技术研究，离不开辩证思维。分析与综合、归纳与演绎、从抽象到具体、历史与逻辑的统一，这些辩证思维的形式体现和贯彻在科学家、工程师的具体科学技术研究中。自觉的认识和提升这些辩证思维的形式，对于树立，马克思主义科学技术观，深入研究科学技术，建设创新型国家具有重要意义。 2.如何理解辩证思维渗透在科学研究的全部过程中？马克思主义科学技术方法论的核心就是辩证思维。马克思主义科学技术方法论的基本原则就是把辩证法贯彻到科学技术研究中，以对立统一、质量互变和否定之否定的辩证思想渗透到具体的科学技术研究中，把握具体科学技术的研究过程。 3.如何把握创造性思维特性？创造是科学研究和技术发明最重要特性之一。创造性思维不是在所有辩证思维和科学研究方法之外独立的一种思维方式或方法，是能够提出创见的思维，与一般性思维相比，是在思维特征方面不刻板，组合各种思维、灵活调用思维的特性。 创造性思维的特点是思维方向的求异性，思维结构的灵活性、思维进程的飞跃性、思维效果的整体性、思维表达的新颖性等。 创造性思维特别注重逻辑思维与非逻辑思维的统一、抽象思维与形象思维的辩证统一。 4.注意多学科的交叉与融贯有何方法论意义？移植和学科交叉或跨学科的研究方法，是创造性思维的两种非常有效的研究方法。当代科学研究和技术发明变得越来越复杂，进行移植与交叉，通过多学科或跨学科的研究，常常能够获得单一学科研究无法获得的创新成果。多学科融合或通过跨学科研究问题也是当代科学和技术解决问题的创造性方法，体现了广泛联系和发展的辩证法。 当代各门科学之间的交叉型越来越大，通过学科之间的交叉往往可以获得新的认识，带来创新。学科交叉成为一种新的思考方式和研究方法。 所谓学科交叉方法，就是两门以上的学科之间在面对同一研究对象时，从不同学科的角度进行比对研究的方法。借鉴其他学科的研究，思考本学科的问题和对象，融合其他学科的研究方法，以达到对研究对象的新认识。 所谓跨学科方法就是通过多学科的协作共同解决同一问题的方法，跨学科也是一种学科融合的方法，也可以称为多维融贯的方法。 5.战略性思维对于科学研究有何意义？战略性思维是对战略科学家的思维要求。同时对于一个从事一般科学研究、技术发明和工程建设的科学家也有重要意义。习近平非常重视战略性思维的重要作用与深刻意义，是其提出的“六大思维”之一，战略性思维对于科学研究而言，非常重要。 战略性思维是高瞻远瞩、统揽全局、善于把握事物发展总体趋势和方向的思维方法，展示的是看问题的高度和深度。古人讲：“不谋万世者，不足谋一时；不谋全局者，不足谋一域。”科学家与工程师没有战略性思维、具有什么样的战略性思维，一定程度上决定着在中国特色社会主义伟大事业中的科学技术研究能登多高、能走多远、将抵达何处。战略性思维能力的强弱，取决于思考问题的高度、理论研究的深度、知识视野的广度，以及对于科学技术发展全局的时间跨度的认识与把握。 对于国家而言，科学技术的总体规划是一种科学技术研究的战略，战略科学家需要掌握国家科学技术的基本战略，按照国家需要，结合自己及其研究团队的研究确定科学研究方向。 第四章 科学技术社会论1.为什么说“科学是一种在历史上起推动作用的、革命的力量”？ 科学技术是历史发展的火车头，改变了社会历史进程，造就了新的社会形态;推动了生产力内部各要素的变革，引发了产业结构的调整、经济形式的变化和经济增长方式的转变，造就了经济转型;产生了技术异化现象，要对异化的资本主义制度展开批判，更好地发挥科学技术的社会功能。 科学技术作为社会发展的动力,是马克思主义的基木观点。科学是生产力的“知识的形态”。作为生产力的科学技术，能够大大提高社会生产力水平，推动着整个人类物质生产的迅猛发展。 作为强大的精神力量的科学技术，能够促进人类思想的解放，在产业革命的基础上，推动社会变革，对社会生产关系产生有力影响。 作为人类最终走向白由的科学技术，能够作为解放的杠杆，增进人类精神生活的丰富性和自我发展能力，有助于实现人的全面自由的发展。 2.如何看待科学技术对人的异化和对自然的异化？ 科技异化实质上是在资本主义制度下劳动异化和人的异化一种必然结果。由于劳动是人的最根本最现实的实践活动，是人及人类社会存在的根本方式，劳动的异化必然带来人的其他社会活动和社会关系的全面异化，科学技术也不例外，因为“宗教、家庭、国家、法、道德、科学、艺术等等，都不过是生产的一些特殊的方式，并且受生产的普遍规律的支配。” 因此，科学技术作为劳动亦即人处理自身与自然界关系的社会活动的产物，也必然随着资本主义社会劳动的异化而表现出异化的现象。最根本的是要消灭对科学技术的资本主义利用方式，把现代科学技术从资本主义制度下解放出来。也就是说只有通过无产阶级革命来最终解决资本主义的科技异化问题。当然，在马克思看来，异化的完全克服只有在共产主义社会制度中才能最终实现。 3.科学技术的社会体制和组织机构对科学技术的发展有何意义？ 科学技术的社会建制有一个历史过程。经济支持制度、法律保障体系等科学技术体制是根本，各种组织机构及其科研组织运行是保证，科学技术的伦理规范是导引。在科学技术发展应用的新阶段，科学技术的社会建制呈现出一些新特点，因此必须进行科学技术体制改革，以保证科学技术的良好运行。 作为社会建制的科学技术体制是在一定社会价值观念支配下，依据相应的物质设备条件形成的一种社会组织制度，旨在支持推动人类对自然的认识和利用。科学技术的体制化以相应的职业化为核心，其内涵随着科学技术的发展而不断拓展和丰富。科学技术的社会体制包括:组织领导体制、经济支持制度、法律保障体制、交流与传播体制、人才教育培养制度等。科学技术与其他各种事业密切相关,需要建立相应的组织机构以保证科学技术活动的顺利进行。科学技术组织机构随着历史的演化而变化，具有各白的特点和功能，是实现科学技术现代化的组织保证。在科学技术社会史上形成与发展起来的组织机构有:科学技术决策、管理与咨询机构，科学技术活动组织机构，科学技术传播机构，科学技术人才培养机构。 【以下摘白百度贴吧帖子“科学技术的社会体制化及其对科学发展的意义”】科学技术体制化的内容包括:科学技术的投入体制、科技研究的结构比例、科学技术的法律制度、科技研究的管理体制。科学技术的社会体制化对科学发展的意义:1、它可以积聚社会上的力量来进行柑应的科学研究;2、当代科技活动的结构中基础研究将会有大量的人员参l与j;3、明确的法律以及管理制度将会更进一步促进科学技术的发展。 4.为什么要对科学技术工作者进行伦理规范？ 科学技术活动与人类其他活动一样，建立在诚信和道德的基础上。现阶段，默顿的科学的精神气质受到挑战，科学技术工作者有失范行为，需要制定相关科研诚信指南和工程师伦理准则加以规范。科学工作者进行科学研究和医学实践，尤其是进行人体实验和动物实验，应该遵循社会伦理、生命伦理、动物伦理等。技术工作者，尤其是工程师，在工程技术活动中，应该遵循一定的职业伦理和社会伦理准则，应该承担对社会、专业、雇主和同事的责任，应该对工程的环境影响负有特别的责任，规范白己的行为，为人类福祉和环境保护服务。 5.如何理解科学技术文化与人文文化之间的冲突与协调？(一）社会文化对科学技术的影响 科学技术的产生和发展需要一定的社会文化环境。社会文化与科学技术文化紧密关联，并由此影响科学技术的发展及其应用。默顿在《十七世纪英格兰的科学、技术与社会》中提出的“清教主义促进英国近代科学的制度变化”，以及“李约瑟难题”——“近代科学为什么没有在中国诞生”的解答，就说明了这一点。 (二）科学文化与人文文化的协调 1．要防止科学在生活世界、自然世界对人文的僭越所造成的科学文化与人文文化之间的冲突，深刻理解科学的限度，用正确的人文理念指导我们的生活。 2．必须以社会先进文化来引领科学技术文化，使科学技术发展和应用为经济社会健康全面发展服务。得到广泛提倡的环境科学技术就是为了协调人与自然之间的关系所做的努力，是科学技术文化与人文文化——绿色文化的良性互动产物。 6.科学技术的风险有哪些？如何恰当地进行科学技术风险评价与决策？ 科学技术的风险包括环境风险、政治风险、经济风险、健康风险和伦理风险等。这些风险会引发一系列争论，造成评价和决策上的困难。习近平指出:“要加快建立科技咨询支撑行政决策的科技决策机制，加强科技决策咨询系统，建设高水平科技智库。要加快推进重大科技决策制度化，解决好实际存在的部门领导拍脑袋、科技专家看颜色行事等问题。” 要恰当进行科学技术风险评价与决策，就应该全面评价科学技术风险—收益的多个方面，批判性地考察“内部”存有争议的科学知识或技术知识，分析相互竞争的利益集团和社会结构的”外部”政治学，理解科学技术专家知识和决策的局限性、公众理解科学的必要性以及外行知识的优势，明确政府、科学技术专家以及公众在与科学技术风险相关的公共决策中的不同作用，确立公众参与决策的可能方式，从而形成最优化的科学技术公共政策模式，以达到对科学技术风险社会有效治理的目的。 第五章 中国马克思主义科学技术观1.为什么说新时代中国马克思主义科学技术是一个科学、完整的思想理论体系？ 毛泽东、邓小平、……、胡锦涛、习近平的科学技术思想，是在中国共产党领导我国科学技术事业发展和进行社会主义现代化建设的伟大时间中，逐渐形成、发展和完善的。 中国马克思主义科学技术观是基于马克思、恩格斯的科学技术思想，对当代科学技术机器发展规律的概括和总结，是马克思主义科学技术论的重要组成部分。 中国马克思主义科学技术观是中国共产党人集体智慧的结晶，是对毛泽东、邓小平、……、习近平科学技术思想的概括和总结，是他们科学技术思想的理论升华和飞跃，是他们科学技术思想的凝练和精髓。 中国马克思主义科学技术观的内容丰富，涉及了科学技术的功能、目标、机制、战略、人才和方针等重大问题，是一个科学、完整的思想理论体系。 2.如何理解中国马克思主义科学技术观的理论精髓？ 中国马克思主义科学技术观概括和总结了毛泽东、邓小平、···、习近平等的科学技术思想，包括科学技术的功能观、战略观、人才观、和谐观和创新观的基木内容，体现出时代性、实践性、科学性、创新性、自主性、人本性等特征，建设中国特色的创新型国家，是中国马克思主义科学技术观的具体体现。中国马克思主义科学技术观，是马克思主义科学技术观与中国具体科学技术实践相结合的产物，是马克思主义科学技术论的重要组成部分。 3.如何理解习近平新时代中国特色社会主义思想中的科学技术观的时代意义？ 中国马克思主义科学技术观的三个历史阶段是其各自所处的历史条件所决定的，是对时代背景实事求是的反映，因此科学技术思想都镌刻了时代的烙印，反映了时代的需求。 习近平新时代中国特色社会主义思想中的科学技术观，是在中国特色社会主义进入新时代的历史条件下形成的。新时代之“新”，一是在于我们进入了一个新的发展阶段，发展环境、发展条件都发生了新的变化，目标任务也发生了新的变化;二是在于我们面临着新的社会主义主要矛盾;三是我们迈向新的奋斗目标。正是基于这一新时代的”新”特征时代背景，习近平立足于我贵哦科学技术与社会发展的现实需要，提出了一系列关于科学技术发展的理论观点，形成了习近平新时代中国特色社会主义科学技术观。","categories":["杂记"]},{"title":"png和jpg格式的图片(二)","path":"/杂记/Qt-images/","content":"[TOC] 背景在上篇文章 png和jpg格式图片 中笔者就 jpg 和 png 两种格式进行了说明，但是关于 Qt 打开改后缀文件名之后图片的问题依然没有说明。要探究Qt为何不能打开改了后缀的图片文件，这个还是得从多方面去定位。前文说了，通过三种方式设置了 QLabel 的图片。 场景复现 这里还是先说明一下设置不成功的场景如何复现: 找一张 .jpg 的图片，修改后缀也就是文件属性为 .png 通过以下三种方式中的任意一种去设置 QLabel 为图片。 Qt 版本是 5.9 编译器试了 MSVC 和 mingw 都不好使。 QLabel 设置图片方法 通过 QPixmap设置 QLabel 的图片 1234QPixmap img(&quot;:/Win11.png&quot;);ui-&gt;label-&gt;setPixmap(img);ui-&gt;label-&gt;setScaledContents(true); 通过 QImage 设置 QLabel 的图片 123QImage img;img.load(&quot;:/Win11.png&quot;);ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(img)) 通过 QLabel.setStyleSheet() 的图片 123ui-&gt;label-&gt;setStyleSheet(QString(&quot;QLabel&#123;&quot; &quot;border-image:url(:/Win11.png) 4 4 4 4 stretch stretch;&quot; &quot;&#125;&quot;)); 当然还有第四种方法，通过 QSvgRenderer 设置： 1234567#include &lt;QSvgRenderer&gt;QSvgRenderer svgRender(QString(&quot;:/Win11.svg&quot;));QPixmap pixmap(20,20);QPainter painter(&amp;pixmap);svgRender.render(&amp;painter);ui-&gt;label-&gt;setPixmap(pixmap); 场景是描述完了，可以动手尝试了 操作接着就是去查看几种实现方式中的源码是如何是设置的了，这里先猜一下结论 就是 png 和 jpg 格式的算法不同，格式问题导致的读取的算法不一致，因此Qt内部实现的读取图片的算法只能根据图片文件的后缀所对应的算法去读取算法，而 setStyleSheet 算法也是基于这么一个逻辑，因此三种读取方式都不成功。 关于图片算法的问题，在上篇文章 png和jpg格式图片 中也略微提到，这个我们不深做研究，只需知道 jpg 和 png 不是同一种算法，也不通用即可。 初步验证因为上述几种步骤笔者都做过尝试，因此在验证过程中我们不纠结于使用哪一种方式，直接看结果。 那如何去验证呢，我们还是看代码，这次我们在 Qt 的 qrc 文件中，去掉图片的后缀名，不带后缀属性去读取图片看看其是否可以读取成功。 运行结果: QLabel 读取成功 如上图所示，在 qrc 文件中去掉图片的后缀，读取图片设置到 QLabel 依然是成功的。 我们接着操作，在代码中修改图片后缀为 png，看看这次能不能读取成功。 运行结果：读取失败 如上图所示，添加后缀后反而还展示不成功了。 初步验证的结果这就基本上说明了： 在 Qt 的内部有很大的几率是通过文件的后缀去判断调用哪个图片读取算法的。也就是说，当你人为的修改了 png-&gt;jpg 时，在 Qt 中就会出现设置图片失败的问题。目前看来，在代码没有问题，但是图片设置后不显示的情况下，最好的方式是，就是去掉图片的后缀，让 Qt 自己去判断调用哪个算法读取图片。 源码分析这里有关于 Qt 图片 I\\O 的描述可以看看Qt帮助手册中关于图像文件读写的文档。 源码部分，我们只需查看两个Qt 类就行，个人感觉看一个就知道了。两者识别图片的算法应该是一致的。包括 setStyleSheet()接口中设置图片的接口应该都是一致的。 QPixmap依赖于所在的平台的绘图引擎，故例如反锯齿等一些效果在不同的平台上可能会有不同的显示效果，QImage使用Qt自身的绘图引擎，可在不同平台上具有相同的显示效果 目前的Qt会把QPixmap都存储在graphics memory中，QImage是存储在客户端的，是独立于硬件的。在X11, Mac 以及 Symbian平台上，QPixmap 是存储在服务器端，而QImage则是存储在客户端，在Windows平台上，QPixmap和QImage都是存储在客户端，并不使用任何的GDI资源。 由于QImage是独立于硬件的，也是一种QPaintDevice，因此我们可以在另一个线程中对其进行绘制，而不需要在GUI线程中处理，使用这一方式可以很大幅度提高UI响应速度。 QPixmap查询到QPixmap的源文件，一般存放在 Qt 安装目录下 $&#123;安装目录&#125;\\5.9.9\\Src\\qtbase\\src\\gui\\image，文件名为 qpixmap.h qpixmap.cpp 先看一下 QPixmap 的 构造函数中读取图片文件的方法。 QPixmap::QPixmap(const QString&amp; fileName, const char *format, Qt::ImageConversionFlags flags)的源码 123456789QPixmap::QPixmap(const QString&amp; fileName, const char *format, Qt::ImageConversionFlags flags) : QPaintDevice() &#123; doInit(0, 0, QPlatformPixmap::PixmapType); if (!qt_pixmap_thread_test()) return; load(fileName, format, flags); // 这里看到调用了load()的接口，接着查看load是如何实现的 &#125; load()函数源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*! Loads a pixmap from the file with the given \\a fileName. Returns true if the pixmap was successfully loaded; otherwise invalidates the pixmap and returns \\c false. The loader attempts to read the pixmap using the specified \\a format. If the \\a format is not specified (which is the default), the loader probes the file for a header to guess the file format. The file name can either refer to an actual file on disk or to one of the application&#x27;s embedded resources. See the \\l&#123;resources.html&#125;&#123;Resource System&#125; overview for details on how to embed pixmaps and other resource files in the application&#x27;s executable. If the data needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the \\a flags to control the conversion. Note that QPixmaps are automatically added to the QPixmapCache when loaded from a file; the key used is internal and can not be acquired. \\sa loadFromData(), &#123;QPixmap#Reading and Writing Image Files&#125;&#123;Reading and Writing Image Files&#125;*//* 翻译过来就是从给定的文件名的文件中加载一个像素图。如果pixmap成功加载，则为True;否则返回无效pixmap并返回\\c false。加载器尝试使用指定的\\a读取pixmap格式。如果没有指定\\a格式(这是默认的)，加载器探测文件的头，以猜测文件的格式。文件名可以指向磁盘上的实际文件，也可以指向磁盘上的实际文件应用程序的嵌入式资源。看到\\l&#123;resources.html&#125;&#123;Resource System&#125;概述如何嵌入pixmap和其他资源文件在应用程序的可执行文件。如果数据需要修改以适应低分辨率结果(例如从32位转换到8位)，使用\\a标志来控制转换。注意，qpixmap会自动添加到QPixmapCache中当从文件加载时;使用的密钥是内部的，不能被收购。\\sa loadFromData()， &#123;QPixmap#读写图像读写图像文件&#125;*/// loadFromdata的源码我也补充到了文末bool QPixmap::load(const QString &amp;fileName, const char *format, Qt::ImageConversionFlags flags)&#123; if (!fileName.isEmpty()) &#123; QFileInfo info(fileName); // Note: If no extension is provided, we try to match the // file against known plugin extensions if (info.completeSuffix().isEmpty() || info.exists()) &#123; QString key = QLatin1String(&quot;qt_pixmap&quot;) % info.absoluteFilePath() % HexString&lt;uint&gt;(info.lastModified().toSecsSinceEpoch()) % HexString&lt;quint64&gt;(info.size()) % HexString&lt;uint&gt;(data ? data-&gt;pixelType() : QPlatformPixmap::PixmapType); if (QPixmapCache::find(key, this)) return true; data = QPlatformPixmap::create(0, 0, data ? data-&gt;pixelType() : QPlatformPixmap::PixmapType); if (data-&gt;fromFile(fileName, format, flags)) &#123; QPixmapCache::insert(key, *this); return true; &#125; &#125; &#125; if (!isNull()) &#123; if (isQBitmap()) *this = QBitmap(); else data.reset(); &#125; return false;&#125; 一看源码是不是就清晰多了。在 load()函数的实现中：①判断文件名是不是为空；②不为空时，首先就是读取文件的后缀。这里我们可以细细查一下第二个 if 判断中 QString 类型的 key 到底是进行了一个什么操作。 12345QString key = QLatin1String(&quot;qt_pixmap&quot;) % info.absoluteFilePath() // 返回文件名的绝对路径 % HexString&lt;uint&gt;(info.lastModified().toSecsSinceEpoch()) // 返回文件最后一次修改的日期和时间 % HexString&lt;quint64&gt;(info.size()) // 返回文件的大小 % HexString&lt;uint&gt;(data ? data-&gt;pixelType() : QPlatformPixmap::PixmapType); // 这里的data是成员变量，就是说如果设置了data的pixelType的值就读取，没设置的话就是默认值 QPlatformPixmap::PixmapType 上述的 HexString&lt;type&gt;就是 ASCII 的数组形式，16进制 的数组。上述代码中的 % 操作如果不是求余的话会是什么呢。如果是求余，QString 会报错才是呀？？？ 这里最终还是通过设置和查看 QPixmap 的内置变量 data 中的标志去查看当前文件是不是图片，如果是图片，则会修改当前的 QPixmap 指针，如果不是就会返回 false。 12if (QPixmapCache::find(key, this)) return true; 这里补充一个QPixmapCache的demo： 1234567/*在缓存中查找与给定键关联的缓存pixmap。如果找到了pixmap，函数将pixmap设置为该pixmap并返回true;否则，它将保留pixmap并返回false。*/QPixmap pm;if (!QPixmapCache::find(&quot;my_big_image&quot;, &amp;pm)) &#123; pm.load(&quot;bigimage.png&quot;); QPixmapCache::insert(&quot;my_big_image&quot;, pm);&#125;painter-&gt;drawPixmap(0, 0, pm); 最终判断当前文件是不是图片应该是在 data-&gt;fromFile() 中实现的。 这个data的定义： 1QExplicitlySharedDataPointer&lt;QPlatformPixmap&gt; data; 未完成这篇文章还在编辑中 补充 补充一下 load()的函数有必要读一下。 QPixmap::loadFromData() 的源码。 12345678910111213141516171819202122232425262728293031323334/*! \\fn bool QPixmap::loadFromData(const uchar *data, uint len, const char *format, Qt::ImageConversionFlags flags) Loads a pixmap from the \\a len first bytes of the given binary \\a data. Returns \\c true if the pixmap was loaded successfully; otherwise invalidates the pixmap and returns \\c false. The loader attempts to read the pixmap using the specified \\a format. If the \\a format is not specified (which is the default), the loader probes the file for a header to guess the file format. If the data needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the \\a flags to control the conversion. \\sa load(), &#123;QPixmap#Reading and Writing Image Files&#125;&#123;Reading and Writing Image Files&#125;*/bool QPixmap::loadFromData(const uchar *buf, uint len, const char *format, Qt::ImageConversionFlags flags)&#123; if (len == 0 || buf == 0) &#123; data.reset(); return false; &#125; data = QPlatformPixmap::create(0, 0, QPlatformPixmap::PixmapType); if (data-&gt;fromData(buf, len, format, flags)) return true; data.reset(); return false;&#125;","tags":["图片","Qt","格式"],"categories":["杂记"]},{"title":"png和jpg格式的图片(一)","path":"/杂记/png和jpg格式图片/","content":"[toc] jpg 和 png 图片格式在写这篇文章之前，笔者在编写一个简单的 Qt 程序时遇到了这样一个问题： 问题：一个png格式的图片改成后缀为jpg格式的图片时，QLabel无法读取的问题。笔者是通过setStyleSheet()、QImage、QPixmap的接口均尝试过将改后缀后图片设置到QLabel中，均以失败告终。 特此研究了一下这jpg和png两者之间的区别，后续再研究一下Qt关于相关格式图片读取的问题。 图片会有jpg和png两种格式，那么这俩种格式的图片又有着什么样的区别呢？下面就给大家分享一下。 png和jpg都是常用的图片格式，其中png属于无损压缩，jpg是有损压缩，使用中两者最明显的一个区别是: png支持透明通道 jpg的图片更适合在网络中传播和使用。 jpg格式 jpg：是JPEG标准的产物，也是目前网络最为流行的图片格式，jpg格式的图片可以将图像文件压缩到最小格式，在高度压缩率的同时，可以展现是分丰富生动的图像，但是随着压缩比的增大，图片的品质会逐渐降低的。我们现在常用的jpg的标准全程为JPEG 2000标准，有以下几点特性： 高压缩率 无损压缩和有损压缩 渐进传输 感兴趣区域压缩 码流的随机访问和处理 容错性 基于内容的描述 png格式 png：是一种采用无损压缩算法的位图模式，其设计目的是视图替代GIF和TIFF文件格式，同时增加一下GIF文件格式所不具备的特性。PNG使用从LZ77派生的无损数据压缩算法，一般应用于JAVA程序、网页或S60程序中，原因就是因为png的压缩比更高，生成文件体积小。png图片也有一些特性： 体积小 无损压缩 索引彩色模式 更优化的网络传输显示 支持透明模式 关于 png 格式还需要说明的是： png格式有8位、24位、32位三种形式，其中8位PNG支持两种不同的透明形式（索引透明和alpha透明），24位PNG不支持透明，32位PNG在24位基础上增加了8位透明通道，因此可展现256级透明程度。 PNG8和PNG24后面的数字则是代表这种PNG格式最多可以索引和存储的颜色值。8代表2的8次方也就是256色，而24则代表2的24次方大概有1600多万色。 区别：png 和 jpg 转自百度百科： 1、JPEG可以对照片（或类似）图像生成更小的文件，这是由于JPEG采用了一种针对照片图像的特定有损编码方法，这种编码适用于低对比，图像颜色过渡平滑，噪声多，且结构不规则的情况下。如果在这种情况下用PNG代替JPEG，文件尺寸增大很多，而图像质量的提高有限。相应的，如果保存文本，线条或类似的边缘清晰，有大块相同颜色区域的图像，PNG格式的压缩效果就要比JPEG好很多，并且不会出现JPEG那样的高对比度区域的图像有损。如果图像既有清晰边缘，又有照片图像的特点，就在在这两种格式之间权衡一下了。JPEG不支持透明度。 2、由于JPEG是有损压缩，会产生迭代有损，在重复压缩和解码的过程中会不断丢失信息使图像质量下降。由于PNG是无损的，保存将要被编辑的图像来说更加合适。虽然PNG压缩照片图像也有效，但有专门针对照片图像设计的无损压缩格式，比如无损JPEG2000，Adobe DNG等。总的来说这些格式都不能做到适用所有图像。对于将要发布的图像可以保存成JPEG，用JPEG编码一次不会造成明显的图像有损。 总结就是： jpg格式的图片能在高度压缩率的同时，展现十分丰富生动的图像，但是随着压缩比的增大，图片的品质会逐渐降低的。而png图片的特性就是体积小，节约空间，与jpg图片相比，png图片时无损压缩，在不损失图片数据的情况下，可以快速的获取自己想要的图片，而且图片的质量并不会下降。 png格式的图片可以编辑，比如图片中的字体、线条等，可以通过ps等软件更改。但是jpg格式的图片则不可以更改，png与jpg图片相比png格式的图片更大。","tags":["图片","格式"],"categories":["杂记"]},{"title":"中国马克思主义科学技术观","path":"/杂记/中国马克思主义科学技术观/","content":"[toc] 第四章、科学技术社会论1. 为什么说“科学是一种在历史上起推动作用的、革命的力量”？ &amp;nbsp;&amp;nbsp;科学技术是历史发展的火车头，改变了社会历史进程，造就了新的社会形态;推动了生产力内部各要素的变革，引发了产业结构的调整、经济形式的变化和经济增长方式的转变，造就了经济转型;产生了技术异化现象，要对异化的资本主义制度展开批判，更好地发挥科学技术的社会功能。&amp;nbsp;&amp;nbsp;科学技术作为社会发展的动力,是马克思主义的基木观点。科学是生产力的“知识的形态”。作为生产力的科学技术，能够大大提高社会生产力水平，推动着整个人类物质生产的迅猛发展。&amp;nbsp;&amp;nbsp;作为强大的精神力量的科学技术，能够促进人类思想的解放，在产业革命的基础上，推动社会变革，对社会生产关系产生有力影响。&amp;nbsp;&amp;nbsp;作为人类最终走向白由的科学技术，能够作为解放的杠杆，增进人类精神生活的丰富性和自我发展能力，有助于实现人的全面自由的发展。 2. 如何看待科学技术对人的异化和对自然的异化？ &amp;nbsp;&amp;nbsp;科技异化实质上是在资本主义制度下劳动异化和人的异化一种必然结果。由于劳动是人的最根本最现实的实践活动，是人及人类社会存在的根本方式，劳动的异化必然带来人的其他社会活动和社会关系的全面异化，科学技术也不例外，因为“宗教、家庭、国家、法、道德、科学、艺术等等，都不过是生产的一些特殊的方式，并且受生产的普遍规律的支配。” &amp;nbsp;&amp;nbsp;因此，科学技术作为劳动亦即人处理自身与自然界关系的社会活动的产物，也必然随着资本主义社会劳动的异化而表现出异化的现象。最根本的是要消灭对科学技术的资本主义利用方式，把现代科学技术从资本主义制度下解放出来。也就是说只有通过无产阶级革命来最终解决资本主义的科技异化问题。当然，在马克思看来，异化的完全克服只有在共产主义社会制度中才能最终实现。 3. 科学技术的社会体制和组织机构对科学技术的发展有何意义？ &amp;nbsp;&amp;nbsp;科学技术的社会建制有一个历史过程。经济支持制度、法律保障体系等科学技术体制是根本，各种组织机构及其科研组织运行是保证，科学技术的伦理规范是导引。在科学技术发展应用的新阶段，科学技术的社会建制呈现出一些新特点，因此必须进行科学技术体制改革，以保证科学技术的良好运行。&amp;nbsp;&amp;nbsp;作为社会建制的科学技术体制是在一定社会价值观念支配下，依据相应的物质设备条件形成的一种社会组织制度，旨在支持推动人类对自然的认识和利用。科学技术的体制化以相应的职业化为核心，其内涵随着科学技术的发展而不断拓展和丰富。科学技术的社会体制包括:组织领导体制、经济支持制度、法律保障体制、交流与传播体制、人才教育培养制度等。科学技术与其他各种事业密切相关,需要建立相应的组织机构以保证科学技术活动的顺利进行。科学技术组织机构随着历史的演化而变化，具有各白的特点和功能，是实现科学技术现代化的组织保证。在科学技术社会史上形成与发展起来的组织机构有:科学技术决策、管理与咨询机构，科学技术活动组织机构，科学技术传播机构，科学技术人才培养机构。 【以下摘白百度贴吧帖子“科学技术的社会体制化及其对科学发展的意义”】科学技术体制化的内容包括:科学技术的投入体制、科技研究的结构比例、科学技术的法律制度、科技研究的管理体制。科学技术的社会体制化对科学发展的意义:1、它可以积聚社会上的力量来进行柑应的科学研究;2、当代科技活动的结构中基础研究将会有大量的人员参l与j;3、明确的法律以及管理制度将会更进一步促进科学技术的发展。 4. 为什么要对科学技术工作者进行伦理规范？ &amp;nbsp;&amp;nbsp;科学技术活动与人类其他活动一样，建立在诚信和道德的基础上。现阶段，默顿的科学的精神气质受到挑战，科学技术工作者有失范行为，需要制定相关科研诚信指南和工程师伦理准则加以规范。科学工作者进行科学研究和医学实践，尤其是进行人体实验和动物实验，应该遵循社会伦理、生命伦理、动物伦理等。技术工作者，尤其是工程师，在工程技术活动中，应该遵循一定的职业伦理和社会伦理准则，应该承担对社会、专业、雇主和同事的责任，应该对工程的环境影响负有特别的责任，规范白己的行为，为人类福祉和环境保护服务。 5. 如何理解科学技术文化与人文文化之间的冲突与协调？ (一）社会文化对科学技术的影响&amp;nbsp;&amp;nbsp;科学技术的产生和发展需要一定的社会文化环境。社会文化与科学技术文化紧密关联，并由此影响科学技术的发展及其应用。默顿在《十七世纪英格兰的科学、技术与社会》中提出的“清教主义促进英国近代科学的制度变化”，以及“李约瑟难题”——“近代科学为什么没有在中国诞生”的解答，就说明了这一点。 (二）科学文化与人文文化的协调&amp;nbsp;&amp;nbsp;1．要防止科学在生活世界、自然世界对人文的僭越所造成的科学文化与人文文化之间的冲突，深刻理解科学的限度，用正确的人文理念指导我们的生活。&amp;nbsp;&amp;nbsp;2．必须以社会先进文化来引领科学技术文化，使科学技术发展和应用为经济社会健康全面发展服务。得到广泛提倡的环境科学技术就是为了协调人与自然之间的关系所做的努力，是科学技术文化与人文文化——绿色文化的良性互动产物。 6. 科学技术的风险有哪些？如何恰当地进行科学技术风险评价与决策？ &amp;nbsp;&amp;nbsp;科学技术的风险包括环境风险、政治风险、经济风险、健康风险和伦理风险等。这些风险会引发一系列争论，造成评价和决策上的困难。习近平指出:“要加快建立科技咨询支撑行政决策的科技决策机制，加强科技决策咨询系统，建设高水平科技智库。要加快推进重大科技决策制度化，解决好实际存在的部门领导拍脑袋、科技专家看颜色行事等问题。” 要恰当进行科学技术风险评价与决策，就应该全面评价科学技术风险—收益的多个方面，批判性地考察“内部”存有争议的科学知识或技术知识，分析相互竞争的利益集团和社会结构的”外部”政治学，理解科学技术专家知识和决策的局限性、公众理解科学的必要性以及外行知识的优势，明确政府、科学技术专家以及公众在与科学技术风险相关的公共决策中的不同作用，确立公众参与决策的可能方式，从而形成最优化的科学技术公共政策模式，以达到对科学技术风险社会有效治理的目的。 第五章、中国马克思主义科学技术观1. 为什么说新时代中国马克思主义科学技术是一个科学、完整的思想理论体系？ &amp;nbsp;&amp;nbsp;毛泽东、邓小平、……、胡锦涛、习近平的科学技术思想，是在中国共产党领导我国科学技术事业发展和进行社会主义现代化建设的伟大时间中，逐渐形成、发展和完善的。 &amp;nbsp;&amp;nbsp;中国马克思主义科学技术观是基于马克思、恩格斯的科学技术思想，对当代科学技术机器发展规律的概括和总结，是马克思主义科学技术论的重要组成部分。 &amp;nbsp;&amp;nbsp;中国马克思主义科学技术观是中国共产党人集体智慧的结晶，是对毛泽东、邓小平、……、习近平科学技术思想的概括和总结，是他们科学技术思想的理论升华和飞跃，是他们科学技术思想的凝练和精髓。 &amp;nbsp;&amp;nbsp;中国马克思主义科学技术观的内容丰富，涉及了科学技术的功能、目标、机制、战略、人才和方针等重大问题，是一个科学、完整的思想理论体系。 2. 如何理解中国马克思主义科学技术观的理论精髓？ &amp;nbsp;&amp;nbsp;中国马克思主义科学技术观概括和总结了毛泽东、邓小平、···、习近平等的科学技术思想，包括科学技术的功能观、战略观、人才观、和谐观和创新观的基木内容，体现出时代性、实践性、科学性、创新性、自主性、人本性等特征，建设中国特色的创新型国家，是中国马克思主义科学技术观的具体体现。中国马克思主义科学技术观，是马克思主义科学技术观与中国具体科学技术实践相结合的产物，是马克思主义科学技术论的重要组成部分。 3. 如何理解习近平新时代中国特色社会主义思想中的科学技术观的时代意义？ &amp;nbsp;&amp;nbsp;中国马克思主义科学技术观的三个历史阶段是其各自所处的历史条件所决定的，是对时代背景实事求是的反映，因此科学技术思想都镌刻了时代的烙印，反映了时代的需求。 &amp;nbsp;&amp;nbsp;习近平新时代中国特色社会主义思想中的科学技术观，是在中国特色社会主义进入新时代的历史条件下形成的。新时代之“新”，一是在于我们进入了一个新的发展阶段，发展环境、发展条件都发生了新的变化，目标任务也发生了新的变化;二是在于我们面临着新的社会主义主要矛盾;三是我们迈向新的奋斗目标。正是基于这一新时代的”新”特征时代背景，习近平立足于我贵哦科学技术与社会发展的现实需要，提出了一系列关于科学技术发展的理论观点，形成了习近平新时代中国特色社会主义科学技术观。 参考链接： 2019自然辩证法课后思考题及答案_文档之家","categories":["杂记"]},{"title":"释怀","path":"/日记/释怀/","content":"真正的成熟，大概就是，喜欢的东西还是喜欢，只是不再强求拥有了，害怕的东西还是害怕，只是敢于面对了。 成长的意义就在于，总有一天，我们要学会坦然面对生命中所有突如其来的境遇。 有的人离开，有的人走来，有的人重逢，有的人再也不见。 太阳照常升起，草木岁岁枯荣。 所有的舍不得，所有的无奈，都有释怀的一天。 你一个人，过得好吗？努力生活，就是答案。 人这一辈子，有人羡慕你，有人看不起你，有人误会你，有人讨厌你，也有人嫉妒你，不要在乎别人怎么看你。 一定要告诉自己，身体是自己的，一定要爱惜，心情也是自己的，一定要顾及，不要为了那些不值得的人和事为难自己。 把身体养好，叫体质，把心情调好，叫格局，把日子过好，叫本事。 现在这个社会，当面一套背后一套，口是心非的人多了去了，所以做好自己就行，剩下的交给良心！ 有些东西，得之我幸，失之我命，选择放下，不是为了原谅别人，只是为了放过自己。 记得有人说过，一个人首先要爱自己，才有能力爱别人。","categories":["日记"]},{"title":"灵魂","path":"/日记/灵魂/","content":"411319705e21b53bb2f6c15c89490a4bd99c949e9cc067890e4786115d9455c9a9c938b70cf42818108866b63a3f2427e938731ea75f4e57749450f67d78e1d03760dc8c272a554c59fdff38ea2a654d7e178f84e81a67c7d3f6849b4b5d1dd47c521d48ed7f98a4999357d031a90fd7b5c76a3036e65f9de2988ae6982eb66ec5df782c8c7f2de0edd7d4a839e00344db9ff754f6b075e9da22f78935932493eb0d7a842a475c62518fcfdcfb86cfa44ca51017e7f00529f5afb69d6a9403d3f5eafe819952213e9b70f72686badd3b827464f499acf18f923209cd4f292db505afea1dd7f5fee8aed3eb6a26282a2574f1b3d19b33db2af20715ea9f511dab29348b02cb57b51a36e924920626adaf5e5a3eb736c6f48a79627d06fd1cb8716a092723741c2db5b5a22ac3c3a4a717687e9e2e96b40c90f6424f4479c2958c0dbfb2a12e7de5a29e8f4654834ac836beb54e065720571c2048a442f5a24d80644db38f2c0045decd9d8496df0ab91abeaa77fe275eced851b7b9cb7248f5c1db078afa9c5973833fa9b606a9938e212417b7303be61ef28811b947d4e39fe57ac8048b0111c3255230a34e19aeba8052b6b7a732718a995dc1f4d4e7d446f7f36a4ad1ecc027ae4707118ce05589badcd01015d4bd94446d96edf7bc7f8f686d62f0ceb838b42188c6300a711021406b80b0d36176e443207b4eaf0bccca0f5ab25b017a21d65fad5da89f2f3eeea88d38a0f1c314533d1e445d21328990f2e35a6101824057b9504a468b35d7e4a5a86db89ddd6046762c4f8546ea37213aa27fb413ca9add077c029459ddbac8c2979094d05ff061b4c82c2fc825749f89931e273f313b4df54b94ffa9e75debf5fb86cce7808b02469dd156eff9aaa95b19976ab9e4cd7179518e48c566fd58beb2744917d6925af8e0f77a81b13a3e32297e1ab3e2c4569ee5810b911105d500890a1bb6cf30d555015d15fba094ac1954924f7481ce3878ac54729f6f5446c65d71312337e07853243f5593476a7760370b846ca0b1b68f3ed47f4806b9d27583dc9230735c42ee0e84c9bdcd749b1c38c3ddb7c01b8ec95bedb728b119e46580a68a3f713371e0e41a85b7f413556d0b44fb7fd64085f18e719b8bd78fd39acf1903d614596991700edf77ad7e558975d9b06bec9228c4fcd8f5f929bfc8e682496207e789daf461e46a31709e228765c7ef56c40a5f069ef4692d0a7b54a56425d0d239db7792b08bb6156312c2b9561f81cf42005ee888c97ded151c9794d3fd4b4d11148221b6c8795c5980c86aa5b6ed722d2a19496b6f068466a07ffe65463ed95483aa88947ddede577dfd5259d57de823716894600cf0963ecbea2f0eef5184d615cdfa5fc1cde58f6ad216e9a3feedd43cb4165006e37ed5244bd2a8611d516abfd2ce0ced0f29debe96642ac1ab4430da9b17ee350c9902b338a46f3c9de90ee440bbe8909a734e57c86bfb2e8fbde3f29da01392b36b5581ce0d1555c46cf590188f9bd4420f013c2e52893da28fa8f579163b3136618eb06c64e75e5e080bf3f3bc268dd3bef07534642722a86205253e14b59d56c5f585870c5b650c9032baf67f3590fe4a130914fd203feb38648155fa60b06277136f7f7527f36a1d38d488d93828164acdb4f2db7f143a1bb6c739df00bdbb242b25c8083dd3299c8710a1baae8486f3f97431bef2e123b6d1eda949f6ffe704a63f1055bbc48fd97f31a6e6c82158be80bbd3c7ee4409d0ea9b5d1a3f3dde1ac63393f4dc550c433c4bd1eb0952cf1b2f377ca10eaa8c2ed724be1d2aecdf2ce5a77430b217774d72024d449a64ad6a0404c1acf6f08684a8897d25f6ff254d83d689334e8fdb081a20b0a4fe81a6a332ac489974811879f4e8a03922701e639e331f5a15cc490c7d2e2477a0936b00ffaa53a5b99d2204724f28fa011bd0d1357f99132fe4e30f7a1cbb09d05414a1f6c843b73e6a229d4b52c5a62de76f621c028d81b8b73a90cbc1590128f26e107b34740ad17f123efbb3b51fade0d5e28889390e4f70a92c149cb7275aecd85dc7fe895df7aad0320511a8b88aff9d26bb9e79f5d83f9fad45b59a01a856cfd52c1bc87a58f651ae6406ccb2e7065f67649cfe16c112d42dd9855d1d6df2eec0388852ee8598cebe131968f259c6a88584b5bbf79d7dba1db82b2e0e7c12de8b9553a9864322d89a37dc9a914617a479cbeba95f808062acda355e1cfeb44d22f0e8da8fd8174df8c8e86817ef03958169855790ee9d8b912e2fb46b9a988fa4c4e41b2bf216c805551265ec67d946144d7f4309786d0261ce22a6ecd8634eb19011dac46315d97b6cbff239b8cdf61548ec3b4c07f619453763bb8d11078048eeb0b385a7c603ec819a016943b3b5f42b4436b925fb1e6319fce0c52cc3f6c05420f3ed98a8e4ce24857f16f82d64b7bf3f28b53fe08d9afd60a883c957d9eb410d832c1278dd88b210d2b84334aaa6d0d55f850e721b9b881c77a4494c2b9ccd8f93a5b6e30d8ae29c9cdb6b35935fb852e90adc169dcb7c3b60e856ed3b614a30a492a440dc4c4c1e6c861da41f24bea39f747ed7a60c44d375e42a30ee3b850e5feae03236e23c3094c97637c46ce089f992 Hey, password is required here.","categories":["日记"]},{"title":"常见排序算法整理（C++)","path":"/日记/刷题记录/排序算法/","content":"快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/******************************************************************************Welcome to GDB Online.GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.Code, Compile, Run and Debug online from anywhere in world.*******************************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 左闭右闭区间int getRand(int min, int max) &#123; return ( rand() % (max - min + 1) ) + min ;&#125;void quickSort(vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(start &gt; end) return; int i = start, j = end; int key = nums[start]; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; nums[j] &lt; key) j--; while(i &lt; j &amp;&amp; nums[i] &gt;= key) i++; if(i&lt;j) &#123; swap(nums[i],nums[j]); &#125; &#125; swap(nums[i], nums[start]); quickSort(nums, start, i-1); quickSort(nums, i+1, end); &#125;void sort(vector&lt;int&gt; &amp; nums)&#123; if(nums.empty() || nums.size() &lt; 2) &#123; return; &#125; quickSort(nums, 0, nums.size() - 1);&#125;int main()&#123; vector&lt;int&gt; nums; for (int i = 0; i &lt; 20; i++) &#123; nums.push_back(std::move(getRand(0,100))); &#125; sort(nums); for (auto it : nums) cout &lt;&lt; it &lt;&lt; endl; return 0;&#125;","tags":["排序","快速排序"],"categories":["日记","刷题记录"]},{"title":"Linux 命令脚本","path":"/手册/脚本/linux命令相关脚本整理/","content":"[toc] ll + awk 获取文件markdown链接1ll | awk &#x27;&#123;print &quot;[&quot;$9&quot;](./&quot;$9&quot;readme.md)&quot;&#125;&#x27;","categories":["手册","脚本"]},{"path":"/手册/所见即所得_Typora及用法/","content":"Markdown介绍Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown语法的目标是：成为一种适用于网络的书写语言「易读易写」。并且Markdown兼容HTML。你可以使用HTML语言编写Markdown，如果你要部署你的个人博客，那这更是你必不可少的技能之一！！！ 强烈推荐typora这款markdown软件，谁用谁说好！ 一款优质的Markdown编辑器,不仅仅是Markdown 除此之外，如果你愿意花一点点时间来了解{ post_link } 简述Markdown常见用法在下面，我将简单介绍几个常用的markdown写法。希望大家写出更好的观看效果的文章。本文一些内容是属于Hexo下buttrerfly主题的内置标签。 大家可以自己下载Typora尝试一下markdown。 为什么推荐Typora,我归纳了以下几点： 一 “所见即所得”（即时渲染） 二 支持图床功能，配合PicGO可以实现图片的随用随传 如下所示，右击图片就可以上传到PicGo指定的图床。真的很好用！！！ 三 Typora还支持将md文件导出为多种格式的文件，目前支持以下文件: 四 如果你还会一点CSS,那你甚至可以自定义界面样式 下面我将从以下这几个方面介绍一下Typora的一些使用方法： 字体 （&lt;small&gt;小&lt;/small&gt; &lt;big&gt;大&lt;/big&gt;） 斜体 *斜体* 粗体 **粗体** 斜体 + 粗体 ***斜体+粗体\\*** 删除 ~~原价：99.9元~~ 链接 [http://www.jianshu.com](https://www.jianshu.com) 分割线 下划线 标题 任务列表 图片 区块引用 行内代码 `markdown` 列表 表格 脚注 高亮 字体 123&lt;small&gt;小号字体&lt;/small&gt;&lt;big&gt;大号字体&lt;/big&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;font color=rgb(25,26,35) face=&quot;华文彩云&quot; size=100px style=&quot;text-align:center&quot;&gt;其他快捷方式&lt;/font&gt;&lt;/div&gt; 属性 值 描述 color rgb();#XXXXXXcolorname 规定文本的颜色，可以使用style代替 face font_family 规定文本的字体 size number 规定文本的大小 小号字体 大号字体 其他快捷方式 斜体西方斜体这一习惯看个人喜好吧。在文字前后各加一个*就👌了 1*斜体* 效果如下：斜体 加粗在文字前后各加两个**就👌了 1**加粗** 效果如下： 加粗 斜体加粗斜体文字前后各加*，加粗文字前后各加**，斜体加粗在文字前后加***。没毛病… 1***斜体加粗*** 效果如下: 斜体加粗 删除1~~content~~ 效果如下：content 链接链接应该是使用最多的场景了。他人有好的文字或者自己摘自哪里、都可以传送门直接过去。 12[网站名](地址)地址 效果如下：example@163.comhttp://www.baidu.com 分割线12341 ****2 *****3 ---以上三种写法都可以，效果一样，看个人心情使用。 下划线1&lt;u&gt;内容&lt;/u&gt; 内容 标题123# 一级标题···###### 六级标题 //最多支持六级标题 效果如下： 一级标题 六级标题 任务列表格式： 12 - [] 待完成- [X] 已完成 效果如下： 待完成 已完成 图片格式为![]() 其中图片名称可以为空。直接输入[]就可以。下面我的url输入的直接就文字url。所以肯定是空图片啦。Typora也可以直接把电脑本地的图片拖进来，自动生成图片链接。 1![图片名](URL) 区块引用代码块，使用’`‘和~都可以 123```代码``` 效果如下： 1代码 行内代码程序猿引用代码，或者是文章中有一些关键性的名词啊，或者为了突出醒目。效果不错。 1`printf(&quot;test&quot;)` 效果如下： printf(&quot;test”); 列表1234567- 无序项目1* 无序项目2+ 无序项目3\t- 无序二级1\t- 无序二级21. 有序标题\t1. 无序二级标题 无序项目1 无序项目2 无序项目3 无序二级1 无序二级2 有序标题 无序二级标题 表格ctrl+t更方便 1234| 第一格表头 | 第二格表头 || -------------------------------- | ---------------------- || 内容单元格 第一列第一格 | 内容单元格第二列第一格 || 内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 | 效果如下: 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 脚注H~2~o效果预览–&gt;H2o 高亮&lt;mark&gt;1&lt;mark&gt;content&lt;/mark&gt; &lt;mark&gt;标签支持全局属性，因此可以通过自定义style修改mark的样式。 参考这个↓： HTML参考手册|编程字典 12&lt;mark&gt;原始样式&lt;/mark&gt;&lt;mark style=&quot;font:&#x27;微软雅黑&#x27;;color:red;font-weight:900&quot;&gt;CSS样式&lt;/mark&gt; 原始样式CSS样式","categories":["手册"]},{"title":"Visual Assist 快捷键整理","path":"/手册/快捷键整理/Visual Assist 快捷键/","content":"Visual Assist 快捷键： shift+alt+F 查找引用alt+M 查看当前文件下函数列表alt+up 将当前行的代码放到上一行alt+down 将当前行的代码放到下一行alt+O .h&#x2F;.cpp文件的切换Ctrl + -：光标回到上一处Ctrl + Shift + -：光标回到下一处Alt + G：快速跳到定义 shift+alt+O 打开解决方案文件对话框shift+alt+S 查找某个对象或是变量shift+alt+Q 鼠标定位到函数名上，若是在cpp文件中，则按此快捷键会弹出右键菜单，里面有一个选项–创建声明。 与Alt+O配合会比较方便。shift+alt+F 找到对象的所有引用shift+alt+R 找到所有对象并重命名","tags":["快捷键","VA"],"categories":["手册","快捷键整理"]},{"title":"写作协作手册","path":"/手册/写作样式/","content":"[toc] 暂时我不想知道你在想什么！ 你想知道什么？ 123456#include&lt;iostream&gt;using namespace std;int main(int argc,const char *argv[])&#123; cout &lt;&lt; &quot;Hello World&quot;; return 0;&#125; 常用颜色代码color=maroon color=grey color=silver color=lightgrey color=HotPink color=DeepPink color=VioletRed color=Purple color=navy color=Blue color=DeepSkyBlue color=LightSkyBlue color=aqua color=DarkTurquoise color=LightSeaGreen color=YellowGreen color=GreenYellow color=Yellow color=Tomato color=red color=fuchsia color=MediumOrchid color=DarkViolet https://img.shields.io/badge/个人主页-fole_del.github.io-blue 常用模板（复杂度） ?style=plastic&amp;logo=appveyor ?style=flat&amp;logo=appveyor ?style=flat-square&amp;logo=appveyor ?style=for-the-badge&amp;logo=appveyor ?style=social&amp;logo=appveyor 其他快捷方式^_^ &#x2F;* default *&#x2F; default &#x2F;* success *&#x2F; success &#x2F;* primary *&#x2F; primary &#x2F;* info *&#x2F; info &#x2F;* warning *&#x2F; warning &#x2F;* danger *&#x2F; danger 动画 需要注意的是在使用时需要添加fas的属性，如&lt;span class=&quot;fas faa-wrench animated&quot;&gt;&lt;/span&gt; 小康博客 On DOM load On hover On parent hover faa-wrench animated faa-wrench animated-hover faa-wrench faa-ring animated faa-ring animated-hover faa-ring faa-horizontal animated faa-horizontal animated-hover faa-horizontal faa-vertical animated faa-vertical animated-hover faa-vertical faa-flash animated faa-flash animated-hover faa-flash faa-bounce animated faa-bounce animated-hover faa-bounce faa-spin animated faa-spin animated-hover faa-spin faa-float animated faa-float animated-hover faa-float faa-pulse animated faa-pulse animated-hover faa-pulse faa-shake animated faa-shake animated-hover faa-shake faa-tada animated faa-tada animated-hover faa-tada faa-passing animated faa-passing animated-hover faa-passing faa-passing-reverse animated faa-passing-reverse animated-hover faa-passing-reverse faa-burst animated faa-burst animated-hover faa-burst faa-falling animated faa-falling animated-hover faa-falling faa-rising animated faa-rising animated-hover faa-rising 外挂标签checkbox1234567891011121314151617&#123;% checkbox 纯文本测试 %&#125;&#123;% checkbox checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;&#123;% checkbox red, 支持自定义颜色 %&#125;&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;&#123;% checkbox plus green checked, 增加 %&#125;&#123;% checkbox minus yellow checked, 减少 %&#125;&#123;% checkbox times red checked, 叉 %&#125;&#123;% radio 纯文本测试 %&#125;&#123;% radio checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;&#123;% radio red, 支持自定义颜色 %&#125;&#123;% radio green, 绿色 %&#125;&#123;% radio yellow, 黄色 %&#125;&#123;% radio cyan, 青色 %&#125;&#123;% radio blue, 蓝色 %&#125; 所有表情:a: :ab: :abc: :abcd: :accept: :aerial_tramway: :afghanistan: :airplane: :central_african_republic: :earth_africa: :south_africa: :aland_islands: :alarm_clock: :alembic: 😄 :smile: 😆 :laughing: 😊 :blush: 😃 :smiley: ☺️ :relaxed: 😏 :smirk: 😍 :heart_eyes: 😘 :kissing_heart: 😚 :kissing_closed_eyes: 😳 :flushed: 😌 :relieved: 😆 :satisfied: 😁 :grin: 😉 :wink: 😜 :stuck_out_tongue_winking_eye: 😝 :stuck_out_tongue_closed_eyes: 😀 :grinning: 😗 :kissing: 😙 :kissing_smiling_eyes: 😛 :stuck_out_tongue: 😴 :sleeping: 😟 :worried: 😦 :frowning: 😧 :anguished: 😮 :open_mouth: 😬 :grimacing: 😕 :confused: 😯 :hushed: 😑 :expressionless: 😒 :unamused: 😅 :sweat_smile: 😓 :sweat: 😥 :disappointed_relieved: 😩 :weary: 😔 :pensive: 😞 :disappointed: 😖 :confounded: 😨 :fearful: 😰 :cold_sweat: 😣 :persevere: 😢 :cry: 😭 :sob: 😂 :joy: 😲 :astonished: 😱 :scream: 😫 :tired_face: 😠 :angry: 😡 :rage: 😤 :triumph: 😪 :sleepy: 😋 :yum: 😷 :mask: 😎 :sunglasses: 😵 :dizzy_face: 👿 :imp: 😈 :smiling_imp: 😐 :neutral_face: 😶 :no_mouth: 😇 :innocent: 👽 :alien: 💛 :yellow_heart: 💙 :blue_heart: 💜 :purple_heart: ❤️ :heart: 💚 :green_heart: 💔 :broken_heart: 💓 :heartbeat: 💗 :heartpulse: 💕 :two_hearts: 💞 :revolving_hearts: 💘 :cupid: 💖 :sparkling_heart: ✨ :sparkles: ⭐️ :star: 🌟 :star2: 💫 :dizzy: 💥 :boom: 💥 :collision: 💢 :anger: ❗️ :exclamation: ❓ :question: ❕ :grey_exclamation: ❔ :grey_question: 💤 :zzz: 💨 :dash: 💦 :sweat_drops: 🎶 :notes: 🎵 :musical_note: 🔥 :fire: 💩 :hankey: 💩 :poop: 💩 :shit: 👍 :+1: 👍 :thumbsup: 👎 :-1: 👎 :thumbsdown: 👌 :ok_hand: 👊 :punch: 👊 :facepunch: ✊ :fist: ✌️ :v: 👋 :wave: ✋ :hand: ✋ :raised_hand: 👐 :open_hands: ☝️ :point_up: 👇 :point_down: 👈 :point_left: 👉 :point_right: 🙌 :raised_hands: 🙏 :pray: 👆 :point_up_2: 👏 :clap: 💪 :muscle: 🤘 :metal: 🖕 :fu: 🚶 :walking: 🏃 :runner: 🏃 :running: 👫 :couple: 👪 :family: 👬 :two_men_holding_hands: 👭 :two_women_holding_hands: 💃 :dancer: 👯 :dancers: 🙆 :ok_woman: 🙅 :no_good: 💁 :information_desk_person: 🙋 :raising_hand: 👰 :bride_with_veil: 🙎 :person_with_pouting_face: 🙍 :person_frowning: 🙇 :bow: :couplekiss: :couplekiss: 💑 :couple_with_heart: 💆 :massage: 💇 :haircut: 💅 :nail_care: 👦 :boy: 👧 :girl: 👩 :woman: 👨 :man: 👶 :baby: 👵 :older_woman: 👴 :older_man: 👱 :person_with_blond_hair: 👲 :man_with_gua_pi_mao: 👳 :man_with_turban: 👷 :construction_worker: 👮 :cop: 👼 :angel: 👸 :princess: 😺 :smiley_cat: 😸 :smile_cat: 😻 :heart_eyes_cat: 😽 :kissing_cat: 😼 :smirk_cat: 🙀 :scream_cat: 😿 :crying_cat_face: 😹 :joy_cat: 😾 :pouting_cat: 👹 :japanese_ogre: 👺 :japanese_goblin: 🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil: 💂 :guardsman: 💀 :skull: 🐾 :feet: 👄 :lips: 💋 :kiss: 💧 :droplet: 👂 :ear: 👀 :eyes: 👃 :nose: 👅 :tongue: 💌 :love_letter: 👤 :bust_in_silhouette: 👥 :busts_in_silhouette: 💬 :speech_balloon: 💭 :thought_balloon: Nature ☀️ :sunny: ☔️ :umbrella: ☁️ :cloud: ❄️ :snowflake: ⛄️ :snowman: ⚡️ :zap: 🌀 :cyclone: 🌁 :foggy: 🌊 :ocean: 🐱 :cat: 🐶 :dog: 🐭 :mouse: 🐹 :hamster: 🐰 :rabbit: 🐺 :wolf: 🐸 :frog: 🐯 :tiger: 🐨 :koala: 🐻 :bear: 🐷 :pig: 🐽 :pig_nose: 🐮 :cow: 🐗 :boar: 🐵 :monkey_face: 🐒 :monkey: 🐴 :horse: 🐎 :racehorse: 🐫 :camel: 🐑 :sheep: 🐘 :elephant: 🐼 :panda_face: 🐍 :snake: 🐦 :bird: 🐤 :baby_chick: 🐥 :hatched_chick: 🐣 :hatching_chick: 🐔 :chicken: 🐧 :penguin: 🐢 :turtle: 🐛 :bug: 🐝 :honeybee: 🐜 :ant: 🐞 :beetle: 🐌 :snail: 🐙 :octopus: 🐠 :tropical_fish: 🐟 :fish: 🐳 :whale: 🐋 :whale2: 🐬 :dolphin: 🐄 :cow2: 🐏 :ram: 🐀 :rat: 🐃 :water_buffalo: 🐅 :tiger2: 🐇 :rabbit2: 🐉 :dragon: 🐐 :goat: 🐓 :rooster: 🐕 :dog2: 🐖 :pig2: 🐁 :mouse2: 🐂 :ox: 🐲 :dragon_face: 🐡 :blowfish: 🐊 :crocodile: 🐪 :dromedary_camel: 🐆 :leopard: 🐈 :cat2: 🐩 :poodle: 🐾 :paw_prints: 💐 :bouquet: 🌸 :cherry_blossom: 🌷 :tulip: 🍀 :four_leaf_clover: 🌹 :rose: 🌻 :sunflower: 🌺 :hibiscus: 🍁 :maple_leaf: 🍃 :leaves: 🍂 :fallen_leaf: 🌿 :herb: 🍄 :mushroom: 🌵 :cactus: 🌴 :palm_tree: 🌲 :evergreen_tree: 🌳 :deciduous_tree: 🌰 :chestnut: 🌱 :seedling: 🌼 :blossom: 🌾 :ear_of_rice: 🐚 :shell: 🌐 :globe_with_meridians: 🌞 :sun_with_face: 🌝 :full_moon_with_face: 🌚 :new_moon_with_face: 🌑 :new_moon: 🌒 :waxing_crescent_moon: 🌓 :first_quarter_moon: 🌔 :waxing_gibbous_moon: 🌕 :full_moon: 🌖 :waning_gibbous_moon: 🌗 :last_quarter_moon: 🌘 :waning_crescent_moon: 🌜 :last_quarter_moon_with_face: 🌛 :first_quarter_moon_with_face: 🌔 :moon: 🌍 :earth_africa: 🌎 :earth_americas: 🌏 :earth_asia: 🌋 :volcano: 🌌 :milky_way: ⛅️ :partly_sunny: Objects 🎍 :bamboo: 💝 :gift_heart: 🎎 :dolls: 🎒 :school_satchel: 🎓 :mortar_board: 🎏 :flags: 🎆 :fireworks: 🎇 :sparkler: 🎐 :wind_chime: 🎑 :rice_scene: 🎃 :jack_o_lantern: 👻 :ghost: 🎅 :santa: 🎄 :christmas_tree: 🎁 :gift: 🔔 :bell: 🔕 :no_bell: 🎋 :tanabata_tree: 🎉 :tada: 🎊 :confetti_ball: 🎈 :balloon: 🔮 :crystal_ball: 💿 :cd: 📀 :dvd: 💾 :floppy_disk: 📷 :camera: 📹 :video_camera: 🎥 :movie_camera: 💻 :computer: 📺 :tv: 📱 :iphone: ☎️ :phone: ☎️ :telephone: 📞 :telephone_receiver: 📟 :pager: 📠 :fax: 💽 :minidisc: 📼 :vhs: 🔉 :sound: 🔈 :speaker: 🔇 :mute: 📢 :loudspeaker: 📣 :mega: ⌛️ :hourglass: ⏳ :hourglass_flowing_sand: ⏰ :alarm_clock: ⌚️ :watch: 📻 :radio: 📡 :satellite: ➿ :loop: 🔍 :mag: 🔎 :mag_right: 🔓 :unlock: 🔒 :lock: 🔏 :lock_with_ink_pen: 🔐 :closed_lock_with_key: 🔑 :key: 💡 :bulb: 🔦 :flashlight: 🔆 :high_brightness: 🔅 :low_brightness: 🔌 :electric_plug: 🔋 :battery: 📲 :calling: ✉️ :email: 📫 :mailbox: 📮 :postbox: 🛀 :bath: 🛁 :bathtub: 🚿 :shower: 🚽 :toilet: 🔧 :wrench: 🔩 :nut_and_bolt: 🔨 :hammer: 💺 :seat: 💰 :moneybag: 💴 :yen: 💵 :dollar: 💷 :pound: 💶 :euro: 💳 :credit_card: 💸 :money_with_wings: 📧 :e-mail: 📥 :inbox_tray: 📤 :outbox_tray: ✉️ :envelope: 📨 :incoming_envelope: 📯 :postal_horn: 📪 :mailbox_closed: 📬 :mailbox_with_mail: 📭 :mailbox_with_no_mail: 🚪 :door: 🚬 :smoking: 💣 :bomb: 🔫 :gun: 🔪 :hocho: 💊 :pill: 💉 :syringe: 📄 :page_facing_up: 📃 :page_with_curl: 📑 :bookmark_tabs: 📊 :bar_chart: 📈 :chart_with_upwards_trend: 📉 :chart_with_downwards_trend: 📜 :scroll: 📋 :clipboard: 📆 :calendar: 📅 :date: 📇 :card_index: 📁 :file_folder: 📂 :open_file_folder: ✂️ :scissors: 📌 :pushpin: 📎 :paperclip: ✒️ :black_nib: ✏️ :pencil2: 📏 :straight_ruler: 📐 :triangular_ruler: 📕 :closed_book: 📗 :green_book: 📘 :blue_book: 📙 :orange_book: 📓 :notebook: 📔 :notebook_with_decorative_cover: 📒 :ledger: 📚 :books: 🔖 :bookmark: 📛 :name_badge: 🔬 :microscope: 🔭 :telescope: 📰 :newspaper: 🏈 :football: 🏀 :basketball: ⚽️ :soccer: ⚾️ :baseball: 🎾 :tennis: 🎱 :8ball: 🏉 :rugby_football: 🎳 :bowling: ⛳️ :golf: 🚵 :mountain_bicyclist: 🚴 :bicyclist: 🏇 :horse_racing: 🏂 :snowboarder: 🏊 :swimmer: 🏄 :surfer: 🎿 :ski: ♠️ :spades: ♥️ :hearts: ♣️ :clubs: ♦️ :diamonds: 💎 :gem: 💍 :ring: 🏆 :trophy: 🎼 :musical_score: 🎹 :musical_keyboard: 🎻 :violin: 👾 :space_invader: 🎮 :video_game: 🃏 :black_joker: 🎴 :flower_playing_cards: 🎲 :game_die: 🎯 :dart: 🀄️ :mahjong: 🎬 :clapper: 📝 :memo: 📝 :pencil: 📖 :book: 🎨 :art: 🎤 :microphone: 🎧 :headphones: 🎺 :trumpet: 🎷 :saxophone: 🎸 :guitar: 👞 :shoe: 👡 :sandal: 👠 :high_heel: 💄 :lipstick: 👢 :boot: 👕 :shirt: 👕 :tshirt: 👔 :necktie: 👚 :womans_clothes: 👗 :dress: 🎽 :running_shirt_with_sash: 👖 :jeans: 👘 :kimono: 👙 :bikini: 🎀 :ribbon: 🎩 :tophat: 👑 :crown: 👒 :womans_hat: 👞 :mans_shoe: 🌂 :closed_umbrella: 💼 :briefcase: 👜 :handbag: 👝 :pouch: 👛 :purse: 👓 :eyeglasses: 🎣 :fishing_pole_and_fish: ☕️ :coffee: 🍵 :tea: 🍶 :sake: 🍼 :baby_bottle: 🍺 :beer: 🍻 :beers: 🍸 :cocktail: 🍹 :tropical_drink: 🍷 :wine_glass: 🍴 :fork_and_knife: 🍕 :pizza: 🍔 :hamburger: 🍟 :fries: 🍗 :poultry_leg: 🍖 :meat_on_bone: 🍝 :spaghetti: 🍛 :curry: 🍤 :fried_shrimp: 🍱 :bento: 🍣 :sushi: 🍥 :fish_cake: 🍙 :rice_ball: 🍘 :rice_cracker: 🍚 :rice: 🍜 :ramen: 🍲 :stew: 🍢 :oden: 🍡 :dango: 🥚 :egg: 🍞 :bread: 🍩 :doughnut: 🍮 :custard: 🍦 :icecream: 🍨 :ice_cream: 🍧 :shaved_ice: 🎂 :birthday: 🍰 :cake: 🍪 :cookie: 🍫 :chocolate_bar: 🍬 :candy: 🍭 :lollipop: 🍯 :honey_pot: 🍎 :apple: 🍏 :green_apple: 🍊 :tangerine: 🍋 :lemon: 🍒 :cherries: 🍇 :grapes: 🍉 :watermelon: 🍓 :strawberry: 🍑 :peach: 🍈 :melon: 🍌 :banana: 🍐 :pear: 🍍 :pineapple: 🍠 :sweet_potato: 🍆 :eggplant: 🍅 :tomato: 🌽 :corn: Places 🏠 :house: 🏡 :house_with_garden: 🏫 :school: 🏢 :office: 🏣 :post_office: 🏥 :hospital: 🏦 :bank: 🏪 :convenience_store: 🏩 :love_hotel: 🏨 :hotel: 💒 :wedding: ⛪️ :church: 🏬 :department_store: 🏤 :european_post_office: 🌇 :city_sunrise: 🌆 :city_sunset: 🏯 :japanese_castle: 🏰 :european_castle: ⛺️ :tent: 🏭 :factory: 🗼 :tokyo_tower: 🗾 :japan: 🗻 :mount_fuji: 🌄 :sunrise_over_mountains: 🌅 :sunrise: 🌠 :stars: 🗽 :statue_of_liberty: 🌉 :bridge_at_night: 🎠 :carousel_horse: 🌈 :rainbow: 🎡 :ferris_wheel: ⛲️ :fountain: 🎢 :roller_coaster: 🚢 :ship: 🚤 :speedboat: ⛵️ :boat: ⛵️ :sailboat: 🚣 :rowboat: ⚓️ :anchor: 🚀 :rocket: ✈️ :airplane: 🚁 :helicopter: 🚂 :steam_locomotive: 🚊 :tram: 🚞 :mountain_railway: 🚲 :bike: 🚡 :aerial_tramway: 🚟 :suspension_railway: 🚠 :mountain_cableway: 🚜 :tractor: 🚙 :blue_car: 🚘 :oncoming_automobile: 🚗 :car: 🚗 :red_car: 🚕 :taxi: 🚖 :oncoming_taxi: 🚛 :articulated_lorry: 🚌 :bus: 🚍 :oncoming_bus: 🚨 :rotating_light: 🚓 :police_car: 🚔 :oncoming_police_car: 🚒 :fire_engine: 🚑 :ambulance: 🚐 :minibus: 🚚 :truck: 🚋 :train: 🚉 :station: 🚆 :train2: 🚅 :bullettrain_front: 🚄 :bullettrain_side: 🚈 :light_rail: 🚝 :monorail: 🚃 :railway_car: 🚎 :trolleybus: 🎫 :ticket: ⛽️ :fuelpump: 🚦 :vertical_traffic_light: 🚥 :traffic_light: ⚠️ :warning: 🚧 :construction: 🔰 :beginner: 🏧 :atm: 🎰 :slot_machine: 🚏 :busstop: 💈 :barber: ♨️ :hotsprings: 🏁 :checkered_flag: 🎌 :crossed_flags: 🏮 :izakaya_lantern: 🗿 :moyai: 🎪 :circus_tent: 🎭 :performing_arts: 📍 :round_pushpin: 🚩 :triangular_flag_on_post: 🇯🇵 :jp: 🇰🇷 :kr: 🇨🇳 :cn: 🇺🇸 :us: 🇫🇷 :fr: 🇪🇸 :es: 🇮🇹 :it: 🇷🇺 :ru: 🇬🇧 :gb: 🇬🇧 :uk: 🇩🇪 :de: Symbols 1️⃣ :one: 2️⃣ :two: 3️⃣ :three: 4️⃣ :four: 5️⃣ :five: 6️⃣ :six: 7️⃣ :seven: 8️⃣ :eight: 9️⃣ :nine: 🔟 :keycap_ten: 🔢 :1234: 0️⃣ :zero: #️⃣ :hash: 🔣 :symbols: ◀️ :arrow_backward: ⬇️ :arrow_down: ▶️ :arrow_forward: ⬅️ :arrow_left: 🔠 :capital_abcd: 🔡 :abcd: 🔤 :abc: ↙️ :arrow_lower_left: ↘️ :arrow_lower_right: ➡️ :arrow_right: ⬆️ :arrow_up: ↖️ :arrow_upper_left: ↗️ :arrow_upper_right: ⏬ :arrow_double_down: ⏫ :arrow_double_up: 🔽 :arrow_down_small: ⤵️ :arrow_heading_down: ⤴️ :arrow_heading_up: ↩️:leftwards_arrow_with_hook: ↪️ :arrow_right_hook: ↔️ :left_right_arrow: ↕️ :arrow_up_down: 🔼 :arrow_up_small: 🔃 :arrows_clockwise: 🔄 :arrows_counterclockwise: ⏪ :rewind: ⏩ :fast_forward: ℹ️ :information_source: 🆗 :ok: 🔀 :twisted_rightwards_arrows: 🔁 :repeat: 🔂 :repeat_one: 🆕 :new: 🔝 :top: 🆙 :up: 🆒 :cool: 🆓 :free: 🆖 :ng: 🎦 :cinema: 🈁 :koko: 📶 :signal_strength: 🈹 :u5272: 🈴 :u5408: 🈺 :u55b6: 🈯️ :u6307: 🈷️ :u6708: 🈶 :u6709: 🈵 :u6e80: 🈚️ :u7121: 🈸 :u7533: 🈳 :u7a7a: 🈲 :u7981: 🈂️ :sa: 🚻 :restroom: 🚹 :mens: 🚺 :womens: 🚼 :baby_symbol: 🚭 :no_smoking: 🅿️ :parking: ♿️ :wheelchair: 🚇 :metro: 🛄 :baggage_claim: 🉑 :accept: 🚾 :wc: 🚰 :potable_water: 🚮 :put_litter_in_its_place: ㊙️ :secret: ㊗️ :congratulations: Ⓜ️ :m: 🛂 :passport_control: 🛅 :left_luggage: 🛃 :customs: 🉐 :ideograph_advantage: 🆑 :cl: 🆘 :sos: 🆔 :id: 🚫 :no_entry_sign: 🔞 :underage: 📵 :no_mobile_phones: 🚯 :do_not_litter: 🚱 :non-potable_water: 🚳 :no_bicycles: 🚷 :no_pedestrians: 🚸 :children_crossing: ⛔️ :no_entry: ✳️ :eight_spoked_asterisk: ✴️ :eight_pointed_black_star: 💟 :heart_decoration: 🆚 :vs: 📳 :vibration_mode: 📴 :mobile_phone_off: 💹 :chart: 💱 :currency_exchange: ♈️ :aries: ♉️ :taurus: ♊️ :gemini: ♋️ :cancer: ♌️ :leo: ♍️ :virgo: ♎️ :libra: ♏️ :scorpius: ♐️ :sagittarius: ♑️ :capricorn: ♒️ :aquarius: ♓️ :pisces: ⛎ :ophiuchus: 🔯 :six_pointed_star: ❎:negative_squared_cross_mark: 🅰️ :a: 🅱️ :b: 🆎 :ab: 🅾️ :o2: 💠:diamond_shape_with_a_dot_inside: ♻️ :recycle: 🔚 :end: 🔛 :on: 🔜 :soon: 🕐 :clock1: 🕜 :clock130: 🕙 :clock10: 🕥 :clock1030: 🕚 :clock11: 🕦 :clock1130: 🕛 :clock12: 🕧 :clock1230: 🕑 :clock2: 🕝 :clock230: 🕒 :clock3: 🕞 :clock330: 🕓 :clock4: 🕟 :clock430: 🕔 :clock5: 🕠 :clock530: 🕕 :clock6: 🕡 :clock630: 🕖 :clock7: 🕢 :clock730: 🕗 :clock8: 🕣 :clock830: 🕘 :clock9: 🕤 :clock930: 💲 :heavy_dollar_sign: ©️ :copyright: ®️ :registered: ™️ :tm: ❌ :x: ❗️ :heavy_exclamation_mark: ‼️ :bangbang: ⁉️ :interrobang: ⭕️ :o: ✖️ :heavy_multiplication_x: ➕ :heavy_plus_sign: ➖ :heavy_minus_sign: ➗ :heavy_division_sign: 💮 :white_flower: 💯 :100: ✔️ :heavy_check_mark: ☑️ :ballot_box_with_check: 🔘 :radio_button: 🔗 :link: ➰ :curly_loop: 〰️ :wavy_dash: 〽️ :part_alternation_mark: 🔱 :trident: :black_square: :black_square: :white_square: :white_square: ✅ :white_check_mark: 🔲 :black_square_button: 🔳 :white_square_button: ⚫️ :black_circle: ⚪️ :white_circle: 🔴 :red_circle: 🔵 :large_blue_circle: 🔷 :large_blue_diamond: 🔶 :large_orange_diamond: 🔹 :small_blue_diamond: 🔸 :small_orange_diamond: 🔺 :small_red_triangle: 🔻 :small_red_triangle_down: span list12345678910111213141516171819202122231&lt;span class=&quot;fas faa-ring animated-hover&quot; style=&quot;border-bottom:3px solid green&quot;&gt;《半小时漫画中国哲学史》&lt;/span&gt;2&lt;span style=&quot;text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;&quot;&gt;“ 既许一人以偏爱，愿尽余生之慷慨 ”&lt;/span&gt;3&lt;span style=&quot;class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;&quot;&gt;[data.json文件链接](https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA )&lt;/span&gt; 4 &lt;mark style=&quot;background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas&quot;&gt;当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。&lt;/mark&gt;5&lt;span style=&quot;background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900&quot;&gt;存储结构管理主要就是通过对表空间的管理来实现的&lt;/span&gt;6&lt;mark style=&quot;background:green;border-radius:10px;color:white&quot;&gt;效果如下：&lt;/mark&gt;7&lt;font size=10px style=&quot;font-weight:700;font-family:&#x27;华文彩云&#x27;;color:rgb(100,190,100)&quot;&gt;基本语言(一)&lt;/font&gt;8&lt;span style=&quot;border-bottom: 2px dashed #000000&quot;&gt;代码段、数据段、BSS段、堆区、文件映射区以及栈区&lt;/span&gt;9&lt;div style=&quot;background:black;font:conloas;color:white;&quot;&gt;&amp;nbsp;数组长度为：3&lt;br&gt;&amp;nbsp;请按任意键继续. . .&lt;/div&gt;10&lt;mark style=&quot;color:white;background:red;font-weight:600;border_radius:100px&quot;&gt;但效率更高&lt;/mark&gt; 《半小时漫画中国哲学史》 “ 既许一人以偏爱，愿尽余生之慷慨 ” data.json文件链接 当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。 存储结构管理主要就是通过对表空间的管理来实现的 效果如下： 基本语言(一) 代码段、数据段、BSS段、堆区、文件映射区以及栈区 &nbsp; 数组长度为：3 &nbsp; 请按任意键继续. . . 但效率更高 For the BadgeFor the Badge","tags":["手册","CSS"],"categories":["手册"]},{"title":"常用变量名缩写","path":"/手册/常用变量名缩写/","content":"变量名 缩写 addition add address addr administrator adm answer ans application app arguments args array arr assemble asm asynchronization asyn attribute attr authority&#x2F;authorize auth average avg begin beg bitmap bmp break brk buffer buf&#x2F;buff button btn calculate calc calendar cal character char click clk clock clk color clr column col command cmd compare cmp config conf configuration cfg container cntr control ctrl coordinates coord copy cpy count cnt current cur cylinder cyl database db debug dbg decrease dec default def define def delete del department dept dependency&#x2F;dependent&#x2F;depends dep destination dst&#x2F;dest develop dev device dev dialog dlg dictionary dict display disp division div document doc double dbl driver drv duplicate&#x2F;duplication dup educate&#x2F;education edu equal&#x2F;equality&#x2F;equivalence&#x2F;equivalent eq error err escape esc execute exec extend ext float flt frame frm frequency freq function func government gov group grp hexadecimal hex horizontal horz image img implement impl increment inc index idx individual indv information info initialize init insert ins instance ins interrupt intr iterator it lable lbl length len library lib link lnk list lst maximum max memory mem message msg middle mid minimum min multiplication mul navigation nav negative neg number num object obj offset ofs operator opr optimization opt organization org original orig 变量名 缩写 package pkg parameter param password pwd picture pic point pt pointer ptr position pos positive pos previous pre print prn program prg properties props public pub receive&#x2F;received recv record rec reference ref register reg request req resource res result res response rsp return ret screen scr second sec segment seg select sel semaphore sem sequence seq server srv signal sig source src stack stk standard std statistic stat status stat storage stg string str student stu subtraction sub summation&#x2F;summary sum synchronize sync system sys table tbl temporary tmp&#x2F;temp test tst text txt time stamp ts total tot translate trans update upd upgrade upg unknown unk user usr utility util value val variable var version ver vertical vert window win thread thrd","tags":["手册","变量"],"categories":["手册"]},{"title":"Fork快捷键整理","path":"/手册/快捷键整理/Fork/","content":"[toc] Fork 快捷键General Navigation Ctrl1 - Show Changes view (second press will focus commit field) Ctrl2 - Show All Commits view (second press will jump to HEAD) Ctrl0 - Reveal HEAD CtrlP - Show Quick Launch window CtrlTab - Select next tab CtrlShiftTab - Select previous tab CtrlT - Open new tab CtrlW - Close current tab Ctrl&#x3D;&#x2F;Ctrl- Zoom in&#x2F; Zoom out Ctrl, - Open Fork preferences All Commits View Ctrl0 - Jump to HEAD CtrlF - Commit search Enter, F3 - Jump to next search result ShiftEnter, ShiftF3 - Jump to previous search result CtrlC - Copy commit info Delete - Remove branch&#x2F;stash CtrlShiftA - Filter by active branch Changes View CtrlEnter - Commit CtrlShiftEnter - Commit and push Ctrl1 - Focus commit message field CtrlF - Filter Enter, CtrlShiftS - Stage&#x2F;unstage selected file (or lines) CtrlAltShiftS - Stage&#x2F;unstage all files Backspace, CtrlShiftD - Discard selected file (or lines) CtrlO - Open selected file CtrlD - Open selected file in external diff tool CtrlC - Copy selected file full path Repository F5 - Refresh CtrlShiftN - Init new repository CtrlN - Clone new repository CtrlO - Open repository CtrlShiftF - Fetch CtrlAltShiftF (Ctrl + click on button) - Quick Fetch CtrlShiftL - Pull CtrlAltShiftL (Ctrl + click on button) - Quick Pull CtrlShiftP - Push CtrlAltShiftP (Ctrl + click on button) - Quick Push CtrlShiftB - New branch CtrlShiftT - New tag CtrlShiftH - Create stash CtrlAltO - Open in File Explorer CtrlAltT - Open in Terminal Repository Manager F2 - Rename Repository Delete - Remove Repository Enter - Open Repository","tags":["快捷键"],"categories":["手册","快捷键整理"]},{"title":"Wiki自动更新脚本","path":"/手册/个人配置/自动提交脚本/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@echo off:reInputecho Git自动更新脚本（输入序号选择命令）echo ===================================================================================echo 1 （:memo: 更新文档）echo 2 （:fire:）echo 3 （:wrench: 部署）echo 4 （:bug:）echo 5 （手动添加commit信息）echo ===================================================================================echo.echo=choice /c:12345 /m:&quot;请输入Git 数字命令更新变动：&quot;if %errorlevel% == 1 set change=&quot;:memo: 更新文档&quot;if %errorlevel% == 2 set change=&quot;:bug:&quot;if %errorlevel% == 3 set change=&quot;:wrench: 部署&quot;if %errorlevel% == 4 set change=&quot;:bug:&quot;if %errorlevel% == 5 set /p change=&quot;请输入Commit信息：&quot;if %change%==&quot;&quot; (clsecho -------echo 提交信息不能为空！echo -------goto reInput )echo.:: cd &quot;D:\\\\wiki\\\\&quot;git pullgit add .git commit -m %change%git pushecho.echo ===================================================================================echo 更新完毕echo.title &quot; update SUCCESS&quot;pause","tags":["手册","自定义","Config"],"categories":["手册","个人配置"]},{"title":"typora bluebook 自定义修改主题代码","path":"/手册/个人配置/typora主题自定义/","content":"说明 修改了目录中 代码块 的颜色 修改了编辑页面的最小宽度 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135@charset &quot;UTF-8&quot;;/* 自定义表格 */tr.md-end-block:hover &#123; background-color: dodgerblue; font-weight: 700; color: white;&#125;/*** Custom fonts ***/@import url(&#x27;./blubook/fonts.css&#x27;);/*** Color setting ***/:root &#123; --side-bar-bg-color: #183055; --active-file-bg-color: #2f4566; --active-file-text-color: #ffffff; --active-file-border-color: #757575; --active-search-item-bg-color: #23242b; --item-hover-bg-color: #ececec; --item-hover-text-color: #000000; --control-text-color: #ddd; --window-border: 1px solid #183055; --code-cursor: #f0f0f0;&#125;/*** Btn in search bar ***/#filesearch-case-option-btn,#filesearch-word-option-btn &#123; background: var(--side-bar-bg-color);&#125;/****** #write basic ******/#write &#123; position: static; width: 90%; min-width: 90%; max-width: 700px; line-height: 1.6; transform: none; height: auto;&#125;/****** #write h1-h6 ******/#write h1,#write h2,#write h3,#write h4,#write h5,#write h6,#write p,#write pre &#123; width: auto;&#125;#write h1::before,#write h2::before,#write h3::before,#write h4::before,#write h5::before,#write h6::before &#123; position: absolute; right: calc(100% + 10px); bottom: 0; color: #b4b4b4; font-size: 1rem; font-weight: bold; font-variant: &#x27;small-caps&#x27;; border: 0; border-radius: 0; left: auto; float: none; padding: 0;&#125;#write h1 &#123; font-size: 2.2rem; font-style: normal; font-weight: 800; line-height: 2; margin-top: 14px; margin-bottom: 14px;&#125;#write h1::before &#123; content: &#x27;H1&#x27;; bottom: 1rem;&#125;#write h2 &#123; font-size: 2rem; font-weight: 800; font-style: normal; line-height: 2; margin-top: 14px; margin-bottom: 14px;&#125;#write h2::before &#123; content: &#x27;H2&#x27;; bottom: .85rem;&#125;#write h3 &#123; font-size: 1.6rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;#write h3::before &#123; content: &#x27;H3&#x27;; top: .44rem; padding: 3px 0 3px 0;&#125;#write h4 &#123; font-size: 1.4rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;#write h4::before &#123; content: &#x27;H4&#x27;; top: .4rem;&#125;#write h5,#write h6 &#123; font-size: 1.2rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;#write h5::before,#write h6::before &#123; top: .2rem;&#125;#write h5::before &#123; content: &#x27;H5&#x27;;&#125;#write h6::before &#123; content: &#x27;H6&#x27;;&#125;h3.md-focus:before,h4.md-focus:before,h5.md-focus:before,h6.md-focus:before &#123; color: #ddd; color: var(--heading-char-color); border: 1px solid; border-radius: 3px; position: absolute; left: -1.642857143rem; top: .357142857rem; float: left; font-size: 9px; padding-left: 2px; padding-right: 2px; vertical-align: bottom; font-weight: 400; line-height: 2;&#125;/****** Global Style ******/body &#123; margin: 0; font-family: &#x27;Glow Sans SC&#x27;, -apple-system, sans-serif; font-weight: 500; text-rendering: geometricPrecision; -webkit-font-smoothing: antialiased; -webkit-text-size-adjust: 100%&#125;html,body &#123; color: #242A31; /* width: 100%; */ height: 100%; margin: 0; padding: 0; font-size: 14px; background: #ffffff; box-sizing: border-box; line-height: 1rem; text-size-adjust: 100%; -moz-osx-font-smoothing: grayscale; -webkit-text-size-adjust: 100%;&#125;hr &#123; border-color: #e6ecf1; height: 2px; border-top: 2px solid #e6ecf1;&#125;img &#123; max-width: 80%; margin-top: 0.2rem; margin-bottom: 0.2rem;&#125;/****** ul ol Style ******/ul&gt;li&gt;ul&gt;li &#123; list-style-type: circle;&#125;ul&gt;li&gt;ul&gt;li&gt;ul&gt;li &#123; list-style-type: square;&#125;ol,ul &#123; padding-left: 2rem; line-height: 1;&#125;ol&gt;li &#123; list-style-type: decimal&#125;ol&gt;li&gt;ol&gt;li &#123; list-style-type: lower-alpha&#125;ol&gt;li&gt;ol&gt;li&gt;ol&gt;li &#123; list-style-type: lower-roman&#125;/****** Table Style ******/table &#123; padding: 0; word-break: initial;&#125;table tr &#123; border-top: 1px solid #dfe2e5; margin: 0; padding: 0;&#125;table tr:nth-child(2n),thead &#123; background-color: #f5f7f9;&#125;table tr th &#123; font-weight: bold; border: 1px solid #dfe2e5; border-bottom: 0; margin: 0; padding: 6px 13px;&#125;table tr td &#123; border: 1px solid #dfe2e5; margin: 0; padding: 6px 13px;&#125;table tr th:first-child,table tr td:first-child &#123; margin-top: 0;&#125;table tr th:last-child,table tr td:last-child &#123; margin-bottom: 0;&#125;/****** YAML Style ******/pre.md-meta-block &#123; font-size: .85rem !important; color: #5d5d5d; min-height: .8rem; white-space: pre-wrap; background: #f5f7f9; display: block; overflow-x: hidden; padding: 1rem; border-radius: 8px;&#125;/****** Global Text ******/p &#123; font-size: 16px; font-family: &quot;Glow Sans SC&quot;, -apple-system, sans-serif; font-weight: 500; line-height: 1.6; font-style: normal; color: rgb(59, 69, 78);&#125;a &#123; /* color: rgb(164, 78, 237); */ color: rgb(56, 132, 254); font-weight: 500; text-decoration: none; text-decoration-style: none; cursor: pointer; padding: 0 3px 0 3px;&#125;#write a:hover &#123; color: rgb(56, 132, 254); text-decoration: underline; text-decoration-style: solid;&#125;strong &#123; font-weight: 700;&#125;mark &#123; background: #87CEFA; padding: 0 2px 0 2px; margin: 0 2px 0 2px;&#125;h1 &#123; font-size: 2rem; font-style: normal; font-weight: 800; line-height: 2; margin-top: 14px; margin-bottom: 14px;&#125;h2 &#123; font-size: 1.8rem; font-weight: 800; font-style: normal; line-height: 2; margin-top: 14px; margin-bottom: 14px;&#125;h3 &#123; font-size: 1.6rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;h4 &#123; font-size: 1.2rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;h5,h6 &#123; font-size: 1rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;/****** Print header ******/@media print &#123; .typora-export * &#123; -webkit-print-color-adjust: exact; &#125; #write h1::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125; #write h2::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125; #write h3::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125; #write h4::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125; #write h5::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125; #write h6::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125;&#125;/****** #write Code Fences ******/#write .md-fences &#123; -webkit-font-smoothing: initial; margin: 1rem 0 1rem 0 !important; line-height: 1.43rem; border-radius: 3px; font-size: 0.95rem; word-wrap: normal;&#125;#write .CodeMirror-wrap .CodeMirror-code pre &#123; padding-left: 30px; line-height: 1.55rem;&#125;#write .CodeMirror-cursors .CodeMirror-cursor &#123; border-left: 2px solid var(--code-cursor);&#125;#write code,tt &#123; margin: 0 2px; padding: 4px 6px; border-radius: 6px; font-size: 0.92rem !important; background: #f5f7f9; display: inline; vertical-align: bottom; line-height: 1.8;&#125;#write .md-footnote &#123; color: var(--main-5); background-color: var(--main-1);&#125;.cm-s-inner.CodeMirror,.cm-s-inner .CodeMirror-gutters &#123; padding: 0.75rem 0.15rem 0.75rem 0.15rem; background-color: #183055 !important; color: #f8f8f2 !important; border: none; border-radius: 6px;&#125;.code-tooltip &#123; box-shadow: 0 1px 1px 0 rgba(0, 28, 36, .3); border-top: 1px solid #eef2f2; background: #183055; border-radius: 6px;&#125;.md-fences &#123; font-size: .9rem; position: relative !important; display: block; page-break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit;&#125;.md-fences &#123; background-color: #f8f8f8; margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px;&#125;.md-fences,tt &#123; border-radius: 3px; /* color: #f0f0f0; */ padding: 0; font-size: 0.9rem;&#125;/****** Sidebar ******/#typora-sidebar * &#123; /* color: #f0f0f0; */ color: white;&#125;code &#123; color: #3399CC!important; font-weight: 700;&#125;#typora-sidebar .file-tree-node.file-library-file-node.active .file-node-background &#123; border-left: 5px solid #3884ff; height: 2.2rem;&#125;#sidebar-files-menu &#123; border: 1px solid rgba(0, 2, 3, 0.7);&#125;.file-list-item &#123; border-bottom: var(--window-border);&#125;.file-list-item &#123; overflow: hidden; padding: 12px; border-bottom: 1px solid #eee; border-bottom: var(--window-border); cursor: pointer; padding-right: 8px; padding-top: 12px; padding-left: 24px; transition: top .5s; -webkit-transition: top .5s;&#125;.file-list-item.active &#123; background: #2f4566; /* background: var(--active-file-bg-color); */ color: var(--active-file-text-color); border-radius: 12px;&#125;.file-list-item:not(.active) &#123; opacity: .9;&#125;.file-node-content &#123; padding-top: 6px; margin: 0 0 8px 0; cursor: default; color: var(--control-text-color); white-space: nowrap; height: 2.2rem; line-height: 1.5;&#125;.ty-on-drag-enter &#123; background-color: #2f4566; color: var(--item-hover-text-color);&#125;.file-node-content:active &#123; border-radius: 0px !important; background: #2f4566;&#125;.active .file-node-content &#123; font-weight: bold;&#125;.file-node-content:hover &#123; cursor: pointer; border-radius: 0px !important;&#125;.file-node-icon,.file-node-open-state &#123; display: block; float: left; line-height: 1.5; min-height: 15px;&#125;.file-node-icon &#123; margin-right: 6px;&#125;.file-list-item-file-name &#123; font-weight: 700; margin-bottom: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%; line-height: 2;&#125;.sidebar-footer &#123; background: var(--side-bar-bg-color); border-top: 1px #555 solid;&#125;.html-for-mac #file-library-search-input &#123; border: 0; border-bottom: 1px solid #ccc; line-height: 16px; margin: 5px 16px 0px 0; width: 0; /* -webkit-flex: 1; */ flex: 1; background: 0 0; color: #bbc0ca !important; /* transform: translateY(-3px); */ /* overflow: auto; */ padding-top: 6px;&#125;#typora-sidebar #ty-sidebar-footer .sidebar-footer-item:hover &#123; background: #021d43;&#125;#typora-sidebar #outline-content .outline-item:hover &#123; background: #202020;&#125;#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .show+.menuitem-group-label.show &#123; border-color: #202020;&#125;#typora-sidebar #ty-sidebar-footer &#123; border-top: 1px solid #19191c;&#125;#typora-sidebar #ty-sidebar-footer #sidebar-files-menu li&gt;a:hover &#123; background: #021d43;&#125;#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .ty-side-sort-btn.active,#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .ty-side-sort-btn:hover &#123; color: #3884FF;&#125;#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .ty-side-sort-btn.active &#123; background: #001129;&#125;#typora-sidebar .file-list-item.file-library-node:not(.active):hover &#123; background: #243959; border-radius: 12px;&#125;#typora-sidebar .file-tree-node.file-library-file-node:not(.active):hover .file-node-background &#123; background: #243959; border-radius: 12px; height: 2.2rem;&#125;/****** Quote style ******/blockquote &#123; position: relative; /* margin: 1rem 1 1rem 2rem; */ padding: 1rem; color: #827676; background-color: #f5f7f9; border-radius: 6px; line-height: 1;&#125;blockquote::before &#123; content: &#x27;&#x27;; position: absolute; top: 0rem; left: 0rem; height: 100%; width: .30rem; background: #3884ff; border-top-left-radius: 6px; border-bottom-left-radius: 6px;&#125;/****** task list style ******/.task-list &#123; padding-left: 0;&#125;.md-task-list-item&gt;input &#123; top: -0.2rem; margin-left: -1.6rem; margin-top: calc(1rem + 1px); -webkit-appearance: initial;&#125;.md-task-list-item&gt;input:before &#123; border: 1px solid#0185ff; border-radius: 1rem; width: 1rem; height: 1rem; background: #fff; content: &#x27; &#x27;; transition: background-color 200ms ease-in-out; display: block;&#125;.md-task-list-item&gt;input:checked:before,.md-task-list-item&gt;input[checked]:before &#123; background: #0185ff; border-width: 1px; transition: background-color 200ms ease-in-out;&#125;.md-task-list-item&gt;input:checked:after,.md-task-list-item&gt;input[checked]:after &#123; opacity: 1;&#125;.md-task-list-item&gt;input:after &#123; opacity: 1; -webkit-transition: opacity 0.05s ease-in-out; -moz-transition: opacity 0.05s ease-in-out; transition: opacity 0.05s ease-in-out; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); transform: rotate(-45deg); position: absolute; top: 0.25rem; left: 0.19rem; width: 0.6rem; height: 0.375rem; border: 2px solid #fff; border-top: 0; border-right: 0; content: &#x27; &#x27;; opacity: 0;&#125;/****** Source style ******/.typora-sourceview-on #write &#123; display: none&#125;#typora-source &#123; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: inherit; padding-right: 0; padding-left: 0; padding-top: 0; display: none; line-height: 1.5&#125;.mac-seamless-mode #typora-source &#123; top: 20px&#125;#typora-source .CodeMirror &#123; height: 100%; overflow-x: hidden&#125;#typora-source .CodeMirror-gutters &#123; left: initial !important&#125;#typora-source .CodeMirror-lines &#123; padding-top: 30px; padding-bottom: 60px; padding-left: 60px; padding-right: 30px; max-width: 800px; margin: 0 auto&#125;#typora-source .CodeMirror-wrap .CodeMirror-scroll &#123; overflow-y: auto&#125;.CodeMirror-activeline .cm-trailing-space-new-line:after &#123; opacity: .6&#125;.CodeMirror-activeline .cm-starttab .cm-tab:after &#123; background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=); background-position: right; background-repeat: no-repeat; width: 100%; opacity: 1&#125;.CodeMirror-activeline .cm-startspace:after,.CodeMirror-activeline .cm-trailing-space-new-line:after &#123; opacity: .2&#125;.cm-s-inner .CodeMirror-vscrollbar &#123; display: none !important&#125;#typora-source .CodeMirror-gutter-wrapper &#123; position: absolute !important; left: -6ch !important; min-width: 4ch !important; text-align: right; font-family: monospace; font-size: .8rem; margin-top: .1rem; display: inline-block; opacity: .6&#125;#typora-source .CodeMirror-linenumber &#123; width: auto !important; visibility: hidden&#125;#typora-source .CodeMirror-sizer &#123; margin-left: 0 !important&#125;#typora-source .CodeMirror-gutter &#123; min-width: 4ch !important&#125;#typora-source .CodeMirror-activeline .CodeMirror-linenumber,#typora-source .CodeMirror-linenumber.CodeMirror-linenumber-show &#123; visibility: visible&#125;#typora-source .CodeMirror-code&gt;.CodeMirror-activeline::before,#typora-source .CodeMirror-code&gt;:first-child::before,#typora-source .CodeMirror-code&gt;:last-child::before,#typora-source .CodeMirror-code&gt;:nth-child(10n)::before &#123; visibility: visible&#125;.cm-s-typora-default .cm-header1:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 2.2rem;&#125;.cm-s-typora-default .cm-header2:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 2rem;&#125;.cm-s-typora-default .cm-header3:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 1.6rem;&#125;.cm-s-typora-default .cm-header4:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 1.4rem;&#125;.cm-s-typora-default .cm-header5:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 1.2rem;&#125;.cm-s-typora-default .cm-header6:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 1.2rem;&#125;.cm-s-typora-default .cm-header,.cm-s-typora-default .cm-property &#123; color: #183055 !important;&#125;pre.CodeMirror-line &#123; page-break-inside: avoid;&#125;/****** Code style ******/code &#123; font-size: .9rem; /* color: #333333; /* #537AA2; border: 1px solid #d0d0d0; */ font-family: &#x27;Cascadia Code&#x27;, Consolas, &#x27;Noto Sans SC&#x27;, &#x27;Courier New&#x27;, monospace; padding: .2rem .2rem; border-radius: 3px; background: #f5f7f9 !important; display: inline; vertical-align: bottom; line-height: 1.8;&#125;code,pre &#123; font-size: 95% !important; font-weight: normal; font-family: &#x27;Cascadia Code&#x27;, Consolas, &#x27;Noto Sans SC&#x27;, &#x27;Courier New&#x27;, monospace; -webkit-font-smoothing: initial; -moz-osx-font-smoothing: initial&#125;/****** The flow chart ******/pre.md-fences[lang=sequence].md-focus .md-diagram-panel,pre.md-fences[lang=flow].md-focus .md-diagram-panel,pre.md-fences[lang=mermaid].md-focus .md-diagram-panel &#123; position: -webkit-sticky; border: 1px solid #777; border-radius: 6px; margin-top: 6px;&#125;.code-tooltip .ty-input,.code-tooltip input &#123; background-color: transparent; border: 0; margin-top: 2px; margin-bottom: 2px; margin-left: 0; margin-right: 0; border-radius: 3px; text-align: center; min-width: 140px; display: inline-block; padding: 0 4px; line-height: 1.5; color: #fff;&#125;.enable-diagrams pre.md-fences[lang=sequence] .code-tooltip,.enable-diagrams pre.md-fences[lang=flow] .code-tooltip,.enable-diagrams pre.md-fences[lang=mermaid] .code-tooltip &#123; right: 8px; bottom: -2.2em;&#125;/****** Windows contral ******/.megamenu-menu-list li a.active,.megamenu-menu-list:not(.saved) li a:hover &#123; background-color: #285e8e;&#125;/****** Fix ******/.md-tab &#123; display: inline-block; white-space: pre; font-family: initial;&#125;div.md-mathjax-preview.mathjax-candidate.mathjax-candidate-show &#123; background-color: white !important; -webkit-user-modify: read-only;&#125;.mathjax-candidate &#123; text-align: center; padding-top: inherit; overflow-x: auto; padding: 10px 0; background-color: white;&#125;input &#123; font-weight: bold; background-color: inherit; background-color: var(--bg-color); color: var(--text-color) !important;&#125;#write input &#123; transform: translateY(-6.5px);&#125;.task-list &#123; padding-left: 0;&#125;.md-task-list-item&gt;input &#123; top: -0.2rem; margin-left: -1.6rem; margin-top: calc(1rem + 1px);&#125;.auto-suggest-container li &#123; padding: 1px; padding-left: 10px; padding-right: 10px; cursor: pointer; -webkit-user-select: none; user-select: none; min-width: 124px; position: relative; line-height: 1.4;&#125;.auto-suggest-container &#123; border: 1px solid #ddd; border-radius: 3px; box-shadow: 0 0 1px rgba(0, 0, 0, .1); position: fixed; background-color: #fff; background-color: var(--bg-color); z-index: 10; font-size: .9rem; display: none; padding: 4px 6px 4px 6px; line-height: 20px;&#125;/****** Code highlight ******/.cm-s-inner .CodeMirror-guttermarker,.cm-s-inner .CodeMirror-guttermarker-subtle,.cm-s-inner .CodeMirror-linenumber &#123; color: #596774;&#125;.cm-s-inner .CodeMirror-cursor &#123; border-left: 1px solid #f8f8f0;&#125;.cm-s-inner div.CodeMirror-selected &#123; background: rgba(255, 255, 255, 0.15);&#125;.cm-s-inner.CodeMirror-focused div.CodeMirror-selected &#123; background: rgba(255, 255, 255, 0.10);&#125;.cm-s-inner .CodeMirror-line::selection,.cm-s-inner .CodeMirror-line&gt;span::selection,.cm-s-inner .CodeMirror-line&gt;span&gt;span::selection &#123; background: rgba(255, 255, 255, 0.10);&#125;.cm-s-inner .CodeMirror-line::-moz-selection,.cm-s-inner .CodeMirror-line&gt;span::-moz-selection,.cm-s-inner .CodeMirror-line&gt;span&gt;span::-moz-selection &#123; background: rgba(255, 255, 255, 0.10);&#125;.cm-s-inner .CodeMirror-activeline-background &#123; background: rgba(0, 0, 0, 0);&#125;.cm-s-inner .cm-keyword &#123; color: rgba(199, 146, 234, 1);&#125;.cm-s-inner .cm-operator &#123; color: rgba(233, 237, 237, 1);&#125;.cm-s-inner .cm-variable-2 &#123; color: #80CBC4;&#125;.cm-s-inner .cm-variable-3 &#123; color: #82B1FF;&#125;.cm-s-inner .cm-builtin &#123; color: #DECB6B;&#125;.cm-s-inner .cm-atom &#123; color: #F77669;&#125;.cm-s-inner .cm-number &#123; color: #F77669;&#125;.cm-s-inner .cm-def &#123; color: rgba(233, 237, 237, 1);&#125;.cm-s-inner .cm-string &#123; color: #C3E88D;&#125;.cm-s-inner .cm-string-2 &#123; color: #80CBC4;&#125;.cm-s-inner .cm-comment &#123; color: #aebcc2;&#125;.cm-s-inner .cm-variable &#123; color: #82B1FF;&#125;.cm-s-inner .cm-tag &#123; color: #80CBC4;&#125;.cm-s-inner .cm-meta &#123; color: #80CBC4;&#125;.cm-s-inner .cm-attribute &#123; color: #FFCB6B;&#125;.cm-s-inner .cm-property &#123; color: #80CBAE;&#125;.cm-s-inner .cm-qualifier &#123; color: #DECB6B;&#125;.cm-s-inner .cm-variable-3 &#123; color: #DECB6B;&#125;.cm-s-inner .cm-tag &#123; color: rgba(255, 83, 112, 1);&#125;.cm-s-inner .cm-error &#123; color: rgba(255, 255, 255, 1.0); background-color: #EC5F67;&#125;.cm-s-inner .CodeMirror-matchingbracket &#123; text-decoration: underline; color: white !important;&#125;.cm-s-inner .cm-header,.cm-s-inner.cm-header &#123; color: #334EEA;&#125;.md-fences .code-tooltip &#123; background-color: #263238;&#125;","tags":["手册","自定义","themes"],"categories":["手册","个人配置"]},{"title":"函数声明","path":"/手册/个人配置/函数文件TODO声明/","content":"函数声明123456789/** @fn $MethodName$* @brief * @param[in] * @param[out] * @return * * @detail */ 文件声明1234567891011/******************************************************************************** * * Copyright (C) 2022 QIANXIN * All rights reserved * * filename: $FILE$ * description: * * created by shi.mingming on $DATE$ * ********************************************************************************/ TODO1// TODO(shimingming@qianxin.com): what: when:? how:？","tags":["手册","配置"],"categories":["手册","个人配置"]},{"title":"3-hexo 主题快捷键","path":"/手册/个人配置/3-hexo主题快捷键/","content":"快捷键为vim风格的。按键可能与vimium（chrome插件）的快捷键有冲突，插件设置屏蔽掉此站的快捷键即可 说明全局 Key Descption s&#x2F;S 全屏&#x2F;取消全屏 w&#x2F;W 打开&#x2F;关闭文章目录 i&#x2F;I 获取搜索框焦点 j&#x2F;J 向下滑动 k&#x2F;K 向上滑动 gg&#x2F;GG 到最顶端 shift+G&#x2F;g 到最下端 搜索框 Key Descption ESC 1.如果输入框有内容，清除内容 2.如果输入框无内容，失去焦点 下 向下选择文章 上 向上选择文章 回车 打开当前选中的文章，若没有，则默认打开第一个 关闭快捷键在主题下 _config.yml 中 找到 shortcutKey 设为 false 1shortcutKey: false","tags":["hexo","快捷键"],"categories":["手册","个人配置"]},{"title":"winDbg 调试手册","path":"/手册/WinDbg/调试手册/","content":"相关工具整理： API Monitor PCHunter工具 windbg脚本 分析32位 1.load wow64exts","tags":["windbg","调试"],"categories":["手册","WinDbg"]},{"title":"Typora Emoji","path":"/手册/Typora Emoji/","content":"[toc] People 😄 :smile: 😆 :laughing: 😊 :blush: 😃 :smiley: ☺️ :relaxed: 😏 :smirk: 😍 :heart_eyes: 😘 :kissing_heart: 😚 :kissing_closed_eyes: 😳 :flushed: 😌 :relieved: 😆 :satisfied: 😁 :grin: 😉 :wink: 😜 :stuck_out_tongue_winking_eye: 😝 :stuck_out_tongue_closed_eyes: 😀 :grinning: 😗 :kissing: 😙 :kissing_smiling_eyes: 😛 :stuck_out_tongue: 😴 :sleeping: 😟 :worried: 😦 :frowning: 😧 :anguished: 😮 :open_mouth: 😬 :grimacing: 😕 :confused: 😯 :hushed: 😑 :expressionless: 😒 :unamused: 😅 :sweat_smile: 😓 :sweat: 😥 :disappointed_relieved: 😩 :weary: 😔 :pensive: 😞 :disappointed: 😖 :confounded: 😨 :fearful: 😰 :cold_sweat: 😣 :persevere: 😢 :cry: 😭 :sob: 😂 :joy: 😲 :astonished: 😱 :scream: 😫 :tired_face: 😠 :angry: 😡 :rage: 😤 :triumph: 😪 :sleepy: 😋 :yum: 😷 :mask: 😎 :sunglasses: 😵 :dizzy_face: 👿 :imp: 显示详细信息 😈 :smiling_imp: 😐 :neutral_face: 😶 :no_mouth: 😇 :innocent: 👽 :alien: 💛 :yellow_heart: 💙 :blue_heart: 💜 :purple_heart: ❤️ :heart: 💚 :green_heart: 💔 :broken_heart: 💓 :heartbeat: 💗 :heartpulse: 💕 :two_hearts: 💞 :revolving_hearts: 💘 :cupid: 💖 :sparkling_heart: ✨ :sparkles: ⭐️ :star: 🌟 :star2: 💫 :dizzy: 💥 :boom: 💥 :collision: 💢 :anger: ❗️ :exclamation: ❓ :question: ❕ :grey_exclamation: ❔ :grey_question: 💤 :zzz: 💨 :dash: 💦 :sweat_drops: 🎶 :notes: 🎵 :musical_note: 🔥 :fire: 💩 :hankey: 💩 :poop: 💩 :shit: 👍 :+1: 👍 :thumbsup: 👎 :-1: 👎 :thumbsdown: 👌 :ok_hand: 👊 :punch: 👊 :facepunch: ✊ :fist: ✌️ :v: 👋 :wave: ✋ :hand: ✋ :raised_hand: 👐 :open_hands: ☝️ :point_up: 👇 :point_down: 👈 :point_left: 👉 :point_right: 🙌 :raised_hands: 🙏 :pray: 👆 :point_up_2: 👏 :clap: 💪 :muscle: 🤘 :metal: 🖕 :fu: 🚶 :walking: 🏃 :runner: 🏃 :running: 👫 :couple: 👪 :family: 👬 :two_men_holding_hands: 👭 :two_women_holding_hands: 💃 :dancer: 👯 :dancers: 🙆 :ok_woman: 🙅 :no_good: 💁 :information_desk_person: 🙋 :raising_hand: 👰 :bride_with_veil: 🙎 :person_with_pouting_face: 🙍 :person_frowning: 🙇 :bow: 💏 :couplekiss: 💑 :couple_with_heart: 💆 :massage: 💇 :haircut: 💅 :nail_care: 👦 :boy: 👧 :girl: 👩 :woman: 👨 :man: 👶 :baby: 👵 :older_woman: 👴 :older_man: 👱 :person_with_blond_hair: 👲 :man_with_gua_pi_mao: 👳 :man_with_turban: 👷 :construction_worker: 👮 :cop: 👼 :angel: 👸 :princess: 😺 :smiley_cat: 😸 :smile_cat: 😻 :heart_eyes_cat: 😽 :kissing_cat: 😼 :smirk_cat: 🙀 :scream_cat: 😿 :crying_cat_face: 😹 :joy_cat: 😾 :pouting_cat: 👹 :japanese_ogre: 👺 :japanese_goblin: 🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil: 💂 :guardsman: 💀 :skull: 🐾 :feet: 👄 :lips: 💋 :kiss: 💧 :droplet: 👂 :ear: 👀 :eyes: 👃 :nose: 👅 :tongue: 💌 :love_letter: 👤 :bust_in_silhouette: 👥 :busts_in_silhouette: 💬 :speech_balloon: 💭 :thought_balloon: 显示详细信息 Nature ☀️ :sunny: ☔️ :umbrella: ☁️ :cloud: ❄️ :snowflake: ⛄️ :snowman: ⚡️ :zap: 🌀 :cyclone: 🌁 :foggy: 🌊 :ocean: 🐱 :cat: 🐶 :dog: 🐭 :mouse: 🐹 :hamster: 🐰 :rabbit: 🐺 :wolf: 🐸 :frog: 🐯 :tiger: 🐨 :koala: 🐻 :bear: 🐷 :pig: 🐽 :pig_nose: 🐮 :cow: 🐗 :boar: 🐵 :monkey_face: 🐒 :monkey: 🐴 :horse: 🐎 :racehorse: 🐫 :camel: 🐑 :sheep: 🐘 :elephant: 🐼 :panda_face: 🐍 :snake: 🐦 :bird: 🐤 :baby_chick: 🐥 :hatched_chick: 🐣 :hatching_chick: 🐔 :chicken: 🐧 :penguin: 🐢 :turtle: 🐛 :bug: 🐝 :honeybee: 🐜 :ant: 🐞 :beetle: 🐌 :snail: 🐙 :octopus: 🐠 :tropical_fish: 🐟 :fish: 🐳 :whale: 🐋 :whale2: 🐬 :dolphin: 🐄 :cow2: 🐏 :ram: 🐀 :rat: 🐃 :water_buffalo: 🐅 :tiger2: 🐇 :rabbit2: 🐉 :dragon: 🐐 :goat: 🐓 :rooster: 🐕 :dog2: 🐖 :pig2: 🐁 :mouse2: 🐂 :ox: 🐲 :dragon_face: 🐡 :blowfish: 🐊 :crocodile: 🐪 :dromedary_camel: 🐆 :leopard: 🐈 :cat2: 🐩 :poodle: 🐾 :paw_prints: 💐 :bouquet: 🌸 :cherry_blossom: 🌷 :tulip: 🍀 :four_leaf_clover: 🌹 :rose: 🌻 :sunflower: 🌺 :hibiscus: 🍁 :maple_leaf: 🍃 :leaves: 🍂 :fallen_leaf: 🌿 :herb: 🍄 :mushroom: 🌵 :cactus: 🌴 :palm_tree: 🌲 :evergreen_tree: 🌳 :deciduous_tree: 🌰 :chestnut: 🌱 :seedling: 🌼 :blossom: 🌾 :ear_of_rice: 🐚 :shell: 🌐 :globe_with_meridians: 🌞 :sun_with_face: 🌝 :full_moon_with_face: 🌚 :new_moon_with_face: 🌑 :new_moon: 🌒 :waxing_crescent_moon: 🌓 :first_quarter_moon: 🌔 :waxing_gibbous_moon: 🌕 :full_moon: 🌖 :waning_gibbous_moon: 🌗 :last_quarter_moon: 🌘 :waning_crescent_moon: 🌜 :last_quarter_moon_with_face: 🌛 :first_quarter_moon_with_face: 🌔 :moon: 🌍 :earth_africa: 🌎 :earth_americas: 🌏 :earth_asia: 🌋 :volcano: 🌌 :milky_way: ⛅️ :partly_sunny: 显示详细信息 Objects 🎍 :bamboo: 💝 :gift_heart: 🎎 :dolls: 🎒 :school_satchel: 🎓 :mortar_board: 🎏 :flags: 🎆 :fireworks: 🎇 :sparkler: 🎐 :wind_chime: 🎑 :rice_scene: 🎃 :jack_o_lantern: 👻 :ghost: 🎅 :santa: 🎄 :christmas_tree: 🎁 :gift: 🔔 :bell: 🔕 :no_bell: 🎋 :tanabata_tree: 🎉 :tada: 🎊 :confetti_ball: 🎈 :balloon: 🔮 :crystal_ball: 💿 :cd: 📀 :dvd: 💾 :floppy_disk: 📷 :camera: 📹 :video_camera: 🎥 :movie_camera: 💻 :computer: 📺 :tv: 📱 :iphone: ☎️ :phone: ☎️ :telephone: 📞 :telephone_receiver: 📟 :pager: 📠 :fax: 💽 :minidisc: 📼 :vhs: 🔉 :sound: 🔈 :speaker: 🔇 :mute: 📢 :loudspeaker: 📣 :mega: ⌛️ :hourglass: ⏳ :hourglass_flowing_sand: ⏰ :alarm_clock: ⌚️ :watch: 📻 :radio: 📡 :satellite: ➿ :loop: 🔍 :mag: 🔎 :mag_right: 🔓 :unlock: 🔒 :lock: 🔏 :lock_with_ink_pen: 🔐 :closed_lock_with_key: 🔑 :key: 💡 :bulb: 🔦 :flashlight: 🔆 :high_brightness: 🔅 :low_brightness: 🔌 :electric_plug: 🔋 :battery: 📲 :calling: ✉️ :email: 📫 :mailbox: 📮 :postbox: 🛀 :bath: 🛁 :bathtub: 🚿 :shower: 🚽 :toilet: 🔧 :wrench: 🔩 :nut_and_bolt: 🔨 :hammer: 💺 :seat: 💰 :moneybag: 💴 :yen: 💵 :dollar: 💷 :pound: 💶 :euro: 💳 :credit_card: 💸 :money_with_wings: 📧 :e-mail: 📥 :inbox_tray: 📤 :outbox_tray: ✉️ :envelope: 📨 :incoming_envelope: 📯 :postal_horn: 📪 :mailbox_closed: 📬 :mailbox_with_mail: 📭 :mailbox_with_no_mail: 🚪 :door: 🚬 :smoking: 💣 :bomb: 🔫 :gun: 🔪 :hocho: 💊 :pill: 💉 :syringe: 📄 :page_facing_up: 📃 :page_with_curl: 📑 :bookmark_tabs: 📊 :bar_chart: 📈 :chart_with_upwards_trend: 📉 :chart_with_downwards_trend: 📜 :scroll: 📋 :clipboard: 📆 :calendar: 📅 :date: 📇 :card_index: 📁 :file_folder: 📂 :open_file_folder: ✂️ :scissors: 📌 :pushpin: 📎 :paperclip: ✒️ :black_nib: ✏️ :pencil2: 📏 :straight_ruler: 📐 :triangular_ruler: 📕 :closed_book: 📗 :green_book: 📘 :blue_book: 📙 :orange_book: 📓 :notebook: 📔 :notebook_with_decorative_cover: 📒 :ledger: 📚 :books: 🔖 :bookmark: 📛 :name_badge: 🔬 :microscope: 🔭 :telescope: 📰 :newspaper: 🏈 :football: 🏀 :basketball: ⚽️ :soccer: ⚾️ :baseball: 🎾 :tennis: 🎱 :8ball: 🏉 :rugby_football: 🎳 :bowling: ⛳️ :golf: 🚵 :mountain_bicyclist: 🚴 :bicyclist: 🏇 :horse_racing: 🏂 :snowboarder: 🏊 :swimmer: 🏄 :surfer: 🎿 :ski: ♠️ :spades: ♥️ :hearts: ♣️ :clubs: ♦️ :diamonds: 💎 :gem: 💍 :ring: 🏆 :trophy: 🎼 :musical_score: 🎹 :musical_keyboard: 🎻 :violin: 👾 :space_invader: 🎮 :video_game: 🃏 :black_joker: 🎴 :flower_playing_cards: 🎲 :game_die: 🎯 :dart: 🀄️ :mahjong: 🎬 :clapper: 📝 :memo: 📝 :pencil: 📖 :book: 🎨 :art: 🎤 :microphone: 🎧 :headphones: 🎺 :trumpet: 🎷 :saxophone: 🎸 :guitar: 👞 :shoe: 👡 :sandal: 👠 :high_heel: 💄 :lipstick: 👢 :boot: 👕 :shirt: 👕 :tshirt: 👔 :necktie: 👚 :womans_clothes: 👗 :dress: 🎽 :running_shirt_with_sash: 👖 :jeans: 👘 :kimono: 👙 :bikini: 🎀 :ribbon: 🎩 :tophat: 👑 :crown: 👒 :womans_hat: 👞 :mans_shoe: 🌂 :closed_umbrella: 💼 :briefcase: 👜 :handbag: 👝 :pouch: 👛 :purse: 👓 :eyeglasses: 🎣 :fishing_pole_and_fish: ☕️ :coffee: 🍵 :tea: 🍶 :sake: 🍼 :baby_bottle: 🍺 :beer: 🍻 :beers: 🍸 :cocktail: 🍹 :tropical_drink: 🍷 :wine_glass: 🍴 :fork_and_knife: 🍕 :pizza: 🍔 :hamburger: 🍟 :fries: 🍗 :poultry_leg: 🍖 :meat_on_bone: 🍝 :spaghetti: 🍛 :curry: 🍤 :fried_shrimp: 🍱 :bento: 🍣 :sushi: 🍥 :fish_cake: 🍙 :rice_ball: 🍘 :rice_cracker: 🍚 :rice: 🍜 :ramen: 🍲 :stew: 🍢 :oden: 🍡 :dango: 🥚 :egg: 🍞 :bread: 🍩 :doughnut: 🍮 :custard: 🍦 :icecream: 🍨 :ice_cream: 🍧 :shaved_ice: 🎂 :birthday: 🍰 :cake: 🍪 :cookie: 🍫 :chocolate_bar: 🍬 :candy: 🍭 :lollipop: 🍯 :honey_pot: 🍎 :apple: 🍏 :green_apple: 🍊 :tangerine: 🍋 :lemon: 🍒 :cherries: 🍇 :grapes: 🍉 :watermelon: 🍓 :strawberry: 🍑 :peach: 🍈 :melon: 🍌 :banana: 🍐 :pear: 🍍 :pineapple: 🍠 :sweet_potato: 🍆 :eggplant: 🍅 :tomato: 🌽 :corn: 显示详细信息 Places 🏠 :house: 🏡 :house_with_garden: 🏫 :school: 🏢 :office: 🏣 :post_office: 🏥 :hospital: 🏦 :bank: 🏪 :convenience_store: 🏩 :love_hotel: 🏨 :hotel: 💒 :wedding: ⛪️ :church: 🏬 :department_store: 🏤 :european_post_office: 🌇 :city_sunrise: 🌆 :city_sunset: 🏯 :japanese_castle: 🏰 :european_castle: ⛺️ :tent: 🏭 :factory: 🗼 :tokyo_tower: 🗾 :japan: 🗻 :mount_fuji: 🌄 :sunrise_over_mountains: 🌅 :sunrise: 🌠 :stars: 🗽 :statue_of_liberty: 🌉 :bridge_at_night: 🎠 :carousel_horse: 🌈 :rainbow: 🎡 :ferris_wheel: ⛲️ :fountain: 🎢 :roller_coaster: 🚢 :ship: 🚤 :speedboat: ⛵️ :boat: ⛵️ :sailboat: 🚣 :rowboat: ⚓️ :anchor: 🚀 :rocket: ✈️ :airplane: 🚁 :helicopter: 🚂 :steam_locomotive: 🚊 :tram: 🚞 :mountain_railway: 🚲 :bike: 🚡 :aerial_tramway: 🚟 :suspension_railway: 🚠 :mountain_cableway: 🚜 :tractor: 🚙 :blue_car: 🚘 :oncoming_automobile: 🚗 :car: 🚗 :red_car: 🚕 :taxi: 🚖 :oncoming_taxi: 🚛 :articulated_lorry: 🚌 :bus: 🚍 :oncoming_bus: 🚨 :rotating_light: 🚓 :police_car: 🚔 :oncoming_police_car: 🚒 :fire_engine: 🚑 :ambulance: 🚐 :minibus: 🚚 :truck: 🚋 :train: 🚉 :station: 🚆 :train2: 🚅 :bullettrain_front: 🚄 :bullettrain_side: 🚈 :light_rail: 🚝 :monorail: 🚃 :railway_car: 🚎 :trolleybus: 🎫 :ticket: ⛽️ :fuelpump: 🚦 :vertical_traffic_light: 🚥 :traffic_light: ⚠️ :warning: 🚧 :construction: 🔰 :beginner: 🏧 :atm: 🎰 :slot_machine: 🚏 :busstop: 💈 :barber: ♨️ :hotsprings: 🏁 :checkered_flag: 🎌 :crossed_flags: 🏮 :izakaya_lantern: 🗿 :moyai: 🎪 :circus_tent: 🎭 :performing_arts: 📍 :round_pushpin: 🚩 :triangular_flag_on_post: 🇯🇵 :jp: 🇰🇷 :kr: 🇨🇳 :cn: 🇺🇸 :us: 🇫🇷 :fr: 🇪🇸 :es: 🇮🇹 :it: 🇷🇺 :ru: 🇬🇧 :gb: 🇬🇧 :uk: 🇩🇪 :de: 显示详细信息 Symbols 1️⃣ :one: 2️⃣ :two: 3️⃣ :three: 4️⃣ :four: 5️⃣ :five: 6️⃣ :six: 7️⃣ :seven: 8️⃣ :eight: 9️⃣ :nine: 🔟 :keycap_ten: 🔢 :1234: 0️⃣ :zero: #️⃣ :hash: 🔣 :symbols: ◀️ :arrow_backward: ⬇️ :arrow_down: ▶️ :arrow_forward: ⬅️ :arrow_left: 🔠 :capital_abcd: 🔡 :abcd: 🔤 :abc: ↙️ :arrow_lower_left: ↘️ :arrow_lower_right: ➡️ :arrow_right: ⬆️ :arrow_up: ↖️ :arrow_upper_left: ↗️ :arrow_upper_right: ⏬ :arrow_double_down: ⏫ :arrow_double_up: 🔽 :arrow_down_small: ⤵️ :arrow_heading_down: ⤴️ :arrow_heading_up: ↩️:leftwards_arrow_with_hook: ↪️ :arrow_right_hook: ↔️ :left_right_arrow: ↕️ :arrow_up_down: 🔼 :arrow_up_small: 🔃 :arrows_clockwise: 🔄 :arrows_counterclockwise: ⏪ :rewind: ⏩ :fast_forward: ℹ️ :information_source: 🆗 :ok: 🔀 :twisted_rightwards_arrows: 🔁 :repeat: 🔂 :repeat_one: 🆕 :new: 🔝 :top: 🆙 :up: 🆒 :cool: 🆓 :free: 🆖 :ng: 🎦 :cinema: 🈁 :koko: 📶 :signal_strength: 🈹 :u5272: 🈴 :u5408: 🈺 :u55b6: 🈯️ :u6307: 🈷️ :u6708: 🈶 :u6709: 🈵 :u6e80: 🈚️ :u7121: 🈸 :u7533: 🈳 :u7a7a: 🈲 :u7981: 🈂️ :sa: 🚻 :restroom: 🚹 :mens: 🚺 :womens: 🚼 :baby_symbol: 🚭 :no_smoking: 🅿️ :parking: ♿️ :wheelchair: 🚇 :metro: 🛄 :baggage_claim: 🉑 :accept: 🚾 :wc: 🚰 :potable_water: 🚮 :put_litter_in_its_place: ㊙️ :secret: ㊗️ :congratulations: Ⓜ️ :m: 🛂 :passport_control: 🛅 :left_luggage: 🛃 :customs: 🉐 :ideograph_advantage: 🆑 :cl: 🆘 :sos: 🆔 :id: 🚫 :no_entry_sign: 🔞 :underage: 📵 :no_mobile_phones: 🚯 :do_not_litter: 🚱 :non-potable_water: 🚳 :no_bicycles: 🚷 :no_pedestrians: 🚸 :children_crossing: ⛔️ :no_entry: ✳️ :eight_spoked_asterisk: ✴️ :eight_pointed_black_star: 💟 :heart_decoration: 🆚 :vs: 📳 :vibration_mode: 📴 :mobile_phone_off: 💹 :chart: 💱 :currency_exchange: ♈️ :aries: ♉️ :taurus: ♊️ :gemini: ♋️ :cancer: ♌️ :leo: ♍️ :virgo: ♎️ :libra: ♏️ :scorpius: ♐️ :sagittarius: ♑️ :capricorn: ♒️ :aquarius: ♓️ :pisces: ⛎ :ophiuchus: 🔯 :six_pointed_star: ❎:negative_squared_cross_mark: 🅰️ :a: 🅱️ :b: 🆎 :ab: 🅾️ :o2: 💠:diamond_shape_with_a_dot_inside: ♻️ :recycle: 🔚 :end: 🔛 :on: 🔜 :soon: 🕐 :clock1: 🕜 :clock130: 🕙 :clock10: 🕥 :clock1030: 🕚 :clock11: 🕦 :clock1130: 🕛 :clock12: 🕧 :clock1230: 🕑 :clock2: 🕝 :clock230: 🕒 :clock3: 🕞 :clock330: 🕓 :clock4: 🕟 :clock430: 🕔 :clock5: 🕠 :clock530: 🕕 :clock6: 🕡 :clock630: 🕖 :clock7: 🕢 :clock730: 🕗 :clock8: 🕣 :clock830: 🕘 :clock9: 🕤 :clock930: 💲 :heavy_dollar_sign: ©️ :copyright: ®️ :registered: ™️ :tm: ❌ :x: ❗️ :heavy_exclamation_mark: ‼️ :bangbang: ⁉️ :interrobang: ⭕️ :o: ✖️ :heavy_multiplication_x: ➕ :heavy_plus_sign: ➖ :heavy_minus_sign: ➗ :heavy_division_sign: 💮 :white_flower: 💯 :100: ✔️ :heavy_check_mark: ☑️ :ballot_box_with_check: 🔘 :radio_button: 🔗 :link: ➰ :curly_loop: 〰️ :wavy_dash: 〽️ :part_alternation_mark: 🔱 :trident: :black_square: :black_square: :white_square: :white_square: ✅ :white_check_mark: 🔲 :black_square_button: 🔳 :white_square_button: ⚫️ :black_circle: ⚪️ :white_circle: 🔴 :red_circle: 🔵 :large_blue_circle: 🔷 :large_blue_diamond: 🔶 :large_orange_diamond: 🔹 :small_blue_diamond: 🔸 :small_orange_diamond: 🔺 :small_red_triangle: 🔻 :small_red_triangle_down: 显示详细信息","categories":["手册"]},{"title":"UML 片段说明","path":"/手册/UML/片段说明/","content":"片断类型 名称 说明 Opt 选项 包含一个可能发生或可能不发生的序列。 能够在临界中指定序列发生的条件。 Alt 抉择 包含一个片断列表，这些片断包含备选消息序列。 在任何场合下只发生一个序列。能够在每一个片断中设置一个临界来指示该片断能够运行的条件。 else 的临界指示其余任何临界都不为 True 时应运行的片断。 若是全部临界都为 False 而且没有 else，则不执行任何片断。 Loop 循环 片断重复必定次数。 能够在临界中指示片断重复的条件。Loop 组合片断具备“Min”和“Max”属性，它们指示片断能够重复的最小和最大次数。 默认值是无限制。 Break 中断 若是执行此片断，则放弃序列的其他部分。 可使用临界来指示发生中断的条件。 Par 并行 并行处理。 片断中的事件能够交错。 Critical 关键 用在 Par 或 Seq 片断中。 指示此片断中的消息不得与其余消息交错。 Seq 弱顺序 有两个或更多操做数片断。 涉及同一辈子命线的消息必须以片断的顺序发生。 若是消息涉及的生命线不一样，来自不一样片断的消息可能会并行交错。 Strict 强顺序 有两个或更多操做数片断。 这些片断必须按给定顺序发生。 10.40.61.20&#x2F;255.255.255.0|192.168.160.1&#x2F;255.255.255.0|192.168.142.1&#x2F;255.255.255.0","categories":["手册","UML"]},{"title":"Readme 工具使用手册","path":"/手册/Readme使用手册/","content":"[toc] ReadMe readme 是一个自动生成 readme 的工具 开源项目地址：https://github.com/kefranabg/readme-md-generator 开源项目作者：Franck Abgrall 用法npx 用法Make sure you have npx installed (npx is shipped by default since npm 5.2.0) Just run the following command at the root of your project and answer questions: 1npx readme-md-generator Or use default values for all questions (-y): 1npx readme-md-generator -y Use your own ejs README template (-p): 1npx readme-md-generator -p path/to/my/own/template.md You can find ejs README template examples here.、 Windows 系统使用1readme Or use default values for all questions (-y): 1readme -y Use your own ejs README template (-p): 1readme -p D:my/own/template.md","categories":["手册"]},{"title":"前端样式配置 style","path":"/手册/SpanStyleList/","content":"12345678910111213141516171819202122232425262728291&lt;span class=&quot;fas faa-ring animated-hover&quot; style=&quot;border-bottom:3px solid green&quot;&gt;《半小时漫画中国哲学史》&lt;/span&gt;2&lt;span style=&quot;text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;&quot;&gt;“ 既许一人以偏爱，愿尽余生之慷慨 ”&lt;/span&gt;3&lt;span style=&quot;class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;&quot;&gt;[data.json文件链接](https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA )&lt;/span&gt; 4 &lt;mark style=&quot;background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas&quot;&gt;当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。&lt;/mark&gt;5&lt;span style=&quot;background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900&quot;&gt;存储结构管理主要就是通过对表空间的管理来实现的&lt;/span&gt;6&lt;mark style=&quot;background:green;border-radius:10px;color:white&quot;&gt;效果如下：&lt;/mark&gt;7&lt;font size=10px style=&quot;font-weight:700;font-family:&#x27;华文彩云&#x27;;color:rgb(100,190,100)&quot;&gt;基本语言(一)&lt;/font&gt;8&lt;span style=&quot;border-bottom: 2px dashed #000000&quot;&gt;代码段、数据段、BSS段、堆区、文件映射区以及栈区&lt;/span&gt;9&lt;div style=&quot;background:black;font:conloas;color:white;&quot;&gt; 数组长度为：3&lt;br&gt; 请按任意键继续. . .&lt;/div&gt;10&lt;mark style=&quot;color:white;background:red;font-weight:600;border_radius:100px&quot;&gt;但效率更高&lt;/mark&gt;11&lt;details&gt; &lt;summary&gt;更多&lt;/summary&gt; &lt;p&gt;内容&lt;/p&gt;&lt;/details&gt; 1《半小时漫画中国哲学史》 2“ 既许一人以偏爱，愿尽余生之慷慨 ” 3data.json文件链接 4当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。 5存储结构管理主要就是通过对表空间的管理来实现的 6效果如下： 7基本语言(一) 8代码段、数据段、BSS段、堆区、文件映射区以及栈区 9 数组长度为：3 请按任意键继续. . . 10但效率更高 11 折叠 更多 1. 列表1 2. 列表2","tags":["手册","样式","CSS"],"categories":["手册"]},{"title":"通过 Commit 关闭 Issue","path":"/手册/Git/关闭issue/","content":"[toc] commit关闭issue如果要在相同仓库关闭一个Issue（工单），可以使用下面列表中的关键词并在其后面加上Issue编号的应用（#+issue编号）。 例如一个提交信息中包含 Fixes #45 ，那么一旦这次提交被合并到默认分支，仓库中的45号issue就会自动关闭。 Issue 关键字123456789closeclosesclosedfixfixesfixedresolveresolvesresolved 关闭多个issues如果你在commit的开头使用多个上述关键字加issue的引用的话，你就可以关闭多个issues。例如，This closes #34, closes #23, and closes example_user&#x2F;example_repo#42将会关闭同一个仓库的34和23号issue以及 example_user&#x2F;example_repo 仓库的42号issue。","tags":["手册","Git","Issue"],"categories":["手册","Git"]},{"title":"Git 速查手册","path":"/手册/Git/Git速查手册/","content":"查看远程仓1git remote -v 分支查看12345678# 查看本地分支git branch# 查看远程分支git branch -r# 查看所有分支git branch -a 删除12345678910111213141516171819# 删除远程分支git push origin --delete [branch_name]2. 删除本地分支区别git branch -d 会在删除前检查merge状态（其与上游分支或者与head）。git branch -D 是git branch --delete --force的简写，它会直接删除。共同点都是删除本地分支的方法（与删除远程分支命令相独立，要想本地和远程都删除，必须得运行两个命令）。3. git查看分支：查看本地分支 git branch查看远程分支 git branch -r查看本地和远程分支 git branch -a4.git删除分支：删除本地分支 git branch -d 本地分支名删除远程分支 git push origin --delete 远程分支名推送空分支到远程（删除远程分支另一种实现）git push origin :远程分支 Config12# 查看git configgit config -l stash123git stashgit stash pop 拉取12# 拉取远端分支到本地分支 Develop分支到本地Develop分支git fetch origin Develop:Develop 查看已push但未提交的内容1git cherry -v 合并合并某个分支上的某一个文件 切换到当前分支（即：要合并文件到的分支） 1git checkout current_branch 合并指定分支上的文件到当前分支 1git checkout --patch zhiding_branch f.txt 合并 zhiding_branch 分支上的 f.txt 文件到 current_branch git log 最强语句1git config --global alias.lg &quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;","tags":["手册","Git"],"categories":["手册","Git"]},{"title":"Git 配置多账号","path":"/手册/Git/Git配置多账号/","content":"[toc] 生成多个密钥 生成多个密钥，生成时修改密钥文件的文件名 1ssh-keygen -t rsa -C &quot;邮箱&quot; 注意上述命令执行完之后第一个输入要求的是输入的保存的文件名 示例： 123456ssh-keygen -t rsa -C &quot;holdyounger@163.com&quot;# 保存的时候可以选择保存文件的名称设置为 fork_hodlyounger_ssh_key# 接着执行另外一个账号ssh-keygen -t rsa -C &quot;公司邮箱&quot;# 保存的时候可以选择保存文件的名称设置为 id_rsa 添加密钥 123456# 切换ssh-agent bash# 添加ssh-add ~/.ssh/fork_hodlyounger_ssh_keyssh-add ~/.ssh/id_rsa 将密钥添加到账户中 使用 cat 查看对应账户的 pub 文件。将其内容添加到账户中。 添加本地配置文件 添加本地配置文件用以区分密钥在哪个git中使用，配置如下所示配置文件更详细的说明可以参考这篇文章 Git：单台电脑同时配置多个git账号 - 怒吼的萝卜 - 博客园 新建config文件，文件内容如下所示。 1234567891011# 这个是我私人的GitHubHost githubHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/fork_hodlyounger_ssh_key# 这个是公司的GitLabHost git-biz.cnHostName git-biz.cnPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa 配置文件补充说明 12345678910111213# 这里是自定义的host简称，以后连接远程服务器就可以用命令ssh myhostHost# 主机名可用ip也可以是域名(如:github.com或者bitbucket.org)HostName# 服务器open-ssh端口（默认：22,默认时一般不写此行）Port# 配置登录时用什么权限认证# 可设为(publickey, password publickey, keyboard-interactive 等)PreferredAuthentications# 证书文件路径（如~/.ssh/id_rsa_*)IdentityFile# 云端仓库登录用户名User 校验 简单点就是ssh： 1ssh -T &quot;holdyoungere@163.com&quot; 返回 Hi (用户名)! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 开头样式的表示添加密钥成功了。","tags":["git","多账号"],"categories":["手册","Git"]},{"title":"git emoji手册","path":"/手册/Git emoji手册/","content":"emoji emoji 代码 commit 说明 🎨 (调色板) :art: 改进代码结构 &#x2F; 代码格式 ⚡️ (闪电) 🐎 (赛马) :zap: :racehorse: 提升性能 🔥 (火焰) :fire: 移除代码或文件 🐛 (bug) :bug: 修复 bug 🚑 (急救车) :ambulance: 重要补丁 ✨ (火花) :sparkles: 引入新功能 📝 (备忘录) :memo: 撰写文档 🚀 (火箭) :rocket: 部署功能 💄 (口红) :lipstick: 更新 UI 和样式文件 🎉 (庆祝) :tada: 初次提交 ✅ (白色复选框) :white_check_mark: 更新测试 🔒 (锁) :lock: 修复安全问题 🍎 (苹果) :apple: 修复 macOS 下的问题 🐧 (企鹅) :penguin: 修复 Linux 下的问题 🏁 (旗帜) :checkered_flag: 修复 Windows 下的问题 🤖（机器人） :robot: 修复 Android 下的问题 🍏 (绿苹果) :green_apple: 修复 iOS 下的问题 🔖 (书签) :bookmark: 发行 &#x2F; 版本标签 🚨 (警车灯) :rotating_light: 移除 linter 警告 🚧 (施工) :construction: 工作进行中 👷 (工人) :construction_worker: 添加 CI 构建系统 💚 (绿心) :green_heart: 修复 CI 构建问题 ⬆️ (上升箭头) :arrow_up: 升级依赖 ⬇️ (下降箭头) :arrow_down: 降级依赖 📌 (图钉) :pushpin: 将依赖项固定到特定版本 📈 (上升趋势图) :chart_with_upwards_trend: 添加分析或跟踪代码 ♻️ （回收） :recycle: 重构代码 🐳 (鲸鱼) :whale: Docker 相关工作 🌐 (带子午线的地球仪) :globe_with_meridians: 国际化与本地化 ➕ (加号) :heavy_plus_sign: 增加一个依赖 ➖ (减号) :heavy_minus_sign: 减少一个依赖 🔧 (扳手) :wrench: 修改配置文件 🔨 (锤子) :hammer: 重大重构 ✏️ (铅笔) :pencil2: 修复 typo 💩 (粑粑…) :hankey: 写了辣鸡代码需要优化 ⏪ (倒带) :rewind: 恢复更改 🔀 (交叉向右的箭头) :twisted_rightwards_arrows: 合并分支 📦 (包裹) :package: 更新编译的文件或包 👽 (外星人) :alien: 由于外部 API 更改而更新代码 🚚 (货车) :truck: 移动或者重命名文件 📄 (正面朝上的页面) :page_facing_up: 增加或更新许可证书 💥 (爆炸) :boom: 引入突破性的变化 🍱 (铅笔) :bento: 增加或更新资源 👌 (OK 手势) :ok_hand: 由于代码审查更改而更新代码 ♿️ (轮椅) :wheelchair: 改善无障碍交互 💡 (灯泡) :bulb: 给代码添加注释 🍻 (啤酒) :beers: 醉醺醺地写代码… 💬 (消息气泡) :speech_balloon: 更新文本文档 🗃 (卡片文件盒) :card_file_box: 执行与数据库相关的更改 🔊 (音量大) :loud_sound: 增加日志 🔇 (静音) :mute: 移除日志 👥 (轮廓中的半身像) :busts_in_silhouette: 增加贡献者 🚸 (孩童通行) :children_crossing: 优化用户体验、可用性 🏗 (建筑建造) :building_construction: 结构变动 📱 (iPhone) :iphone: 做响应式设计 🤡 (小丑脸) :clown_face: 嘲弄事物（直译，这个没明白） 🥚 (鸡蛋) :egg: 增加彩蛋 🙈 (看不见邪恶) :see_no_evil: 增加或更改 gitignore 📸 (照相机闪光灯) :camera_flash: 增加或更新截图 ⚗️ (蒸馏器) :alembic: 尝试新东西 🔍 (放大镜) :mag: SEO 优化 ☸️ (船的方向盘) :wheel_of_dharma: 关于 Kubernetes 的工作 🏷 (标签) :label: 增加类型（FLow、Typescript） 🌱(听诊器) :seedling: 添加或更新种子文件 🧵 (毛线圈) :thread: 添加或更新与多线程或并发性相关的代码 🦺(安全马甲) :safety_vest: 添加或更新与验证相关的代码 🧑‍💻(程序) :technologist: 改善开发者体验 :technologist: 🧱(砖) :bricks: 基础设施相关的变化 🩺(听诊器) :stethoscope: 添加或更新运行状况检查 👔(衬衫) :necktie: 添加或更新业务逻辑 🧪(试管) :test_tube: 添加失败的测试 ⚰️(棺椁) :coffin: 删除死代码 🧐(观察) :monocle_face: 数据探索&#x2F;检查 🩹(创可贴) :adhesive_bandage: 简单修复非关键问题 🛂(鉴权) :passport_control: 处理与授权、角色和权限相关的代码 🗑️(垃圾桶) :wastebasket: 需要清理的废弃代码 💫(动画) :dizzy: 添加或更新动画和过渡 🥅(足球门) :goal_net: 捕获异常 🚩(旗帜) :triangular_flag_on_post: 添加、更新或删除功能标志","tags":["手册","git"],"categories":["手册"]},{"title":"英雄联盟语录","path":"/手册/Game/LOL/","content":"仁义道德，也是一种奢侈。——亚索 千军万马一将在，探囊取物有何难。——皇子 落叶的一生，只是为了归根么。——亚索 我对你的爱就如闪电，狂暴而剧烈，飞出的飞镖，是我向你传达的思念。——狂暴之心 且听风吟，御剑于心。——亚索 一曲终了，繁花散尽，伊人已逝，只余一声空叹。——死亡颂唱者 我只是部落遗子，你确是高贵公主，我愿把我生命的力量化为三刀为你而战，只为证明我，配的上你。——蛮族之王 我对你的爱就如闪电，狂暴而剧烈，飞出的飞镖是向你传达的思念。——狂暴之心 无情的岁月慢慢的侵蚀你我的生命，在这尽头请允许我为你弹下那回忆的肖邦。——琴瑟仙女 从我手中脱离的刀刃一直在飞舞，我不断的变强，只是为了守护我们的家园，我等候你的归来。——刀锋意志 放马过来吧！你会死的很光荣的！——盖伦 即使一无所有，也要未雨绸缪！——法外狂徒 征战沙场，只为守护我们的家园。只为解甲归田后，可以在墓前守护你一辈子。——德邦 我们不受岁月左右。——马尔扎哈 我可以想去哪就去哪，但是我只想进入你的心里。——祖安狂人 想要再来一发吗，我可不会留下任何悬念。——女警 体型并不能说明一切！——提莫 妩媚倾城的面容，我蛊惑万千众生，孰不知，心里，早有了一个人。却只能无尽的思念，你送我的宝珠，我一直带着，只因为我能看见你的身影。——九尾妖狐 规则就是用来打破的！——金克丝 你的遗体将慢慢消散，化为永恒，就像沙漠中的沙砾那样。——狗头 不管是怎么样的天气，不管是什么样的环境，不管有什么样的危险，我的伙伴，雪人，一直都会陪着我。——雪人骑士 世界上最痛苦的事情，莫过于爱你，却不能对你说出，我只能倾注于我的琴，让我的旋律诉说我的爱。——琴瑟仙女 下了手中的武器，我知道你已厌倦。目送你离开，我亮起黄昏的路灯，照亮你回家的路。——武器大师 他们会像迎接英雄一般迎接你们。——暗裔剑魔 这个故事还没有完结。——亚索 我宁愿犯错误，也不愿什么都不做。——艾克 断剑重铸之日，其势归来之时！——瑞文 我追逐的是你的背影，我跟随的是你的微笑，就算暴风雨到来我依然能在你左右。——雷霆咆哮 只有蠢货才会犹豫不决。——卡特琳娜 入体冰凉的月光都比不上你绝情的目光，为了击碎你伪装的表面，我只能用尽全身力气挥出那惊鸿的半月弧光。——皎月女神 念当年有爱的我，可惜啊，你们看不到啦。——水晶先锋 夜，雪花飘落；我，孤独风中；凛冽的寒风，割裂着我的皮肤。不知绝对的零度是否能冻结对你的思念。——雪人骑士 人生最痛苦的事莫过于你明知要失去，却还没发生。——基兰 即使是一无所有的人也会为自己所珍惜的一切而献出生命。——暗裔剑魔 人们向往天堂，可天堂没有你。于是我堕落凡间追寻你的脚步，只因有你的地方才是天堂。——堕落天使 这只是一场战役，而我，已经赢下了战争！——丽桑卓 我来自深海，我没有朋友，大家都不和我玩，只有巨鲨是我的朋友，你愿意和它一起玩吗？——潮汐海灵 征战沙场，只为守护我们的家园。只为解甲归田后，可以在墓前守护你一辈子。——德邦总管 哼，一个能打的都没有！——武器大师 别看我的眼睛，里面只有愤怒和痛苦。我诅咒着一切，也诅咒着自己。——魔蛇之拥 我一直急速前行，穿梭于人人之间，试图叫应接不暇的风景让我褪去对你的思念。——无极剑圣 太阳不会揭露真相。它的光芒只会让人灼伤和致盲。——黛安娜 我一直急速前行穿梭于人人之间试图叫应接不暇的风景让我褪去对你的思念——无极剑圣 死后能做的最棒的事情是什么？就是碾碎你的敌人，看着他们先你一步而去，并聆听他们怯懦的哭喊。——赛恩 你有一双摄人心魄的眼睛。我非常喜欢。——赏金猎人 命运已做出了它的选择！——赵信 你总说我太小，但是出现危险我都会跳跃到你身边，将危险推开。用手中的炮筒，守护我小小的爱。——麦林炮手 你们不能逮捕我，我爹是瓦罗兰的抗把子。——奥拉夫 悄悄的我走了，正如我悄悄的来；我摸一摸戒指，再带走一次五杀。——剑圣 你们知道最强的武器是什么？没错，就是补丁！——武器大师 我在时光中穿梭，只为找回曾经美好的时光。——时光守护者 你们这种战斗力，我建议你们还是投降算了。——拉克丝 炙热的铁拳砸不开你面前的牢笼，不甘放弃的努力，只为了有一天能砸开牢笼见你一面。——皮城执法官 想攻击我？先试试和影子玩拳击吧。——暗夜猎手 我疯狂的奔跑，只想为你承受一切的伤害，我竖起了山丘，不愿你看见我丑陋的脸庞。——诅咒巨魔 哪一个比较沉重，你的剑刃，还是你的过去？——亚索 物是人非，可我依旧穿着嫁衣，在黑夜中寻找你的身影。你我的约定我一直记得，那一道道璀璨的光束，都是为你所亮。——寡妇制造者 断剑可以重铸，破镜是否可以重圆？心碎可以可以无痕？——放逐之刃 不要测试你的运气，召唤师！——卡特琳娜 曾经，我们错过了，但是，我希望你的未来有我，有我来守护着你。——未来守护者 没有你的世界，我感到孤独。我一次次地想随你而去，但是又一次次地重生。长生不死对我而言是一件多么痛苦的事情。——暗裔剑魔 吾之荣耀，离别已久。——亚索 这场流星雨，只是想给你看，没想到却是伤害了你。——众星之子 你将忘记呼吸，你将忘记爱情。——卡尔萨斯 在瓦罗兰，我是一个无恶不作的大海盗。而成为海盗的原因是为你保驾护航。——海盗船长 外表可是具有欺骗性的。——妖姬 那拿枪的海盗，是记忆里的核心；浩空里的流星，在我的脑海闪过。——赏金猎人 守护你是我最后的希望，束缚着的是思念，丢弃的是无奈，最后我会留下一个圈摆放你我的回忆，直到我也干枯，你也远去！——扭曲树精 时间不在于你拥有多少，而在于你怎样使用。——艾克 我每向你射出一支箭，便代表我对你的爱多一分，而你，是否会接受我万千的爱？——寒冰射手 我一直急速前行，穿梭于人人之间。试图借应接不暇的风景让我褪去对你的思念。——无极剑圣 死亡如风，常伴吾身。——亚索 顺我者昌，逆我者亡，此乃天意。——卡牌 即使丑陋的外表也掩盖不了我对召唤师的感激之情，即使在很危险的情况下我也会挺身而出。——诅咒巨魔 那双枪下的弹幕，不是烟花，是琴上律；爆发在好运间，释放着海盗似的野。——赏金猎人 人终归是要死的，为什么不选择一种死亡的方式呢？——卡尔萨斯 过去那个爱笑的我已经不在了，现在的我只剩下魔法与记忆以及这个丑陋不堪的身躯，孤独的在这个世界徘徊。——水晶先锋 这不仅仅只是屠杀，而是我的杰作。——暗裔剑魔 我是一个影子，当我潜入阴影之中，没有人能够看见我，但是我希望你是个例外！——影流之主 甲板上的脚印，稳稳的在船上蔓延；在碧海的波浪里，我如愿做一条飞鱼！——赏金猎人 朋友，有我在你就是不死的。即使我死了。也要让你活着离开。——众星之子 我没有过多的抱怨，漫天的乌鸦都是我的朋友，有这个，就足够了——末日使者 我的剑比什么都重要，除了美酒。——亚索 我也希望变成蝴蝶的那一天，不再灰色，不再痛苦。不会再让我丑陋的外表吓到美丽的你。——深渊巨口 我愚蠢的以为，头上的金箍圈可以圈住你所有的爱，可惜我手中的金箍棒改变不了那个开始，也决定不了这个结局，根本没有齐天大圣，我只是一只猴子。——齐天大圣 冰冷的锁链，无情的束缚，黑色的羽毛，血色的双眼，所有的一切都是因为那颗冷寂的心。——堕落天使 狂野将使他们感到畏惧。——豹女 我不顾一切的冲出去……为你开辟一条安稳的路。我满腔热血的拍打着……为你抛开任何绊脚的石。最后，我坦然微笑着用躯体为你抵挡一切……因为我的身体上旋转着我们的誓言！——牛头酋长 我不会怀着耻辱而死！——亚索 断刃可以修复，残心如何弥补。——放逐之刃 冰封千年的心，只为等待那瞬间的融化。日夜凄美的呼唤。也换不回你微笑的回眸。——冰晶凤凰 树叶的一生只是为了归根么？——疾风剑豪 闭上眼睛，你会看到更多。——仙灵女巫璐璐 炽热的铁拳砸不开你面前的牢笼，不甘放弃的努力，只为了有一天能砸开牢笼见你一面。——皮城执法官蔚 我能在空气中嗅到敌人的味道，我很努力了，可是，为什么还是找不到你的踪迹呢！——嗜血猎手 放下了手中的武器，我知道你已厌倦，目送你离开，亮起黄昏的路灯，照亮你回家的路。——武器大师 你一直在畏惧我的毒刺，别怕，让我用我的毒刺把你牵引到我的身边。——水晶先锋 追逐的是你的背影，我跟随的是你的微笑，就算黑夜到来我依然能在你左右。——永恒梦魇 我日复一日地把自己弄得伤痕累累，只是为了看到你为我查看伤口时的柔情。——阿木木 像英雄一样战斗，或者像懦夫一样死去。——暗裔剑魔 我和战争一样永恒。——暗裔剑魔 我筑起高墙，只为了跟你锁在一起，不离不弃。——皇子 谁说笑着就是愉悦，在我微笑的面具下，是已为你风干了伤痕的心，之所以逗万千人开心，只不过是为了等你转世之后对我的，轻浅一笑。——恶魔小丑 明日安在，无人能允。——亚索 在无人注视的角落，独自默默的弹奏。琴音带着我的思恋，妄图拉住你转身而去的袖角。——琴瑟仙女 生命，不过只是一场骗局，从你开始呼吸的那一刻起，你就已经在慢慢死亡了。——死亡颂唱者 这场战争，将会是我的杰作！——暗裔剑魔 无形之刃，最为致命。——劫 妩媚倾城的面容，我蛊惑万千众生。殊不知心里早有了一个人，却只能无尽的思念。你送我的宝珠我一直带着，只因为我能看见你的身影。——九尾妖狐 永远不要质疑我的忠诚，你不会了解我为之忍受的一切。——卡特琳娜 如果你赢不了，试试换一把大点的剑！通常都有用。——咆啸深渊 我披上坚甲，挡在你前面。万千的关心，只化为一句小心。——披甲龙龟 大地的融化，海水的暴涨，星辰的坠落。我虚空的眼睛无法先知你的足迹。——虚空先知 我在时空中穿梭，只为找回曾经美好的时光……——时光老人 在诺克萨斯有一个残忍的杀手，但是你们都不明白他其实是为了国家在战斗，他的苦楚有几人懂？——诺克萨之手 有我在就不允许别人伤害你，即使我死了，也要你活着离开。——众星之子 刀光剑影，铁石心肠，只有你知道在隐雾下的我，还是那么脆弱，容易感伤。——刀锋之影 如果我俩角色互换，我会让你看看，什么叫残忍！——维嘉 我没有过多的抱怨，漫天的乌鸦都是我的朋友，有这个，就足够了。——末日使者 世间万物，表里如一者，又有几何？——婕拉 卑微的我拿起手弩隐匿在你的左右，守护着你，即使你永远也不知道。——瘟疫之源 每一张牌，都是对你的思念。我赌赢了所有，却赢不回你的爱。——卡牌大师 那手中的冥火，是坦克中的噩梦；无极里的鬼影，在我的身边穿梭。——剑圣 每一张牌，都是对你的一份思念，我赌赢了所有，却赢不回你的爱。——卡牌大师 行走于虚空，我彷徨，我迷茫。我不知何去何从，只有飘飘荡荡。——虚空行者 不要错把仁慈当做弱小。——冰女 我们该怎么进行，这令人预约的折磨呢？——魂锁典狱长 我一路种下了蘑菇，只为让你知道回家的路。——迅捷斥候 邪恶的外表，其实并不是我的内心。你总是说我困住了你，你会为我停留么？——邪恶小法师 心怀恐惧的死去，或者手染鲜血的获胜。——暗裔剑魔 恩……你们的肉非常可口。–嗜血猎手 我是一个影子，当我潜入阴影之中，没有人能够看见我，但是，我希望你是个例外！–影流之主 液压系统已开启。–首领之傲 我披上坚甲，挡在你的身前，万千的关心只化为一句：小心。–披甲龙龟 让我们合伙干吧！–猩红收割者 要协调。–琴瑟仙女 你一直在畏惧我的毒刺，别怕，让我用我的毒刺把你牵引到我的身边。–水晶先锋 我敢打赌，你的味道和鸡肉差不多。–策士统领 众星啊……我……回来……了……–众星之子 面具的笑容，遮挡不住我的悲伤，谁能看到我面具下的眼泪。–恶魔小丑 妩媚倾城的面容，我蛊惑万千众生，孰不知心里早已有了一个人，却只能无尽的思念，你送我的宝珠我一直带着，只因为我能看见你的身影。–九尾妖狐 你要来几发么？–寒冰射手 野性的本能，指引着我们的拳头。–野兽之灵 血块变厚了。–猩红收割者 我可以在空气中嗅到敌人的味道，我很努力了，可是，为什么还是找不到你的踪迹。–嗜血猎手 我们的本能如同剃刀般锋利！–野兽之灵 命运已做出了它的选择！–德邦总管 恶作剧的对象，是你哟！–恶魔小丑 没错，我知道我让你无法呼吸。–风暴女神 在无尽的虚空中，我感到了前所未有的孤独，我可以掠夺任何生命，但是却掠夺他们的心。–虚空掠夺者 现在他们可以死了！–蛮族之王 听我说，召唤师。我并没有兄弟，也不认识特斯拉！我的瞬移以及分身靠的都是魔法！–恶魔小丑 我的剑刃不但准，而且狠！–刀锋意志 愿意送我点血吗？–猩红收割者 艾欧尼亚不会灭亡。–刀锋意志 血液正在慢慢滴落。–猩红收割者 当黑色的玫瑰悄悄绽放，除了镜花水月，又有谁能了解我的心。–诡术妖姬 瞧瞧你的背后~–恶魔小丑 刀光剑影，铁石心肠，只有你知道在隐雾下的我，还是那么脆弱，容易感伤。–刀锋之影 血流成河！–猩红收割者 团结起来吧，我们必将凯旋。–天启者 击鼓，进军！–德邦总管 我没有过多的抱怨，漫天的乌鸦都是我的朋友，有这个就足够了。–末日使者 我会尽情享受他们的骨头的。–嗜血猎手 他们的胜利必将成为奢望！–刀锋意志 你们打架的时候总是这么不给力么？–众星之子 缓慢的步伐，踉跄的脚步，满嘴的胡话，还有嘴角那一抹苦涩的微笑，为何酒精都不能解脱我对你的思念。–酒桶 没有地方可以安生！–扭曲树精 你笑我为何拿上锤和盾，你说有你在，我不会受到伤害。可是你不知道，让我受伤的人，是你。–钢铁大使 收获之月，多美妙的名字啊。–猩红收割者 宝石们显露着它们的锋芒。–宝石骑士 你们只是玻璃制品，一碰就碎。–宝石骑士 我很想陪伴在你的身边，只是你不允许，没关系，在你需要帮助时，我还是会出现在你的身边。–暮光之眼 提莫队长正在待命！–迅捷斥候 要优美。–琴瑟仙女 我追逐的是你的背影，我跟随的是你的微笑，就算暴风雨到来，我依然在你的左右。–雷霆咆哮 下了手中的武器，我知道你已厌倦，目送你离开，亮的起黄昏的路灯，照亮你回家的路。–武器大师 为荣誉而战！–战争女神 您果然深思熟虑，召唤师。–暮光之眼 噢，你想要什么？–瘟疫之源 精彩的二重唱。–琴瑟仙女 我的剑刃从不颤抖。–刀锋意志 只有飞速的旋转，才可以止住我的泪水，忘记你的模样。–不祥之刃 给我找些更强的敌人！–嘉文四世 可以接受的冒险。–策士统领 让我来引领您走向胜利。–众星之子 选牌吧！–卡牌大师 我喜欢有心脏的勇士，并且绝对不会让他们过期。–猩红收割者 我知道自己一身的痛苦，我没有选择，我只有带着你的灵魂离去。–金属大师 将他们冲散！–牛头酋长 在漆黑的夜里你需要一道光照亮夜行的路，我燃烧了自己，但也造就了你我不能相拥。–复仇焰魂 当水晶箭射像你的时候，请不要害怕，只是为了让你片刻的驻足，好让我追赶你的脚步。–寒冰射手 目标已被标记。–暮光之眼 保护忠良！–嘉文四世 哪里有战斗，哪里就有我。–天启者 是啊！哈哈哈哈哈！–邪恶小法师 一曲终了，繁花散尽，伊人已逝，只余一声空叹。–死亡颂唱者 魔法！它在召唤我！–邪恶小法师 我来自深海，我没有朋友，大家都不和我玩，只有巨鲨是我的朋友，你愿意和他一起玩吗？–潮夕海灵 我是魔鬼！不许笑！–邪恶小法师 一切尽在卡牌之中。–卡牌大师 是摇，还是不摇，这是一个问题。–炼金术士 吃我一记重击！–亡灵勇士 中场休息时间！–琴瑟仙女 我想我会让你难受一阵子的！–宝石骑士 我用意念传达给您。–琴瑟仙女 这首是慢板曲，召唤师。–琴瑟仙女 完美的节拍。–琴瑟仙女 我会悼念你的。–宝石骑士 如果善待动物协会问起来的话，我们就说这些皮毛是仿制的。–野兽之灵 我宁愿相信一切，也不愿再相信世人，只有野兽能告诉我什么叫感情。–野兽之灵 忠诚之心永不停息。–首领之傲 我的&#96;道路，清澈无比。–众星之子 我会下达命令。–策士统领 俺很生气，后果很严重！–牛头酋长 视死如归，就在今天！–嘉文四世 正做着呢！–卡牌大师 如果我能休息就好了。–扭曲树精 要象征美好时光，请找琥珀。–宝石骑士 你是没有机会赢我的。–蛮族之王 没有退路了！–刀锋意志 亡命天涯，只是为了追寻你的足迹。却不想命运的捉弄，总是让你我天各一方。–法外狂徒 永恒痛苦的赠品。–首领之傲 战斗吧！–战争女神 这就是我收养那些流浪剑刃的结果。–刀锋意志 我好想射点儿什么！–麦林炮手 狩猎的时候到了。–嗜血猎手 我也试图终结过这困扰，但它总会卷土重来。–扭曲树精 执行均衡之令。–暮光之眼 德玛西亚，永世长存！–嘉文四世 是，长官！–迅捷斥候 不要否认你的本能，召唤师。–野兽之灵 你我的约定，我一直记得。那一道道璀璨的光辉，都是为你所亮。–光辉女郎 我愚蠢的以为，头上的金箍圈可以圈住你所有的爱，可是我手中的金箍棒改变不了那个开始，也决定不了这个结局，根本没有齐天大圣，我只是一只猴子。–齐天大圣 这很好玩吖！–恶魔小丑 我对你的爱就如闪电，狂暴而剧烈，飞出的飞镖，是我向你传达的思念。–狂暴之心 我醒来了，但是什么都不记得，我很害怕，我包裹住自己的身体，独自在黑暗中哭泣。–殇之木乃伊 为了内心的安宁。–众星之子 像节拍器一样准确无误。–琴瑟仙女 稳步前进！–刀锋意志 来次魔术戏法，咋样？–恶魔小丑 你的亲友们正在饱受折磨！–邪恶小法师 物是人非，可是我依然穿着嫁衣，在黑暗中寻找你的身影。–寡妇制造者 好极了！–猩红收割者 我不顾一切的冲出去，为你开辟一条安稳的路，我满腔热血的拍打着，为你抛开任何绊脚的石，最后，我坦然的微笑着用我的身体为你抵挡一切…因为我的身体上旋转着我们的誓言。–牛头酋长 你们跌倒了没？崩溃了么？–麦林炮手 胜利在望。–策士统领 攘除奸邪！–嘉文四世 我自人类诞生，却被人类抛弃，孤独的徘徊于世间，却与世间格格不入，于是我只能试图抓住每个遇到的生命，去倾诉那颗从不被理解的心。–蒸气机器人 为了父王！–嘉文四世 这局胜负已定。–嗜血猎手 漫天的冰雪冻结了我的心，但它冻结不了我心中的正义，我愿用我严寒的身躯冰冻这世间的邪恶。–冰晶凤凰 奉吾王之命！–德邦总管 我对你的爱就如闪电，狂暴而剧烈，飞出的飞镖是对你的思念。–狂暴之心 你必须跟着俺！–牛头酋长 开战吧！–蛮族之王 从我手中脱离的刀刃一直在飞舞，我不断在变强，只是为了守护我们的家园，等候你的归来。–刀锋意志 真正的意志是不会被击败的！–刀锋意志 我也希望变成蝴蝶的那一天，不再灰色，不再痛苦，不再让我丑陋的外表吓到美丽的你。–深渊巨口 我会在那儿的。–瘟疫之源 我可以想去哪里就去哪里，但是我只想去你心里。–祖安狂人 随心而动，随刃而行！–蛮族之王 我的目标很纯粹。–策士统领 我觉得我……变回人类了……–嗜血猎手 是的，只要998，就能让你爽到不能呼吸哟。–风暴女神 我们不知道何为怜悯，即使对象是你！–野兽之灵 你已经死了……只是你还没发觉而已。–暮光之眼 生存，就是折磨。–首领之傲 诺克萨斯人从来不会闲逛。–策士统领 哦好的，好的！–瘟疫之源 非常荣幸。–暮光之眼 有情况！–迅捷斥候 入体冰凉的月光，都比不上你绝情的目光。为了击碎你伪装的表面，我只能用尽全身力气挥出那惊鸿的半月弧光。——皎月女神 我束缚住了你的人，却束缚不住你的心。所以我只能远远跳离你身边，因为我知道，离你越近，我的心就会越痛。——皮城女警 沙漠中的太阳，是我对你爱的象征。——沙漠死神 在无人注视的角落，独自默默的弹奏。琴音带着我的思恋，妄图拉住你转身而去的袖角。——琴瑟仙女 我追逐的是你的背影，我跟随的是你的微笑。就算暴风雨到来，我依然能在你左右。——雷霆咆哮 默默的在背后望着你的背影，当你有危险时我会毫不犹豫的从天而降。哪怕双腿震得生疼，我依然会咬紧牙关再次跳向对手，抛出手中的战矛。哪怕是死，我也要保护你的安全。——战争之王 别看我的眼睛，里面只有愤怒和痛苦。我诅咒着一切，也诅咒着自己。——魔蛇之拥 金色的长驽陪伴我的一生，沾满鲜血的双手却磨灭不了心中的伤痛，我翻腾着身影在人群中闪烁，寻找一句最真心的问候。然后我悄悄的隐没、隐没，隐没在那孤寂的草丛……——暗夜猎手 行走于虚空，我彷徨，我迷茫。我不知何去何从，只有飘飘荡荡。——虚空行者 逝于晨，诞于暮。追寻着芳香的血液，环于世与墓之间。——猩红收割着 尘封千年，肉体早已湮灭，意识已然不清。探索了全部魔法的奥秘，只为能开辟虚空，寻找早已失去的你。——远古巫灵 你总说我太小，但是出现危险我都会跳跃到你身边，将危险推开。用手中的炮筒，守护我小小的爱。——麦林炮手 炙热的铁拳砸不开你面前的牢笼，不甘放弃的努力，只为了有一天能砸开牢笼见你一面。——皮城执法官","tags":["语录","LOL"],"categories":["手册","Game"]},{"title":"常见编程命名缩写","path":"/手册/En/常见命名缩写/","content":"通用 缩写 翻译 控件 缩写 翻译 address addr 地址 calendar cdr 日历 application app 应用程序 messageDialog msgdlg 消息框 asynchronization asyn 异步 drawer drw 抽屉 average avg 平均数 buttonGroup btngrp 按钮分组 bitmap bmp 位图 checkBox chk 复选框 buffer buf 缓冲区 container cntr 容器 character char 字符 button btn 按钮 color clr 颜色 comboBox cmb 下拉框 command cmd 命令 lable lbl 标签 delete del 删除 progressBar prg 进度条 destination dest&#x2F;dst 目的地 pageIndicator pgindic Tab分页控件 decrease dec 减少 radioButton rdo 单选框 device dev 设备 rangeSlider rngsld 滑块 different diff 不同的 scrollView svw 视图滚动 directory dir 目录 scrollBar vsb(垂直)&#x2F;hsb(水平) 滚动条 document doc 文档 slider sld 滑动器 dynamic dyna 动态的 spinBox spn 旋转框 environment env 环境 splitView spltvw 分割视图 error err 错误 stackView stackvw 堆栈视图 execute exec 执行 statusBar statbr 状态条 group grp 组 swipeView swpvw 滑动控件 image img 图像 switch sw 开关 information info 信息 tabBar tbbr tab栏 initialize init 初始化 textField txtfld 文本输入框 library lib 库 toolBar tlbr 工具栏 maximum max 最大值 toolTip tltp 提示框 minimum min 最小值 toolButton tlbtn 工具按钮 message msg 消息 treeView trvw 树形视图 number num 数字，数，数量 layout lyt 布局 object obj 对象 mainMenu mmnu 菜单栏 parameter Param 参数(形参) groupBox gbx 组合框 package pkg 打包 pictureBox pic 图片框 position pos 位置 listView lvw 列表视图 previous pre 前一个 window win(wnd) 窗口 process&#x2F;Procedure proc 进程&#x2F;过程 form frm 表单 pointer ptr 指针 textBox txt 文本框 password pwd 密码 linkLabel llbl 超链接标签框 public pub 公共的 dialog dlg 对话框 reference ref 引用 scrollIndicator scrlindic 滚动指示器 source src 源 string str 字符串 summation sum 和 synchronization sync 同步 system sys 系统 table tbl 表格 temporary tmp 临时 text txt 文本 variable var 变量 addition add 加法&#x2F;添加 argument arg 实参 array arr 数组 calculate calc 计算 configuration config 配置 column col 列 control ctrl 控制 hexadecimal hex 十六进制 original orig 原件 return rtn 返回 repeat rpt 重复 signal sig 信号 status stat 状态 stack stk 栈区 standard std 标准 trigger trig 触发 background bg 背景 escape esc 退出 user usr 用户 list lst 列表 server srv 服务 manager mgr 管理者 insert ins 插入 point pt 点 function func 函数 back bk 返回 break brk 间断 date dat 日期 edit edt 编辑 flag flg 标志 grid grd 网格 increment inc 增量 length len 长度 oracle ora 甲骨文数据库 panorama pano 全景 print prn 打印 program prg 程序 statistic stat 统计 administrator adm 管理员 database db 数据库 change chg 改变 click clk 点击 compare cmp 比较 coordinates coord 坐标 copy cpy 复制 current cur 当前的 dictionary dict 字典 display disp 显示 driver drv 驱动 extend ex&#x2F;ext 扩展 frame frm 框架&#x2F;帧 index idx&#x2F;ndx 索引 horizontal horz 水平 instance ins 实例 increase inc 增加 link lnk 链接 middle mid 中间 multiply mul 乘 resource res 资源 select sel 选择 test tst 测试 vertical vert 垂直 英文术语 描述 abstract 抽象的 abstraction 抽象性 access 访问 access level 访问级别 access function 访问函数 adapter 适配器 address 地址 address-of operator 取地址操作符 aggregation 聚合 algorithm 算法 allocate 分配 allocator 分配器 application 应用程序 architecture 体系结构 argument 实参 array 数组 arrow operator 箭头操作符 assembly language 汇编语言 assert(-ion) 断言 assign(-ment) 赋值 assignment operator 赋值操作符 base class 基类 base type 基类型 binary search 二分查找 binary tree 二叉树 binary operator 二元操作符 binding 绑定 bit 位 bitwise 以 bit 为单元逐一…… block 区块 boolean 布尔值 breakpoint 断点 build 构建 build-in 内置 bus 总线 byte 字节 cache 高速缓存（区） call 调用 callback 回调 call operator call 操作符 character 字符 child class 子类 class 类 class template 类模板 client 客户（端） code 代码 compatible 兼容 compiler time 编译期 compiler 编译器 component 组件 composition 复合 concrete 具象的 concurrent 并发 configuration 配置 connection 连接 constraint 约束（条件） construct 构件 container 容器 const C++ 关键字，constant 的缩写 constant 常量 constructor 构造函数 copy 拷贝（动词&#x2F;名词），副本（名词） create 创建 custom 定制 data 数据 database 数据库 data member 数据成员（变量） data structure 数据结构 debug 调试 debugger 调试器 declaration 声明式 default 缺省（默认） definition 定义式 delegate 委托 dereference 提领（解参考） derived class 派生类 design pattern 设计模式 destroy 销毁 destructor 析构函数 directive 指示符 document 文档 dynamic binding 动态绑定 entity 物体 encapsulation 封装 enum(-eration) 枚举 equality 相等 equivalence 等价 evaluate 核定、核算 exception 异常 explicit 显式 expression 表达式 file 文件 framework 框架 full specialization 全特化 function 函数 function object 函数对象 function template 函数模板 generic 泛型、泛化、一般化 getter 取值函数 global 全局的 handle 句柄 handler 处理函数 hash table 哈希表、散列表 header(file) 头文件 heap 堆 hierarchy 继承体系 identifier 标识符 implement(-ation) 实现 implicit 隐喻的、暗自的、隐式 information 信息 inheritance 继承 inline 内联 initialization list 初始化列表 initialize 初始化 instance 实体 instantiate 实体化 interface 接口 Internet 互联网 interpreter 解释器 invariants 恒常性 invoke 调用 iterator 迭代器 library 程序库 linker 连接器 literal 字面常量 list 链表 load 装载 local 局部的 lock 机锁 loop 循环 lvalue 左值 macro 宏 member 成员 member function 成员函数 memory 内存 memory leak 内存泄漏 meta 元 meta-programming 元编程 modeling 塑膜 module 模块 modifier 修饰符 multi-tasking 多任务 namespace 命名空间 native 固有的 nested 嵌套的 object 对象 object based 基于对象的 object model 对象模型 object oriented 面对对象 operand 操作数 operating system 操作系统 operator 操作符 overflow 溢出 overhead 额外开销 overload 重载 override 覆写 package 包 parallel 并行 parameter 参数、形参 parent class 父类 parse 解析 partial specialization 偏特化 pass by reference 按址传递 pass by value 按值传递 pattern 模式 placement delete （某种特殊形式的 delete operatoe） placement new （某种特殊形式的 new operatoe） pointer 指针 polymorphism 多态 preprocessor 预处理器 print 打印 printer 打印机 process 进程 program 程序 programer 程序员 programming 编程 project 项目 pseudo code 伪代码 quality 质量 queue 队列 raw 原始的、未经处理的 recursive 递归 refer to 指向、指称 reference 引用 regular expression 正则表达式 resolve 解析 return 返回 return type 返回类型 return value 返回值 runtime 运行期 rvalue 右值 save 保存 schedule 调度 scheduler 调度器 scope 作用域 search 查找 semantics 语义 setter 设值函数 signature 签名 smart pointer 智能指针 specialization 特化 source 源码 stack 栈 standard library 标准程序库 statement 语句 static 静态的 string 字符串 subtype 子类型 support 支持 template 模板 temporary object 临时对象 text 文本 thread 线程 thread safe 多线程安全 throw 抛出 token 语汇单元 type 类型 unary function 单参函数 underflow 下溢 unqualified 未经资格修饰 user 用户 user interface 用户界面 value 值 variable 变量 vector 矢量 virtual function 虚拟函数 virtual machine 虚拟机","tags":["手册","速查"],"categories":["手册","En"]},{"title":"《深入理解Windows操作系统》一书附录中英语单词整理","path":"/手册/En/CodeEn_from_Windows/","content":"摘自《深入理解Windows操作系统》附录章节的英语对照。 《深入理解Windows操作系统》术语对照表 英文 对照 access token 访问令牌 access validation 访问验证 access-control entry，ACE 访问控制项 access-control list，ACL 访间控制列表 Active Directory 活动目录 Address Windowing Extension，AWE 地址窗口 context switch 环境切换扩展 affinity 亲和性 alert 警醒 assertion 断言 asymmetric multiprocessing，ASMP 非对称多处理 asynchronous procedure call，APC 异步过程调用 attach 附载 authentication 认证 balance set manager 平衡集管理器 bin 巢箱 bind， binding 绑定 blue screen 蓝屏 boost 提升 boot 引导 boot partition 引导分区 boot sector 引导扇区 boot volume 引导卷 bucket 桶 bug check 错误检查 bus driver 总线型驱动程序 cable 线缆 cache manager 缓存管理器 cache miss 缓存未命中 Careful Write file system 谨慎写文件系统 catalog file 编目文件 cel 巢室 change journal 变化日志 class driver 类驱动程序 cluster 簇（用于磁盘存储单元），集群 COM 组件对象模型 committed memory 提交的内存 Common Internet File System， CIFS Internet 文件系统 compatibility 兼容性 concurrency 并发性 context 环境 copy-on-write 写时复制 crash analysis 崩溃分析 crash dump 崩溃转储 credential 凭证 critical section 临界区 cryptographic service provider，CSP 密码服务提供者 cyclic redundancy checksum， CRC 循环冗余检验和 DCOM 分布式组件对象模型 deadlock 死锁 debugger 调试器 deferred procedure call，DPC 延迟过程调用 defragmenter 碎片整理器 deliver 交付（针对APC&amp;DPC） dependency 相依性 desktop 桌面 device driver 设备驱动程序 Device Enumeration 设备列举 Discretionary access control，DAC 自主访问控制 disk spanning 磁盘跨展 dismount 卸载 dispatcher 分发器 dispatching 分发 Distributed File System，DFS 分布式文件系统 docking station 插接站 double-freeing 两次释放 drive letter 驱动器字母 Driver Verifier 驱动程序检验器 dynamic link library，DLL 动态链接库 Encrypting File System， EFS 加密文件系统 environment subsystem 环境子系统 ETW， Event Tracing for Windows Windows 事件跟踪 event 事件 Event Log 事件日志 exception 异常 exception dispatching 异常分发 exception frame 异常帧 exception handler 异常处理器 exception handling 异常处理 executive 执行体 executive object 执行体对象 extended partition 扩展分区 extensibility 扩展性 Extensible Firmware Interface，EFI 可扩展的固件接口 fast mutex 快速互斥体 fault tolerance 容错 fiber 纤程 fibre channel 光纤通道 file allocation table 文件分配表 file encryption key，FEK 文件加密密钥 file mapping object 文件映射对象 file system driver， FSD 文件系统驱动程序 file system recognizer 文件系统识别器 filter driver 过滤型驱动程序 firmware 固件 footprint 印迹 free list 空闲（页面）列表 function driver 功能型驱动程序 GINA 图形化标识和认证 Group Policy 组策略 guard page 守护页面 GUID 全局唯一标识符 GUID Partition Table，GPT GUID 分区表 handle 句柄 handle table 句柄表 handler 处理器 hardware abstraction layer 硬件抽象层（HAL） heap manager 堆管理器 hive 储巢 hotfix 热补丁 Hyper-Threading 超线程 I&#x2F;O request packet，IRP I&#x2F;O 请求包 idle process 空闲进程 idle thread 空闲线程 impersonation 模仿 inter-processor interrupt，IPI 处理器间的中断 interrupt controller 中断控制器 interrupt dispatch table 中断分发表 interrupt handler 中断处理器 interrupt request level，IRQL 中断请求级别 Interrupt service routine，ISR 中断服务例程 interupt 中断 job 作业 junction 交接 kernel 内核 kernel mode 内核模式 kernel object 内核对象 key ring 密钥环 keystroke 键击 last known good，LKG 最后已知的好配置，最后已知的好控制集 lazy write file system 延迟写文件系统 lazy writer 延迟写出器 Lightweight Directory Acess Protocol, LDAP 轻量的目录访问协议 local procedure call，LPC 本地过程调用 local security authentication 本地安全认证 lock convoy 锁封护 loCompletion I&#x2F;O 完成 logical cluster number.LCN 逻辑簇号 Logical Disk Manager.LDM 逻辑磁盘管理器 logical prefetcher 逻辑预取器 logical sequence number，LSN 逻辑序列号 logon 登录 look-aside list 预读列表 Low Fragmentation Heap，LFH 低碎片堆 LUID 本地唯一标识符 mailslot 邮件槽 managed code 托管代码 manifest 清单 mapped file 映射的文件 master boot record.MBR 主引导记录 master file table 主文件表 mechanism 机制 memory 内存 memory descriptor list.MDL 内存描述符列表 memory mapped file 内存映射文件 metadata 元数据 microkernel 微内核 minidump 小转储 miniport 小端口 miniport driver 小端口驱动程序 mirrored volume 镜像卷 MMC snap-in MMC 加载件 modified page writer 已修改页面写出器 mount 挂载 mount point 挂载点 multimaster replication 多主复制 Multiple Provider Router 多提供者转发器 Multiple UNC Provider，MUP 多UNC提供者 multiprocessing 多处理 multitasking 多任务 mutant 突变体 mutex 互斥体 named pipe 命名管道 native 原生的 network address translation.NAT 网络地址转译 Network Driver Interface Specification, NDIS 网络驱动程序接口规范 Network Monitor 网络监视器 network share 网络共享体 NTFS object atribute NTFS 对象属性 NUMA（non-uniform memory architecture） 非一致的内存结构 objcct manager 对象管理器 object linking and embedding. OLE 对象链接和嵌入 ommit 提交 on-disk structure 磁盘上的结构 Open System Interconnection， OSI 开放系统互联 opportunistic locking，oplock 机会锁 overlapped 可重叠的 page 页面 page directory 页目录 page directory entry，PDE 页目录项 page fault 页面错误 page file，paging file 页面文件 page frame number，PFN 页面帧编号 page table 页表 page table entry，PTE 页表项 pageable 换页的 paged pool， nonpaged pool 换页内存池，非换页内存池 pager 换页器 parition 分区 partition table 分区表 payload 有效载荷 Performance Monitor 性能监视器 Performance tool 性能工具 Physical Address Extension，PAE 物理地址扩展 placement policy 放置策略 plug and play 即插即用 pool tracking 内存池跟踪 port driver 端口驱动程序 portability 可移植性 preempt 抢占 preemptive 抢先式 prefetcher 预取器 principal 安全个体 priority boost 优先级提升 priority inversion 优先级倒置 privilege 特权 procedure 过程 process 进程 Process environment block，PEB 进程环境块 process explorer 进程管理器（视上下文 process manager 进程管理器（视上下文 processor 处理器 profile 轮廓，性能剖析 prototype page table entry，prototype PTE 原型页表项 push lock 推锁 quality of service，QOS 服务质量 quantum 时限 quantum boosting 时限增大 queue 队列 quota 配额 quota charges 配额花费 RAM Optimizer RAM 优化器 read-ahead 预读 record 记录 recoverability 可恢复性 Recovery Console 恢复控制台 redirector 重定向器 redo 重做 reference count 引用计数 reference monitor 引用监视器 registry 注册表 registry key 注册表键 registry value 注册表值 reliability 可靠性 Remote Direct Memory Access， RDMA 远程直接内存访问 Remote NDIS 外接NDIS remote procedure call，RPC 远过程调用 reparse 重解析 reparse point 重解析点 reserved memory 保留的内存 resource accounting 资源记账 resource gate 资源门控 Resource Reservation Protocol，RSVP 资源预留协议 robustness 健壮性 routine 例程 run 行串（用于NTFS结构中） scalability 可伸缩性 scatter&#x2F;gather LI&#x2F;O 分散&#x2F;聚集 I&#x2F;O scheduler 调度器 schema 表结构 secondary object namespace 从属对象名字空间 section object 内存区对象 section， memory section 内存区 sector sparing 扇区备用 secure attention sequence.SAS 安全注意序列 Security Accounts Manager， SAM 安全账户管 security credential 安全凭证 Security descriptor 安全描述符 security identifier， SID 安全标识符 security quality of service， SQOS 安全服务质量 Security reference monitor 安全引用监视器 Security Support Provider Interface，SSPI 安全支持提供者接口 security validation 安全验证 Semaphore 信号量 serial port 串行口 server 服务器 service 服务 Service Control Manager，SCM 服务控制管理器 service descriptor table 服务描述符表 Service Pack 服务补丁包 session manager 会话管理器 session namespace 会话名字空间 shared memory 共享的内存 shim 铺垫 shutdown 停机 socket 套接字 sof fault 软错误 Software Restriction Policy 软件限制策略 spanned volume 跨距卷 spin-down 停止旋转 spinlock 自旋锁 splash screen 启动屏幕 stack frame 栈帧 stack location 栈单元 stack overrun 栈溢出 stack trash 栈破坏 standby list 备用（页面）列表 startup 启动 starvation 饥饿 storage area network，SAN 存储区域网络 striped volume 条带卷 stub 存根 symbolic link 符号链接 symmetric multiprocessing， SMP 对称多处理 synchronization 同步 system service 系统服务 system service call 系统服务调用理器 system service dispatching 系统服务分发 system volume 系统卷 targeted DPC 定向的DPC（与特定的CPU相关联） Task Manager 任务管理器 task ofloading 任务外移 TDI transport TD 1传输器 terminal service 终端服务 thread 线程 Thread environment block，TEB 线程环境块 thread scheduling 线程调度 thread-thrashing 线程频繁轮换 tick 嘀嗒 time slice 时间片 timer 定时器 TLS 线程局部存储区 transaction 事务 transition 转移，转换 Translation Look-aside Buffer，TLB 地址转译快查缓冲区 Transport Driver Interface， TDI 传输驱动程序接口 trap 捕获（动词），陷阱（名词） trap frame 陷阱帧 trap handler 陷阱处理器 trigger 触发器 trim 修剪 truncate 截断、截短 undo 撤销 unicast 单播 Universal Disk Format， UDF 通用磁盘格式 Universal Naming Convention， UNC 统一命名规范 Universal Plug and Play.UPnP 通用即插即用 unmanaged code 非托管代码 user mode 用户模式 view 视图（确切含义视上下文） virtual address control block，VACB 虚拟地址控制块 Virtual address descriptor，VAD 虚拟地址描述符 virtual cluster number，VCN 虚拟簇号 volatile 易失的、易失性 window station 窗口站 Windows 管理规范 Windows Driver Model， WDM Windows 驱动程序模型 Windows Error Reporting Windows 错误报告 Windows File Protection， WFP Windows 文件保护机制 Windows Global Flags Windows 全局标志 Windows Internet 名称服务 Windows Internet Name Service WINS，Windows管理规范 Windows Management Instrumentation Windows管理规范 Windows Sockets Direct， WSD Windows 套接字直接访问 working set 工作集 working set trimming 工作集修剪 write throtling 写节流 write-behind 滞后写 write-through 直写 yield 放弃 zero list 零（页面）列表 zero page thread 零页面线程","tags":["手册","《深入理解Windows操作系统》","英语"],"categories":["手册","En"]},{"title":"编程常用英语词汇","path":"/手册/En/CodeEn/","content":"编程常用英语整理一、交互式环境与print输出1、print：打印&#x2F;输出2、coding：编码3、syntax：语法4、error：错误5、invalid：无效6、identifier：名称&#x2F;标识符7、character ：字符 二、字符串的操作1、user：用户2、name：姓名&#x2F;名称3、attribute：字段&#x2F;属性4、value：值 三、重复&#x2F;转换&#x2F;替换&#x2F;原始字符串1、upper：上面2、lower：下面3、capitalize：用大写字母写或印刷4、title：标题5、replace：替换6、old：旧的7、new：新的8、count：计数9、swap：互换10、case：情形11、path：路径12、new：新的\\新建13、project：项目14、test：测试15、file：文件16、data：数据 四、去除&#x2F;查询&#x2F;计数1、strip：去除2、index：索引3、find：查找4、count：计数5、start：开始6、end：结束7、chars：字符8、sub：附属 五、获取输入&#x2F;格式化1、input：输入2、prompt：提示3、ID：身份证4、format：格式化5、args（argument）：参数6、kwargs：关键字参数7、year：年8、month：月9、day：日 六、元祖1、tuple：元组2、max：最大3、min：最小4、iterable：可迭代5、key：关键字6、function：方法&#x2F;函数7、stop：停止8、object：对象 七、列表1、list：列表2、reverse：反向3、true：真4、false：假5、append：附加6、extend：扩展7、insert：插入8、pop：取出9、remove：移除10、del（delete）：删除11、clear：清除12、sort：排序 八、集合1、set：集合&#x2F;设置2、add：添加3、update：更新4、discard：丢弃5、intersection：相交6、union：联合7、difference：差数8、symmetric：对称9、in：在…里面10、not：不&#x2F;不是11、disjoint：不相交12、subset：子集13、superset：父集&#x2F;超集14、copy：复制 九、字典1、dict：字典2、key：键&#x2F;关键字3、value：值4、item：项5、mapping：映射6、seq（sequence）：序列7、from：从&#x2F;来自8、get：获取9、default：默认10、none：没有11、arg：可变元素12、kwargs（keyword args）：可变关键字元素 十、常用的一些必备的英语单词 Projects ：项目 Process finished with exit code 0 进程结束，退出代码为0，一般是执行成功的过程 Process： 过程 code ：代码 Traceback：回溯 File：文件 line：行 module：模块[‘mɑdʒul] NameError：名称错误 is not defined：没有定义 SyntaxError：语法错误 literal：文字，文字的 string：字符串 scanning：扫描 EOL ：寿命终止 IndentationError：缩减错误 unindent：取消缩进 match：匹配 indentation：缩进 [,ɪndɛn’teʃən]缩进 unindent does not match any outer indentation level： 未缩进不匹配任何外部缩进级别 invalid syntax：无效的语法 十一、扇贝扇贝上有专门整理好的pyhon常用单词，但是要支付199贝壳。 我写了个爬虫，免199贝壳去支付…拿下网页的单词，下面是代码： 12345678910111213141516171819202122232425262728293031323334import requestsimport refile = open(&quot;vocabulary.doc&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)def spider(url): res = requests.get(url).text pattern = &#x27;&lt;strong&gt;([a-z,A-Z]*?)&lt;/strong&gt;\\s*&lt;/td&gt;\\s*&lt;td class=&quot;span10&quot;&gt;(.*?)&lt;/td&gt;&#x27; vocabulary_list = re.findall(pattern, res) for vocabulary in vocabulary_list: file.writelines((vocabulary[0].strip(&#x27;&#x27;), vocabulary[1].strip(&#x27;&#x27;), &quot; &quot;))url_list = [&quot;[词串： list 1](https://www.shanbay.com/wordlist/104899/202159/?page=)&quot;, &quot;[词串： list 2](https://www.shanbay.com/wordlist/104899/202162/?page=)&quot;, ]for url in url_list: for i in range(1, 10): url = &quot;[词串： list 1](https://www.shanbay.com/wordlist/104899/202159/?page=)&quot; + str(i) spider(url)file.close() 会生成一个word的结果文档在代码运行的同一目录下，结果如下，没有可以排版，最好是放在excel下。 十二、程序员常用单词600个A application 应用程式 应用、应用程序 application framework 应用程式框架、应用框架 应用程序框架 architecture 架构、系统架构 体系结构 argument 引数（传给函式的值）。叁见 parameter 叁数、实质叁数、实叁、自变量 array 阵列 数组 arrow operator arrow （箭头）运算子 箭头操作符 assembly 装配件 assembly language 组合语言 汇编语言 assert (ion) 断言 assign 指派、指定、设值、赋值 赋值 assignment 指派、指定 赋值、分配 assignment operator 指派（赋值）运算子 &#x3D; 赋值操作符 associated 相应的、相关的 相关的、关联、相应的 associative container 关联式容器（对应 sequential container） 关联式容器 atomic 不可分割的 原子的 attribute 属性 属性、特性 audio 音讯 音频 A.I. 人工智慧 人工智能 B background 背景 背景（用於图形着色） 后台（用於行程） backward compatible 回溯相容 向下兼容 bandwidth 频宽 带宽 base class 基础类别 基类 base type 基础型别 (等同於 base class) batch 批次（意思是整批作业） 批处理 benefit 利益 收益 best viable function 最佳可行函式 最佳可行函式 （从 viable functions 中挑出的最佳吻合者） binary search 二分搜寻法 二分查找 binary tree 二元树 二叉树 binary function 二元函式 双叁函数 binary operator 二元运算子 二元操作符 binding 系结 绑定 bit 位元 位 bit field 位元栏 位域 bitmap 位元图 位图 bitwise 以 bit 为单元逐一┅ bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝 block 区块,区段 块、区块、语句块 boolean 布林值（真假值，true 或 false） 布尔值 border 边框、框线 边框 brace (curly brace) 大括弧、大括号 花括弧、花括号 bracket (square brakcet) 中括弧、中括号 方括弧、方括号 breakpoint 中断点 断点 build 建造、构筑、建置（MS 用语） build－in 内建 内置 bus 汇流排 总线 business 商务,业务 业务 buttons 按钮 按钮 byte 位元组（由 8 bits 组成） 字节 C cache 快取 高速缓存 call 呼叫、叫用 调用 callback 回呼 回调 call operator call （函式呼叫）运算子调用操作符 （同 function call operator） candidate function 候选函式 候选函数 （在函式多载决议程序中出现的候选函式） chain 串链（例 chain of function calls） 链 character 字元 字符 check box 核取方块 (i.e. check button) 复选框 checked exception 可控式异常(Java) check button 方钮 (i.e. check box) 复选按钮 child class 子类别（或称为derived class, subtype） 子类 class 类别 类 class body 类别本体 类体 class declaration 类别宣告、类别宣告式 类声明 class definition 类别定义、类别定义式 类定义 class derivation list 类别衍化列 类继承列表 class head 类别表头 类头 class hierarchy 类别继承体系, 类别阶层 类层次体系 class library 类别程式库、类别库 类库 class template 类别模板、类别范本 类模板 class template partial specializations 类别模板偏特化 类模板部分特化 class template specializations 类别模板特化 类模板特化 cleanup 清理、善后 清理、清除 client 客端、客户端、客户 客户 client－server 主从架构 客户&#x2F;服务器 clipboard 剪贴簿 剪贴板 clone 复制 克隆 collection 群集 集合 combo box 复合方块、复合框 组合框 command line 命令列 命令行 (系统文字模式下的整行执行命令) communication 通讯 通讯 compatible 相容 兼容 compile time 编译期 编译期、编译时 compiler 编译器 编译器 component 组件 组件 composition 复合、合成、组合 组合 computer 电脑、计算机 计算机、电脑 concept 概念 概念 concrete 具象的 实在的 concurrent 并行 并发 configuration 组态 配置 connection 连接，连线（网络,资料库） 连接 constraint 约束（条件） construct 构件 构件 container 容器 容器（存放资料的某种结构如 list, vector…） containment 内含 包容 context 背景关系、周遭环境、上下脉络 环境、上下文 control 控制元件、控件 控件 console 主控台 控制台 const 常数（constant 的缩写，C++ 关键字） constant 常数（相对於 variable） 常量 constructor (ctor） 建构式 构造函数 （与class 同名的一种 member functions） copy (v) 复制、拷贝 拷贝 copy (n) 复件, 副本 cover 涵盖 覆盖 create 创建、建立、产生、生成 创建 creation 产生、生成 创建 cursor 游标 光标 custom 订制、自定 定制 D data 资料 数据 database 资料库 数据库 database schema 数据库结构纲目 data member 资料成员、成员变数 数据成员、成员变量 data structure 资料结构 数据结构 datagram 资料元 数据报文 dead lock 死结 死锁 debug 除错 调试 debugger 除错器 调试器 declaration 宣告、宣告式 声明 deduction 推导（例：template argument deduction） 推导、推断 default 预设 缺省、默认 defer 延缓 推迟 define 定义 预定义 definition 定义、定义区、定义式 定义 delegate 委派、委托、委任 委托 delegation （同上） demarshal 反编列 散集 dereference 提领（取出指标所指物体的内容） 解叁考 dereference operator dereference （提领）运算子 * 解叁考操作符 derived class 衍生类别 派生类 design by contract 契约式设计 design pattern 设计范式、设计样式 设计模式 ※ 最近我比较喜欢「设计范式」一词 destroy 摧毁、销毁 destructor 解构式 析构函数 device 装置、设备 设备 dialog 对话窗、对话盒 对话框 directive 指令（例：using directive） (编译)指示符 directory 目录 目录 disk 碟 盘 dispatch 分派 分派 distributed computing 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算) document 文件 文档 dot operator dot （句点）运算子 . (圆)点操作符 driver 驱动程式 驱动（程序） dynamic binding 动态系结 动态绑定 E efficiency 效率 效率 efficient 高效 高效 end user 终端用户 entity 物体 实体、物体 encapsulation 封装 封装 enclosing class 外围类别（与巢状类别 nested class 有关）外围类 enum (enumeration) 列举（一种 C++ 资料型别） 枚举 enumerators 列举元（enum 型别中的成员） 枚举成员、枚举器 equal 相等 相等 equality 相等性 相等性 equality operator equality （等号）运算子 &#x3D;&#x3D; 等号操作符 equivalence 等价性、等同性、对等性 等价性 equivalent 等价、等同、对等 等价 escape code 转义码 转义码 evaluate 评估、求值、核定 评估 event 事件 事件 event driven 事件驱动的 事件驱动的 exception 异常情况 异常 exception declaration 异常宣告（ref. C++ Primer 3&#x2F;e, 11.3） 异常声明 exception handling 异常处理、异常处理机制 异常处理、异常处理机制 exception specification 异常规格（ref. C++ Primer 3&#x2F;e, 11.4） 异常规范 exit 退离（指离开函式时的那一个执行点） 退出 explicit 明白的、明显的、显式 显式 export 汇出 引出、导出 expression 运算式、算式 表达式 F facility 设施、设备 设施、设备 feature 特性 field 栏位,资料栏（Java） 字段, 值域（Java） file 档案 文件 firmware 韧体 固件 flag 旗标 标记 flash memory 快闪记忆体 闪存 flexibility 弹性 灵活性 flush 清理、扫清 刷新 font 字型 字体 form 表单（programming 用语） 窗体 formal parameter 形式叁数 形式叁数 forward declaration 前置宣告 前置声明 forwarding 转呼叫,转发 转发 forwarding function 转呼叫函式,转发函式 转发函数 fractal 碎形 分形 framework 框架 框架 full specialization 全特化（ref. partial specialization） function 函式、函数 函数 function call operator 同 call operator function object 函式物件（ref. C++ Primer 3&#x2F;e, 12.3） 函数对象 function overloaded resolution 函式多载决议程序 函数重载解决（方案） functionality 功能、机能 功能 function template 函式模板、函式范本 函数模板 functor 仿函式 仿函式、函子 G game 游戏 游戏 generate 生成 generic 泛型、一般化的 一般化的、通用的、泛化 generic algorithm 泛型演算法 通用算法 getter (相对於 setter) 取值函式 global 全域的（对应於 local） 全局的 global object 全域物件 全局对象 global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符 group 群组 group box 群组方块 分组框 guard clause 卫述句 (Refactoring, p250) 卫语句 GUI 图形介面 图形界面 H hand shaking 握手协商 handle 识别码、识别号、号码牌、权柄 句柄 handler 处理常式 处理函数 hard－coded 编死的 硬编码的 hard－copy 硬拷图 屏幕截图 hard disk 硬碟 硬盘 hardware 硬体 硬件 hash table 杂凑表 哈希表、散列表 header file 表头档、标头档 头文件 heap 堆积 堆 hierarchy 阶层体系 层次结构（体系） hook 挂钩 钩子 hyperlink 超链结 超链接 I icon 图示、图标 图标 IDE 整合开发环境 集成开发环境 identifier 识别字、识别符号 标识符 if and only if 若且唯若 当且仅当 Illinois 伊利诺 伊利诺斯 image 影像 图象 immediate base 直接的（紧临的）上层 base class。 直接上层基类 immediate derived 直接的（紧临的）下层 derived class。 直接下层派生类 immutability 不变性 immutable 不可变（的） implement 实作、实现 实现 implementation 实作品、实作体、实作码、实件 实现 implicit 隐喻的、暗自的、隐式 隐式 import 汇入 导入 increment operator 累加运算子 ++ 增加操作符 infinite loop 无穷回圈 无限循环 infinite recursive 无穷递回 无限递归 information 资讯 信息 infrastructure 公共基础建设 inheritance 继承、继承机制 继承、继承机制 inline 行内 内联 inline expansion 行内展开 内联展开 initialization 初始化（动作） 初始化 initialization list 初值列 初始值列表 initialize 初始化 初始化 inner class 内隐类别 内嵌类 instance 实体 实例 （根据某种表述而实际产生的「东西」） instantiated 具现化、实体化（常应用於 template） 实例化 instantiation 具现体、具现化实体（常应用於 template） 实例 integer (integral) 整数（的） 整型（的） integrate 整合 集成 interacts 交谈、互动 交互 interface 介面 接口 for GUI 介面 界面 interpreter 直译器 解释器 invariants 恒常性,约束条件 约束条件 invoke 唤起 调用 iterate 迭代（回圈一个轮回一个轮回地进行） 迭代 iterative 反覆的，迭代的 iterator 迭代器（一种泛型指标） 迭代器 iteration 迭代（回圈每次轮回称为一个 iteration） 迭代 item 项目、条款 项、条款、项目 L laser 雷射 激光 level 阶 层 (级) 例 high level 高阶 高层 library 程式库、函式库 库、函数库 lifetime 生命期、寿命 生命期、寿命 link 联结、连结 连接,链接 linker 联结器、连结器 连接器 literal constant 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数 list 串列（linked－list） 列表、表、链表 list box 列表方块、列表框 列表框 load 载入 装载 loader 载入器 装载器、载入器 local 区域的（对应於 global） 局部的 local object 区域物件 局部对象 lock 机锁 loop 回圈 循环 lvalue 左值 左值 M macro 巨集 宏 magic number 魔术数字 魔法数 maintain 维护 维护 manipulator 操纵器（iostream 预先定义的一种东西） 操纵器 marshal 编列 列集 叁考 demarshal mechanism 机制 机制 member 成员 成员 member access operator 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符 member function 成员函式 成员函数 member initialization list 成员初值列 成员初始值列表 memberwise 以 member 为单元┅、members 逐一┅ 以成员为单位 memberwise copy 以 members 为单元逐一复制 memory 记忆体 内存 menu 表单、选单 菜单 message 讯息 消息 message based 以讯息为基础的 基於消息的 message loop 讯息回圈 消息环 method (Java) 方法、行为、函式 方法 meta micro 微 middleware 中介层 中间件 modeling 模塑 modeling language 塑模语言，建模语言 modem 数据机 调制解调器 module 模组 模块 modifier 饰词 修饰符 most derived class 最末层衍生类别 最底层的派生类 mouse 滑鼠 鼠标 mutable 可变的 可变的 multi－tasking 多工 多任务 N namespace 命名空间 名字空间、命名空间 native 原生的 本地的、固有的 nested class 巢状类别 嵌套类 network 网路 网络 network card 网路卡 网卡 O object 物件 对象 object based 以物件为基础的 基於对象的 object file 目的档 目标文件 object model 物件模型 对象模型 object oriented 物件导向的 面向对象的 online 线上 在线 opaque 不透明的 operand 运算元 操作数 operating system (OS) 作业系统 操作系统 operation 操作、操作行为 操作 operator 运算子 操作符、运算符 option 选项，可选方案 选项 ordinary 常规的 常规的 overflow 上限溢位（相对於 underflow） 溢出（underflow:下溢） overhead 额外负担、额外开销 额外开销 overload 多载化、多载化、重载 重载 overloaded function 多载化函式 重载的函数 overloaded operator 多载化运算子 被重载的操作符 overloaded set 多载集合 重载集合 override 改写、覆写 重载、改写、重新定义 （在 derived class 中重新定义虚拟函式 P package 套件 包 pair 对组 palette 调色盘、组件盘、工具箱 pane 窗格 窗格（有时为嵌板之意，例 Java Content Pane） parallel 平行 并行 parameter 叁数（函式叁数列上的变数） 叁数、形式叁数、形叁 parameter list 叁数列 叁数列表 parent class 父类别（或称 base class） 父类 parentheses 小括弧、小括号 圆括弧、圆括号 parse 解析 解析 part 零件 部件 partial specialization 偏特化（ref. C++ Primer 3&#x2F;e, 16.10） 局部特化 （ref. full specialization） pass by address 传址（函式引数的传递方式）（非正式用语）传地址 pass by reference 传址（函式引数的一种传递方式） 传地址, 按引用传递 pass by value 传值（函式引数的一种传递方式） 按值传递 pattern 范式、样式 模式 performance 效率、性能兼而有之 性能 persistence 永续性 持久性 pixel 图素、像素 像素 placement delete ref. C++ Primer3&#x2F;e, 15.8.2 placement new ref. C++ Primer 3&#x2F;e, 15.8.2 platform 平台 平台 pointer 指标 指针 址位器（和址叁器 reference 形成对映，满好） poll 轮询 轮询 polymorphism 多型 多态 pop up 冒起式、弹出式 弹出式 port 埠 端口 postfix 后置式、后序式 后置式 precedence 优先序（通常用於运算子的优先执行次序） prefix 前置式、前序式 前置式 preprocessor 前处理器 预处理器 prime 质数 素数 primitive type 基本型别 (不同於 base class,基础类别) print 列印 打印 printer 印表机 打印机 priority 优先权 (通常用於执行绪获得 CPU 时间的优先次序） procedure 程序 过程 procedural 程序性的、程序式的 过程式的、过程化的 process 行程 进程 profile 评测 评测 profiler 效能（效率）评测器 效能（性能）评测器 programmer 程式员 程序员 programming 编程、程式设计、程式化 编程 progress bar 进度指示器 进度指示器 project 专案 项目、工程 property 属性 protocol 协定 协议 pseudo code 假码、虚拟码、伪码 伪码 Q qualified 经过资格修饰（例如加上 scope 运算子） 限定 qualifier 资格修饰词、饰词 限定修饰词 quality 品质 质量 queue 伫列 队列 R radian 径度 弧度 radio button 圆钮 单选按钮 raise 引发（常用来表示发出一个 exception） 引起、引发 random number 随机数、乱数 随机数 range 范围、区间（用於 STL 时） 范围、区间 rank 等级、分等（ref. C++Primer 3&#x2F;e 9,15章） 等级 raw 生鲜的、未经处理的 未经处理的 record 记录 记录 recordset 记录集 记录集 recursive 递回 递归 re－direction 重导向 重定向 refactoring 重构、重整 重构 refer 取用 叁考 refer to 指向、指涉、指代 reference （C++ 中类似指标的东西，相当於 “化身”） 引用、叁考 址叁器, see pointer register 暂存器 寄存器 reflection 反射 反射、映像 relational database 关联式资料库 关系数据库 represent 表述，表现 表述，表现 resolve 决议（为算式中的符号名称寻找 解析 对应之宣告式的过程） resolution 决议程序、决议过程 解析过程 resolution 解析度 分辨率 restriction 局限 return 传回、回返 返回 return type 回返型别 返回类型 return value 回返值 返回值 robust 强固、稳健 健壮 robustness 强固性、稳健性 健壮性 routine 常式 例程 runtime 执行期 运行期、运行时 common language runtime (CLR) 译为「通用语言执行层」 rvalue 右值 右值 S save 储存 存储 schedule 排程 调度 scheduler 排程器 调度程序 scheme 结构纲目、组织纲目 scroll bar 卷轴 滚动条 scope 生存空间、生存范围、范畴、作用域 生存空间 scope operator 生存空间（范围决议）运算子 :: 生存空间操作符 scope resolution operator 生存空间决议运算子 生存空间解析操作符 （与scope operator同） screen 萤幕 屏幕 search 搜寻 查找 semantics 语意 语义 sequential container 序列式容器 顺序式容器 （对应於 associative container） server 伺服器、伺服端 服务器、服务端 serial 串行 serialization 次第读写,序列化 序列化 (serialize) setter (相对於 getter) 设值函式 signal 信号 signature 标记式、签名式、署名式 签名 slider 滚轴 滑块 slot 条孔、槽 槽 smart pointer 灵巧指标、精灵指标 智能指针 snapshot 萤幕快照（图） 屏幕截图 specialization 特殊化、特殊化定义、特殊化宣告 特化 specification 规格 规格、规范 splitter 分裂视窗 切分窗口 software 软体 软件 solution 解法,解决方案 方案 source 原始码 源码、源代码 stack 堆叠 栈 stack unwinding 堆叠辗转开解（此词用於 exception 主题） 栈辗转开解 * standard library 标准程式库 standard template library 标准模板程式库 statement 述句 语句、声明 status bar 状态列、状态栏 状态条 STL 见 standard template library stream 资料流、串流 流 string 字串 字符串 subroutine 子路由 subscript operator 下标运算子 [ ] 下标操作符 subtype 子型别 子类型 support 支援 支持 suspend 虚悬 挂起 symbol 符号 记号 syntax 语法 语法 T tag 标签 标记 索引标签,页签 target 标的（例 target pointer：标的指标） 目标 task switch 工作切换 任务切换 template 模板、范本 模板 template argument deduction 模板引数推导 模板叁数推导 template explicit specialization 模板显式特化（版本） 模板显式特化 template parameter 模板叁数 模板叁数 temporary object 暂时物件 临时对象","tags":["手册","英语"],"categories":["手册","En"]},{"title":"Curl 请求 Https","path":"/手册/Curl/curl请求https/","content":"使用 curl 发送 https 请求时，如下命令就会报错： 1curl &quot;https://www.baidu.com&quot; 错误代码： curl: (60) SSL certificate problem: unable to get local issuer certificate More details here: https://curl.haxx.se/docs/sslcerts.html 一般的解决办法就是下载CA证书。但是使用C++代码调用 libcurl 发送 https 请求，只需要在设置一下这个就可以关闭 ssl 验证，从而能够发送 https 请求。 1curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false);","tags":["curl","https"],"categories":["手册","Curl"]},{"title":"CMakeList","path":"/手册/CMake使用/","content":"概述： CMake 使用手册 [toc] 默认配置1project","categories":["手册"]},{"title":"使用 osquery 查询系统uuid和系统信息","path":"/工具/osquery/查询uuid和系统信息/","content":"查询uuid方法一 见查询信息方法二 通过注册表12345SELECT data from registry where key =&#x27;HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Cryptography&#x27; AND name=&#x27;MachineGuid&#x27;;# 或者SELECT data FROM registry WHERE path=&#x27;HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Cryptography\\\\MachineGuid&#x27; 查询系统版本号和windows版本方法一 直接查询1SELECT uuid, computer_name, hardware_model, hardware_serial FROM system_info; 方法二 通过注册表123456789101112SELECT data FROM registry WHERE key = &#x27;HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion&#x27; AND name IN(&#x27;CurrentMajorVersionNumber&#x27;,&#x27;CurrentMinorVersionNumber&#x27;, &#x27;CurrentBuildNumber&#x27;, &#x27;ProductName&#x27;)ORDER BY CASE name WHEN &#x27;ProductName&#x27; THEN 1 WHEN &#x27;CurrentMajorVersionNumber&#x27; THEN 2 WHEN &#x27;CurrentMinorVersionNumber&#x27; THEN 3 WHEN &#x27;CurrentBuildNumber&#x27; THEN 4 ELSE 3 END;","tags":["windows","osquery"],"categories":["工具","osquery"]},{"title":"自动生成 readme 文档","path":"/工具/ReadneGenerator/","content":"开源地址： https://github.com/kefranabg/readme-md-generator 自动生成 readme 的开源工具 安装方式：npm i -g readme-md-generator npm版本要大于8","tags":["工具","readme"],"categories":["工具"]},{"title":"使用SM3加密文件","path":"/工具/OpenSSL/使用sm3加密文件/","content":"以下是使用 OpenSSL 库进行 SM3 消息摘要和文件加密的 C++ 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;openssl/evp.h&gt;#include &lt;openssl/sha.h&gt;#include &lt;openssl/sm3.h&gt;// 计算字符串的 SM3 摘要值std::string sm3_hash_string(const std::string&amp; str) &#123; unsigned char md[SM3_DIGEST_LENGTH]; SM3(reinterpret_cast&lt;const unsigned char*&gt;(str.data()), str.size(), md); std::string hash_str(reinterpret_cast&lt;const char*&gt;(md), SM3_DIGEST_LENGTH); return hash_str;&#125;// 计算文件的 SM3 摘要值std::string sm3_hash_file(const std::string&amp; file_path) &#123; unsigned char md[SM3_DIGEST_LENGTH]; std::ifstream input(file_path, std::ios::binary); if (input) &#123; EVP_MD_CTX* mdctx = EVP_MD_CTX_new(); EVP_DigestInit_ex(mdctx, EVP_sm3(), nullptr); const size_t buf_size = 4096; char buf[buf_size]; while (input.read(buf, buf_size)) &#123; EVP_DigestUpdate(mdctx, buf, buf_size); &#125; size_t remain_size = input.gcount(); EVP_DigestUpdate(mdctx, buf, remain_size); EVP_DigestFinal_ex(mdctx, md, nullptr); EVP_MD_CTX_free(mdctx); input.close(); std::string hash_str(reinterpret_cast&lt;const char*&gt;(md), SM3_DIGEST_LENGTH); return hash_str; &#125; else &#123; throw std::runtime_error(&quot;fail to open file &quot; + file_path); &#125;&#125;// 使用密码对文件进行加密void encrypt_file(const std::string&amp; input_file_path, const std::string&amp; output_file_path, const std::string&amp; password) &#123; std::ifstream input(input_file_path, std::ios::binary); std::ofstream output(output_file_path, std::ios::binary); if (input &amp;&amp; output) &#123; const int key_len = EVP_MAX_KEY_LENGTH; const int iv_len = EVP_MAX_IV_LENGTH; unsigned char key[key_len]; unsigned char iv[iv_len]; EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sm3(), nullptr, reinterpret_cast&lt;const unsigned char*&gt;(password.data()), password.size(), 1, key, iv); EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new(); EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv); const size_t buf_size = 4096; char buf[buf_size]; while (input.read(buf, buf_size)) &#123; int len = input.gcount(); int out_len = 0; EVP_EncryptUpdate(ctx, reinterpret_cast&lt;unsigned char*&gt;(buf), &amp;out_len, reinterpret_cast&lt;unsigned char*&gt;(buf), len); output.write(buf, out_len); &#125; int len = input.gcount(); int out_len = 0; EVP_EncryptFinal_ex(ctx, reinterpret_cast&lt;unsigned char*&gt;(buf), &amp;out_len); output.write(buf, out_len); EVP_CIPHER_CTX_free(ctx); input.close(); output.close(); &#125; else &#123; throw std::runtime_error(&quot;fail to open input/output file.&quot;); &#125;&#125;int main() &#123; std::string str = &quot;message to be hashed&quot;; std::cout &lt;&lt; &quot;SM3 hash of string \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; sm3_hash_string(str) &lt;&lt; std::endl; std::string file_path = &quot;test.txt&quot;; std::cout &lt;&lt; &quot;SM3 hash of file \\&quot;&quot; &lt;&lt; file_path &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; sm3_hash_file(file_path) &lt;&lt; std::endl; std::string password = &quot;123456&quot;; try &#123; encrypt_file(file_path, &quot;test_encrypted.txt&quot;, password); &#125; catch (const std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 上述代码中，使用 SM3 函数对字符串或文件内容进行摘要；使用 EVP_BytesToKey 函数生成密码加密密钥和初始化向量，并使用 EVP_EncryptInit_ex 函数初始化加密上下文，在循环中调用 EVP_EncryptUpdate 函数对文件进行逐块加密，最后调用 EVP_EncryptFinal_ex 函数完成加密过程，将结果写入新的加密文件中。","tags":["加密","SM3","OpenSSL"],"categories":["工具","OpenSSL"]},{"path":"/index/","content":"学习|记录|分享 🤗🙂🤩🤔🤨😗🥰😘😀😁😂🤣😃😄😅😆😗🥰😘😍😎😋😊😉😙😚😐😑😶🙄🙂🤗😏🤩😣🤔😥🤨😮😛😌😴😫🥱😪😯🤐😜😝🤤😒😓😔😕🙃🤑😲☹🙁😞😖😟😤😬🤯😩😨😧😦😭😢😰😱🥵🥶😳🤪😵🥴🤮🤢🤕🤒😷🤬😡😠🤧😇🥳🥺🤠🤡🤥🤫💀👺👹👿😈🤓🧐🤭☠👻👽👾🤖💩😺😸🐱‍👤😾😿🙀😽😼😻😹 个人维护的wiki，涉及工作、学习中用到的技术和方案以及工具 我的简历 📚 文章列表 👉 Xmind文件 🎵 音乐 🎨 封面 🔎 资源 🎨 UML 📺 Code"},{"path":"/readme/","content":"🏠 返回 Qt Qt 鼠标 hover 操作时弹出文字气泡 Qt Http 下载（转载） png和jpg格式的图片(二) Qt 重启 Qt 圆形进度条 Qt动画类 Qt获取控件位置 Qt 截图 Qt在Win系统上的消息通知 Qt 自定义气泡 Qt插件——使用 QtCipherSqlitePlugin 对数据库进行加密 Qt常用基础代码汇总 QListWidget 用法整理 【一文搞懂】qss 使用 QWebEngineView 加载网页慢的问题 窗体不显示或半透明 QTableWidget 遍历 Qt窗口适配系统缩放 QLineEdit 修改部分文本样式 QStackWidget动画2 Qt 因为槽函数问题或者逻辑问题导致重复new问题解决办法及建议 Qt任务栏显示进度条 QStackWidget动画（1） Qt 启动动画 Qt 动画效果 （抖动、下坠、透明度） Qt事件过滤器（eventFilter） Qt图片旋转 Qt 窗口居中显示 Qt实现窗口拖拽 Qt 国际化 Linux Linux RPC Linux查询是否安装了某个软件 5 环境变量与文件查找 Linux基础入门15 Linux进程概念 Linux内核2 跟踪分析Linux内核的启动过程 ls命令详解 Linux 内核分析配套实验 linux 内核1 完成一个简单的时间片轮转躲到程序内核代码 工具 Readme 工具使用手册 自动生成 readme 文档 Windows Procmon 过滤用法 Win7 使用未签名驱动程序 FormatMessage函数的使用 Windows聚焦不更新 监控系统事件（网卡） winuser说明 cmd——route 热补丁支持 网络连接事件 监控路由事件 一个完整的wfp驱动 提权工具 psExec.exe 批处理获取ip到剪切板 服务中以管理员&amp;#92;普通权限启动进程 Windows 降权 使用 UMDH 定位用户模式内存泄漏 iphepler 接口整理 提权 监控指定网卡事件 C++ 通过 COM 组件 启用&amp;#92;禁用&amp;#92;查看 网卡状态 操作网卡类 监控网卡事件 使用 winsock2 相关函数 加载动态库 (loadlibrary) windows 查看进程启动参数命令行 【管道】（二） 管道通信 【管道】（一） 初识管道 其他 字符串类型转换整理(char、TCHAR、string、wstring、CString、WCHAR) 密钥分配 第7章 网络安全 常用写法整理 内存泄漏分析实战 友元 UML 片段说明 配置多个账号 3-hexo 主题快捷键 函数声明 &lt;2&gt; const 关键字 &lt;3&gt; 确定对象使用前初始化 返回值类型的规范 &lt;4&gt; 了解C++默认创建并调用的函数 OSI参考模型 三黑豆浆 C++ 枚举 typora bluebook 自定义修改主题代码 tcp.flags 说明 Xcode 下载与安装 UnSplash 获取随机图片的API 系统锁 管道demo libevent——evconnlistener_new_bind(1) 《深入理解Windows操作系统》一书附录中英语单词整理 Curl 请求 Https 正则表达式反向引用 切换shell IPv6 socket 长连接 TCP&#x2F;IP的四元组、五元组、七元组 Curl使用的一些demo，记录 临时文件 png和jpg格式的图片(一) 自然辩证法 QAction Icon 大小问题 文件大小换算方法 GO HACK PE文件分析 try-catch块 Lambda表达式 using 用法整理 动态声明子类 各种宏定义用法整理 文件后缀校验 Json11 C++ 用法总结 ⏰ 时间处理 visual studio 编译告警常见处理手段 TypeScript 中国马克思主义科学技术观 TODO using 用法整理 动态声明子类 各种宏定义用法整理 文件后缀校验 【不敢说一文搞懂】VLD 内存泄漏定位 共享文件夹 libevent http server OSI七层网络协议模型各层协议 音频房间创建及连接说明 声网参赛经历记录——白板插件开发(前端) 手册 代码规范 git emoji手册 Typora Emoji Visual Assist 快捷键整理 前端样式配置 style 常用变量名缩写 写作协作手册 Git 速查手册 常见编程命名缩写 编程常用英语词汇 winDbg 调试手册 英雄联盟语录 随机字符串 SQLite3 数据库加密 脚本 Wiki自动更新脚本 CPP C++ 常见错误——无法解析的外部符号"},{"title":"代码规范","path":"/QIANXIN/safecode/","content":"TrustClient 相关1） win api使用宏控制123#ifdef Q_OS_WIN\t#include &lt;Windows.h&gt;#endif 内存相关函数段 申请内存 12345678void *zallloc(size_t len) &#123; void *p = malloc(len); if(p) &#123; memset(p, 0, len); &#125; return p;&#125; 常用的宏1234#define safe_free(p) &#123;\\\tfree(p);\\\tp = NULL;\\&#125;\\ 线程的资源竞争 对链表、边界资源、临界区域的操作一定要加锁 12345678std::mutex mtx; // 保护countermtx.lock();// 要进行的资源操作todo();mtx.unlock();","tags":["code"],"categories":["QIANXIN"]},{"title":"TODO","path":"/TODO/index/","content":"[TOC] reinterpret_cast&lt;&gt;() 2022年7月20日18:07:34 __declspec(selectany) 2022年7月20日18:08:56 qt http 上传和下载资源的进度条显示 2022年7月20日18:09:11 关于qt的http上传和下载资源的进度条显示_yangkping123的博客-CSDN博客https://blog.csdn.net/yangkping123/article/details/46804181?utm_source=blogxgwz5 2022年7月20日18:09:28 windows DEP 2022年7月20日18:00:14 qt第五个参数 2022年7月20日18:10:00","categories":["TODO"]},{"title":"rapidjson 使用整理","path":"/OpenSource/RapidJson/","content":"概述: rapidjson使用整理 RapidJSON: 首页 [toc]","tags":["json","opensource"],"categories":["OpenSource"]},{"title":"UnSplash 获取随机图片的API","path":"/OpenSource/API/Unsplash API/","content":"我经常会使用 unsplash， 这里面的图片非常清爽，我的大多数文章的图片都是在这个网上找的，虽然也有同类型网站，但是用过一段时间以后基本都放弃了，图片质量参差不齐，筛选过程太费劲。 但是 unsplash 访问速度是个大问题，我经常会因为图片无法加载而被劝退。 今天一时手痒，顺手搜了 unsplash api 这个关键字，看官方有没有提供相关的 api 服务，还真有！ unsplash 提供了 2 个版本的 API。 一个是简单版，主要是给小型应用，流量比较少的 app 使用，可以通过 source.unsplash.com 进入；一个是进阶版的开发者中心 API, 支持更多流量的 app 使用，可以通过 unsplash.com&#x2F;developers 进入。 Source APIsource api 提供的功能比较简单。如果想获取一张随机图片，可以访问地址： 1https://source.unsplash.com/random 这个地址会重定向到一张图片的地址，可以通过响应直接获取到一张图片。 如果图片太大，加载速度也会比较慢。你可以在 url 后面添加尺寸，控制返回的图片大小： 1https://source.unsplash.com/random/800x600 如果原图片不是这种长宽比，unsplash 会对图片进行裁剪，某些部分就会丢失。如果你想保持图片的原始比例，可以把高度设成 0 ： 1https://source.unsplash.com/random/800x0 小提示 无论是什么 API, 你都可以在最后使用 &#x2F;800x0 这样的方式控制图片的大小。 你可以指定获取某位作者的图片。比如我特别喜欢 Raamin ka 拍摄的照片。 我可以把它的用户名小写以后再去掉空格，添加到 &#x2F;user 的后面： 1https://source.unsplash.com/user/raaminka 这样我就能获取到这位作者拍摄的随机妹子照片了。不要忘了，你同样是可以控制图片尺寸的。 获取某个用户喜欢的照片： 1https://source.unsplash.com/user/raaminka/like unsplash api 还支持搜索。通常来说，我都会根据要写的文章的主题在 unsplash 上搜索图片。比如我要写一篇关于加密的文章，那我就会去搜索 encryption 相关的图片： 1https://source.unsplash.com/800x0/?encryption 你也可以组合多个不同的关键字。如果没有图片同时包含这些关键字，则会优先匹配最后的关键字。 1https://source.unsplash.com/800x0/?encryption,girl 现在我们每次访问同一个 API, 得到图片都不一样，因为是随机生成的。但是如果我们在每个 API 的后面添加 &#x2F;daily 或者 &#x2F;weekly， 则可以得到固定的一张图。需要注意，这并不是说这些图片更加热门或者质量更高，只是每天&#x2F;每周保持不变的随机图片而已。 1https://source.unsplash.com/800x0/daily?sports","tags":["图片","资源","Unsplash"],"categories":["OpenSource","API"]},{"title":"libevent——evconnlistener_new_bind(1)","path":"/OpenSource/libevent/evconnlistener_new_bind(1)/","content":"libevent封装了监听套接字，将套接字和struct event统一管理。 官方的解释是： The evonnlistener mechanism gives you a way to listen for and accept incoming TCP connections 首先还是学习怎么去使用evconnlistener （一）接口1234567891011121314151617//创建struct evconnlistener *evconnlistener_new(struct event_base*base,evconnlistener_cb cb,void *ptr,unsigned flags ,int backlog,evutil_socket_t fd);struct evconnlistener*evconnlistener_new_bind(struct event_base*base,evconnlistener_cb cb,void *ptr,unsigned flags,int backlog,const struct sockaddr*sa,int socklen);void evconnlistener_free(struct evconnlistener*lev)//其中callback的定义如下：typedef void (*evconnlistener_cb)(struct evconnlistener *listener,evutil_socket_t sock, struct sockaddr*addr,int len,void *ptr);//enable 和 disableint evconnlistener_disable(struct evconnlistener *lev);int evconnlistener_enable(struct evconnlistener *lev);//调整callbackvoid evconnlistener_set_cb(struct evconnlistener*lev,evconnlistener_cb cb,void *arg)//检查evconnlistenerevutil_socket_t evconnlistener_get_fd(struct evconnlistener *lev)struct event_base *evconnlistener_get_base(struct evconnlistener*lev) evconnlistener是对 套接字和event 的封装，可以想见，在这些接口中，除了调用socket api之外，还会关联套接子到event上进而注册到event_base上去 不过接口封装好了这些行为，只需要了解这些参数的含义即可。 base：即event_basecb：当有新连接时调用的回调函数ptr：callback的参数flags：控制listner的行为backlog：同 listen(2)中backlog的含义fd：已经bind的fd，传入api让libevent做listen调用 （二）例子使用evconnlistener管理监听套接字构建一个简单的 echo server代码也可参考gayhub 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;event2/listener.h&gt;#include &lt;event2/bufferevent.h&gt;#include &lt;event2/buffer.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;assert.h&gt;static void echo_read_cb(struct bufferevent*bev,void*ctx)&#123; struct evbuffer*input=bufferevent_get_input(bev); struct evbuffer*output=bufferevent_get_output(bev); evbuffer_add_buffer(output,input);&#125;static voidecho_event_cb(struct bufferevent*bev,short events,void*ctx)&#123; if(events&amp;BEV_EVENT_ERROR) perror(&quot;Error from bufferevent&quot;); if(events&amp;(BEV_EVENT_EOF|BEV_EVENT_ERROR)) &#123; bufferevent_free(bev); &#125;&#125;static voidaccept_error_cb(struct evconnlistener*listener,void*ctx)&#123; struct event_base*base=evconnlistener_get_base(listener); event_base_loopexit(base,NULL);&#125;void accept_conn_cb(struct evconnlistener*listener,evutil_socket_t fd,struct sockaddr*address,int socklen,void*ctx)&#123; struct event_base*base=evconnlistener_get_base(listener); struct bufferevent*bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); bufferevent_setcb(bev,echo_read_cb,NULL,echo_event_cb,NULL); bufferevent_enable(bev,EV_READ|EV_WRITE);&#125;int main(int argc,char**argv)&#123; struct event_base *base; struct evconnlistener *listener; struct sockaddr_in sin; int port = 1025; base = event_base_new(); assert(base!=NULL); memset(&amp;sin,0,sizeof(sin)); sin.sin_family=AF_INET; sin.sin_addr.s_addr=htonl(0); sin.sin_port=htons(port); listener=evconnlistener_new_bind(base,//event_base accept_conn_cb,//cb NULL,// ptr LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE,//flag -1,//backlog (struct sockaddr*)&amp;sin, sizeof(sin)); assert(listener!=NULL); evconnlistener_set_error_cb(listener,accept_error_cb); event_base_dispatch(base); return 0;&#125; （三）源码看看evconnlistenr做了哪些封装 3.1结构体1234567891011121314struct evconnlistener &#123; const struct evconnlistener_ops *ops; //一些回调函数 void *lock; evconnlistener_cb cb;// evconnlistener_errorcb errorcb; void *user_data;// unsigned flags; short refcnt; unsigned enabled : 1;&#125;;struct evconnlistener_event &#123; struct evconnlistener base; struct event listener;&#125;; evconnlistener结构体将一些基本的回调函数、用户数据等封装，然后evconnlistener_event将这些东西和struct event封装在一起 3.2创建一个evconnlistener看一下初始化有哪些内容： 1234567891011121314151617181920212223242526272829303132333435struct evconnlistener *evconnlistener_new(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, evutil_socket_t fd)&#123; struct evconnlistener_event *lev; if (backlog &gt; 0) &#123; if (listen(fd, backlog) &lt; 0)//调用listen return NULL; &#125; else if (backlog &lt; 0) &#123; if (listen(fd, 128) &lt; 0) return NULL; &#125; lev = mm_calloc(1, sizeof(struct evconnlistener_event)); if (!lev) return NULL; //lev-&gt;base是一个evconnlistener结构体 lev-&gt;base.ops = &amp;evconnlistener_event_ops;//设置ops参数 lev-&gt;base.cb = cb;//设置回调 lev-&gt;base.user_data = ptr;//ptr lev-&gt;base.flags = flags;//flag lev-&gt;base.refcnt = 1; if (flags &amp; LEV_OPT_THREADSAFE) &#123; EVTHREAD_ALLOC_LOCK(lev-&gt;base.lock, EVTHREAD_LOCKTYPE_RECURSIVE); &#125; //将fd关联到struct event上去 lev-&gt;listener是struct event结构体 //这样assigh将listener_read_cb设置到event的cb中，并将struct evconnlistner做为参数 //这是一个比较复杂的过程，首先由于event激活，将先调用listener_read_cb //在listener_read_cb通过传入的struct evconnlistner调用用户自定义回调 event_assign(&amp;lev-&gt;listener, base, fd, EV_READ|EV_PERSIST, listener_read_cb, lev); //这里底层调用event_enable evconnlistener_enable(&amp;lev-&gt;base); return &amp;lev-&gt;base;&#125; 在另外一个接口evconnlistener_new_bind中由于指定了套接字结构体，因此在底层还调用了bind 3.3 listener_read_cb这个底层的回调函数先于用户回调函数调用，在这个回调中会调用用户回调，并且会将已连接的套接字作为参数传入用户回调，这也正是evconnlistener的精髓，无需要用户进行listen、bind、accept等操作 123456789101112131415161718192021222324252627282930313233343536373839404142static voidlistener_read_cb(evutil_socket_t fd, short what, void *p)&#123; struct evconnlistener *lev = p; int err; evconnlistener_cb cb; evconnlistener_errorcb errorcb; void *user_data; LOCK(lev); while (1) &#123; struct sockaddr_storage ss; socklen_t socklen = sizeof(ss); evutil_socket_t new_fd = accept(fd, (struct sockaddr*)&amp;ss, &amp;socklen);//accept if (new_fd &lt; 0) break; if (socklen == 0) &#123; /* This can happen with some older linux kernels in * response to nmap. */ evutil_closesocket(new_fd); continue; &#125; if (!(lev-&gt;flags &amp; LEV_OPT_LEAVE_SOCKETS_BLOCKING)) evutil_make_socket_nonblocking(new_fd);//non blocking if (lev-&gt;cb == NULL) &#123; UNLOCK(lev); return; &#125; ++lev-&gt;refcnt; cb = lev-&gt;cb;//拿到用户回调 user_data = lev-&gt;user_data; UNLOCK(lev); cb(lev, new_fd, (struct sockaddr*)&amp;ss, (int)socklen, user_data);//调用用户回调并将connfd传入用户回调 LOCK(lev); if (lev-&gt;refcnt == 1) &#123; int freed = listener_decref_and_unlock(lev); EVUTIL_ASSERT(freed); return; &#125; --lev-&gt;refcnt; &#125;&#125; （四）参考1.libevent programming2.libevent 深入浅出","tags":["Opensource","libevent"],"categories":["OpenSource","libevent"]},{"title":"汇编命令整理","path":"/OS/汇编/汇编基础命令/","content":"概述: 汇编命令整理 [toc] COMISSCOMISS（Compare Or Ordered Move SIMD Single）指令是x86指令集中的一条比较指令，用于比较两个单精度浮点数或单精度寄存器，并设置标志位。它也可以将比较结果移动到另一个寄存器或内存位置。 具体来说，COMISS指令将两个单精度浮点数或单精度寄存器进行比较，并设置标志位ZF（Zero Flag，零标志位）、PF（Parity Flag，奇偶标志位）和CF（Carry Flag，进位标志位）。它可以将比较结果移动到目标寄存器或内存位置。 例如，以下是一条COMISS指令的示例代码： 123复制代码comiss xmm1, xmm2 ; 比较xmm1和xmm2寄存器中的单精度浮点数 该指令会将两个寄存器中的单精度浮点数进行比较，并设置相应的标志位。然后，可以将比较结果移动到另一个寄存器或内存位置。 需要注意的是，COMISS指令只能用于单精度浮点数的比较，不能用于双精度浮点数的比较。 CVTSD2SSCVTSD2SS 是 Intel C&#x2F;C++ 编译器的一个指令，用于将 64 位双精度浮点数转换为 32 位单精度浮点数。在此过程中，源操作数（SRC）被读取并转换为 32 位单精度浮点数，然后存储在目标操作数（DEST）中。 注意，以上信息仅供参考。在实际编程中，如果你使用 CVTSD2SS 指令，你需要参考 Intel 处理器的架构和相关文档，以确保你的代码可以在目标硬件上正确执行。 JAE 在汇编语言中，JAE（Jump if Above or Equal）指令是一种根据无符号整数比较的结果进行条件转移的指令。 当CF（Carry Flag）为0且ZF（Zero Flag）为0时，表示前面的操作结果是无符号整数大于（Above）或等于（Equal）的情况，此时执行跳转操作。 例如，假设当前指令的地址为0x1000，下一条指令的地址为0x1001，而某个无符号整数的比较结果使得CF为0且ZF为0，那么执行JAE指令后，程序将会跳转到地址0x1001处执行下一条指令。 需要注意的是，具体的指令用法和语法可能会因为不同的汇编语言而略有不同，具体需要参考对应的汇编语言文档或手册。 JE 在汇编语言中，JE指令全称为“Jump if Equal”，也被称为“Jump if Zero”。它根据标志寄存器中的零标志位(ZF)的值来判断是否进行跳转。当ZF为1时，表示前面的操作结果为零，则跳转到目标地址执行；当ZF为0时，则不进行跳转。 JP 在汇编语言中，JP（Jump if Parity）指令是一种根据奇偶标志位PF（Parity Flag）的状态进行跳转的条件转移指令。 当PF为1时，表示前面操作的结果具有偶数个1位（即低8位有偶数个1），此时执行跳转操作；当PF为0时，表示前面操作的结果具有奇数个1位（即低8位有奇数个1），此时不执行跳转操作。 例如，假设当前指令的地址为0x1000，下一条指令的地址为0x1001，而某个操作的结果使得PF为1，那么执行JP指令后，程序将会跳转到地址0x1001处执行下一条指令。 需要注意的是，具体的指令用法和语法可能会因为不同的汇编语言而略有不同，具体需要参考对应的汇编语言文档或手册。 DD DD 作为伪操作命令，用于定义操作数占用的字节数，即DoubleWord的缩写，表示4个字节（32位）。 movapsmovaps是x86指令集中的一种指令，用于将对齐的封装好的128位数据从源地址移动到目标地址。这个指令通常用于处理SSE（Streaming SIMD Extensions）寄存器之间的数据传送。 在movaps指令中，”aps”表示”Aligned Packed Single”，即对齐的封装好的单精度浮点数。它要求源地址和目标地址都是16字节对齐的，以确保数据传送的效率。 例如，假设有两个SSE寄存器xmm0和xmm1，以及一个内存地址addr，那么可以使用以下指令将xmm0中的数据移动到addr所指向的内存中： 123复制代码movaps [addr], xmm0 这个指令将会将xmm0中的128位数据（即4个单精度浮点数）对齐地存储在addr所指向的内存地址中。 movss movss 是x86指令集中的一种单精度移动指令，用于将单精度浮点数（32位）从一个位置移动到另一个位置。这个指令可以用于寄存器之间、存储器和寄存器之间、存储器之间的数据传送。","tags":["汇编"],"categories":["OS","汇编"]},{"path":"/OS/Windows/驱动/驱动安装错误/","content":"安装声网卡驱动报错，代码：0xe0000246打开注册表，找到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\DeviceInstall\\Parameters 将：DeviceInstallDisabled 的值改为 0重新安装驱动即可 参考：0xe0000246解决方案 注册表被保护问题https://techquack.com/how-to-fix-the-the-configuration-registry-database-is-corrupt-error/","categories":["OS","Windows","驱动"]},{"title":"驱动常见错误及解决方案","path":"/OS/Windows/驱动/驱动开发常见错误及解决方案/","content":"概述： windows驱动开发常见错误整理及其解决思路整理 [toc] 1 指定的服务已被标记为删除在Windows系统中，有时候在尝试启动或停止服务时，可能会遇到“指定的服务已被标记为删除”错误。这个错误常是由于服务已被删除，但是其配置信息仍然存在于系统中所导致的。本文将详细讲解如何解决“指定的服务已被标记为删除”错误，包括使用方法和示例说明。 解决“指定的服务已被标记为删除”错误要解决指定的服务已被标记为删除”错误，可以使用以下方法： 方法一：使用命令行 打开命令提示符（以管理员身份运行）。 输入以下命令： 1sc delete servicename 其中，servicename是要删除的服务的名称。 按下回车键，待命执行完成。 重新启动计算机。 方法二：使用注册表编辑器 打开注册表编辑器（以管理员身份运行）。 导航到以下路径： 1HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services 3.找并删除要删除的服务的子项。 重新启动计算机。 使用示例以下是两个使用命令行和注册表编辑器解决“指定的服务已被标记为删除”错误的示例说明： 使用命令行删除服务：假设我们需要删除名“testservice”的服务，可以使用以下命令： 1sc delete testservice 这样就可以删除该服务。 使用注册表编辑器删除服务：假设我们需要删除名为“testservice”的服务，可以使用以下步骤： 打开注册表编辑器。 导航到“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services”路径。 查找名为“testservice”的子项，并删除该子项。 重新启动计算机。 这样就可以删除该服务。 总结以上是关于如何解决“指定的服务已被标记为删除”错误的攻略，包括方法和示例说明。如果您遇到了这个错误，请尝试使用以上方法解决。","tags":["Windows","驱动","OS"],"categories":["OS","Windows","驱动"]},{"title":"驱动禁用签名","path":"/OS/Windows/驱动/驱动禁用签名/","content":"方法一：使用命令提示符 \\1. 首先，按下Win+X组合键，选择“命令提示符（管理员）”。 2. 在命令提示符窗口中，输入以下命令并按下回车键：bcdedit &#x2F;set testsigning on 3. 系统会显示“操作成功完成”的提示信息，表示已成功禁用驱动签名。 4. 重新启动电脑，即可生效。 现在，你已经成功禁用了Win10的驱动签名限制，可以自由安装非官方或未经认证的驱动程序了！但是请注意，禁用驱动签名可能会带来一定的安全风险，所以在安装驱动程序时，请确保来源可靠，并及时恢复驱动签名以保证系统的安全性。 希望本文的教程能够帮助到大家，让你的电脑更加自由灵活。如果你有任何问题或者建议，欢迎在评论区留言，我会尽力解答。祝大家使用愉快！","categories":["OS","Windows","驱动"]},{"title":"获取网卡数量","path":"/OS/Windows/网络helper/获取网卡数量/","content":"获取虚拟网卡的个数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int GetNetCardNums()&#123;\tint nRet = 0;\tCoInitialize(NULL);\tINetConnectionManager* pNetManager;\tINetConnection* pNetConnection;\tIEnumNetConnection* pEnum;\tULONG celtFetched;\tstd::string strComGuid;\tNETCON_PROPERTIES* properties = nullptr;\tbool bIsInstalledNcCard = false;\tTapReg setRegGuid = get_tap_reg();\tNcStatusList ncStausList;\tif (setRegGuid.size() == 0)\t&#123; SP_LOGW(&quot;%s Reg Not Found, Re Install&quot;, __SP_FUNC__); return 0;\t&#125;\tif (S_OK != CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionManager, (void**)&amp;pNetManager))\t&#123; SP_LOGW(&quot;%s Com Instance Failed, sleep(5s)&quot;, __SP_FUNC__); return 0;\t&#125;\tpNetManager-&gt;EnumConnections(NCME_DEFAULT, &amp;pEnum);\tpNetManager-&gt;Release();\tif (NULL == pEnum)\t&#123; return 0;\t&#125;\twhile (pEnum-&gt;Next(1, &amp;pNetConnection, &amp;celtFetched) == S_OK)\t&#123; pNetConnection-&gt;GetProperties(&amp;properties); strComGuid = GUIDToString(properties-&gt;guidId); // 查看当前网卡与注册表的guid一致时的状态 for (auto&amp; it : setRegGuid) &#123; // #1 判断是否安装了 虚拟网卡 if (strComGuid.compare(it) == 0) &#123; nRet++; &#125; &#125;\t&#125;\tpEnum-&gt;Release();\treturn nRet;&#125; 网卡保活声明 1234567/** @fn keepAlive* @brief 网络连接保活** @detail 线程，通过COM组件实现*/void keepDeviceTAVnicAlive(); 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159void keepDeviceTAVnicAlive()&#123;\tstd::lock_guard&lt;std::mutex&gt; lock(g_mutex);\tbool bRet = false;\tstatic int iRePtunFlag = 1; // Nc重连标志\tstatic int iReLoadFlag = 1; // Dll重载标志\t// ipc 主要处理nc发送的消息\tTrustSpaceIPCUtil m_ncIpc(&quot;trustNcToCore&quot;);\tm_ncIpc.Initialize(&amp;HandleIpcCallBack);\tdo\t&#123; CoInitialize(NULL); INetConnectionManager* pNetManager = nullptr; INetConnection* pNetConnection = nullptr; IEnumNetConnection* pEnum = nullptr; ULONG celtFetched; std::string strComGuid; bool bIsInstalledNcCard = false; TapReg setRegGuid = get_tap_reg(); NcStatusList ncStausList; if (setRegGuid.size() == 0) &#123; SP_LOGW(&quot;%s Reg Not Found, Re Install&quot;, __SP_FUNC__); goto __REINSTALL; &#125; if (S_OK != CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionManager, (void**)&amp;pNetManager)) &#123; SP_LOGW(&quot;%s Com Instance Failed, sleep(5s)&quot;, __SP_FUNC__); std::this_thread::sleep_for(std::chrono::milliseconds(1000 * 5)); continue; &#125; pNetManager-&gt;EnumConnections(NCME_DEFAULT, &amp;pEnum); if (pNetManager) &#123; pNetManager-&gt;Release(); pNetManager = nullptr; &#125; if (NULL == pEnum) &#123; return; &#125; while (pEnum-&gt;Next(1, &amp;pNetConnection, &amp;celtFetched) == S_OK) &#123; NETCON_PROPERTIES* properties = nullptr; pNetConnection-&gt;GetProperties(&amp;properties); if (properties != nullptr) &#123; strComGuid = GUIDToString(properties-&gt;guidId); // T1 查看当前网卡与注册表的guid一致时的状态 for (auto&amp; it : setRegGuid) &#123; // #1 判断是否安装了 虚拟网卡 int minSize = min(strComGuid.size(), it.size()); if (it.compare(0, minSize, strComGuid, 0, minSize) == 0) &#123; ncStausList[properties-&gt;Status] = properties-&gt;pszwDeviceName; // #2 已安装 bIsInstalledNcCard = true; // #3 判断是否被禁用 if (NCS_DISCONNECTED == properties-&gt;Status) &#123; pNetConnection-&gt;Connect(); SP_LOGI(&quot;%s [NcCard] ReConnect&quot;, __SP_FUNC__); &#125; &#125; &#125; &#125; if (pNetConnection) &#123; pNetConnection-&gt;Release(); pNetConnection = nullptr; &#125; &#125; if (pEnum) &#123; pEnum-&gt;Release(); pEnum = nullptr; &#125; // T2 网卡启用时，判断是否有业务需要开启 if (g_sp_trust_model &amp;&amp; g_sp_trust_model-&gt;Session()-&gt;NeedsL3Tunnel() &amp;&amp; // 有三层业务 !g_sp_trust_model-&gt;Session()-&gt;IsTunnelSvrsEmpty() &amp;&amp; // 服务不为空 g_sp_trust_model-&gt;Session()-&gt;IsOnline() &amp;&amp; // 会话在线 g_bNetWorkOnline) // 必须联网 &#123; iRePtunFlag = (iRePtunFlag &gt; 300) ? 0 : ++iRePtunFlag; if (ncStausList.find(NCS_CONNECTED) == ncStausList.end() &amp;&amp; (iRePtunFlag % 30 == 0)) &#123; SP_LOGI(&quot;%s [NcCard] Auto Detect ReConnect PTUN&quot;, __SP_FUNC__); if (iReLoadFlag == 5) &#123; SP_LOGI(&quot;%s [NcCard] Auto Detect ReConnect PTUN FAILED. RUN TIMES OVER 5, NECT:[NO OPTION]&quot;, __SP_FUNC__); &#125; handleReStartNc(); Sleep(5 * 1000); iReLoadFlag++; &#125; else if (ncStausList.find(NCS_CONNECTED) != ncStausList.end()) &#123; iReLoadFlag = 0; &#125; &#125;\t__REINSTALL: CoUninitialize(); if (false == bIsInstalledNcCard) // 未安装，重新安装 &#123; // #1 未安装，重新安装 if (false == bIsInstalledNcCard) &#123; SP_DEV_LOGW(&quot;[NetCard] Detect Nc Card Not Installed&quot;); // #2 重新安装 bIsInstalledNcCard = true; std::thread installCardThread([] &#123; g_sp_trust_model-&gt;NotifyUpMessage(SP_TRUST_TOPIC_MSG_NC_INSTALL, SPJSONObject(), 100); &#125;); installCardThread.detach(); // #3 等待客户端安装 Sleep(15 * 1000); &#125; &#125; else &#123; Sleep(1 * 1000); // 每一秒检查一次 &#125;\t&#125; while (true);\treturn;&#125; 网卡是否存在12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485bool IsExistNcCard()&#123;\tbool bIsExist = false;\tint nNetCardSize = 20;\tstd::shared_ptr&lt;IP_ADAPTER_INFO&gt; pIpAdapterInfo(new IP_ADAPTER_INFO[nNetCardSize]);\tunsigned long stSize = sizeof(IP_ADAPTER_INFO) * nNetCardSize;\t//获取所有网卡信息，参数二为输入输出参数 int nRel = GetAdaptersInfo(pIpAdapterInfo.get(), &amp;stSize);\t// 空间不足\tif (ERROR_BUFFER_OVERFLOW == nRel) &#123; pIpAdapterInfo.reset(new IP_ADAPTER_INFO[stSize]); if (GetAdaptersInfo(pIpAdapterInfo.get(), &amp;stSize) != NO_ERROR) &#123; std::cout &lt;&lt; &quot;Failed to get adapter info&quot; &lt;&lt; std::endl; return false; &#125;\t&#125;\tPIP_ADAPTER_INFO cur = pIpAdapterInfo.get();\t// 多个网卡 通过链表形式链接起来的\tstd::string netdesc;\tstd::string netip;\twhile (cur) &#123; netdesc = cur-&gt;Description; switch (cur-&gt;Type) &#123; case MIB_IF_TYPE_OTHER: break; case MIB_IF_TYPE_ETHERNET: &#123; IP_ADDR_STRING* pIpAddrString = &amp;(cur-&gt;IpAddressList); netip = pIpAddrString-&gt;IpAddress.String; &#125; break; case MIB_IF_TYPE_TOKENRING: break; case MIB_IF_TYPE_FDDI: break; case MIB_IF_TYPE_PPP: break; case MIB_IF_TYPE_LOOPBACK: break; case MIB_IF_TYPE_SLIP: break; default://无线网卡,Unknown type &#123; IP_ADDR_STRING* pIpAddrString = &amp;(cur-&gt;IpAddressList); netip = pIpAddrString-&gt;IpAddress.String; &#125; break; &#125; char hex[16] = &#123; &#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27; &#125;; // mac 地址一般6个字节 // mac 二进制转16进制字符串 char macStr[18] = &#123; 0 &#125;;//12+5+1 int k = 0; for (UINT j = 0; j &lt; cur-&gt;AddressLength; j++) &#123; macStr[k++] = hex[(cur-&gt;Address[j] &amp; 0xf0) &gt;&gt; 4]; macStr[k++] = hex[cur-&gt;Address[j] &amp; 0x0f]; macStr[k++] = &#x27;-&#x27;; &#125; if (k &lt; 18 &amp;&amp; k &gt; 0) &#123; macStr[k - 1] = 0; &#125; cur = cur-&gt;Next; // 找到 &quot;TrustAgent VNIC&quot; if (netdesc.find(&quot;TrustAgent VNIC&quot;) != std::string::npos) &#123; bIsExist = true; goto _END_; &#125;\t&#125;_END_:\treturn bIsExist;&#125;","tags":["windows","网卡"],"categories":["OS","Windows","网络helper"]},{"title":"一个完整的wfp驱动","path":"/OS/Windows/驱动/一个完整地wfp驱动/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390#include &lt;ntddk.h&gt;#pragma warning(push)#pragma warning(disable:4201) // unnamed struct/union#pragma warning(disable:4995)#include &lt;fwpsk.h&gt;#pragma warning(pop)#include &lt;ndis.h&gt;#include &lt;fwpmk.h&gt;#include &lt;limits.h&gt;#include &lt;ws2ipdef.h&gt;#include &lt;in6addr.h&gt;#include &lt;ip2string.h&gt;#include &lt;strsafe.h&gt;#define INITGUID#include &lt;guiddef.h&gt;#define bool BOOLEAN#define true TRUE #define false FALSE#define DEVICE_NAME L&quot;\\\\Device\\\\WFP_TEST&quot;#define DEVICE_DOSNAME L&quot;\\\\DosDevices\\\\WFP_TEST&quot;#define kmalloc(_s) ExAllocatePoolWithTag(NonPagedPool, _s, &#x27;SYSQ&#x27;)#define kfree(_p) ExFreePool(_p)DEFINE_GUID // &#123;6812FC83-7D3E-499a-A012-55E0D85F348B&#125;(GUID_ALE_AUTH_CONNECT_CALLOUT_V4,0x6812fc83,0x7d3e,0x499a,0xa0, 0x12, 0x55, 0xe0, 0xd8, 0x5f, 0x34, 0x8b);PDEVICE_OBJECT gDevObj;HANDLE\tgEngineHandle = 0;HANDLE\tgInjectHandle = 0;//CalloutIdUINT32\tgAleConnectCalloutId = 0;//FilterIdUINT64\tgAleConnectFilterId = 0;/*以下两个回调函数没啥用*/NTSTATUS NTAPI WallNotifyFn(IN FWPS_CALLOUT_NOTIFY_TYPE notifyType,IN const GUID *filterKey,IN const FWPS_FILTER *filter)&#123;\tKdPrint((&quot;NotifyFn &quot;));\treturn STATUS_SUCCESS;&#125;VOID NTAPI WallFlowDeleteFn(IN UINT16 layerId,IN UINT32 calloutId,IN UINT64 flowContext)&#123;\tKdPrint((&quot;FlowDeleteFn &quot;));\treturn;&#125;//协议代码转为名称char* ProtocolIdToName(UINT16 id)&#123;\tchar *ProtocolName = kmalloc(16);\tRtlZeroMemory(ProtocolName,16);\tswitch (id)\t&#123;\tcase 1: strcpy_s(ProtocolName, 4 + 1, &quot;ICMP&quot;); break;\tcase 2: strcpy_s(ProtocolName, 4 + 1, &quot;IGMP&quot;); break;\tcase 6: strcpy_s(ProtocolName, 3 + 1, &quot;TCP&quot;); break;\tcase 17: strcpy_s(ProtocolName, 3 + 1, &quot;UDP&quot;); break;\tcase 27: strcpy_s(ProtocolName, 3 + 1, &quot;RDP&quot;); break;\tdefault: strcpy_s(ProtocolName, 7 + 1, &quot;UNKNOWN&quot;); break;\t&#125;\treturn ProtocolName;&#125;//最重要的过滤函数void NTAPI WallALEConnectClassify(IN const FWPS_INCOMING_VALUES0* inFixedValues,//此结构包含筛选层上每个数据字段的值 //incomingValue[index] =&gt; index的值是枚举类型FWPS_FIELDS_ALE_AUTH_CONNECT_V4,//枚举名字说明了该值的类型例如:FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS 就是本地IP\tIN const FWPS_INCOMING_METADATA_VALUES0* inMetaValues,//此结构包含筛选层上每个元数据字段的值。IN OUT void* layerData,//指向结构的指针，该结构描述正在过滤的层上的原始数据。此参数可能为NULL，//这取决于所筛选的层和调用classfyFn0标注函数的条件。//对于流层，此参数指向FWPS_stream_Callout_IO_PACKET 0结构。//对于所有其他层，如果NetBufferList结构不是NULL，则该参数指向该结构。IN const void* classifyContext,//由过滤器引擎指向与标注驱动程序关联的上下文数据的指针 没有找出该指针类型IN const FWPS_FILTER* filter,//指向FWPS_FILTER1结构的指针。此结构描述指定筛选器操作的标注的筛选器。IN UINT64 flowContext,//包含与数据流关联的上下文的UINT 64类型变量。如果没有与数据流相关联的上下文，则此参数为零。//如果在不支持数据流的过滤层将标注添加到筛选引擎中，则clamfyFn1回调函数应忽略此参数OUT FWPS_CLASSIFY_OUT* classifyOut //指向FWPS_GARGY_OUT 0结构的指针，该结构接收clamfyFn1回调函数返回给调用方的任何数据)&#123;\tchar *ProtocolName = NULL;\tDWORD LocalIp, RemoteIP;\tPWCHAR Path = NULL; do\t&#123; Path = ExAllocatePoolWithTag(NonPagedPool, inMetaValues-&gt;processPath-&gt;size+2, &#x27;NET&#x27;); if (NULL==Path) &#123; break; &#125; RtlZeroMemory(Path, inMetaValues-&gt;processPath-&gt;size + 2); wcscpy_s(Path, inMetaValues-&gt;processPath-&gt;size / 2, (WCHAR*)inMetaValues-&gt;processPath-&gt;data); LocalIp = inFixedValues-&gt;incomingValue[FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS].value.uint32; RemoteIP = inFixedValues-&gt;incomingValue[FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_ADDRESS].value.uint32; ProtocolName = ProtocolIdToName(inFixedValues-&gt;incomingValue[FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_PROTOCOL].value.uint16); DbgPrint(&quot;进程ID : %d&quot;, (DWORD)(inMetaValues-&gt;processId)); DbgPrint(&quot;Path=%S&quot;, Path); DbgPrint(&quot;本地地址=%u.%u.%u.%u &quot;, (LocalIp &gt;&gt; 24) &amp; 0xFF, (LocalIp &gt;&gt; 16) &amp; 0xFF, (LocalIp &gt;&gt; 8) &amp; 0xFF, LocalIp &amp; 0xFF); DbgPrint(&quot;端口%d &quot;, inFixedValues-&gt;incomingValue[FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT].value.uint16); DbgPrint(&quot;远程地址=%u.%u.%u.%u &quot;, (RemoteIP &gt;&gt; 24) &amp; 0xFF, (RemoteIP &gt;&gt; 16) &amp; 0xFF, (RemoteIP &gt;&gt; 8) &amp; 0xFF, RemoteIP &amp; 0xFF); DbgPrint(&quot;端口%d &quot;, inFixedValues-&gt;incomingValue[FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT].value.uint16); DbgPrint(&quot;协议名: %s &quot;, ProtocolName); kfree(ProtocolName);\t&#125; while (0); if (NULL != Path)\t&#123; ExFreePoolWithTag(Path, &#x27;NET&#x27;);\t&#125;\tclassifyOut-&gt;actionType = FWP_ACTION_PERMIT;//允许连接\treturn;&#125;NTSTATUS RegisterCalloutForLayer(IN const GUID* layerKey,IN const GUID* calloutKey,IN FWPS_CALLOUT_CLASSIFY_FN classifyFn,IN FWPS_CALLOUT_NOTIFY_FN notifyFn,IN FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN flowDeleteNotifyFn,OUT UINT32* calloutId, //注册callout时返回此IDOUT UINT64* filterId)&#123;\tNTSTATUS status = STATUS_SUCCESS;\tFWPS_CALLOUT sCallout = &#123; 0 &#125;;\tFWPM_FILTER mFilter = &#123; 0 &#125;;\tFWPM_FILTER_CONDITION mFilter_condition[1] = &#123; 0 &#125;;\tFWPM_CALLOUT mCallout = &#123; 0 &#125;;\tFWPM_DISPLAY_DATA mDispData = &#123; 0 &#125;;\tBOOLEAN bCalloutRegistered = FALSE;\t//这里未指定sCallout.flags\tsCallout.calloutKey = *calloutKey; //一个唯一的GUID值,用来标记此callout\tsCallout.classifyFn = classifyFn; //每当回调处理网络数据时，过滤器引擎将调用此函数,处理网络数据在这个回调函数里面处理.\tsCallout.flowDeleteFn = flowDeleteNotifyFn; //每当终止由回调处理的数据流时，筛选器引擎将调用此函数\tsCallout.notifyFn = notifyFn; //卸载callout时,会调用这个回调\t//要使用哪个设备对象注册\tstatus = FwpsCalloutRegister(gDevObj, //自己创建的设备对象 &amp;sCallout, //该结构体有用的是指定了classifyFn回调,处理连接时的数据就会用到这个回调函数. calloutId //返回的calloutID ,取消注册callout会用到这个值 );\tif (!NT_SUCCESS(status)) goto exit;\tbCalloutRegistered = TRUE;\tmDispData.name = L&quot;WFP TEST&quot;; //可选的名字\tmDispData.description = L&quot;yxp&#x27;s WFP TEST&quot;; //可选的描述\t//你感兴趣的内容\tmCallout.applicableLayer = *layerKey; //过滤层标识符 此过滤层允许授权对传出tcp连接的连接请求，\t//以及基于发送的第一个数据包授权传出非tcp通信量\t//你感兴趣的内容的GUID\tmCallout.calloutKey = *calloutKey; //该GUID值必须与FwpsCalloutRegister注册时的GUID值相同.\tmCallout.displayData = mDispData;\t//向过滤引擎添加callout\tstatus = FwpmCalloutAdd(gEngineHandle, &amp;mCallout, //flags没有设置 NULL, //安全描述符 可以为NULL NULL); //返回一个ID 与FwpsCalloutRegister函数返回的ID是相同的.\tif (!NT_SUCCESS(status)) goto exit;\t//FWPM_action0结构指定在所有筛选条件都为真时所采取的操作\tmFilter.action.calloutKey = *calloutKey;\t//交给callout处理 由callout来决定返回阻止(block)或者允许(permit)\tmFilter.action.type = FWP_ACTION_CALLOUT_TERMINATING;\t//描述\tmFilter.displayData.name = L&quot;WFP TEST&quot;;\tmFilter.displayData.description = L&quot;yxp&#x27;s WFP TEST&quot;;\tmFilter.layerKey = *layerKey;\t//这个值和FwpmCalloutAdd里面使用的值一样 过滤层标识符 此过滤层允许授权对传出tcp连接的连接请求，\t//以及基于发送的第一个数据包授权传出非tcp通信量 //过滤条件数\tmFilter.numFilterConditions = 0;\t//过滤条件\tmFilter.filterCondition = mFilter_condition;\tmFilter.subLayerKey = FWPM_SUBLAYER_UNIVERSAL; //此子层承载所有未分配给任何其他子层的筛选器\t//BFE将根据过滤条件自动分配权重\tmFilter.weight.type = FWP_EMPTY;\t//添加一个新的过滤器对象到系统中\tstatus = FwpmFilterAdd(gEngineHandle, &amp;mFilter, NULL, filterId);\tif (!NT_SUCCESS(status)) goto exit;exit:\tif (!NT_SUCCESS(status))\t&#123; if (bCalloutRegistered) &#123; FwpsCalloutUnregisterById(*calloutId); &#125;\t&#125;\treturn status;&#125;NTSTATUS WallRegisterCallouts()&#123;\tNTSTATUS status = STATUS_SUCCESS;\tBOOLEAN bInTransaction = FALSE;\tBOOLEAN bEngineOpened = FALSE;\tFWPM_SESSION session = &#123; 0 &#125;;\t//置此标志时，会话结束时将自动删除在会话期间添加的任何对象\tsession.flags = FWPM_SESSION_FLAG_DYNAMIC;\t//开启WFP引擎\tstatus = FwpmEngineOpen(NULL, RPC_C_AUTHN_WINNT, NULL, &amp;session, &amp;gEngineHandle);\tif (!NT_SUCCESS(status)) goto exit;\tbEngineOpened = TRUE;\t// 在当前会话中开始显式事务\tstatus = FwpmTransactionBegin(gEngineHandle, 0);\tif (!NT_SUCCESS(status)) goto exit;\tbInTransaction = TRUE;\t//注册回调函数\tstatus = RegisterCalloutForLayer( &amp;FWPM_LAYER_ALE_AUTH_CONNECT_V4, //此过滤层允许授权对传出tcp连接的连接请求， //以及基于发送的第一个数据包授权传出非tcp通信量 &amp;GUID_ALE_AUTH_CONNECT_CALLOUT_V4, WallALEConnectClassify, WallNotifyFn, WallFlowDeleteFn, &amp;gAleConnectCalloutId, &amp;gAleConnectFilterId);\tif (!NT_SUCCESS(status))\t&#123; DbgPrint(&quot;RegisterCalloutForLayer失败! &quot;); goto exit;\t&#125;\t//确认所有内容并提交，让回调函数正式发挥作用\tstatus = FwpmTransactionCommit(gEngineHandle);\tif (!NT_SUCCESS(status)) goto exit;\tbInTransaction = FALSE;exit:\tif (!NT_SUCCESS(status))\t&#123; if (bInTransaction) &#123; FwpmTransactionAbort(gEngineHandle); &#125; if (bEngineOpened) &#123; FwpmEngineClose(gEngineHandle); gEngineHandle = 0; &#125;\t&#125;\treturn status;&#125;NTSTATUS WallUnRegisterCallouts()&#123;\tif (gEngineHandle != 0)\t&#123; //删除FilterId FwpmFilterDeleteById(gEngineHandle, gAleConnectFilterId); //删除CalloutId FwpmCalloutDeleteById(gEngineHandle, gAleConnectCalloutId); //清空FilterId gAleConnectFilterId = 0; //反注册CalloutId FwpsCalloutUnregisterById(gAleConnectCalloutId); //清空CalloutId gAleConnectCalloutId = 0; //关闭引擎 FwpmEngineClose(gEngineHandle); gEngineHandle = 0;\t&#125;\treturn STATUS_SUCCESS;&#125;VOID DriverUnload(PDRIVER_OBJECT driverObject)&#123;\tNTSTATUS status;\tUNICODE_STRING deviceDosName = &#123; 0 &#125;;\tstatus = WallUnRegisterCallouts();\tif (!NT_SUCCESS(status))\t&#123; DbgPrint(&quot;WallUnRegisterCallouts失败 &quot;); return;\t&#125;\tRtlInitUnicodeString(&amp;deviceDosName, DEVICE_DOSNAME);\tIoDeleteSymbolicLink(&amp;deviceDosName);\tif (gDevObj)\t&#123; IoDeleteDevice(gDevObj); gDevObj = NULL;\t&#125;\tDbgPrint(&quot;驱动卸载成功 &quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT driverObject, PUNICODE_STRING registryPath)&#123;\tUNICODE_STRING deviceName = &#123; 0 &#125;;\tUNICODE_STRING deviceDosName = &#123; 0 &#125;;\tNTSTATUS status = STATUS_SUCCESS;\tdriverObject-&gt;DriverUnload = DriverUnload;\tRtlInitUnicodeString(&amp;deviceName, DEVICE_NAME);\tstatus = IoCreateDevice(driverObject, 0, &amp;deviceName, FILE_DEVICE_NETWORK, 0, FALSE, &amp;gDevObj);\tif (!NT_SUCCESS(status))\t&#123; DbgPrint(&quot;创建设备对象失败 &quot;); return STATUS_UNSUCCESSFUL;\t&#125;\tRtlInitUnicodeString(&amp;deviceDosName, DEVICE_DOSNAME);\tstatus = IoCreateSymbolicLink(&amp;deviceDosName, &amp;deviceName);\tif (!NT_SUCCESS(status))\t&#123; DbgPrint(&quot;创建符号链接失败 &quot;); return STATUS_UNSUCCESSFUL;\t&#125;\tstatus = WallRegisterCallouts();\tif (!NT_SUCCESS(status))\t&#123; DbgPrint(&quot;WallRegisterCallouts 失败! &quot;); return STATUS_UNSUCCESSFUL;\t&#125;\tDbgPrint(&quot;过滤驱动加载成功 &quot;);\treturn status;&#125;","tags":["windows","驱动"],"categories":["OS","Windows","驱动"]},{"title":"Visual Studio 2022 驱动开发环境准备","path":"/OS/Windows/驱动/windows驱动开发教程/驱动开发准备(VS2022)/","content":"概述：驱动开发环境准备 [toc] 步骤一 安装sdk与wdk安装windows相关的sdk 参考微软文档：下载 Windows 驱动程序工具包 (WDK) - Windows drivers | Microsoft Learn 步骤二 调试与安装工具 下载 dbgview dbgview 在 SysinternalsSuite 套件中，下载 SysinternalsSuite 套件即可。 https://docs.microsoft.com/zh-cn/sysinternals/downloads/ 下载驱动安装器 KmdManager驱动加载调试工具 Kernel Mode Drivers Manager 1.3 free download - Software reviews, downloads, news, free trials, freeware and full commercial software - Downloadcrew PCHunter http://www.xuetr.com/ 步骤三 驱动框架1234567891011121314151617181920#include &lt;ntddk.h&gt;// #include &lt;ntifs.h&gt;NTSTATUS UnloadDriver(PDRIVER_OBJECT pDriver)&#123;\tDbgPrint(&quot;Bye, Driver&quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123;\tDbgPrint(&quot;Hello World, Driver&quot;);\tDbgPrint(&quot;DRIVER ADDress, [%]&quot;);\tDbgPrint(&quot;Hello World, Driver&quot;);\tpDriver-&gt;DriverUnload = UnloadDriver;\treturn STATUS_SUCCESS;&#125; 步骤三 Visual Studio配置 C&#x2F;C++ -&gt; 常规 -&gt; 将警告视为错误 -&gt; 否 C&#x2F;C++ -&gt; 常规 -&gt; 警告等级 -&gt; 等级3（也可忽略） 驱动运行环境 inf2cat -&gt; 否 编译运行，会生成sys文件 其他补充禁用界面输出无用信息12ed nt!Kd_SXS_Masked nt!Kd_FUSION_Mask","tags":["windows","驱动","driver"],"categories":["OS","Windows","驱动","windows驱动开发教程"]},{"title":"HelloWorld驱动与安装","path":"/OS/Windows/驱动/windows驱动开发教程/HelloWorld驱动与安装/","content":"概述：实现一个最简单的helloworld驱动，微软官方有相关教程 编写 Hello World Windows 驱动程序 (KMDF) - Windows drivers | Microsoft Learn","tags":["windows","驱动","driver"],"categories":["OS","Windows","驱动","windows驱动开发教程"]},{"title":"驱动开发相关API整理","path":"/OS/Windows/驱动/windows驱动开发教程/驱动开发相关函数整理/","content":"概述：驱动开发过程中，相关API的学习整理 [toc] WdfDriverCreateWdfDriverCreate 是 Windows Driver Frameworks (WDF) 中用于创建驱动程序的函数。它用于初始化驱动程序，并将其与 Windows 操作系统进行集成。 WdfDriverCreate 函数需要填写一个 WDFDRIVER 结构体来定义驱动程序的属性和行为。以下是一些常见的参数： DriverName: 驱动程序的名称，用于在调试和日志记录中标识驱动程序。 DriverVersion: 驱动程序的版本号，用于标识驱动程序的版本。 DeviceAddVersion: 用于添加新设备的 WDF 函数版本。 DriverUnload: 驱动程序卸载时的回调函数，用于清理资源并执行其他必要的操作。 DispatchTable: 一个包含驱动程序处理 IRP 请求的回调函数的表。 RegistryPath: 驱动程序在注册表中的路径，用于存储配置信息和设置。 WdfDeviceCreateWdfDeviceCreate 是 Windows Driver Frameworks (WDF) 中的一个函数，用于创建设备对象并初始化与设备相关的数据结构。它是 WDF 中非常重要和常用的函数之一。 WdfDeviceCreate 函数需要填写一个 WDFDEVICE_INIT 结构体来定义设备的属性和行为。以下是一些常见的参数： Driver: 指向驱动程序的指针，用于关联设备和驱动程序。 DeviceAttributes: 指向调用方分配的 WDF_OBJECT_ATTRIBUTES 结构的指针，该结构包含新设备的属性。 StackSize: 设备的堆栈大小，用于定义设备对象的执行环境。 DeviceInit: 指向 WDFDEVICE_INIT 结构的指针的地址，用于初始化设备的状态和行为。 在调用 WdfDeviceCreate 之后，WDF 将使用提供的参数来创建并初始化一个设备对象。然后，设备可以使用 WDF 提供的其他函数来管理设备的状态、处理请求以及与其他设备或驱动程序进行交互。 需要注意的是，WdfDeviceCreate 是一个高级别的函数，通常用于创建完整的设备对象。对于较简单的设备或需要更精细控制的情况，可能需要使用其他 WDF 函数来手动创建和配置设备对象。同时，在使用 WdfDeviceCreate 和其他 WDF 函数时，应注意遵循正确的使用方法和规范，以避免产生潜在的问题和风险。","categories":["OS","Windows","驱动","windows驱动开发教程"]},{"title":"监控网卡事件","path":"/OS/Windows/网络helper/监控网卡禁用事件/","content":"方法一可以使用Win32 API中的NotifySubscribeCallouts和NotifyRegisterNetEvent api函数来监控网络适配器状态的改变，包括被禁用的事件。 具体步骤如下： 使用NotifySubscribeCallouts函数来注册一个回调函数，当网络适配器状态改变时会调用该函数。 在回调函数中使用NotifyRegisterNetEvent函数来注册一个网络事件，比如网络适配器被禁用。 监听回调函数中传递的事件类型，当事件类型为被禁用时，执行自己的逻辑处理。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;ipexport.h&gt;using namespace std;BOOL WINAPI HandlerRoutine(DWORD dwCtrlType);void CALLBACKNetEventCallback(PVOID pCallerContext, ULONG NotificationType, PVOID Notification);int main()&#123;\t// 注册控制事件处理函数\tSetConsoleCtrlHandler(HandlerRoutine, TRUE);\tHANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\tHANDLE hWaitableHandle[2] = &#123; hEvent, INVALID_HANDLE_VALUE &#125;;\t// 注册网络事件回调函数\tDWORD dwFlags = NOTIFY_FILTER_INTERFACE_CHANGE | NOTIFY_FILTER_DRIVER_LOADED;\tHMODULE hModule = NULL;\tPVOID pCallerContext = (PVOID)hEvent;\tHANDLE hNotifyObject = NULL;\tNotifySubscribeCallouts(dwFlags, NetEventCallback, pCallerContext, hModule, &amp;hNotifyObject);\t// 等待事件\tDWORD dwWaitResult;\tdo &#123; dwWaitResult = WaitForMultipleObjects(2, hWaitableHandle, FALSE, INFINITE);\t&#125; while (dwWaitResult != WAIT_OBJECT_0);\t// 取消订阅并关闭事件句柄\tNotifyUnsubscribeCallouts(hNotifyObject);\tCloseHandle(hEvent);\treturn 0;&#125;BOOL WINAPI HandlerRoutine(DWORD dwCtrlType)&#123;\tswitch (dwCtrlType)\t&#123;\tcase CTRL_CLOSE_EVENT: printf(&quot; Close signal received.&quot;); return TRUE;\tdefault: return FALSE;\t&#125;&#125;void CALLBACK NetEventCallback(PVOID pCallerContext, ULONG NotificationType, PVOID Notification)&#123;\tswitch (NotificationType)\t&#123;\tcase NOTIFY_INTERFACE_ARRIVAL: printf(&quot; Interface arrival.&quot;); break;\tcase NOTIFY_INTERFACE_REMOVAL: printf(&quot; Interface removal.&quot;); break;\tcase NOTIFY_INTERFACE_ENABLED: printf(&quot; Interface enabled.&quot;); break;\tcase NOTIFY_INTERFACE_DISABLED: printf(&quot; Interface disabled.&quot;); break;\tdefault: printf(&quot; Unknown notification type.&quot;); break;\t&#125;\tPIP_INTERFACE_INFO pIfInfo = (PIP_INTERFACE_INFO)Notification;\t// 监听网卡被禁用事件\tif (NotificationType == NOTIFY_INTERFACE_DISABLED)\t&#123; printf(&quot; Interface % ws has been disabled.&quot;, pIfInfo-&gt;Adapter[0].Name);\t&#125;&#125; 注意事项： 如果需要使用NotifyRegisterNetEvent函数，需要将应用程序编译为驱动程序或系统服务，因为这个函数需要管理员权限。 回调函数中不能阻塞或进行耗时操作，因为这会影响系统功能的正常运作。 可以使用SetConsoleCtrlHandler函数注册控制事件处理函数，以便在收到控制事件时可以及时退出程序。 方法二参考注册设备通知 - Win32 apps | Microsoft Learn 要获取Windows网卡被禁用事件，您可以使用以下步骤： 使用Windows API函数注册网络配置更改通知。使用以下代码： 1234567891011121314151617181920212223HANDLE hNotify = NULL;HDEVNOTIFY hDevNotify = NULL;hNotify = FindFirstChangeNotificationW( HKEY_LOCAL_MACHINE, L&quot;SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network&quot;, FALSE, FILE_NOTIFY_CHANGE_LAST_WRITE);if (hNotify == INVALID_HANDLE_VALUE)&#123; // Handle error&#125;hDevNotify = RegisterDeviceNotification( hwnd, &amp;filter, DEVICE_NOTIFY_WINDOW_HANDLE);if (hDevNotify == NULL)&#123; // Handle error&#125; 其中，HWND是接收通知的窗口句柄，filter是一些条件，例如通知类型，设备范围等。 在您的窗口过程函数中处理通知消息。 它将提供一个 lParam 参数，该参数是一个包含有关更改的结构体。 您可以使用以下代码来检查是否禁用了任何网络适配器： 12345678910111213141516171819202122232425262728case WM_DEVICECHANGE: PDEV_BROADCAST_HDR pHdr = (PDEV_BROADCAST_HDR)lParam; if (pHdr-&gt;dbch_devicetype == DBT_DEVTYP_VOLUME) &#123; PDEV_BROADCAST_VOLUME pVol = (PDEV_BROADCAST_VOLUME)pHdr; // Check if network adapter is disabled if (pVol-&gt;dbcv_flags &amp; DBTF_MEDIA) // Media is removed &#123; // Check if any network adapter is disabled DWORD dwDriveMask = pVol-&gt;dbcv_unitmask; if (dwDriveMask != 0) &#123; for (int i = 0; i &lt; 26; i++) &#123; if ((dwDriveMask &amp; 0x01) == 0x01) &#123; char szDrive[4] = &#123; &#x27;A&#x27; + i, &#x27;:&#x27;, &#x27;\\\\&#x27;, &#x27;\\0&#x27; &#125;; if (GetDriveType(szDrive) == DRIVE_CDROM) &#123; // Network adapter on this drive is disabled &#125; &#125; dwDriveMask &gt;&gt; = 1; &#125; &#125; &#125; &#125; return TRUE; 这段代码检查网络适配器是否被禁用，并根据需要执行操作。 请注意，这些代码只是一种参考。要使它们正常工作，您需要将它们植入到您的代码中，并根据需要进行修改。","tags":["windows","网卡"],"categories":["OS","Windows","网络helper"]},{"title":"监控路由事件","path":"/OS/Windows/网络helper/监控路由事件/","content":"相关文章： 使用winsock2 说明监控网卡可以使用 NotifyRouteChange 和 NotifyRouteChange2 函数，通过注册回调实现路由监控 主要步骤 声明一个回调函数处理通知 调用notifyRouteChange2注册通知,指定通知类型 等待通知 取消通知(可选) 在回调函数中根据通知类型进行处理 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#ifndef WIN32_LEAN_AND_MEAN#define WIN32_LEAN_AND_MEAN#endif#define _WINSOCK_DEPRECATED_NO_WARNINGS#include &lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;string&gt;#include &lt;windows.h&gt;#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;iphlpapi.h&gt;#pragma comment(lib, &quot;iphlpapi.lib&quot;)#pragma comment(lib, &quot;ws2_32.lib&quot;)using namespace std;#define NAMEPRINTFORMAT(X) std::left &lt;&lt; setw(60)&lt;&lt; #X &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; Xstd::string ipToString(DWORD dwIP)&#123;\tstd::string strDestIp = &quot;&quot;;\tstd::string strMaskIp = &quot;&quot;;\tstruct in_addr network;\tnetwork.S_un.S_addr = dwIP; //为s_addr赋值--网络字节序\tstrDestIp = inet_ntoa(network);\treturn strDestIp;&#125;void CALLBACK RouteChanged1(void* CallerContext, PMIB_IPFORWARD_ROW2 Table, MIB_NOTIFICATION_TYPE NotificationType)&#123;\tusing context = void(*)(DWORD);\tcontext ctx = (context)CallerContext;\tauto PrintTable = [](MIB_IPFORWARD_ROW2 table) &#123; cout &lt;&lt; &quot;---------------&quot; &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.InterfaceLuid.Info.IfType) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.InterfaceLuid.Info.NetLuidIndex) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.InterfaceLuid.Info.Reserved) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.InterfaceLuid.Value) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.InterfaceIndex) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.si_family) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv4.sin_addr.S_un.S_addr) &lt;&lt; &quot;\\t&quot; &lt;&lt; ipToString(table.DestinationPrefix.Prefix.Ipv4.sin_addr.S_un.S_addr) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv4.sin_family) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv4.sin_port) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv4.sin_zero) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_addr.u.Byte) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_addr.u.Word) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_family) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_flowinfo) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_port) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_scope_id) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_scope_struct.Level) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_scope_struct.Value) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_scope_struct.Zone) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.NextHop.Ipv4.sin_addr.S_un.S_addr) &lt;&lt; &quot;\\t&quot; &lt;&lt; ipToString(table.NextHop.Ipv4.sin_addr.S_un.S_addr) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.NextHop.Ipv6.sin6_addr.u.Byte) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.NextHop.Ipv6.sin6_addr.u.Word) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.SitePrefixLength) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.ValidLifetime) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.PreferredLifetime) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Metric) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Protocol) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Loopback) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.AutoconfigureAddress) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Immortal) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Age) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Origin) &lt;&lt; endl; cout &lt;&lt; &quot;---------------&quot; &lt;&lt; endl &lt;&lt; endl;\t&#125;;\t// 处理路由表变更通知\tswitch (NotificationType)\t&#123;\tcase MibParameterNotification: cout &lt;&lt; &quot;1-- 参数被更改&quot; &lt;&lt; endl; break;\tcase MibAddInstance: cout &lt;&lt; &quot;2-- 添加&quot; &lt;&lt; endl; PrintTable(*Table); ctx(Table-&gt;DestinationPrefix.Prefix.Ipv4.sin_addr.S_un.S_addr); break;\tcase MibDeleteInstance: cout &lt;&lt; &quot;3-- 删除&quot; &lt;&lt; endl; PrintTable(*Table); ctx(Table-&gt;DestinationPrefix.Prefix.Ipv4.sin_addr.S_un.S_addr); break;\tcase MibInitialNotification: cout &lt;&lt; &quot;4-- 函数已注册&quot; &lt;&lt; endl; break;\tdefault: break;\t&#125;&#125;void checkIsMyRoute (DWORD ip)&#123;\tcout &lt;&lt; NAMEPRINTFORMAT(ipToString(ip)) &lt;&lt; endl;&#125;;void main()&#123;\tHANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\tHANDLE hNotify = NULL;\tPVOID callerContext = static_cast&lt;PVOID&gt;(&amp;checkIsMyRoute);\tBOOLEAN bSuccess = TRUE;\tULONG pdwPrevNotified = 0;\tif (callerContext != nullptr &amp;&amp; NotifyRouteChange2(AF_UNSPEC, &amp;RouteChanged1, callerContext, bSuccess, &amp;hNotify) != NO_ERROR) &#123; printf(&quot;Could not register for route change notifications &quot;); return ;\t&#125;\twhile (TRUE) &#123; DWORD dwWait = WaitForSingleObject(hNotify, INFINITE); if (dwWait == WAIT_OBJECT_0) &#123; // 接收到异步通知，处理结果 break; &#125;\t&#125;\t// 取消监控\tCancelMibChangeNotify2(hNotify);\tCloseHandle(hNotify);\treturn ;&#125;","tags":["windows","监控","route"],"categories":["OS","Windows","网络helper"]},{"title":"C++ 通过 COM 组件 启用\\禁用\\查看 网卡状态","path":"/OS/Windows/网络helper/COM查看网卡状态/","content":"123456789101112131415161718192021222324252627282930313233343536#include &lt;NetCon.h&gt;void ChangeNetState()&#123; CoInitialize(NULL); INetConnectionManager* pNetManager; INetConnection* pNetConnection; IEnumNetConnection* pEnum; if (S_OK != CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionManager, (void**)&amp;pNetManager)) &#123; return ; &#125; pNetManager-&gt;EnumConnections(NCME_DEFAULT, &amp;pEnum); pNetManager-&gt;Release(); if (NULL == pEnum) &#123; return ; &#125; ULONG celtFetched; while (pEnum-&gt;Next(1, &amp;pNetConnection, &amp;celtFetched) == S_OK) &#123; NETCON_PROPERTIES* properties; pNetConnection-&gt;GetProperties(&amp;properties); //properties-&gt;pszwName; //网络连接的名称 //properties-&gt;pszwDeviceName; //网卡名称 //properties-&gt;Status; //状态 //pNetConnection-&gt;Disconnect(); //禁用网卡 //pNetConnection-&gt;Connect(); //启用网卡 &#125; CoUninitialize(); return ;&#125; NETCON_PROPERTIES 结构体使用的变量为宽字符，在打印时需要在程序入口调用以下函数才能正确输出。 1setlocale(LC_CTYPE, &quot;chs&quot;);","tags":["windows","网卡"],"categories":["OS","Windows","网络helper"]},{"title":"socket 保活","path":"/OS/Windows/网络helper/socket保活/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142BOOL _KeepAlive(SP_SOCKET fd)&#123;\t//定义结构及宏\tstruct KeepAlive\t&#123; u_long onoff; u_long keepalivetime; u_long keepaliveinterval;\t&#125;;#define SIO_KEEPALIVE_VALS _WSAIOW(IOC_VENDOR,4)\t//KeepAlive实现\tKeepAlive inKeepAlive = &#123; 0 &#125;; //输入参数\tunsigned long ulInLen = sizeof(KeepAlive);\tKeepAlive outKeepAlive = &#123; 0 &#125;; //输出参数\tunsigned long ulOutLen = sizeof(KeepAlive);\tunsigned long ulBytesReturn = 0;\t//keepalive xp以前的系统发送5次，xp之后的系统发送10\tinKeepAlive.onoff = 1;\tinKeepAlive.keepaliveinterval = 5000; //两次KeepAlive探测间的时间间隔\tinKeepAlive.keepalivetime = 5000; //开始首次KeepAlive探测前的TCP空闭时间\tif (WSAIoctl((SOCKET)fd, SIO_KEEPALIVE_VALS, (LPVOID)&amp;inKeepAlive, ulInLen, (LPVOID)&amp;outKeepAlive, ulOutLen, &amp;ulBytesReturn, NULL, NULL) == SOCKET_ERROR)\t&#123; LOGT(&quot;Set Keep Alive FAILED.&quot;); return FALSE;\t&#125;\telse\t&#123; LOGT(&quot;Set Keep Alive OK.&quot;); return TRUE;\t&#125;&#125;","categories":["OS","Windows","网络helper"]},{"title":"iphepler 接口整理","path":"/OS/Windows/网络helper/iphelper接口整理/","content":"The following functions are used in Windows networking: Obsolete FunctionsThe following function is provided only for compatibility with 16-bit versions of Windows: windows提供了大量的网络辅助函数，如下也为探讨内容： IP Helper FunctionsThe following functions retrieve and modify configuration settings for the TCP&#x2F;IP transport on the local computer. The following categorical listing can help determine which collection of functions is best suited for a given task: Adapter Management GetAdapterIndex GetAdaptersAddresses GetAdaptersInfo GetPerAdapterInfo GetUniDirectionalAdapterInfo Address Resolution Protocol (ARP) Management CreateIpNetEntry CreateProxyArpEntry DeleteIpNetEntry DeleteProxyArpEntry FlushIpNetTable GetIpNetTable SendARP SetIpNetEntry Interface Conversion ConvertInterfaceAliasToLuid ConvertInterfaceGuidToLuid ConvertInterfaceIndexToLuid ConvertInterfaceLuidToAlias ConvertInterfaceLuidToGuid ConvertInterfaceLuidToIndex ConvertInterfaceLuidToNameA ConvertInterfaceLuidToNameW ConvertInterfaceNameToLuidA ConvertInterfaceNameToLuidW if_indextoname if_nametoindex Interface Management GetFriendlyIfIndex GetIfEntry GetIfEntry2 GetIfStackTable GetIfTable GetIfTable2 GetIfTable2Ex GetInterfaceInfo GetInvertedIfStackTable GetIpInterfaceEntry GetIpInterfaceTable GetNumberOfInterfaces InitializeIpInterfaceEntry SetIfEntry SetIpInterfaceEntry Internet Protocol (IP) and Internet Control Message Protocol (ICMP) GetIcmpStatistics GetIpStatistics Icmp6CreateFile Icmp6ParseReplies Icmp6SendEcho2 IcmpCloseHandle IcmpCreateFile IcmpParseReplies IcmpSendEcho IcmpSendEcho2 IcmpSendEcho2Ex SetIpTTL IP Address Management AddIPAddress CreateAnycastIpAddressEntry CreateUnicastIpAddressEntry DeleteIPAddress DeleteAnycastIpAddressEntry DeleteUnicastIpAddressEntry GetAnycastIpAddressEntry GetAnycastIpAddressTable GetIpAddrTable GetMulticastIpAddressEntry GetMulticastIpAddressTable GetUnicastIpAddressEntry GetUnicastIpAddressTable InitializeUnicastIpAddressEntry IpReleaseAddress IpRenewAddress NotifyStableUnicastIpAddressTable SetUnicastIpAddressEntry IP Address String Conversion RtlIpv4AddressToString RtlIpv4AddressToStringEx RtlIpv4StringToAddress RtlIpv4StringToAddressEx RtlIpv6AddressToString RtlIpv6AddressToStringEx RtlIpv6StringToAddress RtlIpv6StringToAddressEx IP Neighbor Address Management CreateIpNetEntry2 DeleteIpNetEntry2 FlushIpNetTable2 GetIpNetEntry2 GetIpNetTable2 ResolveIpNetEntry2 ResolveNeighbor SetIpNetEntry2 IP Path Management FlushIpPathTable GetIpPathEntry GetIpPathTable IP Route Management CreateIpForwardEntry CreateIpForwardEntry2 DeleteIpForwardEntry DeleteIpForwardEntry2 EnableRouter GetBestInterface GetBestInterfaceEx GetBestRoute GetBestRoute2 GetIpForwardEntry2 GetIpForwardTable GetIpForwardTable2 GetRTTAndHopCount InitializeIpForwardEntry SetIpForwardEntry SetIpForwardEntry2 SetIpStatistics SetIpStatisticsEx UnenableRouter IP Table Memory Management FreeMibTable IP Utility ConvertIpv4MaskToLength ConvertLengthToIpv4Mask CreateSortedAddressPairs ParseNetworkString Network Configuration GetNetworkParams Notification CancelMibChangeNotify2 NotifyAddrChange","tags":["网络","windows","ip"],"categories":["OS","Windows","网络helper"]},{"title":"使用 winsock2 相关函数","path":"/OS/Windows/网络helper/使用winsock2/","content":"winsock2.h在最开始include ip的一些工具函数在 Iphlpapi.h 12345#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;) windows.h 默认加载 winsock版本1.winsock2.h 默认加 windows.h 不得不加 windows.h 时候记得加宏 WIN32_LEAN_AND_MEAN 123456789101112131415#ifndef WIN32_LEAN_AND_MEAN#define WIN32_LEAN_AND_MEAN#endif#include &lt;windows.h&gt;#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;iphlpapi.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)int main() &#123; return 0;&#125;","tags":["win","winsock","iphelper"],"categories":["OS","Windows","网络helper"]},{"title":"操作网卡类","path":"/OS/Windows/网络helper/操作网卡类/","content":"在 windows 环境下，使用wmi修改网卡 ip+dns main.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546//main.cpp:#include &lt;iostream&gt;#include &lt;locale&gt;#include &lt;string&gt;#include &lt;codecvt&gt;#include &quot;net_config.h&quot;#pragma execution_character_set(&quot;utf-8&quot;)using namespace std;int main()&#123;\tstd::locale::global(std::locale(&quot;&quot;));\tNetConfig config;\t//网卡的key可以从注册表获取, 路径: 计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\\tconfig.set_key(&quot;&#123;cd574b17-73e1-42df-a50c-f95d7f15c1d0&#125;&quot;);\t//设置静态ip之前要调用下enable_dhcp, 可以把以前设置的ip和网关都清空, 否则注册表会有多个ip信息\tif (config.enable_dhcp()) &#123; cout &lt;&lt; &quot;enable_dhcp success&quot; &lt;&lt; endl;\t&#125;\telse &#123; cout &lt;&lt; &quot;error code: &quot; &lt;&lt; config.get_last_error_code() &lt;&lt; endl;\t&#125; if (config.set_ip_config(&quot;192.168.1.100&quot;, &quot;255.255.255.0&quot;, &quot;192.168.1.1&quot;)) &#123; cout &lt;&lt; &quot;set_ip_config success&quot; &lt;&lt; endl;\t&#125;\telse &#123; cout &lt;&lt; &quot;error code: &quot; &lt;&lt; config.get_last_error_code() &lt;&lt; endl;\t&#125;\tif (config.set_dns(&quot;255.255.255.0&quot;, &quot;&quot;)) &#123; cout &lt;&lt; &quot;set_dns success&quot; &lt;&lt; endl;\t&#125;\telse &#123; cout &lt;&lt; &quot;error code: &quot; &lt;&lt; config.get_last_error_code() &lt;&lt; endl;\t&#125; cin.get();\treturn 0;&#125; net_config.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//net_config.h#pragma once#include &lt;string&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;Wbemidl.h&gt;class NetConfig&#123;public:\tNetConfig() &#123;&#125;\tNetConfig(const std::string &amp;key) :key_(key)&#123; &#125;\t~NetConfig();\t//设置网络设备GUID\tvoid set_key(const std::string &amp;key) &#123; clear(); key_ = key;\t&#125;\t//启用DHCP\tbool enable_dhcp();\t//启动静态IP,设置IP,掩码,网关\tbool set_ip_config(const std::string &amp;ip, const std::string &amp;mask, const std::string &amp;gateway);\tbool set_ip_config(const std::string &amp;ip, const std::string &amp;mask);\t//设置网关\tbool set_gateway(const std::string &amp;gateway);\t//设置DNS地址\tbool set_dns(const std::string &amp;default_dns, const std::string &amp;backup_dns);\t//设置自动DNS\tbool set_auto_dns();\tint get_last_error_code()const &#123; return last_error_code_;\t&#125;\tvoid clear();private:\tNetConfig(const NetConfig &amp;rhs) = delete;\tNetConfig &amp;operator = (const NetConfig &amp;rhs) = delete;private:\t//初始化\tbool init();\t//创建COM数组\tstd::shared_ptr&lt;SAFEARRAY&gt; create_SAFEARRAY(const std::vector&lt;std::string&gt; &amp;args);\tbool set_dns_base(bool is_auto, const std::string &amp;default_dns, const std::string &amp;backup_dns);\tbool exec_method(const wchar_t *method, IWbemClassObject *params_instance);private:\tstd::string key_;\tbool is_init_ = false;\tIWbemLocator* p_instance_ = NULL;\tIWbemServices* p_service_ = NULL;\tIEnumWbemClassObject* p_enum_ = NULL;\tIWbemClassObject *p_obj_ = NULL;\tIWbemClassObject *p_config = NULL;\tVARIANT path_;\tint last_error_code_ = 0;&#125;; net_config.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367//net_config.cpp#include &quot;net_config.h&quot;#include &lt;codecvt&gt;#include &lt;atlbase.h&gt;#include &lt;comutil.h&gt;#ifdef _DEBUG#include &lt;iostream&gt;#endif#pragma comment(lib, &quot;wbemuuid.lib&quot;)#pragma comment(lib, &quot;comsuppw.lib&quot;)#pragma execution_character_set(&quot;utf-8&quot;)using namespace std;NetConfig::~NetConfig()&#123;\tclear();&#125;bool NetConfig::enable_dhcp()&#123;\tif (!init()) return false;\treturn exec_method(L&quot;EnableDHCP&quot;, NULL);&#125;bool NetConfig::set_ip_config(const std::string &amp; ip, const std::string &amp; mask, const std::string &amp; gateway)&#123;\tif (set_ip_config(ip, mask)) &#123; return set_gateway(gateway);\t&#125;\treturn false;&#125;bool NetConfig::set_ip_config(const std::string &amp; ip, const std::string &amp; mask)&#123;\tbool rt = false;\tif (!init()) return rt;\tIWbemClassObject *params = NULL;\tIWbemClassObject *paramsInst = NULL;\tp_config-&gt;GetMethod(_bstr_t(&quot;EnableStatic&quot;), 0, &amp;params, NULL);\tparams-&gt;SpawnInstance(0, &amp;paramsInst);\tauto p1 = create_SAFEARRAY(&#123; ip &#125;);\tVARIANT paramVt;\tparamVt.vt = VT_ARRAY | VT_BSTR;\tparamVt.parray = p1.get();\tparamsInst-&gt;Put(L&quot;IPAddress&quot;, 0, &amp;paramVt, NULL);\tp1 = create_SAFEARRAY(&#123; mask &#125;);\tparamVt.parray = p1.get();\tparamsInst-&gt;Put(L&quot;SubnetMask&quot;, 0, &amp;paramVt, NULL);\trt = exec_method(L&quot;EnableStatic&quot;, paramsInst);\tif (params) &#123; params-&gt;Release();\t&#125;\treturn rt;&#125;bool NetConfig::set_dns(const std::string &amp; default_dns, const std::string &amp; backup_dns)&#123;\treturn set_dns_base(false, default_dns, backup_dns);&#125;bool NetConfig::set_auto_dns()&#123;\treturn set_dns_base(true, &quot;&quot;, &quot;&quot;);&#125;bool NetConfig::set_gateway(const std::string &amp; gateway)&#123;\tbool rt = false;\tif (!init()) return rt;\tIWbemClassObject *params = NULL;\tIWbemClassObject *paramsInst = NULL;\tp_config-&gt;GetMethod(_bstr_t(&quot;SetGateways&quot;), 0, &amp;params, NULL);\tparams-&gt;SpawnInstance(0, &amp;paramsInst);\tauto p1 = create_SAFEARRAY(&#123; gateway &#125;);\tVARIANT paramVt;\tparamVt.vt = VT_ARRAY | VT_BSTR;\tparamVt.parray = p1.get();\tparamsInst-&gt;Put(L&quot;DefaultIPGateway&quot;, 0, &amp;paramVt, NULL);\tparamVt.vt = VT_UINT;\tparamVt.uintVal = 1;\tparamsInst-&gt;Put(L&quot;GatewayCostMetric&quot;, 0, &amp;paramVt, NULL);\trt = exec_method(L&quot;SetGateways&quot;, paramsInst);\tif (params) &#123; params-&gt;Release();\t&#125;\treturn rt;&#125;void NetConfig::clear()&#123;\tif (p_config) &#123; p_config-&gt;Release(); p_config = nullptr;\t&#125;\tif (p_obj_) &#123; p_obj_-&gt;Release(); p_obj_ = nullptr;\t&#125;\tif (p_enum_) &#123; p_enum_-&gt;Release(); p_enum_ = nullptr;\t&#125;\tif (p_service_) &#123; p_service_-&gt;Release(); p_service_ = nullptr;\t&#125;\tif (p_instance_) &#123; p_instance_-&gt;Release(); p_instance_ = nullptr;\t&#125;\tif (is_init_) &#123; CoUninitialize();\t&#125;\tis_init_ = false;&#125;bool NetConfig::init()&#123;\tif (is_init_) &#123; return true;\t&#125;\t// Step 1: Initialize COM.\tHRESULT\thres = CoInitializeEx(0, COINIT_MULTITHREADED);\tif (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;CoInitializeEx failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false;\t&#125;\t/*\t// Step 2: Set general COM security levels\thres = CoInitializeSecurity( NULL, -1, // COM negotiates service NULL, // Authentication services NULL, // Reserved RPC_C_AUTHN_LEVEL_DEFAULT, // Default authentication RPC_C_IMP_LEVEL_IMPERSONATE, // Default Impersonation NULL, // Authentication info EOAC_NONE, // Additional capabilities NULL // Reserved\t);\t//ASSERT_THROW(SUCCEEDED(hres), &quot;CoInitializeSecurity failed&quot;);\tif (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;CoInitializeSecurity failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false;\t&#125;\t*/\t// Step 3: Obtain the initial locator to WMI\thres = CoCreateInstance( CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&amp;p_instance_);\t//ASSERT_THROW(SUCCEEDED(hres), &quot;CoCreateInstance failed&quot;);\tif (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;CoCreateInstance failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false;\t&#125;\t// Step 4: Connect to the local root\\cimv2 namespace and obtain pointer pSvc to make IWbemServices calls.\thres = p_instance_-&gt;ConnectServer( _bstr_t(L&quot;ROOT\\\\CIMV2&quot;), NULL, NULL, 0, NULL, 0, 0, &amp;p_service_\t);\t//ASSERT_THROW(SUCCEEDED(hres), &quot;ConnectServer failed&quot;);\tif (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;ConnectServer failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false;\t&#125;\t// Step 5: Set security levels for the proxy\thres = CoSetProxyBlanket( p_service_, // Indicates the proxy to set RPC_C_AUTHN_WINNT, // RPC_C_AUTHN_xxx RPC_C_AUTHZ_NONE, // RPC_C_AUTHZ_xxx NULL, // Server principal name RPC_C_AUTHN_LEVEL_CALL, // RPC_C_AUTHN_LEVEL_xxx RPC_C_IMP_LEVEL_IMPERSONATE, // RPC_C_IMP_LEVEL_xxx NULL, // client identity EOAC_NONE // proxy capabilities );\t//ASSERT_THROW(SUCCEEDED(hres), &quot;CoSetProxyBlanket failed&quot;);\tif (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;CoSetProxyBlanket failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false;\t&#125;\t// 通过适配器名称来找到指定的适配器对象.\tCComBSTR TheQuery = L&quot;SELECT * FROM Win32_NetworkAdapterConfiguration WHERE SettingID = \\&quot;&quot;;\tstd::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;, wchar_t&gt; conversion;\tTheQuery += conversion.from_bytes(key_).c_str();\tTheQuery += L&quot;\\&quot;&quot;;\thres = p_service_-&gt;ExecQuery( //SysAllocString(L&quot;WQL&quot;), L&quot;WQL&quot;, TheQuery, WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &amp;p_enum_);\t//ASSERT_THROW(SUCCEEDED(hres), &quot;ExecQuery failed&quot;);\tif (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;ExecQuery failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false;\t&#125; // Get the adapter object.\tULONG num = 0;\thres = p_enum_-&gt;Next(WBEM_INFINITE, 1, &amp;p_obj_, &amp;num);\t//ASSERT_THROW(SUCCEEDED(hres), &quot;Next failed&quot;);\tif (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;Next failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false;\t&#125;\t//ASSERT_THROW(0 &lt; num, &quot;Next failed&quot;);\tif (num &lt; 1) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;Next failed num &lt; 1&quot; &lt;&lt; endl;#endif return false;\t&#125;\tVariantInit(&amp;path_);\thres = p_obj_-&gt;Get(L&quot;__PATH&quot;, 0, &amp;path_, NULL, NULL);\t//ASSERT_THROW(SUCCEEDED(hres), &quot;Get path failed&quot;);\tif (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;Get failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false;\t&#125;\thres = p_service_-&gt;GetObject(_bstr_t(L&quot;Win32_NetworkAdapterConfiguration&quot;), 0, NULL, &amp;p_config, NULL);\t//ASSERT_THROW(SUCCEEDED(hres), &quot;GetObject Win32_NetworkAdapterConfiguration failed&quot;);\tif (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;GetObject failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false;\t&#125;\tis_init_ = true;\treturn true;&#125;std::shared_ptr&lt;SAFEARRAY&gt; NetConfig::create_SAFEARRAY(const std::vector&lt;std::string&gt; &amp;args)&#123;\tSAFEARRAY *psa = SafeArrayCreateVector(VT_BSTR, 0, args.size());\tlong idx[] = &#123; 0 &#125;;\tfor (int i = 0; i &lt; args.size(); i++) &#123; std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;, wchar_t&gt; conversion; BSTR ip = SysAllocString(conversion.from_bytes(args[i]).c_str()); idx[0] = i; if (FAILED(SafeArrayPutElement(psa, idx, ip))) &#123; return (false); &#125; SysFreeString(ip);\t&#125;\treturn shared_ptr&lt;SAFEARRAY&gt;(psa, [](SAFEARRAY *psa) &#123;SafeArrayDestroy(psa); &#125;);&#125;bool NetConfig::set_dns_base(bool is_auto, const std::string &amp; default_dns, const std::string &amp; backup_dns)&#123;\tbool rt = false;\tif (!init()) return rt;\tIWbemClassObject *params = NULL;\tIWbemClassObject *paramsInst = NULL;\tp_config-&gt;GetMethod(_bstr_t(&quot;SetDNSServerSearchOrder&quot;), 0, &amp;params, NULL);\tparams-&gt;SpawnInstance(0, &amp;paramsInst);\tshared_ptr&lt;SAFEARRAY&gt; p1;\tif (is_auto) &#123; paramsInst-&gt;Put(L&quot;DNSServerSearchOrder&quot;, 0, NULL, NULL);\t&#125;\telse &#123; if (backup_dns.size()) &#123; p1 = create_SAFEARRAY(&#123; default_dns, backup_dns &#125;); &#125; else &#123; p1 = create_SAFEARRAY(&#123; default_dns &#125;); &#125; VARIANT paramVt; paramVt.vt = VT_ARRAY | VT_BSTR; paramVt.parray = p1.get(); paramsInst-&gt;Put(L&quot;DNSServerSearchOrder&quot;, 0, &amp;paramVt, NULL);\t&#125;\trt = exec_method(L&quot;SetDNSServerSearchOrder&quot;, paramsInst);\tif (params) &#123; params-&gt;Release();\t&#125;\treturn rt;&#125;bool NetConfig::exec_method(const wchar_t * method, IWbemClassObject * params_instance)&#123;\tbool rt = false;\tIWbemClassObject *results = NULL;\tauto res = p_service_-&gt;ExecMethod(path_.bstrVal, _bstr_t(method), 0, NULL, params_instance, &amp;results, NULL);\tif (SUCCEEDED(res)) &#123; VARIANT vtRet; VariantInit(&amp;vtRet); if (!FAILED(results-&gt;Get(L&quot;ReturnValue&quot;, 0, &amp;vtRet, NULL, 0))) &#123; if (vtRet.uintVal == 0 || vtRet.uintVal == 1) &#123; rt = true; &#125; else &#123; last_error_code_ = vtRet.uintVal;#ifdef _DEBUG wcout &lt;&lt; method &lt;&lt; &quot; failed, result: &quot; &lt;&lt; last_error_code_ &lt;&lt; endl;#endif &#125; &#125;#ifdef _DEBUG else &#123; cout &lt;&lt; &quot;ExecMethod Get ReturnValue failed: &quot; &lt;&lt; res &lt;&lt; endl; &#125;#endif VariantClear(&amp;vtRet); results-&gt;Release();\t&#125;#ifdef _DEBUG\telse &#123; cout &lt;&lt; &quot;ExecMethod failed: &quot; &lt;&lt; res &lt;&lt; endl;\t&#125;#endif if (params_instance) &#123; params_instance-&gt;Release();\t&#125;\treturn rt;&#125;","tags":["windows","网卡"],"categories":["OS","Windows","网络helper"]},{"title":"监控指定网卡事件","path":"/OS/Windows/网络helper/(超详细)监控网卡事件2/","content":"[toc] win com类和接口说明1. INetworkListManager INetworkListManager 接口提供了一组用于执行网络列表管理功能的方法。 [通过com组件获取系统网卡] INetworkListManager接口 INetworkListManager：：ClearSimulatedProfileInfo 清除以前通过 SetSimulatedProfileInfo 应用于 Internet 连接配置文件的连接配置文件值。 下一个 Internet 连接查询（通过 GetInternetConnectionProfile）将使用系统信息。 INetworkListManager：：get_IsConnected get_IsConnected 属性指定本地计算机是否具有网络连接。 INetworkListManager：：get_IsConnectedToInternet get_IsConnectedToInternet 属性指定本地计算机是否具有 Internet 连接。 INetworkListManager：：GetConnectivity GetConnectivity 方法返回计算机的整体连接状态。 INetworkListManager：：GetNetwork GetNetwork 方法基于提供的网络 ID 检索网络。 INetworkListManager：：GetNetworkConnection GetNetworkConnection 方法基于提供的网络连接 ID 检索网络。 INetworkListManager：：GetNetworkConnections GetNetworkConnections 方法枚举已建立的网络连接的完整列表。 INetworkListManager：：GetNetworks GetNetworks 方法检索本地计算机上可用的网络列表。 INetworkListManager：：SetSimulatedProfileInfo SetSimulatedProfileInfo 方法将一组特定的连接配置文件值应用于 Internet 连接配置文件，以支持特定按流量计费的 Internet 连接条件模拟。 使用参考： 123456789101112...IUnknown* pUnknown = NULL;HRESULT Result = CoCreateInstance(CLSID_NetworkListManager, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&amp;pUnknown);if (SUCCEEDED(Result))&#123; INetworkListManager* pNetworkListManager = NULL; Result = pUnknown-&gt;QueryInterface(IID_INetworkListManager, (void**)&amp;pNetworkListManager); if (SUCCEEDED(Result)) &#123; &#125;... 2. INetConnectionManager 3. IConnectionPointContainer 支持可连接对象的连接点。 IConnectionPointContainer：：EnumConnectionPoints 创建枚举器对象以循环访问可连接对象中支持的所有连接点，每个传出 IID 一个连接点。 IConnectionPointContainer：：FindConnectionPoint 如果 IID 描述支持的传出接口，则返回指向指定 IID 的连接点的 IConnectionPoint 接口的指针。 使用参考： 12345678910111213...IConnectionPointContainer* pCPContainer = NULL;Result = pNetworkListManager-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;pCPContainer);if (SUCCEEDED(Result))&#123; IConnectionPoint* pConnectPoint = NULL; Result = pCPContainer-&gt;FindConnectionPoint(IID_INetworkListManagerEvents, &amp;pConnectPoint); // 查找 IID 对应的连接点 if (SUCCEEDED(Result)) &#123; &#125;&#125;... 4. IConnectionPoint 支持可连接对象的连接点。通过 IConnectionPointContainer::FindConnectionPoint 获取。通过其函数 Advise 可以建立连接点对象与客户端接收器之间的连接。也就是可以通过此接口实现网络事件的监控。 第一个参数参考 netListmgr.h 使用参考： 123456789101112131415...IConnectionPoint* pConnectPoint = NULL;Result = pCPContainer-&gt;FindConnectionPoint(IID_INetworkListManagerEvents, &amp;pConnectPoint);if (SUCCEEDED(Result))&#123; DWORD Cookie = NULL; CNetworkMonitor networkMonitor; std::function&lt;void(bool)&gt; monitorFunc = std::bind(&amp;CNetworkMonitor::NetworkStatusChangedCallback, networkMonitor, std::placeholders::_1); // CNetworkListManagerEvent 为继承自 INetworkListManagerEvents 的类，重载了 ConnectivityChanged 函数 CNetworkListManagerEvent* pNetEvent = new(std::nothrow) CNetworkListManagerEvent(monitorFunc); if (pNetEvent) &#123; Result = pConnectPoint-&gt;Advise((IUnknown*)pNetEvent, &amp;Cookie); ... 5. INetConnectionhttps://learn.microsoft.com/en-us/windows/win32/api/netcon/nn-netcon-inetconnection 使用示例 1： 监控网络状态，同时可以监控wife的网络质量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;locale&gt;#include &lt;codecvt&gt;#include &lt;functional&gt;#include &lt;Windows.h&gt;#include &lt;netlistmgr.h&gt;#include &lt;atlbase.h&gt;#include &lt;objbase.h&gt;#include &lt;wtypes.h&gt;#include &lt;wlanapi.h&gt;#include &lt;netcon.h&gt;#include &lt;IPHlpApi.h&gt;#include &lt;comutil.h&gt;#pragma comment(lib, &quot;comsuppwd.lib&quot;)#pragma comment(lib, &quot;ole32.lib&quot;)#pragma comment(lib, &quot;wlanapi.lib&quot;)#pragma comment(lib, &quot;Iphlpapi.lib&quot;)static std::string WCharToMByte(LPCWSTR lpcwszStr)&#123;\tstd::string str;\tDWORD dwMinSize = 0;\tLPSTR lpszStr = NULL;\tdwMinSize = WideCharToMultiByte(CP_OEMCP, NULL, lpcwszStr, -1, NULL, 0, NULL, FALSE);\tif (0 == dwMinSize)\t&#123; return FALSE;\t&#125;\tlpszStr = new char[dwMinSize];\tWideCharToMultiByte(CP_OEMCP, NULL, lpcwszStr, -1, lpszStr, dwMinSize, NULL, FALSE);\tstr = lpszStr;\tdelete[] lpszStr;\treturn str;&#125;static std::wstring GUIDToString(const GUID&amp; guid)&#123;\tOLECHAR guidString[40] = &#123; 0 &#125;;\t::StringFromGUID2(guid, guidString, sizeof(guidString));\treturn guidString;&#125;static std::string UnicodeToUTF8(const std::wstring&amp; wstr)&#123;\tstd::string ret;\ttry\t&#123; std::wstring_convert&lt; std::codecvt_utf8&lt;wchar_t&gt; &gt; wcv; ret = wcv.to_bytes(wstr);\t&#125;\tcatch (const std::exception&amp; e)\t&#123; std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;\t&#125;\treturn ret;&#125;class NetWorkEvent : public INetworkConnectionEvents&#123;private:\tLONG _ref;\tstd::function&lt;void()&gt; _callback;public:\tNetWorkEvent(const std::function&lt;void()&gt;&amp; cb);\tvirtual HRESULT STDMETHODCALLTYPE NetworkConnectionConnectivityChanged( /* [in] */ GUID connectionId, /* [in] */ NLM_CONNECTIVITY newConnectivity);\tvirtual HRESULT STDMETHODCALLTYPE NetworkConnectionPropertyChanged( /* [in] */ GUID connectionId, /* [in] */ NLM_CONNECTION_PROPERTY_CHANGE flags);\tSTDMETHODIMP QueryInterface(REFIID refIID, void** pIFace);\tvirtual ULONG __stdcall AddRef(void);\tvirtual ULONG __stdcall Release(void);&#125;;NetWorkEvent::NetWorkEvent(const std::function&lt;void()&gt;&amp; cb)\t: _callback(cb)&#123;&#125;HRESULT NetWorkEvent::NetworkConnectionConnectivityChanged(GUID connectionId, NLM_CONNECTIVITY newConnectivity)&#123;\tstd::wcout &lt;&lt; GUIDToString(connectionId) &lt;&lt; &quot; | NUL_CONNECTIVITY : &quot; &lt;&lt; newConnectivity &lt;&lt; std::endl;\tif (_callback)\t&#123; _callback();\t&#125;\treturn S_OK;&#125;HRESULT NetWorkEvent::NetworkConnectionPropertyChanged(GUID connectionId, NLM_CONNECTION_PROPERTY_CHANGE flags)&#123;\treturn S_OK;&#125;STDMETHODIMP NetWorkEvent::QueryInterface(REFIID refIID, void** pIFace)&#123;\tHRESULT hr = S_OK;\t*pIFace = NULL;\tif (IsEqualIID(refIID, IID_IUnknown))\t&#123; *pIFace = (IUnknown*)this; ((IUnknown*)*pIFace)-&gt;AddRef();\t&#125;\telse if (IsEqualIID(refIID, IID_INetworkConnectionEvents))\t&#123; *pIFace = (INetworkConnectionEvents*)this; ((IUnknown*)*pIFace)-&gt;AddRef();\t&#125;\telse\t&#123; hr = E_NOINTERFACE;\t&#125;\treturn hr;&#125;ULONG NetWorkEvent::AddRef(void)&#123;\treturn (ULONG)InterlockedIncrement(&amp;_ref);&#125;ULONG NetWorkEvent::Release(void)&#123;\tLONG Result = InterlockedDecrement(&amp;_ref);\tif (Result == 0) delete this;\treturn (ULONG)Result;&#125;enum NetworkType&#123;\tNotNetwork,\tEthernet,\tWlan,&#125;;enum WiFiQuality&#123;\tWeak, // (-INF, -70dBm)\tFair, // [-70dBm, -60dBm)\tGood, // [-60dBm, -50dBm)\tExcellent // [-50dBm, +INF)&#125;;struct ConnectionInfo&#123;\tstd::wstring guid;\tNetworkType type;&#125;;class NetworkMonitor&#123;\tfriend void OnNotificationCallback(PWLAN_NOTIFICATION_DATA Data, PVOID context);public:\tNetworkMonitor();\t~NetworkMonitor();\tstd::vector&lt;ConnectionInfo&gt; GetNetworkConnections();\tNetworkType GetNetAdpaterType(const std::wstring&amp; guid);\tvoid OnNetworkStatusChange();\tWiFiQuality GetWiFiSignalQuality(const std::wstring&amp; guid);\tvoid OnWiFiQualityChange(const GUID&amp; guid);\tvoid ShowNetworkStatus();private:\tstd::unique_ptr&lt;NetWorkEvent&gt; _networkEvent;\tDWORD _cookie;\tCComPtr&lt;INetworkListManager&gt; _pNLM;\tCComPtr&lt;IConnectionPointContainer&gt; _pCpc;\tCComPtr&lt;IConnectionPoint&gt; _pConnectionPoint;\tHANDLE _wlanHandle;&#125;;static NetworkMonitor* InstanceOfNetworkMonitor()&#123;\tstatic NetworkMonitor instance;\treturn &amp;instance;&#125;NetworkMonitor::NetworkMonitor()&#123;\tCoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);\tHRESULT hr = CoCreateInstance(CLSID_NetworkListManager, NULL, CLSCTX_ALL, IID_INetworkListManager, (LPVOID*)&amp;_pNLM);\thr = _pNLM-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;_pCpc);\thr = _pCpc-&gt;FindConnectionPoint(IID_INetworkConnectionEvents, &amp;_pConnectionPoint);\t_networkEvent = std::make_unique&lt;NetWorkEvent&gt;(std::bind(&amp;NetworkMonitor::OnNetworkStatusChange, this));\thr = _pConnectionPoint-&gt;Advise((IUnknown*)_networkEvent.get(), &amp;_cookie);&#125;NetworkMonitor::~NetworkMonitor()&#123;\tif (_pConnectionPoint)\t&#123; _pConnectionPoint-&gt;Unadvise(_cookie);\t&#125;\tCloseHandle(_wlanHandle);\tCoUninitialize();&#125;void OnNotificationCallback(PWLAN_NOTIFICATION_DATA Data, PVOID context)&#123;\tif (Data != NULL &amp;&amp; Data-&gt;NotificationSource == WLAN_NOTIFICATION_SOURCE_MSM &amp;&amp; Data-&gt;NotificationCode == wlan_notification_msm_signal_quality_change)\t&#123; WLAN_SIGNAL_QUALITY Qality = (WLAN_SIGNAL_QUALITY)Data-&gt;pData; std::cout &lt;&lt; &quot;WiFi OnNotification Qality : &quot; &lt;&lt; Qality &lt;&lt; std::endl; InstanceOfNetworkMonitor()-&gt;OnWiFiQualityChange(Data-&gt;InterfaceGuid);\t&#125;&#125;std::vector&lt;ConnectionInfo&gt; NetworkMonitor::GetNetworkConnections()&#123;\tstd::vector&lt;ConnectionInfo&gt; result;\tCComPtr&lt;IEnumNetworkConnections&gt; enumConnectons;\tif (FAILED(_pNLM-&gt;GetNetworkConnections(&amp;enumConnectons)))\t&#123; std::cerr &lt;&lt; &quot;GetNetworkConnections error : &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; return result;\t&#125;\tif (enumConnectons)\t&#123; ULONG lFetch; INetworkConnection* connection = nullptr; while (SUCCEEDED(enumConnectons-&gt;Next(1, &amp;connection, &amp;lFetch)) &amp;&amp; nullptr != connection) &#123; // 判断是否当前连接网卡 /* VARIANT_BOOL isConnectInternet = VARIANT_FALSE; connection-&gt;get_IsConnectedToInternet(&amp;isConnectInternet); if (isConnectInternet == VARIANT_FALSE) &#123; continue; &#125; */ ConnectionInfo item; GUID guid; INetwork* network; BSTR strNetWorkName = nullptr; if (SUCCEEDED(connection-&gt;GetNetwork(&amp;network)) &amp;&amp; network != nullptr) &#123; network-&gt;GetName(&amp;strNetWorkName); &#125; std::string strName = _com_util::ConvertBSTRToString(strNetWorkName); if (strName.compare(&quot;TrustAgent VNIC&quot;) != 0) &#123; continue; &#125; // 获取 GUID connection-&gt;GetAdapterId(&amp;guid); item.guid = GUIDToString(guid); result.push_back(item); &#125; if (connection) &#123; connection-&gt;Release(); &#125;\t&#125;\tfor (auto it = result.begin(); it != result.end(); ++it)\t&#123; it-&gt;type = GetNetAdpaterType(it-&gt;guid);\t&#125;\tstd::partition(result.begin(), std::partition(result.begin(), result.end(), [](const ConnectionInfo&amp; info) &#123; return info.type != NetworkType::NotNetwork; &#125;), [](const ConnectionInfo&amp; info) &#123; return info.type == NetworkType::Ethernet; &#125;);\tfor (auto it = result.begin(); it != result.end(); ++it)\t&#123; std::wcout &lt;&lt; &quot;connect network guid : &quot; &lt;&lt; it-&gt;guid &lt;&lt; &quot; | type : &quot; &lt;&lt; it-&gt;type &lt;&lt; std::endl;\t&#125;\treturn result;&#125;NetworkType NetworkMonitor::GetNetAdpaterType(const std::wstring&amp; guid)&#123;\tunsigned long unSize = sizeof(IP_ADAPTER_INFO);\tstd::unique_ptr&lt;uint8_t[]&gt; data = std::make_unique&lt;uint8_t[]&gt;(unSize);\tbool find = false;\tunsigned long unResult = GetAdaptersInfo(reinterpret_cast&lt;PIP_ADAPTER_INFO&gt;(data.get()), &amp;unSize);\tif (ERROR_BUFFER_OVERFLOW == unResult)\t&#123; data = std::make_unique&lt;uint8_t[]&gt;(unSize); unResult = GetAdaptersInfo(reinterpret_cast&lt;PIP_ADAPTER_INFO&gt;(data.get()), &amp;unSize);\t&#125;\tif (ERROR_SUCCESS == unResult)\t&#123; PIP_ADAPTER_INFO pIpAdapterInfo = reinterpret_cast&lt;PIP_ADAPTER_INFO&gt;(data.get()); while (pIpAdapterInfo) &#123; if (UnicodeToUTF8(guid) == pIpAdapterInfo-&gt;AdapterName) &#123; return MIB_IF_TYPE_ETHERNET == pIpAdapterInfo-&gt;Type ? NetworkType::Ethernet : IF_TYPE_IEEE80211 == pIpAdapterInfo-&gt;Type ? NetworkType::Wlan : NetworkType::NotNetwork; &#125; pIpAdapterInfo = pIpAdapterInfo-&gt;Next; &#125;\t&#125;\treturn NetworkType::NotNetwork;&#125;void NetworkMonitor::OnNetworkStatusChange()&#123;\tShowNetworkStatus();&#125;WiFiQuality NetworkMonitor::GetWiFiSignalQuality(const std::wstring&amp; guid)&#123;\tWiFiQuality result = WiFiQuality::Weak;\tDWORD dwMaxClient = 2;\tDWORD dwCurVersion = 0;\tDWORD dwResult = 0;\tunsigned int i, j;\tPWLAN_INTERFACE_INFO_LIST pIfList = NULL;\tPWLAN_INTERFACE_INFO pIfInfo = NULL;\tPWLAN_AVAILABLE_NETWORK_LIST pBssList = NULL;\tPWLAN_AVAILABLE_NETWORK pBssEntry = NULL;\tint iRSSI = 0;\tif (_wlanHandle == NULL)\t&#123; dwResult = WlanOpenHandle(dwMaxClient, NULL, &amp;dwCurVersion, &amp;_wlanHandle); if (dwResult != ERROR_SUCCESS) &#123; std::cerr &lt;&lt; &quot;WlanOpenHandle failed with error: &quot; &lt;&lt; dwResult &lt;&lt; std::endl; return result; &#125; dwResult = WlanRegisterNotification(_wlanHandle, WLAN_NOTIFICATION_SOURCE_ALL, TRUE, WLAN_NOTIFICATION_CALLBACK(OnNotificationCallback), NULL, NULL, NULL); if (dwResult != ERROR_SUCCESS) &#123; std::cerr &lt;&lt; &quot;WlanRegisterNotification failed with error: &quot; &lt;&lt; dwResult &lt;&lt; std::endl; return result; &#125;\t&#125;\tdwResult = WlanEnumInterfaces(_wlanHandle, NULL, &amp;pIfList);\tif (dwResult != ERROR_SUCCESS)\t&#123; std::cerr &lt;&lt; &quot;WlanEnumInterfaces failed with error: &quot; &lt;&lt; dwResult &lt;&lt; std::endl; return result;\t&#125;\tfor (i = 0; i &lt; (int)pIfList-&gt;dwNumberOfItems; i++)\t&#123; pIfInfo = (WLAN_INTERFACE_INFO*)&amp;pIfList-&gt;InterfaceInfo[i]; if (guid != GUIDToString(pIfInfo-&gt;InterfaceGuid) || pIfInfo-&gt;isState != wlan_interface_state_connected) &#123; continue; &#125; dwResult = WlanGetAvailableNetworkList(_wlanHandle, &amp;pIfInfo-&gt;InterfaceGuid, 0, NULL, &amp;pBssList); if (dwResult != ERROR_SUCCESS) &#123; std::cerr &lt;&lt; &quot;WlanGetAvailableNetworkList failed with error:&quot; &lt;&lt; dwResult &lt;&lt; std::endl; return result; &#125; for (j = 0; j &lt; pBssList-&gt;dwNumberOfItems; j++) &#123; pBssEntry = (WLAN_AVAILABLE_NETWORK*)&amp;pBssList-&gt;Network[j]; if (pBssEntry-&gt;bNetworkConnectable &amp;&amp; (pBssEntry-&gt;dwFlags &amp; WLAN_AVAILABLE_NETWORK_CONNECTED)) &#123; if (pBssEntry-&gt;wlanSignalQuality == 0) iRSSI = -100; else if (pBssEntry-&gt;wlanSignalQuality == 100) iRSSI = -50; else iRSSI = -100 + (pBssEntry-&gt;wlanSignalQuality / 2); std::cout &lt;&lt; &quot;Signal Quality:\\t &quot; &lt;&lt; pBssEntry-&gt;wlanSignalQuality &lt;&lt; &quot; (RSSI: &quot; &lt;&lt; iRSSI &lt;&lt; &quot; dBm)&quot; &lt;&lt; std::endl; result = iRSSI &lt; -70 ? WiFiQuality::Weak : iRSSI &lt; -60 ? WiFiQuality::Fair : iRSSI &lt; -50 ? WiFiQuality::Good : WiFiQuality::Excellent; &#125; &#125;\t&#125;\tif (pBssList != NULL)\t&#123; WlanFreeMemory(pBssList); pBssList = NULL;\t&#125;\tif (pIfList != NULL)\t&#123; WlanFreeMemory(pIfList); pIfList = NULL;\t&#125;\treturn result;&#125;void NetworkMonitor::OnWiFiQualityChange(const GUID&amp; guid)&#123;\tauto nowQuality = GetWiFiSignalQuality(GUIDToString(guid));\tstd::cout &lt;&lt; &quot;WiFi signal quality now : &quot; &lt;&lt; nowQuality &lt;&lt; std::endl;\tShowNetworkStatus();&#125;void NetworkMonitor::ShowNetworkStatus()&#123;\tNetworkType type;\tWiFiQuality quality;\tauto connections = GetNetworkConnections();\tif (connections.empty())\t&#123; type = NetworkType::NotNetwork;\t&#125;\telse\t&#123; type = connections.front().type; if (type == NetworkType::Wlan) &#123; quality = GetWiFiSignalQuality(connections.front().guid); &#125;\t&#125;\tstd::cout &lt;&lt; &quot;====== Notify ======&quot; &lt;&lt; std::endl;\tstd::cout &lt;&lt; &quot;* Type : &quot; &lt;&lt; (type == NetworkType::NotNetwork ? &quot;NetworkError&quot; : type == NetworkType::Ethernet ? &quot;Ethernet&quot; : &quot;WiFi&quot;) &lt;&lt; std::endl;\tif (type == NetworkType::Wlan)\t&#123; std::cout &lt;&lt; &quot;* Signal : &quot; &lt;&lt; quality + 1 &lt;&lt; std::endl;\t&#125;\tstd::cout &lt;&lt; std::endl;&#125;int main()&#123;\tInstanceOfNetworkMonitor()-&gt;ShowNetworkStatus();\twhile (true) std::this_thread::sleep_for(std::chrono::hours(10));\treturn 0;&#125; 使用示例2 监控网络连接状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;netlistmgr.h&gt;#include &quot;sp_log.h&quot;#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;netcon.h&gt;#include &lt;Shlwapi.h&gt;#include &lt;TLHELP32.H&gt;#include &lt;UserEnv.h&gt;#include &lt;iphlpapi.h&gt;#pragma comment(lib,&quot;shlwapi.lib&quot;)#pragma comment(lib,&quot;Iphlpapi.lib&quot;)class CNetworkListManagerEvent : public INetworkListManagerEvents&#123;public:\tCNetworkListManagerEvent(std::function&lt;void(bool)&gt; netChangedHandler) : m_ref(1) , netChangedHandler_(netChangedHandler)\t&#123;\t&#125;\t~CNetworkListManagerEvent()\t&#123;\t&#125;\tHRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppvObject)\t&#123; HRESULT Result = S_OK; if (IsEqualIID(riid, IID_IUnknown)) &#123; *ppvObject = (IUnknown*)this; &#125; else if (IsEqualIID(riid, IID_INetworkListManagerEvents)) &#123; *ppvObject = (INetworkListManagerEvents*)this; &#125; else &#123; Result = E_NOINTERFACE; &#125; return Result;\t&#125;\tULONG STDMETHODCALLTYPE AddRef()\t&#123; return (ULONG)InterlockedIncrement(&amp;m_ref);\t&#125;\tULONG STDMETHODCALLTYPE Release()\t&#123; LONG Result = InterlockedDecrement(&amp;m_ref); if (Result == 0) delete this; return (ULONG)Result;\t&#125;\tvirtual HRESULT STDMETHODCALLTYPE ConnectivityChanged( /* [in] */ NLM_CONNECTIVITY newConnectivity)\t&#123; if (newConnectivity == NLM_CONNECTIVITY_DISCONNECTED) &#123; SP_DEV_LOGT(&quot;internet status changed. connect closed&quot;); // 网络断开 netChangedHandler_(false); &#125; else if ((newConnectivity &amp; NLM_CONNECTIVITY_IPV4_INTERNET) || (newConnectivity &amp; NLM_CONNECTIVITY_IPV6_INTERNET)) &#123; SP_DEV_LOGT(&quot;internet status changed. connect success&quot;); // 网络连接成功 netChangedHandler_(true); &#125; return S_OK;\t&#125;private:\tLONG m_ref;\tstd::function&lt;void(bool)&gt; netChangedHandler_;&#125;;class CNetworkMonitor&#123;public:\tCNetworkMonitor() &#123;&#125;;\t~CNetworkMonitor() &#123;&#125;;private:\t// 监控网络状态变化\tstatic void InitNetworkMonitor()\t&#123; SP_DEV_LOGT(&quot;InitNetworkMonitor&quot;); bool bSuccess = false; CoInitialize(NULL); // // 通过NLA接口获取网络状态 // IUnknown* pUnknown = NULL; HRESULT Result = CoCreateInstance(CLSID_NetworkListManager, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&amp;pUnknown); if (SUCCEEDED(Result)) &#123; INetworkListManager* pNetworkListManager = NULL; Result = pUnknown-&gt;QueryInterface(IID_INetworkListManager, (void**)&amp;pNetworkListManager); if (SUCCEEDED(Result)) &#123; VARIANT_BOOL IsConnect = VARIANT_FALSE; Result = pNetworkListManager-&gt;get_IsConnectedToInternet(&amp;IsConnect); if (SUCCEEDED(Result)) &#123; printf(&quot;connect to internet:%s&quot;, IsConnect == VARIANT_TRUE ? &quot;TRUE&quot; : &quot;FALSE&quot;); &#125; IConnectionPointContainer* pCPContainer = NULL; Result = pNetworkListManager-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;pCPContainer); if (SUCCEEDED(Result)) &#123; IConnectionPoint* pConnectPoint = NULL; Result = pCPContainer-&gt;FindConnectionPoint(IID_INetworkListManagerEvents, &amp;pConnectPoint); if (SUCCEEDED(Result)) &#123; DWORD Cookie = NULL; CNetworkMonitor networkMonitor; std::function&lt;void(bool)&gt; monitorFunc = std::bind(&amp;CNetworkMonitor::NetworkStatusChangedCallback, networkMonitor, std::placeholders::_1); CNetworkListManagerEvent* pNetEvent = new(std::nothrow) CNetworkListManagerEvent(monitorFunc); if (pNetEvent) &#123; Result = pConnectPoint-&gt;Advise((IUnknown*)pNetEvent, &amp;Cookie); if (SUCCEEDED(Result)) &#123; printf(&quot;InitNetworkMonitor success&quot;); bSuccess = true; MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); if (msg.message == WM_QUIT) &#123; break; &#125; &#125; pConnectPoint-&gt;Unadvise(Cookie); pConnectPoint-&gt;Release(); &#125; &#125; &#125; pCPContainer-&gt;Release(); &#125; pNetworkListManager-&gt;Release(); &#125; pUnknown-&gt;Release(); &#125; CoUninitialize();\t&#125;\tvoid NetworkStatusChangedCallback(bool status)\t&#123; g_bNetWorkOnline = status; if (status) &#123; if (g_sp_trust_model.get()) &#123; if (g_sp_trust_model-&gt;IsOnline()) &#123; //休眠唤醒后网络连接成功，自动发送一次心跳 printf(&quot;Sleep wakes up and automatically triggers a heartbeat&quot;); &#125; else &#123; printf(&quot;No login, will not rebuild trust nc&quot;); &#125; &#125; else &#123; printf(&quot;rebuild trust nc - g_sp_trust_model is null&quot;); &#125; &#125;\t&#125;public:\tvoid StartMonitor()\t&#123; std::thread monitorThread(&amp;InitNetworkMonitor); monitorThread.detach();\t&#125;&#125;;","categories":["OS","Windows","网络helper"]},{"title":"监控系统事件（网卡）","path":"/OS/Windows/监控系统事件/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#pragma once#include &lt;netlistmgr.h&gt;#include &lt;atomic&gt;std::atomic_bool g_bNetWorkOnline(true);class CNetworkListManagerEvent : public INetworkListManagerEvents&#123;public:\tCNetworkListManagerEvent(std::function&lt;void(bool)&gt; netChangedHandler) : m_ref(1) , netChangedHandler_(netChangedHandler)\t&#123;\t&#125;\t~CNetworkListManagerEvent()\t&#123;\t&#125;\tHRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppvObject)\t&#123; HRESULT Result = S_OK; if (IsEqualIID(riid, IID_IUnknown)) &#123; *ppvObject = (IUnknown*)this; &#125; else if (IsEqualIID(riid, IID_INetworkListManagerEvents)) &#123; *ppvObject = (INetworkListManagerEvents*)this; &#125; else &#123; Result = E_NOINTERFACE; &#125; return Result;\t&#125;\tULONG STDMETHODCALLTYPE AddRef()\t&#123; return (ULONG)InterlockedIncrement(&amp;m_ref);\t&#125;\tULONG STDMETHODCALLTYPE Release()\t&#123; LONG Result = InterlockedDecrement(&amp;m_ref); if (Result == 0) delete this; return (ULONG)Result;\t&#125;\tvirtual HRESULT STDMETHODCALLTYPE ConnectivityChanged( /* [in] */ NLM_CONNECTIVITY newConnectivity)\t&#123; if (newConnectivity == NLM_CONNECTIVITY_DISCONNECTED) &#123; SP_DEV_LOGT(&quot;internet status changed. connect closed&quot;); // 网络断开 netChangedHandler_(false); &#125; else if ((newConnectivity &amp; NLM_CONNECTIVITY_IPV4_INTERNET) || (newConnectivity &amp; NLM_CONNECTIVITY_IPV6_INTERNET)) &#123; SP_DEV_LOGT(&quot;internet status changed. connect success&quot;); // 网络连接成功 netChangedHandler_(true); &#125; return S_OK;\t&#125;private:\tLONG m_ref;\tstd::function&lt;void(bool)&gt; netChangedHandler_;&#125;;class CNetworkMonitor&#123;public:\tCNetworkMonitor() &#123;&#125;;\t~CNetworkMonitor() &#123;&#125;;private:\t// 监控网络状态变化\tstatic void InitNetworkMonitor()\t&#123; SP_DEV_LOGT(&quot;InitNetworkMonitor&quot;); bool bSuccess = false; CoInitialize(NULL); // // 通过NLA接口获取网络状态 // IUnknown* pUnknown = NULL; HRESULT Result = CoCreateInstance(CLSID_NetworkListManager, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&amp;pUnknown); if (SUCCEEDED(Result)) &#123; INetworkListManager* pNetworkListManager = NULL; Result = pUnknown-&gt;QueryInterface(IID_INetworkListManager, (void**)&amp;pNetworkListManager); if (SUCCEEDED(Result)) &#123; VARIANT_BOOL IsConnect = VARIANT_FALSE; Result = pNetworkListManager-&gt;get_IsConnectedToInternet(&amp;IsConnect); if (SUCCEEDED(Result)) &#123; SP_DEV_LOGT(&quot;connect to internet:%s&quot;, IsConnect == VARIANT_TRUE ? &quot;TRUE&quot; : &quot;FALSE&quot;); &#125; IConnectionPointContainer* pCPContainer = NULL; Result = pNetworkListManager-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;pCPContainer); if (SUCCEEDED(Result)) &#123; IConnectionPoint* pConnectPoint = NULL; Result = pCPContainer-&gt;FindConnectionPoint(IID_INetworkListManagerEvents, &amp;pConnectPoint); if (SUCCEEDED(Result)) &#123; DWORD Cookie = NULL; CNetworkMonitor networkMonitor; std::function&lt;void(bool)&gt; monitorFunc = std::bind(&amp;CNetworkMonitor::NetworkStatusChangedCallback, networkMonitor, std::placeholders::_1); CNetworkListManagerEvent* pNetEvent = new(std::nothrow) CNetworkListManagerEvent(monitorFunc); if (pNetEvent) &#123; Result = pConnectPoint-&gt;Advise((IUnknown*)pNetEvent, &amp;Cookie); if (SUCCEEDED(Result)) &#123; SP_DEV_LOGT(&quot;InitNetworkMonitor success&quot;); bSuccess = true; MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); if (msg.message == WM_QUIT) &#123; break; &#125; &#125; pConnectPoint-&gt;Unadvise(Cookie); pConnectPoint-&gt;Release(); &#125; &#125; &#125; pCPContainer-&gt;Release(); &#125; pNetworkListManager-&gt;Release(); &#125; pUnknown-&gt;Release(); &#125; CoUninitialize();\t&#125;\tvoid NetworkStatusChangedCallback(bool status)\t&#123; g_bNetWorkOnline = status; if (status) &#123; if (g_sp_trust_model.get()) &#123; if (g_sp_trust_model-&gt;IsOnline()) &#123; //休眠唤醒后网络连接成功，自动发送一次心跳 SP_LOGI(&quot;Sleep wakes up and automatically triggers a heartbeat&quot;); g_sp_trust_model-&gt;OnWakeToSendHeartBeat(); SP_LOGI(&quot;rebuild trust nc&quot;); if (g_sp_trust_model-&gt;Session()-&gt;NeedsL3Tunnel() &amp;&amp; !g_sp_trust_model-&gt;Session()-&gt;IsTunnelSvrsEmpty()) &#123; // 网络连接成功后自动触发重连 std::thread buildUtunThread([] &#123; g_sp_trust_model-&gt;NotifyUpMessage(SP_TRUST_TOPIC_BUILD_UTUN, SPJSONObject()); &#125;); buildUtunThread.detach(); &#125; &#125; else &#123; SP_LOGI(&quot;No login, will not rebuild trust nc&quot;); &#125; &#125; else &#123; SP_LOGI(&quot;rebuild trust nc - g_sp_trust_model is null&quot;); &#125; &#125;\t&#125;public:\tvoid StartMonitor()\t&#123; std::thread monitorThread(&amp;InitNetworkMonitor); monitorThread.detach();\t&#125;&#125;;","tags":["windows","监控"],"categories":["OS","Windows"]},{"title":"管道demo","path":"/OS/Windows/管道的使用/","content":"[toc] 管道类.h123456789101112131415161718192021222324252627282930313233343536373839#pragma once#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;memory&gt;#define TIME_ASECOND 1000enum PIPEUSERTYPE &#123;\tUSER_CLIENT, //客户端\tUSER_SERVER, //服务端&#125;;class PipeIPC &#123;public:\texplicit PipeIPC(PIPEUSERTYPE role) :m_Role(role), m_hPipeHandle(INVALID_HANDLE_VALUE) &#123;&#125;;\t~PipeIPC();\tbool WriteData(__in const std::string&amp; datas); //写入数据\tvoid Release();\tbool ReadData(__out std::string&amp; datas, __out bool bIsPipeEnd); //读取数据\tbool InitPipeIPC(); //初始化管道通信\tbool IsInit();\tBOOL InitSecurityAttributes();\tvoid Connect();\tvoid DisConnect();private:\tPIPEUSERTYPE m_Role;\tHANDLE m_hPipeHandle;\tSECURITY_ATTRIBUTES m_sec_attr; //security attributes &#125;; .cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include &quot;PipeIPC.h&quot;#include &lt;AccCtrl.h&gt;#include &lt;AclAPI.h&gt;using namespace std;#define PIPE_SERVER_NAME &quot;\\\\\\\\.\\\\pipe\\\\TrustAgent\\\\pipe.ToFixService&quot;#define PIPE_CLIENT_NAME &quot;\\\\\\\\.\\\\pipe\\\\TrustAgent\\\\pipe.ToTrustAgent&quot;PipeIPC::~PipeIPC()&#123;\tif (m_hPipeHandle != INVALID_HANDLE_VALUE)\t&#123; DisconnectNamedPipe(m_hPipeHandle); CloseHandle(m_hPipeHandle);\t&#125;&#125;bool PipeIPC::InitPipeIPC()&#123;\tif (USER_SERVER == m_Role &amp;&amp; nullptr != m_hPipeHandle)\t&#123; InitSecurityAttributes(); // cout &lt;&lt; &quot;ser&quot; &lt;&lt; endl; m_hPipeHandle = CreateNamedPipeA(PIPE_SERVER_NAME, PIPE_ACCESS_DUPLEX, //双向模式 PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE/* | PIPE_NOWAIT*/, PIPE_UNLIMITED_INSTANCES,//设置最大容纳实例数目 0, 0, NULL, (LPSECURITY_ATTRIBUTES)&amp;m_sec_attr); //如果管道创建失败 if (m_hPipeHandle == INVALID_HANDLE_VALUE) &#123; return false; &#125;#if 0 if (!ConnectNamedPipe(m_hPipeHandle, nullptr)) &#123; cout &lt;&lt; &quot;ConnectNamedPipe failed&quot; &lt;&lt; endl; return false; &#125;#endif\t&#125;\telse\t&#123; if (WaitNamedPipeA(PIPE_CLIENT_NAME, TIME_ASECOND * 5) == FALSE) return 0; m_hPipeHandle = CreateFileA( PIPE_CLIENT_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); //如果管道创建失败 if (m_hPipeHandle == INVALID_HANDLE_VALUE) &#123; return false; &#125; WriteData(&quot;[PIPE] ------ V10 Init ------&quot;);\t&#125;\treturn true;&#125;bool PipeIPC::IsInit()&#123;\treturn m_hPipeHandle == INVALID_HANDLE_VALUE ? false : true;&#125;/*\t[details] 创建管道去管理员权限*/BOOL PipeIPC::InitSecurityAttributes()&#123;\tPSID pEveryoneSID = NULL;\tPACL pACL = NULL;\tEXPLICIT_ACCESS ea;\tPSECURITY_DESCRIPTOR pSD = NULL;\tvoid* ea_addr = NULL;\tvoid* acl_addr = NULL;\tvoid* sd_addr = NULL;\tSID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;\tif (!AllocateAndInitializeSid(&amp;SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &amp;pEveryoneSID))\t&#123; return FALSE;\t&#125;\tZeroMemory(&amp;ea, sizeof(EXPLICIT_ACCESS));\tea.grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;\tea.grfAccessMode = SET_ACCESS;\tea.grfInheritance = NO_INHERITANCE;\tea.Trustee.TrusteeForm = TRUSTEE_IS_SID;\tea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;\tea.Trustee.ptstrName = (LPTSTR)pEveryoneSID;\tea_addr = &amp;ea;\tif (ERROR_SUCCESS != SetEntriesInAcl(1, &amp;ea, NULL, &amp;pACL))\t&#123; goto cleanup;\t&#125;\tacl_addr = &amp;pACL;\tpSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);\tif (NULL == pSD)\t&#123; goto cleanup;\t&#125;\tif (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))\t&#123; goto cleanup;\t&#125;\tsd_addr = &amp;pSD;\tif (!SetSecurityDescriptorDacl(pSD, TRUE, pACL, FALSE))\t&#123; goto cleanup;\t&#125;\tm_sec_attr.nLength = sizeof(SECURITY_ATTRIBUTES);\tm_sec_attr.lpSecurityDescriptor = pSD;\tm_sec_attr.bInheritHandle = FALSE;\treturn TRUE;cleanup:\tif (pEveryoneSID) FreeSid(pEveryoneSID);\tif (pACL) LocalFree(pACL);\tif (pSD) LocalFree(pSD);\treturn FALSE;&#125;void PipeIPC::Connect()&#123;\tConnectNamedPipe(m_hPipeHandle, nullptr);&#125;void PipeIPC::DisConnect()&#123;\tDisconnectNamedPipe(m_hPipeHandle);&#125;//读取数据bool PipeIPC::ReadData(__out std::string&amp; datas, __out bool bIsPipeEnd)&#123;\tif (INVALID_HANDLE_VALUE == m_hPipeHandle || nullptr == m_hPipeHandle)\t&#123; InitPipeIPC();\t&#125;\tDWORD cbRead = 0;//定义数据长度\tDWORD cbData = 0;\tif (ReadFile(m_hPipeHandle, &amp;cbData, sizeof(cbData), &amp;cbRead, nullptr) &amp;&amp; sizeof(cbData) == cbRead)\t&#123; DWORD error = GetLastError(); bIsPipeEnd = (error == ERROR_BROKEN_PIPE ? true : false); datas.resize(cbData); if (ReadFile(m_hPipeHandle, (LPVOID)datas.data(), cbData, &amp;cbRead, nullptr) &amp;&amp; cbData == cbRead) &#123; return true; &#125;\t&#125;\telse\t&#123; DWORD dwError = GetLastError(); bIsPipeEnd = (dwError == ERROR_BROKEN_PIPE) ? true : false;\t&#125;\tdatas.resize(0);\treturn false;&#125;//写入数据bool PipeIPC::WriteData(__in const std::string&amp; datas)&#123;\tif (m_Role == USER_SERVER)\t&#123; bool connect = ConnectNamedPipe(m_hPipeHandle, NULL); if (!connect) &#123; if (!InitPipeIPC()) &#123; DWORD error = GetLastError(); if (error != ERROR_PIPE_CONNECTED) &#123; //cout &lt;&lt; &quot;客户端还没连接&quot; &lt;&lt; endl; //连接失败 return false; &#125; &#125; &#125;\t&#125;\tif (!IsInit())\t&#123; if (!InitPipeIPC()) &#123; return false; &#125;\t&#125;\t//连接成功！\tDWORD wLen;\tconst DWORD cbData = datas.size() * sizeof(datas[0]);\tif (!WriteFile(m_hPipeHandle, &amp;cbData, sizeof(cbData), &amp;wLen, NULL))\t&#123; return false;\t&#125;\tif (!WriteFile(m_hPipeHandle, datas.c_str(), datas.size() * sizeof(datas[0]), &amp;wLen, NULL))\t&#123; return false;\t&#125;\treturn true;&#125;void PipeIPC::Release()&#123;\tif (m_hPipeHandle)\t&#123; DisconnectNamedPipe(m_hPipeHandle); CloseHandle(m_hPipeHandle); // 关闭句柄 m_hPipeHandle = NULL;\t&#125;&#125; 定义与声明12__declspec(selectany) PipeIPC* pRead = new PipeIPC(USER_SERVER);__declspec(selectany) PipeIPC* pWrite = new PipeIPC(USER_CLIENT); 使用监听管道 随程序同时启动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 BOOL StartPipeRead()&#123;\tEventLog(LOG_ALL, &quot;[IPC][THREAD] ,Create PipeReadThread Success, pipe = %p&quot;, pRead );\tEventLog(LOG_ALL, &quot;pipe = %p, pipe-&gt;IsInit()=%d&quot;, pRead, pRead-&gt;IsInit());\tbool isPipeEnd = true;\twhile (true)\t&#123; if (isPipeEnd) &#123; pRead-&gt;Connect(); &#125; std::string datas; if (!pRead-&gt;ReadData(datas, isPipeEnd)) &#123; if (isPipeEnd) &#123; EventLog(LOG_ALL, &quot;-----------[PIPE END]----------&quot;); pRead-&gt;DisConnect(); &#125; &#125; datas = &quot;Add&quot;; // 数据处理 if (datas.find(&quot;start&quot;) != std::string::npos) // 启动成功 &#123; EventLog(LOG_ALL, &quot; [PIPE] [REC] TrustAgentStart&quot;); // 启动 管道客户端 if (!StartPipeWrite()) &#123; EventLog(LOG_ALL, &quot; [PIPE] Failed to Create Client Pipe, GetLastError()=&quot;, GetLastError()); &#125; &#125; else if (!datas.empty()) &#123; EventLog(LOG_ALL, &quot;[PIPE] [RECV] datas: %s&quot;, datas.c_str()); // 调用导出的接口 &#123; std::thread th(HandleFix, datas); th.detach(); &#125; // NSPTRUST::SendRpcMsgToPlugin(POLICY_SENDTQA_USER, datas.c_str()); &#125;\t&#125;&#125; 写管道启动时机，同名管道的监听管道启动后再启动 1234567BOOL StartPipeWrite()&#123;\tif (pWrite-&gt;IsInit()) return true;\telse return pWrite-&gt;InitPipeIPC();&#125; 写数据 12std::string datas = &quot;Send data to PIPE Read&quot;;pWrite-&gt;WriteData(datas);","categories":["OS","Windows"]},{"title":"系统锁","path":"/OS/Windows/系统锁/","content":"概述：系统锁就是在创建句柄，再次创建该句柄时，会返回失败 [toc] 系统锁系统锁就是使用 CreateMutexA 创建一个句柄，创建成功时，句柄不为空。当再次使用该锁的命名创建时，因为已经创建了一个同名锁了，所以会报错，也就实现了进程启动一次或者函数执行一次的逻辑。 代码12345678910111213141516171819202122class WinSingleleton &#123;public: WinSingleleton(string name); ~WinSingleleton() &#123; if (_handle != INVALID_HANDLE_VALUE) &#123; CloseHandle(_handle); &#125; _handle = INVALID_HANDLE_VALUE; &#125;private: HANDLE _handle;&#125;;WinSingleleton::WinSingleleton(string name) :_handle(INVALID_HANDLE_VALUE)&#123; _handle = CreateMutexA(NULL, FALSE, name.c_str());&#125;","tags":["windows","锁"],"categories":["OS","Windows"]},{"title":"【windows】查询处理器架构","path":"/OS/Windows/查询系统信息/查询处理器架构/","content":"问题： 在 arm 架构的 windows 上使用 GetSystemInfo 获取到的 wProcessorArchitecture 参数不准确。 由于 arm 架构的 windows 操作系统非常少见，所以客户端上线时并没有回归过检测 arm 操作系统。导致上线后出现驱动安装失败问题。 [toc] 使用 GetSystemInfo 查询12345678910111213141516171819202122232425262728293031323334std::string GetNcProcessorArchitecture()\t&#123; SYSTEM_INFO si = &#123; 0 &#125;; GetSystemInfo(&amp;si); DWORD architecture = si.wProcessorArchitecture;#if 0#define PROCESSOR_ARCHITECTURE_INTEL 0 #define PROCESSOR_ARCHITECTURE_MIPS 1 #define PROCESSOR_ARCHITECTURE_ALPHA 2#define PROCESSOR_ARCHITECTURE_PPC 3#define PROCESSOR_ARCHITECTURE_SHX 4 #define PROCESSOR_ARCHITECTURE_ARM 5 #define PROCESSOR_ARCHITECTURE_IA64 6 #define PROCESSOR_ARCHITECTURE_ALPHA64 7 #define PROCESSOR_ARCHITECTURE_MSIL 8 #define PROCESSOR_ARCHITECTURE_AMD64 9#define PROCESSOR_ARCHITECTURE_ARM64 12#endif if (architecture == PROCESSOR_ARCHITECTURE_AMD64) &#123; return &quot;amd64&quot;; &#125; else if (architecture == PROCESSOR_ARCHITECTURE_INTEL) &#123; return &quot;i386&quot;; &#125; else if (architecture == PROCESSOR_ARCHITECTURE_ARM64 || architecture == PROCESSOR_ARCHITECTURE_ARM) &#123; return &quot;arm&quot;; &#125; return &quot;&quot;;\t&#125; 使用 GetSystemInfo 查询的 wProcessorArchitecture 的值为 0。 查询注册表调研一番后，发现使用注册表的方式更稳妥一点。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main() &#123; HKEY hKey; TCHAR processorArchitecture[255]; DWORD bufferSize = sizeof(processorArchitecture); // 打开注册表键 if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT(&quot;SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager\\\\Environment&quot;), 0, KEY_READ, &amp;hKey) == ERROR_SUCCESS) &#123; // 读取注册表值 if (RegQueryValueEx(hKey, TEXT(&quot;PROCESSOR_ARCHITECTURE&quot;), nullptr, nullptr, reinterpret_cast&lt;LPBYTE&gt;(processorArchitecture), &amp;bufferSize) == ERROR_SUCCESS) &#123; std::cout &lt;&lt; &quot;Processor Architecture: &quot; &lt;&lt; processorArchitecture; &#125; // 关闭注册表键 RegCloseKey(hKey); &#125; return 0;&#125;","tags":["windows","sysinfo"],"categories":["OS","Windows","查询系统信息"]},{"title":"判断windows版本","path":"/OS/Windows/查询系统信息/判断windows版本/","content":"[toc] 接口说明在windows操作系统上，判断系统版本号一般都是使用 GetVersionEx 函数，但是该函数 windows8.1 以后被启用了，尽管可以通过添加宏来忽略 4996 的错误。在新的API中提供了新的接口以供判断操作系统版本： Versionhelpers.h 标头 - Win32 apps | Microsoft Learn 声明的宏 本文介绍如何使用 IsWindowsVersionOrGreater 和 verifyVersionInfoW 函数。 关于如何查询windows版本号可以看这个文档： 更新 WINVER 和 _WIN32_WINNT | Microsoft Learn Windows各个版本的宏 所需的最低系统 NTDDI_VERSION的值 Windows 10 1903 “19H1” NTDDI_WIN10_19H1 (0x0A000007) Windows 10 1809 “红石 5” NTDDI_WIN10_RS5 (0x0A000006) Windows 10 1803 “红石 4” NTDDI_WIN10_RS4 (0x0A000005) Windows 10 1709 “红石 3” NTDDI_WIN10_RS3 (0x0A000004) Windows 10 1703 “红石 2” NTDDI_WIN10_RS2 (0x0A000003) Windows 10 1607 “红石 1” NTDDI_WIN10_RS1 (0x0A000002) Windows 10 1511“阈值 2” NTDDI_WIN10_TH2 (0x0A000001) Windows 10 1507“阈值” NTDDI_WIN10 (0x0A000000) Windows 8.1 NTDDI_WINBLUE (0x06030000) Windows 8 NTDDI_WIN8 (0x06020000) Windows 7 NTDDI_WIN7 (0x06010000) Windows Server 2008 NTDDI_WS08 (0x06000100) Windows Vista Service Pack 1 (SP1) NTDDI_VISTASP1 (0x06000100) Windows Vista NTDDI_VISTA (0x06000000) Windows Server 2003 Service Pack 2 (SP2) NTDDI_WS03SP2 (0x05020200) 带有 Service Pack 1 (SP1) 的 Windows Server 2003 NTDDI_WS03SP1 (0x05020100) Windows Server 2003 NTDDI_WS03 (0x05020000) Windows XP Service Pack 3 (SP3) NTDDI_WINXPSP3 (0x05010300) Windows XP Service Pack 2 (SP2) NTDDI_WINXPSP2 (0x05010200) Windows XP Service Pack 1 (SP1) NTDDI_WINXPSP1 (0x05010100) Windows XP NTDDI_WINXP (0x05010000) 补充关于 函数的三个参数的输入可以参考文档中定义的宏： 123#define OSVER(Version) ((Version) &amp; OSVERSION_MASK)#define SPVER(Version) (((Version) &amp; SPVERSION_MASK) &gt;&gt; 8)#define SUBVER(Version) (((Version) &amp; SUBVERSION_MASK) ) 除此之外，还可以使用以下宏获取三个版本号： 1234567891011/*LOWORD()得到一个32bit数的低16bit HIWORD()得到一个32bit数的高16bitLOBYTE()得到一个16bit数最低（最右边）那个字节HIBYTE()得到一个16bit数最高（最左边）那个字节*/#define LOWORD(l) ((WORD)(((DWORD_PTR)(l)) &amp; 0xffff))#define HIWORD(l) ((WORD)((((DWORD_PTR)(l)) &gt;&gt; 16) &amp; 0xffff))#define LOBYTE(w) ((BYTE)(((DWORD_PTR)(w)) &amp; 0xff))#define HIBYTE(w) ((BYTE)((((DWORD_PTR)(w)) &gt;&gt; 8) &amp; 0xff)) 示例IsWindowsVersionOrGreater 函数是 Windows API 中的一个函数，用于检查当前运行的操作系统版本是否满足指定的条件。以下是该函数的一些常见用法： 检查特定版本及以上的 Windows 版本： 1234567#include &lt;Windows.h&gt;// 示例：检查 Windows 7 及以上版本if (IsWindowsVersionOrGreater(6, 1, 0))&#123; // 在 Windows 7 或更高版本上执行某些操作&#125; 检查特定版本和 Service Pack 的 Windows 版本： 1234567#include &lt;Windows.h&gt;// 示例：检查 Windows 10 版本 1809（秋季创意者更新）及以上版本if (IsWindowsVersionOrGreater(10, 0, 17763))&#123; // 在 Windows 10 版本 1809（秋季创意者更新）或更高版本上执行某些操作&#125; 检查是否为特定 Windows Server 版本： 1234567#include &lt;Windows.h&gt;// 示例：检查是否为 Windows Server 2016 版本if (IsWindowsVersionOrGreater(HIBYTE(_WIN32_WINNT_WIN10), LOBYTE(_WIN32_WINNT_WIN10), 0))&#123; // 在 Windows Server 2016 或更高版本上执行某些操作&#125; 检查特定版本、Service Pack 和产品类型的 Windows 版本： 1234567#include &lt;Windows.h&gt;// 示例：检查 Windows 8.1 Update 版本且为工作站类型if (IsWindowsVersionOrGreater(6, 3, 0, VER_GREATER_EQUAL, VER_NT_WORKSTATION))&#123; // 在 Windows 8.1 Update 版本且为工作站类型上执行某些操作&#125; 这些示例可以帮助你理解 IsWindowsVersionOrGreater 函数的各种用法，你可以根据实际需求在代码中适当调整参数和条件。 请注意，IsWindowsVersionOrGreater 是一个动态链接库函数，在使用时需要包含 &lt;Windows.h&gt; 头文件，且需要链接到 Version.lib 库。 判断 dwPlatformIddwPlatformId 字段说明在 Windows 系统中，常用的平台标识（Platform ID）定义如下： VER_PLATFORM_WIN32s：表示 Win32s 子系统，它是为 Windows 3.1 提供的一个扩展运行环境，使得部分 32 位应用程序可以在 Windows 3.1 上运行。 VER_PLATFORM_WIN32_WINDOWS：表示 Windows 9x 系列操作系统，包括 Windows 95、Windows 98 和 Windows ME。这些操作系统都是基于 MS-DOS 的。 VER_PLATFORM_WIN32_NT：表示 Windows NT 系列操作系统，包括 Windows NT、Windows 2000、Windows XP、Windows Server 2003、Windows Vista、Windows 7、Windows 8、Windows 10 等版本。这些操作系统是基于全新的内核设计的，并具有更强大的功能和稳定性。 每个平台标识对应不同的操作系统系列，因此在开发应用程序时，根据需要选择正确的平台标识是很重要的。 判断1234567891011121314bool IsWindowsNT()&#123;\tOSVERSIONINFOEX osvi;\tZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX));\tosvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\t// osvi.dwPlatformId = VER_PLATFORM_WIN32s;\t// osvi.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;\tosvi.dwPlatformId = VER_PLATFORM_WIN32_NT;\tDWORDLONG conditionMask = 0;\tVER_SET_CONDITION(conditionMask, VER_PLATFORMID, VER_EQUAL);\treturn VerifyVersionInfo(&amp;osvi, VER_PLATFORMID, conditionMask);&#125;","tags":["windows","os"],"categories":["OS","Windows","查询系统信息"]},{"title":"Windows 降权","path":"/OS/Windows/权限与会话/降权/","content":"[toc] 背景说明在服务程序中调用了某一个程序的安装程序，由于权限的问题，这个安装程序也继承了服务的 SYSTEM 权限，导致安装程序与预期不符合。 解决方案最终实现的目标就是在服务中以普通用户的权限去启动安装程序，要以普通用户去启动，就涉及到降权的问题，需要获取用户的信息。在任务管理器详细信息中可以看到，资源管理器是以普通用户的身份启动的，因此可以在服务中以 Explore.exe 的权限去调用安装程序。 实现逻辑此逻辑也可以用于解决 UAC 弹窗的问题。 获取token 通过token获取用户的会话ID 通过token和ID启动进程 代码接口最终调用的接口为： CreateProcessAsUser 12345678910111213141516int ExecutePackage(LPCSTR pszPath, LPCSTR pszParams)&#123;\tif (nullptr == pszPath) return -1;\twstring szPath = stringToWstring(pszPath);\twstring szParams;\tif (pszParams)\t&#123; szParams = stringToWstring(pszParams);\t&#125;\tCreateProcessWithAdmin(szPath.c_str(), szParams.c_str());\treturn 0;&#125; 实现实现如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** @fn * @brief CreateProcessWithAdmin* @param[in] * strpath： 程序路径* strParams: 程序执行命令* @param[out] * @return * * @detail */bool CreateProcessWithAdmin(LPCWSTR lpExePath, LPCWSTR lpParam)&#123; HANDLE hExplorerToken = GetExplorerToken(); HANDLE hTokenDup = NULL; LPVOID pEnvironment = nullptr; bool res&#123; false &#125;; char\tszErr[256] = &#123; 0 &#125;; int iErrCode = 0; do &#123; if (hExplorerToken == NULL) &#123; iErrCode = GetLastError(); break; &#125; // 复制令牌,把调用方有效的所有访问权限给复制后的令牌. DWORD dwReturnBytes = 0; DWORD dwReturnLen = 0; DWORD dwTokenSessionId = 0; // 通过token获取sessionId if (::GetTokenInformation(hExplorerToken, TokenSessionId, &amp;dwTokenSessionId, sizeof(DWORD), &amp;dwReturnLen) == FALSE) &#123; break; &#125; // 通过 SessionId 和 Token运行程序- res = _CreateProcessAsSystemBySession(lpExePath, lpParam, NULL, dwTokenSessionId, hExplorerToken); // 改动如下所示 // 改动 // 判断当前特权token是否已提升，如果已经提升，则直接通过当前的token启动，如果未提升，则通过提升后的token启动+ HANDLE hNewToken = NULL;+ if (GetElevatedToken(hExplorerToken, &amp;hNewToken) &amp;&amp; hNewToken)+ &#123;+ res = CreateProcessByToken(hNewToken, hExplorerToken, lpExePath, lpParam, NULL, FALSE);+ CloseHandle(hNewToken);+ &#125;+ else+ &#123;+ res = CreateProcessAsSystemBySession(lpExePath, lpParam, NULL, dwTokenSessionId, hExplorerToken);+ &#125;+ CloseHandle(hExplorerToken); &#125; while (false); return res;&#125; 判断token是否被提升： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152BOOL IsElevatedToken(HANDLE hToken, PBOOL pbElevated)&#123;\tDWORD dwReturnBytes = 0;\tDWORD dwElevateionType = 0;\tBOOL bElevated = FALSE;\tif (hToken &amp;&amp; pbElevated)\t&#123; if (GetTokenInformation(hToken, TokenElevationType, &amp;dwElevateionType, sizeof(dwElevateionType), &amp;dwReturnBytes)) &#123; if (dwElevateionType == TokenElevationTypeFull) bElevated = TRUE; else if (dwElevateionType == TokenElevationTypeDefault) &#123; TOKEN_ELEVATION te; ZeroMemory(&amp;te, sizeof(te)); if (GetTokenInformation(hToken, TokenElevation, &amp;te, sizeof(te), &amp;dwReturnBytes)) &#123; if (te.TokenIsElevated) bElevated = TRUE; &#125; &#125; &#125; if (pbElevated) *pbElevated = bElevated; return TRUE;\t&#125;\treturn FALSE;&#125;BOOL GetElevatedToken(HANDLE hToken, PHANDLE phNewToken)&#123;\tBOOL bElevated = FALSE;\tIsElevatedToken(hToken, &amp;bElevated);\tif (bElevated)\t&#123; return DuplicateTokenEx(hToken, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, phNewToken);\t&#125;\telse\t&#123; DWORD dwReturnBytes = 0; return GetTokenInformation(hToken, TokenLinkedToken, phNewToken, sizeof(HANDLE), &amp;dwReturnBytes);\t&#125;\treturn FALSE;&#125; 获取资源管理器的 token 1234567891011121314151617181920212223242526272829303132333435363738HANDLE GetExplorerToken()&#123; PromotePrivilege(); HANDLE hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapshot == INVALID_HANDLE_VALUE) &#123; return NULL; &#125; HANDLE hExplorerToken = NULL; PROCESSENTRY32 pe = &#123; 0 &#125;; pe.dwSize = sizeof(pe); BOOL bMore = ::Process32First(hSnapshot, &amp;pe); while (bMore) &#123; if (StrCmpI(L&quot;explorer.exe&quot;, pe.szExeFile) == 0) &#123; HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe.th32ProcessID); if (hProcess == NULL) &#123; continue; &#125; if (OpenProcessToken(hProcess, TOKEN_QUERY, &amp;hExplorerToken)) &#123; CloseHandle(hProcess); break; &#125; &#125; bMore = ::Process32Next(hSnapshot, &amp;pe); &#125; CloseHandle(hSnapshot); return hExplorerToken;&#125; 给本进程特权，以便访问系统进程 123456789101112131415161718192021222324252627282930313233343536373839404142/** @fn PromotePrivilege* @brief 调整进程权限 * * @detail 将进程权限提升成具有调试权限的进程，这个权限应该是进程所能具有的最大权限* 前提启动这个进程的账户必须是一个管理员，否则没法提升*/BOOL PromotePrivilege()&#123; // 附给本进程特权,以便访问系统进程 HANDLE hToken; // 打开一个进程的访问令牌 if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123; // 取得特权名称为&quot;SetDebugPrivilege&quot;的LUID LUID uID; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;uID)) &#123; CloseHandle(hToken); return FALSE; &#125; // 调整特权级别 TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; // 只启动调试权限，所以权限的个数是一个 tp.Privileges[0].Luid = uID; //当Attributes = SE_PRIVILEGE_ENABLE时，激活权限 //当Attributes = 0时，关闭权限 tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; // AdjustTokenPrivileges函数激活或者关闭tp中给定的权限 if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL)) &#123; CloseHandle(hToken); return FALSE; &#125; // 关闭访问令牌句柄 CloseHandle(hToken); return TRUE; &#125; return FALSE;&#125; 设置当前进程的会话信息： 1234567891011121314151617181920212223242526272829bool CreateProcessAsSystemBySession(LPCTSTR pszAppName, LPCTSTR pszCmd, LPCTSTR pszCwd, DWORD dwSession, HANDLE hEnvToken)&#123; if (pszCmd == NULL) return false; bool bRet = false; HANDLE hTokenThis = NULL; bRet = OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE | TOKEN_QUERY, &amp;hTokenThis); if (!bRet || hTokenThis == NULL) return false; HANDLE hTokenDup = NULL; bRet = DuplicateTokenEx(hTokenThis, MAXIMUM_ALLOWED, NULL, SecurityIdentification, TokenPrimary, &amp;hTokenDup); CloseHandle(hTokenThis); if (!bRet || hTokenDup == NULL) return false; if (!SetTokenInformation(hTokenDup, TokenSessionId, &amp;dwSession, sizeof(DWORD))) &#123; CloseHandle(hTokenDup); return false; &#125; bRet = CreateProcessByToken(hTokenDup, hEnvToken, pszAppName, pszCmd, pszCwd, TRUE); CloseHandle(hTokenDup); return bRet;&#125; 调用接口创建进程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566typedef BOOL(STDMETHODCALLTYPE FAR* LPFNCREATEENVIRONMENTBLOCK) (LPVOID* lpEnvironment, HANDLE hToken, BOOL bInherit);typedef BOOL(STDMETHODCALLTYPE FAR* LPFNDESTROYENVIRONMENTBLOCK) (LPVOID lpEnvironment);bool CreateProcessByToken(HANDLE hToken, HANDLE hEnvToken, LPCTSTR pszAppName, LPCTSTR pszCmd, LPCTSTR pszCwd, BOOL bWndHide/* = FALSE*/)&#123; STARTUPINFO si = &#123; sizeof(si) &#125;; PROCESS_INFORMATION pi = &#123; 0 &#125;; si.lpDesktop = (LPWSTR)L&quot;Winsta0\\\\Default&quot;; if (bWndHide) &#123; si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_HIDE; &#125; DWORD dwCreationFlag = NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE; LPVOID pEnvironment = NULL; LPFNCREATEENVIRONMENTBLOCK lpfnCreateEnvironmentBlock = NULL; LPFNDESTROYENVIRONMENTBLOCK lpfnDestroyEnvironmentBlock = NULL; HMODULE hUserEnvLib = NULL; hUserEnvLib = LoadLibrary(L&quot;userenv.dll&quot;); if (NULL != hUserEnvLib) &#123; lpfnCreateEnvironmentBlock = (LPFNCREATEENVIRONMENTBLOCK)GetProcAddress(hUserEnvLib, &quot;CreateEnvironmentBlock&quot;); lpfnDestroyEnvironmentBlock = (LPFNDESTROYENVIRONMENTBLOCK)GetProcAddress(hUserEnvLib, &quot;DestroyEnvironmentBlock&quot;); &#125; if (NULL != lpfnCreateEnvironmentBlock) &#123; if (lpfnCreateEnvironmentBlock(&amp;pEnvironment, hEnvToken, FALSE)) &#123; dwCreationFlag |= CREATE_UNICODE_ENVIRONMENT; // must specify &#125; else pEnvironment = NULL; &#125; bool bRet = false; BOOL bDisableRedirect = FALSE; if (CreateProcessAsUser(hToken, pszAppName, (LPTSTR)pszCmd, NULL, NULL, FALSE, dwCreationFlag, pEnvironment, pszCwd, &amp;si, &amp;pi)) &#123; CloseHandle(pi.hThread); DWORD dwRet = WaitForSingleObject(pi.hProcess, 2 * 60 * 60 * 1000); if (WAIT_TIMEOUT == dwRet) &#123; &#125; else if (WAIT_OBJECT_0 == dwRet) &#123; bRet = true; &#125; CloseHandle(pi.hProcess); &#125; if (NULL != lpfnDestroyEnvironmentBlock) lpfnDestroyEnvironmentBlock(pEnvironment); if (NULL != hUserEnvLib) FreeLibrary(hUserEnvLib); return bRet;&#125;","tags":["Windows","权限"],"categories":["OS","Windows","权限与会话"]},{"title":"提权","path":"/OS/Windows/权限与会话/提权/","content":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273BOOL EnablePrivilege(LPCTSTR lpszPrivilegeName, BOOL bEnable)&#123; int nResult = FALSE; int nRetCode = FALSE; HANDLE hToken = NULL; TOKEN_PRIVILEGES tkp = &#123; 0 &#125;; do &#123; nRetCode = ::OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken); if (!nRetCode) break; nRetCode = ::LookupPrivilegeValue(NULL, lpszPrivilegeName, &amp;tkp.Privileges[0].Luid); if (!nRetCode) break; tkp.PrivilegeCount = 1; tkp.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0; nRetCode = ::AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL); if (!nRetCode) break; nResult = TRUE; &#125; while (FALSE); if (hToken != NULL) &#123; CloseHandle(hToken); &#125; return nResult;&#125;HANDLE GetExplorerToken()&#123; EnablePrivilege(SE_DEBUG_NAME, TRUE); HANDLE hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapshot == INVALID_HANDLE_VALUE) &#123; return NULL; &#125; HANDLE hExplorerToken = NULL; PROCESSENTRY32 pe = &#123; 0 &#125;; pe.dwSize = sizeof(pe); BOOL bMore = ::Process32First(hSnapshot, &amp;pe); while (bMore) &#123; if (_tcsicmp(&quot;explorer.exe&quot;, pe.szExeFile) == 0) &#123; HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe.th32ProcessID); if (hProcess == NULL) &#123; continue; &#125; if (OpenProcessToken(hProcess, TOKEN_QUERY, &amp;hExplorerToken)) &#123; CloseHandle(hProcess); break; &#125; CloseHandle(hProcess); &#125; bMore = ::Process32Next(hSnapshot, &amp;pe); &#125; CloseHandle(hSnapshot); return hExplorerToken;&#125; 使用1234567891011HANDLE hExplorerToken = GetExplorerToken();if (hExplorerToken == NULL) break;char szUserProfilePath[MAX_PATH] = &#123; 0 &#125;;DWORD cchSize = MAX_PATH;if (!GetUserProfileDirectoryA(hExplorerToken, szUserProfilePath, &amp;cchSize))&#123; CloseHandle(hExplorerToken); break;&#125;","categories":["OS","Windows","权限与会话"]},{"title":"提权工具 psExec.exe","path":"/OS/Windows/权限与会话/提权工具/","content":"使用方法： 1psexec -i -d -s cmd.exe # 就是提权运行cmd","categories":["OS","Windows","权限与会话"]},{"title":"服务中以管理员\\普通权限启动进程","path":"/OS/Windows/权限与会话/权限与会话/","content":"管理员权限启动进程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 管理员权限启动进程#ifdef UNICODEMMSYSSHARED_EXPORT bool CreateProcessWithAdmin(const std::wstring&amp; exe, const std::wstring&amp; param, bool show)#elseMMSYSSHARED_EXPORT bool CreateProcessWithAdmin(const std::string&amp; exe, const std::string&amp; param, bool show)#endif // UNICODE&#123; HANDLE hToken&#123; NULL &#125;; HANDLE hTokenDup&#123; NULL &#125;; LPVOID pEnvironment&#123; NULL &#125;; bool res&#123; false &#125;;#ifdef UNICODE wchar_t* cmd = (wchar_t*)param.c_str();#else char* cmd = (wchar_t*)param.c_str();#endif do &#123; if (exe.empty()) &#123; LOG_ERROR(&quot;exe is null!&quot;); break; &#125; if (!GetTokenWithProcessName(L&quot;explorer.exe&quot;, hToken)) &#123; LOG_ERROR(&quot;GetTokenWithProcessName Error: %u&quot;, GetLastError()); break; &#125; // 复制令牌,把调用方有效的所有访问权限给复制后的令牌. if (!DuplicateTokenEx(hToken, MAXIMUM_ALLOWED/*TOKEN_ALL_ACCESS*/, NULL/*&amp;sa*/, SecurityImpersonation, TokenPrimary, &amp;hTokenDup)) &#123; LOG_ERROR(&quot;DuplicateTokenEx Error: %u&quot;, GetLastError()); break; &#125; STARTUPINFO si; ZeroMemory(&amp;si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO);#ifdef UNICODE wchar_t desk[]&#123; TEXT(&quot;WinSta0\\\\Default&quot;) &#125;;#else char desk[]&#123; TEXT(&quot;WinSta0\\\\Default&quot;) &#125;;#endif si.lpDesktop = desk; if (show) &#123; si.wShowWindow = SW_SHOW; &#125; else &#123; si.wShowWindow = SW_HIDE; &#125; si.dwFlags = STARTF_USESHOWWINDOW; PROCESS_INFORMATION pi; // 检索指定用户的环境变量。然后，可以将此块传递给 CreateProcessAsUser 函数。 if (!CreateEnvironmentBlock(&amp;pEnvironment, hTokenDup, FALSE)) &#123; LOG_ERROR(&quot;CreateEnvironmentBlock Error: %u&quot;, GetLastError()); break; &#125; // 缺少环境变量时某些依赖环境变量的程序打不开，或者运行不正常。 if (!CreateProcessAsUser(hTokenDup, exe.c_str(), cmd, NULL, NULL, FALSE , NORMAL_PRIORITY_CLASS /*| CREATE_NEW_CONSOLE */ | CREATE_UNICODE_ENVIRONMENT , pEnvironment, NULL, &amp;si, &amp;pi)) &#123; LOG_ERROR(&quot;CreateProcessAsUser Error: %u&quot;, GetLastError()); break; &#125; res = true; &#125; while (0); // 清理 if (cmd) &#123; delete[]cmd; &#125; if (pEnvironment) &#123; DestroyEnvironmentBlock(pEnvironment); &#125; if(hToken) CloseHandle(hToken); if (hTokenDup) CloseHandle(hTokenDup); return res;&#125; 普通用户权限启动进程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 普通用户权限启动进程#ifdef UNICODEbool CreateProcessWithUser(const std::wstring&amp; exePath, const std::wstring&amp; param, bool show)#elsebool CreateProcessWithUser(const std::string&amp; exePath, const std::string&amp; param, bool show)#endif // UNICODE&#123; HANDLE hToken = 0; HANDLE hNewToken = 0; LPVOID pEnvironment&#123; NULL &#125;; bool res&#123; false &#125;; int l = param.length();#ifdef UNICODE wchar_t* cmd = new wchar_t[l + 1]; memcpy(cmd, param.c_str(), l * sizeof(wchar_t)); cmd[l] = 0;#else char* cmd = new char[l + 1]; memcpy(cmd, param.c_str(), l * sizeof(char)); cmd[l] = 0;#endif // UNICODE do &#123; if (!GetTokenWithProcessName(L&quot;explorer.exe&quot;, hToken)) &#123; LOG_ERROR(&quot;GetTokenWithProcessName Error: %u&quot;, GetLastError()); break; &#125; if (!DuplicateTokenEx(hToken, TOKEN_ALL_ACCESS, NULL/*&amp;sa*/, SECURITY_MAX_IMPERSONATION_LEVEL, TokenPrimary, &amp;hNewToken)) &#123; LOG_ERROR(&quot;DuplicateTokenEx Error: %u&quot;, GetLastError()); break; &#125; DWORD dwCreationFlag = NORMAL_PRIORITY_CLASS /*| CREATE_NEW_CONSOLE*/ | CREATE_UNICODE_ENVIRONMENT; // 检索指定用户的环境变量。然后，可以将此块传递给 CreateProcessAsUser 函数。 if (!CreateEnvironmentBlock(&amp;pEnvironment, hNewToken, FALSE)) &#123; LOG_ERROR(&quot;CreateEnvironmentBlock Error: %u&quot;, GetLastError()); break; &#125; STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO);#ifdef UNICODE wchar_t desktop[] = L&quot;winsta0\\\\default&quot;;#else char desktop[] = &quot;winsta0\\\\default&quot;;#endif si.lpDesktop = desktop; si.dwFlags = STARTF_USESHOWWINDOW; if (show) &#123; si.wShowWindow = SW_SHOW; &#125; else &#123; si.wShowWindow = SW_HIDE; &#125; if (!CreateProcessAsUser(hNewToken, exePath.c_str(), cmd, 0, 0, FALSE, dwCreationFlag, pEnvironment, 0, &amp;si, &amp;pi)) &#123;#ifdef UNICODE std::string ansicmd = mm::Charset::UnicodeToANSI(cmd); std::string ansibat = mm::Charset::UnicodeToANSI(exePath.c_str()); LOG_ERROR(&quot;CreateProcessAsUser error! LastError=%ld, %s, %s&quot;, GetLastError(), ansibat.c_str(), ansicmd.c_str());#else LOG_ERROR(&quot;CreateProcessAsUser error! LastError=%ld, %s, %s&quot;, GetLastError(), exePath.c_str(), cmd.c_str());#endif // UNICODE break; &#125; res = true; &#125; while (0); // 清理 delete[] cmd; if (hToken) &#123; CloseHandle(hToken); &#125; if (hNewToken) &#123; CloseHandle(hNewToken); &#125; if (pEnvironment) &#123; DestroyEnvironmentBlock(pEnvironment); &#125; return res;&#125; 根据名字查找进程句柄123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#ifdef UNICODE bool GetTokenWithProcessName(const wchar_t* szName, HANDLE&amp; hToken)#else bool GetTokenWithProcessName(const char* szName, HANDLE&amp; hToken)#endif // _DEBUG &#123; // HANDLE hToken&#123; NULL &#125;; HANDLE hProcessSnap&#123; NULL &#125;; PROCESSENTRY32 pe32&#123; NULL &#125;; HANDLE hProcess&#123; NULL &#125;; bool res&#123; false &#125;; do &#123; // 多用户模式时任务管理器里可能出现多个explorer // 需要先获取当前会话ID，再通过枚举进程，通过比较sessionID进而得到token。 //DWORD dwSessionId = WTSGetActiveConsoleSessionId(); //PWTS_PROCESS_INFO ppi = NULL; //DWORD dwProcessCount = 0; //if (WTSEnumerateProcesses(WTS_CURRENT_SERVER_HANDLE, 0, 1, &amp;ppi, &amp;dwProcessCount)) //&#123; // for (int i = 0; i &lt; dwProcessCount; i++) // &#123; // if (_wcsicmp(ppi[i].pProcessName, L&quot;explorer.exe&quot;) == 0) // &#123; // if (ppi[i].SessionId == dwSessionId) // &#123; // break; // &#125; // &#125; // &#125; // WTSFreeMemory(ppi); //&#125; hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (!hProcessSnap) &#123; LOG_ERROR(&quot;CreateToolhelp32Snapshot error! %d&quot;, GetLastError()); break; &#125; pe32.dwSize = sizeof(PROCESSENTRY32); for (Process32First(hProcessSnap, &amp;pe32); Process32Next(hProcessSnap, &amp;pe32);) &#123;#ifdef UNICODE if (_wcsicmp((pe32.szExeFile), szName))#else if (_stricmp((pe32.szExeFile), szName))#endif // _DEBUG continue; hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe32.th32ProcessID); if (!hProcess) &#123; LOG_ERROR(&quot;OpenProcess error! %d&quot;, GetLastError()); break; &#125; BOOL ret = OpenProcessToken(hProcess, TOKEN_ALL_ACCESS, &amp;hToken); if(!ret) &#123; LOG_ERROR(&quot;OpenProcess error! %d&quot;, GetLastError()); break; &#125; res = true; break; &#125; &#125; while (0); if (hProcessSnap) &#123; CloseHandle(hProcessSnap); &#125; if (hProcess) &#123; CloseHandle(hProcess); &#125; return res; &#125;","tags":["windows","权限","会话"],"categories":["OS","Windows","权限与会话"]},{"title":"windows 安全基线检查项","path":"/OS/Windows/安全基线/安全基线检查项/","content":"[toc] 系统配置安全检查1. 身份鉴别1.1 密码最长使用期限内容描述： 此策略使管理员能够通过确保旧密码不被连续重新使用来增强安全性。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为90或较少的天数，但不是0 ：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\密码最长使用期限。 注意： 域账户需要联系域管理员做对应修改。 1.2 密码最短使用期限内容描述： 此策略设置定义用户密码必须使用多长时间。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为1或更大天：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\密码最短使用期限。 注意： 域账户需要联系域管理员做对应修改。 1.3 强制密码历史内容描述： 此策略使管理员能够通过确保旧密码不被连续重新使用来增强安全性。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为24或更多密码：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\强制执行密码历史。 注意： 域账户需要联系域管理员做对应修改。 1.4 密码长度最小值内容描述： 密码长度最小值越大，暴力破解难度就越高。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为14或更多字符：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\密码长度最小值。 注意： 域账户需要联系域管理员做对应修改。 1.5 密码必须符合复杂性要求内容描述： 如果启用此策略，密码必须符合下列最低要求： 不包含用户的帐户名或用户全名中超过两个的部分连续字符 至少六个字符 包含以下三个类别的字符： 英文大写字母（A到Z） 英文小写字母（a到z） 以10为基数的数字（0到9） 非字母字符（例如，！，$，＃，％） 不属于以下任何Unicode字符的全部类别前四个类别。第五类可以是区域特定的。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为启用：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\密码必须符合复杂性要求。 注意： 域账户需要联系域管理员做对应修改。 1.6 用可还原的加密来储存密码内容描述： 通过远程访问或 Internet 身份验证服务(IAS)使用质询握手身份验证协议(CHAP)验证时需要设置此策略。在 Internet 信息服务(IIS)中使用摘要式身份验证时也需要设置此策略。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为禁用：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\用可还原的加密来储存密码。 注意： 域账户需要联系域管理员做对应修改。 1.7 阻止Microsoft帐户内容描述： 此策略设置阻止用户在此计算机上添加新的 Microsoft 帐户。 如果选择“用户不能添加 Microsoft 帐户”选项，用户将不能在此计算机上创建新的 Microsoft 帐户，不能将本地帐户切换到 Microsoft 帐户，也不能将域帐户连接到 Microsoft 帐户。如果需要在企业中限制使用 Microsoft 帐户，这是首选选项。 如果选择“用户不能添加 Microsoft 帐户或使用该帐户登录”选项，则现有的 Microsoft 帐户用户将不能登录到 Windows。选中此选项后，此计算机上的现有管理员可能无法登录和管理系统。 如果禁用或不配置此策略(推荐)，则用户能够将 Microsoft 帐户用于 Windows。 加固建议： Windows10&#x2F;8：请将以下UI路径设置为用户不能添加 Microsoft 帐户或使用该帐户登录：计算机配置\\Windows设置\\安全设置\\本地策略\\安全选项\\帐户：阻止Microsoft帐户。 1.8 帐户锁定阈值内容描述： 此安全设置确定导致用户帐户被锁定的登录尝试失败的次数。在管理员重置锁定帐户或帐户锁定时间期满之前，无法使用该锁定帐户。可以将登录尝试失败次数设置为介于 0 和 999 之间的值。如果将值设置为 0，则永远不会锁定帐户。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为10或较少的无效登录尝试，但不是0 ：计算机配置\\Windows设置\\安全设置\\本地策略\\安全选项\\交互式登录：计算机帐户锁定阈值。 注意： 域账户需要联系域管理员做对应修改。 1.9 帐户锁定持续时间内容描述： 此策略设置确定锁定帐户之前必须经过的时间长度解锁，用户可以尝试再次登录。该设置通过指定数字来实现锁定的帐户将在几分钟之内不可用。如果此策略设置的值配置为0，锁定的帐户将保持锁定状态，直到管理员手动解锁。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为1或更多分钟：计算机配置\\Windows设置\\安全设置\\帐户策略\\帐户锁定策略\\帐户锁定持续时间。 注意： 如果定义了帐户锁定阈值，则帐户锁定时间必须大于或等于重置时间。只有在指定了帐户锁定阈值时，此策略设置才有意义。 1.10 重置账号锁定计数器内容描述： 此安全设置确定在某次登录尝试失败之后将登录尝试失败计数器重置为 0 次错误登录尝试之前需要的时间。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\Windows设置\\安全设置\\帐户策略\\帐户锁定策略\\重置帐户锁定计数器后。 注意： 如果定义了帐户锁定阈值，此重置时间必须小于或等于帐户锁定时间。只有在指定了帐户锁定阈值时，此策略设置才有意义。 1.11 启用屏幕保护程序内容描述： 确保终端在不活动的状态下，超过一定时间后会自动进入屏幕保护状态。防止终端盗用。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为启用：用户配置\\管理模板\\控制面板\\个性化\\启用屏幕保护程序 注意： 默认情况下，此组策略路径可能不存在。 它由Microsoft Windows 7和Server 2008 R2管理模板（或更新版本）附带的组策略模板ControlPanelDisplay.admx &#x2F; adml提供。 2. 访问控制2.1 Guest 帐户状态内容描述： 此安全设置确定是启用还是禁用来宾帐户。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为“已禁用”：我的电脑\\右键\\管理\\计算机管理（本地）&#x2F;本地用户和组&#x2F;用户&#x2F; Guest属性&#x2F;账户已禁用。 注意： 如果来宾帐户被禁用且安全选项“网络访问: 本地帐户的共享和安全模型”被设置为“仅来宾”，则网络登录(如由 Microsoft 网络服务器(SMB 服务)所执行的网络登录)将失败。 2.2 使用空密码的本地帐户只允许进行控制台登录内容描述： 此安全设置确定未进行密码保护的本地帐户是否可以用于从物理计算机控制台之外的位置登录。如果启用此设置，则未进行密码保护的本地帐户将仅能够通过计算机的键盘登录。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为已启用：计算机配置\\Windows设置\\安全设置\\本地策略\\安全选项\\帐户：使用空密码的本地帐户只允许进行控制台登录。 注意： 1、此设置不影响使用域帐户的登录。 2、使用远程交互式登录的应用程序可以绕过此设置。 3、在以前版本的 Windows Server 中，远程桌面服务称为终端服务。 2.3 帐户: 重命名来宾帐户内容描述： 此安全设置确定是否存在另一个帐户名称与帐户 “Guest” 的安全标识符(SID)相关联。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\安全选项\\帐户: 重命名来宾帐户 2.4 帐户: 重命名管理员帐户内容描述： 此安全设置确定是否存在另一个帐户名称与帐户 Administrator 的安全标识符(SID)相关联。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\安全选项\\帐户: 重命名管理员帐户 2.5 交互式登录: 提示用户在密码过期之前更改密码内容描述： 确定提前多长时间(以天为单位)向用户发出其密码即将过期的警告。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\安全选项\\交互式登录: 提示用户在密码过期之前更改密码。 2.6 交互式登录: 不显示上次登录内容描述： 该安全设置确定 Windows 登录屏幕是否将显示上次登录该台电脑的人员的用户名，如果启用该策略，将不显示用户名。如果禁用该策略，将显示用户名。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\安全选项\\交互式登录: 不显示上次登录。 2.7 关机: 清除虚拟内存页面文件内容描述： 启用此策略会在干净关机时清除系统页面文件。启用此安全选项时，如果禁用休眠，休眠文件(hiberfil.sys)也会被清零。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\安全选项\\关机: 清除虚拟内存页面文件。 2.8 操作系统UAC用户账户控制是否开启至指定级别内容描述： 用户账户控制有助于预防有害程序对你的计算机进行更改。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：控制面板\\用户账户\\更改用户账户控制设置。 2.9 允许Windows自动连接到建议的开放式热点，与联系人共享的网络以及提供付费服务的热点内容描述： 此策略设置确定用户是否可以启用以下 WLAN 设置:“连接到建议的开放热点”、“连接到我的联系人共享的网络”和“启用付费服务”。 加固建议： Windows10&#x2F;8：请将以下UI路径设置为“已禁用”：计算机配置\\管理模板\\网络\\WLAN服务\\WLAN设置\\允许Windows自动连接到建议的开放热点，联系人共享的网络以及提供付费服务的热点 注意： 默认情况下，此组策略路径可能不存在。 它由Microsoft Windows 10版本1511管理模板（或更新版本）附带的组策略模板wlansvc.admx &#x2F; adml提供。 2.10 允许用户通过使用远程桌面服务进行远程连接内容描述： 使用此策略设置，可以通过使用远程桌面服务配置对计算机的远程访问。 如果启用此策略设置，则目标计算机上的“远程桌面用户”组成员用户可以使用远程桌面服务远程连接到该目标计算机。 如果禁用此策略设置，则用户无法使用远程桌面服务远程连接到目标计算机。目标计算机将保持当前的所有连接，但不会接受任何新传入的连接。 如果未配置此策略设置，则远程桌面服务使用目标计算机上的“远程桌面”设置来确定是否允许远程连接。此设置位于“系统属性”表的“远程”选项卡上。默认情况下，不允许进行远程连接。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为“已禁用”：计算机配置\\管理模板\\Windows组件\\远程桌面服务\\远程桌面会话主机\\连接\\允许用户使用远程桌面服务进行远程连接。 Windows XP：计算机配置\\管理模板\\Windows组件\\终端服务\\允许用户使用远程终端服务远程连接。 注意： 1、此组策略路径由所有版本的Microsoft Windows管理模板附带的组策略模板TerminalServer.admx &#x2F; adml提供。 2、在较旧的Microsoft Windows管理模板中，此设置最初名为Windows 7＆Server 2008 R2管理模板中的“允许用户使用终端服务远程连接”，但在“ Windows 7＆Server 2008 R2管理模板”中已重命名为“允许用户使用远程桌面服务远程连接”。最终，它再次被重命名为“允许用户使用从Windows 8.0＆Server 2012（非R2）管理模板开始的远程桌面服务”进行远程连接。 2.11 管理员帐户状态内容描述： 此安全设置确定是启用还是禁用本地管理员帐户。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：已禁用：我的电脑\\右键\\管理\\计算机管理（本地）\\本地用户和组\\用户\\Administrator属性\\账户已禁用。 注意： 如果在管理员帐户被禁用之后试图重新启用它，且如果当前管理员密码不符合密码要求，则无法重新启用该帐户。在这种情况下，Administrators 组的某个备用成员必须重置管理员帐户上的密码。有关如何重置密码的信息，请参阅“重置密码”。 在某些环境下，禁用管理员帐户会成为一个维护问题。 在安全模式启动下，禁用的管理员帐户仅在该计算机未加入域并且没有任何其他本地活动管理员帐户时才可以启用。如果计算机加入了域，将不能启用禁用的管理员。 2.12 允许ICMP重定向覆盖OSPF生成的路由内容描述： Internet控制消息协议（ICMP）重定向导致堆栈检测主机路由。 这些路由会覆盖“开放式最短路径优先”（OSPF）生成的路由。 对于企业环境，建议将此设置配置为“未定义”，对于高安全性环境，建议配置为“禁用”。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为“已禁用”：计算机配置\\管理模板\\MSS（传统）\\MSS：（EnableICMPRedirect）允许ICMP重定向覆盖OSPF生成的路由。 注意： 默认情况下，此组策略路径不存在。 需要附加的组策略模板（MSS-legacy.admx &#x2F; adml）-可从此TechNet博客文章中获得：MSS设置-Microsoft安全指南博客。 2.13 检查是否关闭了默认共享内容描述： 检查是否关闭了系统默认共享，未关闭将检查不通过。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：“禁用”。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\server；（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 2.14 设置活动但空闲的远程桌面服务会话的时间限制内容描述： 使用此策略设置可以指定活动的远程桌面服务会话在自动断开连接之前可以保持空闲状态(无用户输入)的最长时间。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为“启用”：计算机配置\\管理模板\\Windows组件\\远程桌面服务\\远程桌面会话主机\\会话时间限制\\设置活动但空闲的远程桌面服务会话的时间限制。 注意： “计算机配置”和“用户配置”中都有此策略设置。如果同时配置了这两个策略设置，则将优先考虑“计算机配置”策略设置。 2.15 TCP&#x2F;IP筛选内容描述： 允许您连接到您的Windows计算机的TCP&#x2F;IP网络流量类型。 加固建议： 网上邻居\\属性\\本地连接右键属性\\ Internet协议（TCP&#x2F;IP)\\属性\\高级\\选项\\TCP&#x2F;IP筛选\\属性\\启动TCP&#x2F;IP筛选的功能 3. 资源控制3.1 Remote Access Auto Connection Manager (RasAuto)内容描述： 每当程序引用远程DNS或NetBIOS名称或地址时，都会创建到远程网络的连接。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：“禁用”。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Access Auto Connection Manager；（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.2 Remote Desktop Services (TermService)内容描述： 允许用户以交互方式连接到远程计算机。 远程桌面和远程桌面会话主机服务器取决于此服务。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Desktop Services。（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.3 Remote Procedure Call (RPC) Locator (RpcLocator)内容描述： 在Windows 2003和Windows的早期版本中，远程过程调用（RPC）定位器服务管理RPC名称服务数据库。 在Windows Vista和Windows的更高版本中，此服务不提供任何功能，并且提供此功能是为了与应用程序兼容。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Procedure Call (RPC) Locator (RpcLocator)。（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.4 Remote Registry (RemoteRegistry)内容描述： 在Windows 2003和Windows的早期版本中，远程过程调用（RPC）定位器服务管理RPC名称服务数据库。 在Windows Vista和Windows的更高版本中，此服务不提供任何功能，并且提供此功能是为了与应用程序兼容。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Registry（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.5 Remote Desktop Configuration (SessionEnv)内容描述： 远程桌面配置服务（RDCS）负责所有需要SYSTEM上下文的与远程桌面相关的配置和会话维护活动。 其中包括每个会话的临时文件夹，RD主题和RD证书。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Desktop Configuration。（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.6 Remote Desktop Services UserMode Port Redirector (UmRdpService)内容描述： 允许重定向打印机&#x2F;驱动器&#x2F;端口以进行RDP连接。 加固建议： helpDocument.baseline.checkItems.1037.suggest 注意： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Desktop Services UserMode Port Redirector。（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.7 Telnet服务器内容描述： 提供网络访问的服务是一个攻击用的很好的渠道，在没有必要的情况下建议关闭。 加固建议： Windows8&#x2F;7&#x2F;XP：请将以下UI路径设置为：我的电脑鼠标右键“管理”\\打开计算机管理\\服务和应用程序\\Telnet。 注意： 如何验证telnet服务是否真的关闭了？使用快捷键win键+r，输入cmd，点击【确定】。输入telnet +IP地址（例如：telnet 192.168.1.1），回车，提示telnet不是内部或外部命令，也不是可运行的程序或批处理文件。说明已经禁止telnet。 3.8 IE受信任站点检查内容描述： 检查对应站点是否加入IE受信任站点。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：通过以下UI路径设置为：已启用。计算机配置\\管理模板\\Windows组件\\Internet Explorer\\Internet 控制面板\\安全页\\站点到区域分配列表。 3.9 Routing And Remote Access (RemoteAccess)内容描述： 为局域网和广域网环境中的企业提供路由服务。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Routing and Remote Access（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.10 Windows Event Log内容描述： 此服务管理事件和事件日志。它支持日志记录事件、查询事件、订阅事件、归档事件日志以及管理事件元数据。它可以用 XML 和纯文本两种格式显示事件。停止该服务可能危及系统的安全性和可靠性。 加固建议： Windows10&#x2F;8&#x2F;7：控制面板\\系统和安全\\管理工具\\服务\\Windows Event Log 3.11 专用配置文件的:防火墙状态内容描述： 指定将计算机连接到专用网络位置时的行为。 加固建议： Windows10&#x2F;8&#x2F;7：计算机配置\\ Windows设置\\安全设置\\高级安全Windows Defender防火墙\\高级安全Windows Defender防火墙-本地组策略对象\\Windows Defender防火墙属性\\专用配置文件\\防火墙状态 3.12 公用配置文件的:防火墙状态内容描述： 指定将计算机连接到专用网络位置时的行为。 加固建议： Windows10&#x2F;8&#x2F;7：计算机配置\\ Windows设置\\安全设置\\高级安全Windows Defender防火墙\\高级安全Windows Defender防火墙-本地组策略对象\\Windows Defender防火墙属性\\公用配置文件\\防火墙状态 3.13 公用配置文件的:应用本地防火墙规则内容描述： 指定将计算机连接到专用网络位置时的行为。 加固建议： Windows10&#x2F;8&#x2F;7：计算机配置\\ Windows设置\\安全设置\\高级安全Windows Defender防火墙\\高级安全Windows Defender防火墙-本地组策略对象\\Windows Defender防火墙属性\\公用配置文件\\指定Windows Defender防火墙行为的设置-自定义\\应用本地防火墙规则设置为否 3.14 Windows防火墙检查（仅针对Xp系统）内容描述： 检查防火墙启用状态。 加固建议： 请按以下路径配置：防火墙状态。若您购买的奇安信终端安全管理系统已授权模块包含“主机防火墙”，您可在主机防火墙模块完成防火墙的状态调整。奇安信终端安全管理系统授权模块不包含 “主机防火墙”，您可按照以下路径下配置：控制面板\\系统和安全\\Windows Defender 防火墙\\自定义设置。 4. 安全审计4.1 审核登录内容描述： 此策略设置允许你审核由计算机上的用户帐户登录尝试所生成的事件。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为：成功和失败。计算机配置\\Windows设置\\安全设置\\高级审核策略配置\\系统审核策略\\登录&#x2F;注销\\审核登录。 4.2 审核其他登录&#x2F;注销事件内容描述： 此策略设置允许你审核“登录&#x2F;注销”策略设置未涵盖的其他登录&#x2F;注销相关事件，例如: 终端服务会话断开连接。 新建终端服务会话。 锁定和解锁工作站。 调用屏幕保护程序。 解除屏幕保护程序。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为成功和失败：计算机配置\\Windows设置\\安全设置\\高级审核策略配置\\系统审核策略\\登录&#x2F;注销\\审核其他登录&#x2F;注销事件。 4.3 审核审核策略更改内容描述： 此策略设置允许你审核对安全审核策略设置的更改，例如: 设置审核策略对象上的权限和审核设置。 更改系统审核策略。 注册安全事件源。 注销安全事件源。 更改每用户审核设置。 更改 CrashOnAuditFail 的值。 更改文件系统或注册表对象上的系统访问控制列表。 更改特殊组列表。 加固建议： Windows10&#x2F;8&#x2F;7：请设置以下UI路径以包含成功：计算机配置\\Windows设置\\安全设置\\高级审核策略配置\\系统审核策略\\策略更改\\审核审核策略更改。 注意： 当某个对象的系统访问控制列表(SACL)发生更改并且启用策略更改类别时执行 SACL 更改审核。在启用对象访问审核并且将对象的 SACL 配置为审核 DACL&#x2F;所有者更改时审核自定义访问控制列表(SACL)和所有权更改。 4.4 管理审核和安全日志内容描述： 此安全设置确定哪些用户可以为各种资源(如文件、Active Directory 对象和注册表项)指定对象访问审核选项。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\用户权限分配\\管理审核和安全日志 4.5 审核帐户锁定内容描述： 此策略设置允许你审核由尝试登录到已锁定帐户失败而生成的事件。 加固建议： Windows10&#x2F;8&#x2F;7：计算机配置\\ Windows设置\\安全设置\\高级审核策略配置\\系统审核策略\\登录&#x2F;注销\\审核账户锁定 \\5. 入侵防范 5.1 关闭自动播放内容描述： 此策略可防止可移动存储设备连接到计算机后，恶意软件会自动运行起来。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F; vista：请将以下UI路径设置为：已启用所有驱动器：计算机配置\\管理模板\\Windows组件\\自动播放策略\\关闭自动播放。 注意： “计算机配置”和“用户配置”文件夹中都存在此策略设置。如果两个策略设置发生冲突，则“计算机配置”中的策略设置优先于“用户配置”中的策略设置。 此组策略路径由Microsoft Windows管理模板的所有版本附带的组策略模板AutoPlay.admx &#x2F; adml提供。 系统状态安全检查1 补丁检查内容描述： 是否安装关键和重要系统补丁。 加固建议： 若您购买的奇安信终端安全管理系统已授权模块包含“补丁管理”，您可在补丁管理模块完成补丁修复，若您购买的奇安信终端安全管理系统授权模块不包含“补丁管理”，您可以联系销售来咨询购买事项。 注意： 无“补丁管理”模块，该项检查无结果，系统显示检查异常，但本项不扣除对应分数。 2 防病毒检查内容描述： 检查终端上是否安装了防病毒软件。本地防病毒软件的版本及病毒库是否及时更新。 加固建议： 若您购买的奇安信终端安全管理系统已授权模块包含“软件管家”，您可在软件管家模块完成防病毒软件安装及本地防病毒软件版本更新。若您购买的奇安信终端安全管理系统授权模块不包含 “软件管家”，您可以在对应杀软官网手动下载或联系销售来咨询模块授权购买事项。 3 杀毒软件保护检查内容描述： 检查计算机是否存在杀毒软件保护，存在杀毒软件则检查通过 加固建议： 请在计算机上安装防病毒软件 4 工作组命名检查内容描述： 检查工作组命名规范。 加固建议： 请按以下路径配置：控制面板\\系统和安全\\系统\\计算机名、域和工作组设置\\计算机名\\更改\\工作组 (查看方式为类别) 注意： 请根据管理员设置规范设置工作组名称。 5 域检查内容描述： 检测当前系统是否加入域。 加固建议： 请按以下路径配置：将计算机加入域。控制面板\\系统和安全\\系统\\计算机名、域和工作组设置\\计算机名\\网络ID (查看方式为类别) 注意： 该项与计算机工作组命名二选一 6 计算机命名检查内容描述： 检查计算机命名规范。 加固建议： 请按以下路径配置：控制面板\\系统和安全\\系统\\计算机名、域和工作组设置\\计算机名 (查看方式为类别) 注意： 请根据管理员设置规范设置工作组名称。 7 空口令检查内容描述： 检查操作系统账户密码是否为空口令。 加固建议： 请尽快设置系统账户密码。 8 系统中重要目录对Everyone或Guests来宾账户开放检查内容描述： 检查操作系统中重要目录（C:\\windows\\system和C:\\windows\\system32\\config）是否对Everyone或Guests来宾账户开放。 加固建议： 请取消对Everyone或Guests来宾账户开放操作系统中重要目录（右键\\属性\\安全，查看文件目录对应的组或用户名是否包含Everyone或Guests来宾账户） 9 系统备份还原点检查内容描述： 检查在计算机中是否发现系统备份还原点。 加固建议： 请在系统设置\\系统保护\\配置中设置系统还原点。 10 系统隐藏用户检查内容描述： 检查系统是否存在隐藏的用户。 加固建议： 我的电脑\\右键\\管理\\计算机管理(本地)\\系统工具\\本地用户和组\\用户\\右键删除（名称结尾带$符号的是隐藏用户） 注意： 所谓隐藏账户即为控制面板与开机选择中看不见的账户。它可以用输账号密码的方式进入。 11 操作系统是否开启Hardware DEP Available保护检查内容描述： 检查操作系统是否开启Hardware DEP Available保护 加固建议： 控制面板\\系统和安全\\系统\\高级系统设置\\高级\\性能-设置\\数据执行保护 系统运行安全检查1 进程检查内容描述： 检测进程项是否运行&#x2F;禁止，运行&#x2F;禁止其中任意进程即视为符合规范。 加固建议： 请按以下路径配置：进程启停状态。Ctrl+Alt+Delete\\启动。 2 端口检查内容描述： 端口状态检查。 加固建议： 请检查监听的端口是否符合管理员设置的端口开放要求（可以通过运行CMD并输入命令查看系统正在监听的端口：netstat -ano |findstr “xxx”）。","tags":["windows","安全基线"],"categories":["OS","Windows","安全基线"]},{"title":"关于Windows服务","path":"/OS/Windows/服务/关于windows服务/","content":"[toc] windows服务程序崩溃后自动拉起Windows 操作系统中的服务程序崩溃后自动重新启动是由操作系统的服务控制管理机制决定的。这个机制确保关键的系统服务能够持续运行，即使在发生错误或异常情况下也能够自动进行恢复。 下面是一些可能导致服务程序崩溃后自动重新启动的原因： 服务恢复选项设置：Windows 操作系统提供了服务恢复选项，允许你为每个服务定义特定的恢复行为。这包括启动服务、重新启动服务和采取其他操作，如运行脚本或发送警报。通过配置这些选项，你可以指定服务崩溃后的行为，以实现自动重新启动。 故障回收管理器：Windows 服务控制管理器（SCM）负责监控和管理运行在操作系统中的服务。SCM 包含一个故障回收管理器（Failure Recovery Manager），它会检测服务崩溃事件，并根据预定义的规则自动触发恢复操作。这些规则可以指定在发生故障时自动重新启动服务。 服务依赖关系：在 Windows 系统中，服务可以定义它们所依赖的其他服务。当一个服务崩溃后，如果它的依赖服务还正常运行，那么操作系统会自动重新启动崩溃的服务，以保持整个系统的稳定性和连续性。 需要注意的是，服务程序崩溃后自动拉起并不一定总是适用于所有服务。某些服务可能会配置成在崩溃后停留在错误状态，并等待手动干预或其他特定条件才会重新启动。 总之，Windows 操作系统通过服务控制管理机制来确保关键服务的连续运行，使其具备自动恢复能力。这种行为通过服务恢复选项、故障回收管理器和服务依赖关系等机制来实现。","tags":["windows","windows服务"],"categories":["OS","Windows","服务"]},{"title":"刷新托盘图标","path":"/OS/Windows/刷新托盘图标/","content":"[toc] 背景程序崩溃结束后，创建的系统托盘区图标并不能被刷新掉，重启客户端程序后，托盘区会有两个一样的图标。 解决方案方案一调用以下代码模拟鼠标hover操作遍历系统托盘区图标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#ifdef Q_OS_WIN\t//刷新托盘图标 auto RefreshTrayIcon = []() &#123; //任务栏窗口 HWND hShellTrayWnd = ::FindWindow(L&quot;Shell_TrayWnd&quot;, NULL); //任务栏右边托盘图标+时间区 HWND hTrayNotifyWnd = ::FindWindowEx(hShellTrayWnd, 0, L&quot;TrayNotifyWnd&quot;, NULL); //不同系统可能有可能没有这层 HWND hSysPager = ::FindWindowEx(hTrayNotifyWnd, 0, L&quot;SysPager&quot;, NULL); //托盘图标窗口 HWND hToolbarWindow32; if (hSysPager) &#123; hToolbarWindow32 = ::FindWindowEx(hSysPager, 0, L&quot;ToolbarWindow32&quot;, NULL); &#125; else &#123; hToolbarWindow32 = ::FindWindowEx(hTrayNotifyWnd, 0, L&quot;ToolbarWindow32&quot;, NULL); &#125; if (hToolbarWindow32) &#123; RECT r; ::GetWindowRect(hToolbarWindow32, &amp;r); int width = r.right - r.left; int height = r.bottom - r.top; int iconWidth = GetSystemMetrics(SM_CXSMICON); // 图标基准宽度 int iconHeight = GetSystemMetrics(SM_CYSMICON); // 图标基准高度 //从任务栏中间从左到右 MOUSEMOVE一遍，所有图标状态会被更新 for (int x = 1; x &lt; width; x+=iconWidth) &#123; for (int y = 1; y &lt; height; y+=iconHeight) &#123; ::SendMessage(hToolbarWindow32, WM_MOUSEMOVE, 0, MAKELPARAM(x, y)); &#125; &#125; &#125; &#125;; // RefreshTrayIcon();#endif // Q_OS_WIN 方案二重新启动进程的时候先删除再创建，但是需要通过添加 uID 和 guidItem 来识别已创建的托盘图标 1234567891011 // 设置 uid 和 guiditemm_nid.uID = GUID_TrayIcon.Data2;if (QSysInfo::WindowsVersion &gt;= QSysInfo::WV_WINDOWS7)&#123;\tm_nid.uFlags |= NIF_GUID;\tm_nid.guidItem = GUID_TrayIcon;&#125; // 删除 Shell_NotifyIcon(NIM_DELETE, &amp;m_nid);","tags":["windows","托盘","tray"],"categories":["OS","Windows"]},{"title":"Win 10/11 通过命令行打开系统设置页面","path":"/OS/Windows/命令行打开系统设置页/","content":"概述: 程序中或者脚本中要打开系统设置界面时，可以使用如下方式和接口 [toc] 使用 Win32 API1::ShellExecute(hWnd, &quot;open&quot;, &quot;ms-settings:about&quot;, ...); KeyBoard Win+R启动命令行Win+R 在输入框直接输入启动的界面命令即可。 Command Line(cmd.exe)1start ms-settings:about 启动说明对照表 Settings page ▾ Uri &#x2F; Setting Name Category About (device name&#x2F;specification) ms-settings:about Windows Access work or school ms-settings:workplace Network Account info (share between apps) ms-settings:privacy-accountinfo Privacy Activation ms-settings:activation Security Activity history (build 17040+) ms-settings:privacy-activityhistory Privacy Adaptive Color Filters Link ms-settings:easeofaccess-colorfilter-adaptivecolorlink Accessibility Airplane mode (wireless&#x2F;bluetooth) ms-settings:network-airplanemode Network Airplane mode (wireless&#x2F;bluetooth) ms-settings:proximity Network App diagnostics (share between apps) ms-settings:privacy-appdiagnostics Privacy App volume and device preferences (1903) ms-settings:apps-volume Audio Apps &amp; features ms-settings:appsfeatures Apps Apps for websites ms-settings:appsforwebsites Apps AutoPlay ms-settings:autoplay Apps Automatic online file downloads ms-settings:privacy-automaticfiledownloads Apps Background apps ms-settings:privacy-backgroundapps Apps Backgrounds ms-settings:personalization-background Customisation Backup ms-settings:backup Storage Battery Saver ms-settings:batterysaver Power Battery Saver - settings ms-settings:batterysaver-settings Power Battery Saver - usage ms-settings:batterysaver-usagedetails Power Bluetooth &amp; Connected Devices ms-settings:bluetooth Network Bluetooth &amp; Connected Devices ms-settings:connecteddevices Network Calendar (share between apps) ms-settings:privacy-calendar Privacy Call history (share between apps) ms-settings:privacy-callhistory Privacy Cellular Network ms-settings:network-cellular Network Clipboard ms-settings:clipboard Apps Closed Captioning ms-settings:easeofaccess-closedcaptioning Accessibility Color Filters (build 17025+) ms-settings:easeofaccess-colorfilter Accessibility Colors ms-settings:personalization-colors ms-settings:colors Customisation Connect to a wireless display ms-settings-connectabledevices:devicediscovery Display Contacts (share between apps) ms-settings:privacy-contacts Privacy Cortana ms-settings:cortana Search Cortana more details ms-settings:cortana-moredetails Search Cortana permissions ms-settings:cortana-permissions Search Data Sense ms-settings:datausage Storage Date &amp; Time ms-settings:dateandtime Region &amp; Language Default Save Locations ms-settings:savelocations Storage Default apps ms-settings:defaultapps Apps Delivery Optimization ms-settings:delivery-optimization Windows Device Encryption (where available) ms-settings:deviceencryption Security Dial-up Network ms-settings:network-dialup Network DirectAccess ms-settings:network-directaccess Network Display ms-settings:display Display Display Screen rotation ms-settings:screenrotation Display Display Text scaling (build 17025+) ms-settings:easeofaccess-display Accessibility Document Library (share between apps) ms-settings:privacy-documents Privacy Download maps ms-settings:maps-downloadmaps Apps Dynamic Lock ms-settings:signinoptions-dynamiclock Security Ease of Access Audio (build 17035+) ms-settings:easeofaccess-audio Accessibility Edge web browser microsoft-edge:url Apps Email &amp; app accounts ms-settings:emailandaccounts Security Email (share between apps) ms-settings:privacy-email Privacy Ethernet Network ms-settings:network-ethernet Network Eye Control (build 17035+) ms-settings:easeofaccess-eyecontrol Accessibility Eye tracker (requires eyetracker hardware) ms-settings:privacy-eyetracker Privacy Family &amp; other users ms-settings:family-group Security Family &amp; other users ms-settings:otherusers Security Feedback &amp; diagnostics (privacy) ms-settings:privacy-feedback Security File System (share between apps) ms-settings:privacy-broadfilesystemaccess Privacy Find My Device ms-settings:findmydevice Security Focus assist (build 17074+) ms-settings:quiethoursOR ms-settings:quietmomentshome Apps Fonts (build 17083+) ms-settings:fonts Customisation For developers ms-settings:developers Apps Graphics Advanced scaling settings ms-settings:display-advanced Display Graphics performance preference ms-settings:display-advancedgraphics Display High Contrast ms-settings:easeofaccess-highcontrast Accessibility Home page for Settings ms-settings: Windows Keyboard ms-settings:easeofaccess-keyboard Devices Location (share between apps) ms-settings:privacy-location Privacy Lock screen ms-settings:lockscreen Security Magnifier ms-settings:easeofaccess-magnifier Accessibility Manage known Wi-Fi ms-settings:network-wifisettings Network Manage sound devices (disable&#x2F;test) ms-settings:sound-devices Audio Messaging (share between apps) ms-settings:privacy-messaging Privacy Microphone (share between apps) ms-settings:privacy-microphone Privacy Mobile Hotspot ms-settings:network-mobilehotspot Network Motion (share between apps) ms-settings:privacy-motion Privacy Mouse ms-settings:easeofaccess-mouse Accessibility Mouse &amp; Touchpad Devices ms-settings:mousetouchpad Devices Mouse Pointer (Cursor &amp; pointer, build 17040+) ms-settings:easeofaccess-cursorandpointersize Accessibility Mouse Pointer (Cursor &amp; pointer, build 17040+) ms-settings:easeofaccess-mousepointer Accessibility Multitasking ms-settings:multitasking Display Narrator ms-settings:easeofaccess-narrator Audio Network &amp; Internet ms-settings:network Network Network Status ms-settings:network-status Network Night light settings ms-settings:nightlight Customisation Notifications (share between apps) ms-settings:privacy-notifications Privacy Notifications and Actions ms-settings:notifications Customisation Offline Maps ms-settings:maps Apps Online Speech recognition ms-settings:privacy-speech Privacy Optional features ms-settings:optionalfeatures Apps Other options ms-settings:easeofaccess-otheroptions Accessibility Personalization ms-settings:personalization Customisation Picture Library (share between apps) ms-settings:privacy-pictures Privacy Power &amp; Sleep ms-settings:powersleep Power Printers ms-settings:printers Devices Privacy ms-settings:privacy Privacy Projecting to this PC ms-settings:project Display Proxy (Network) ms-settings:network-proxy Network Radio (share between apps) ms-settings:privacy-radios Privacy Recovery - Reset&#x2F;Advanced startup ms-settings:recovery Windows Region ms-settings:regionformatting Region &amp; Language Region &amp; language ms-settings:regionlanguage Region &amp; Language Remember typing patterns ms-settings:privacy-speechtyping Privacy Remote Desktop ms-settings:remotedesktop Network Search Permissions &amp; search history ms-settings:search-permissions Search Search details ms-settings:search-moredetails Search Security Key setup ms-settings:signinoptions-launchsecuritykeyenrollment Security Send Diagnostic Data to Microsoft ms-settings:privacy-feedback-telemetryviewergroup Privacy Set up a kiosk ms-settings:assignedaccess Security Shared experiences ms-settings:crossdevice Network Sign-in options ms-settings:signinoptions Security Software Center (SCCM) softwarecenter: Apps Sound (build 17063+) ms-settings:sound Audio Speech ms-settings:speech Audio Speech recognition (build 17035+) ms-settings:easeofaccess-speechrecognition Accessibility Start Menu ms-settings:personalization-start Customisation Start Menu (choose which folders appear) ms-settings:personalization-start-places Customisation Start Narrator after sign-in ms-settings:easeofaccess-narrator-isautostartenabled Audio Startup (build 17017+) ms-settings:startupapps Customisation Storage Sense ms-settings:storagesense Storage Storage Sense configuration ms-settings:storagepolicies Storage Sync your settings ms-settings:sync Network Tablet mode ms-settings:tabletmode Customisation Taskbar ms-settings:taskbar Apps Tasks (share between apps) ms-settings:privacy-tasks Privacy Text Cursor ms-settings:easeofaccess-cursor Accessibility Themes ms-settings:themes Customisation Touchpad ms-settings:devices-touchpad Devices Troubleshoot - Fix Windows Update ms-settings:troubleshoot Windows Typing ms-settings:typing Accessibility USB ms-settings:usb Devices Unpaired devices (share between apps) ms-settings:privacy-customdevices Privacy VPN ms-settings:network-vpn Network Video Library (share between apps) ms-settings:privacy-videos Privacy Video playback (build 16215+) ms-settings:videoplayback Display Voice activation (apps can listen) ms-settings:privacy-voiceactivation Privacy Webcam (share between apps) ms-settings:privacy-webcam Privacy Wi-Fi ms-settings:network-wifi Network WinUpdate - Active Hours ms-settings:windowsupdate-activehours Security WinUpdate - Advanced options ms-settings:windowsupdate-options Security WinUpdate - Check for updates ms-settings:windowsupdate-action Security WinUpdate - Optional updates ms-settings:windowsupdate-optionalupdates Security WinUpdate - Restart options ms-settings:windowsupdate-restartoptions Security WinUpdate - Update history ms-settings:windowsupdate-history Security Windows Hello face setup ms-settings:signinoptions-launchfaceenrollment Security Windows Hello fingerprint setup ms-settings:signinoptions-launchfingerprintenrollment Security Windows Insider Program (beta’s) ms-settings:windowsinsider Windows Windows Search ms-settings:cortana-windowssearch Search Windows Security (Defender) ms-settings:windowsdefender Security Windows Security at a glance windowsdefender: Security Windows Update ms-settings:windowsupdate Security Your info (Microsoft account) ms-settings:yourinfo Security","tags":["windows","ms-settings","快捷方式"],"categories":["OS","Windows"]},{"title":"使用 UMDH 定位用户模式内存泄漏","path":"/OS/Windows/内存泄漏/内存泄漏定位 UMDH/","content":"[toc] UMDH UMDH（用户模式转储堆），是与操作系统一起用于分析特性进程Windows堆分配。UMDH查找特定进程中的哪个例程正在泄漏内存。特别要注意的事：使用UMDH显示堆栈跟踪数据之前，必须使用 GFlags 正确配置系统。Windows的调试工具中包含了 GFlags。 使用启用 UMDH stack 跟踪： 在 GFlags 图形界面中，选择 “图像文件” 选项卡，键入进程名称 (包括文件扩展名) ，按 TAB 键，选择 “ 创建用户模式堆栈跟踪数据库“，然后选择 “ 应用“。或者，在命令行界面使用 gflags 命令设置。 1gflags /i imageName +ust 当完成分析后，使用 - 清楚设置： 1gflags /i imageName -ust 默认情况下，在 x86 处理器上 Windows 收集的堆栈跟踪数据量限制为 32 MB，在 x64 处理器上限制为 64 mb。 如果必须增加此数据库的大小，请选择 “GFlags” 图形界面中的 “ 映像文件 “ 选项卡，键入进程名称，按 tab 键，选中 “ Stack Backtrace (Megs) “ 复选框，在 “关联” 文本框中键入值 (，以) MB 为单位），然后选择 “ 应用“。 仅在必要时增加此数据库，因为它可能会耗尽有限的 Windows 资源。 如果不再需要更大的大小，则将此设置返回到其原始值。 如果更改了 “系统注册表“ 选项卡上的任何标志，则必须重新启动 Windows 以使这些更改生效。 如果更改了 “ 图像文件 “ 选项卡上的任何标志，则必须重新启动该过程才能使更改生效。 对内核标志选项卡所做的更改会立即生效，但下次重新启动 Windows，它们会丢失。 在使用 UMDH 之前，必须有权访问应用程序的正确符号。UMDH 使用环境变量指定的符号路径 _NT_SYMBOL_PATH。将此变量设置为包含应用程序的符号的路径。如果还包括 Windows 符号的路径，则分析可能更完整。此符号路径的语法与调试器使用的语法相同。 例如，如果你的应用程序的符号位于 C:\\MySymbols，并且你想要为你的 Windows 符号使用公共 Microsoft 符号存储区，则使用 C:\\MyCache 作为下游存储，你将使用以下命令设置你的符号路径： 1set _NT_SYMBOL_PATH=c:\\mysymbols;srv*c:\\mycache*https://msdl.microsoft.com/download/symb 此外，若需要确保准确的结果，必须禁用 BSTR 缓存。为此，请将 OANOCACHE 环境变量的值设置为 1（需要在启动跟踪其分配的应用程序之前进行设置）。如果需要跟踪服务所做的分配，则必须将 OANOCACHE 设置为西戎环境变量，然后重新启动 Windows 以使此设置生效。 检测通过 UMDH 增加的堆分配1. 确认进程ID (PID)1tlist | finstr &quot;进程名&quot; 2. 保存日志文件使用 UMDH 分析此进程的堆内存分配，并将其保存到日志文件。将 -p 开关与 PID 一起使用，并将 -f 开关与日志文件的名称一起使用。例如，如果 PID 为123，并且你想要将日志文件命名为 Log1.txt ，请使用以下命令： 1umdh -p:123 -f:log1.txt 3. 查看日志使用记事本或其他程序打开日志文件。 此文件包含每个堆分配的调用堆栈、通过该调用堆栈进行的分配数，以及通过该调用堆栈使用的字节数。 4. 前后两次日志对比结果由于您正在查找内存泄漏，因此，单个日志文件的内容是不够的。 你必须比较在不同时间记录的日志文件，以确定哪些分配正在增长。 UMDH 可以比较两个不同的日志文件，并在各自的分配大小中显示更改。 您可以使用大于符号 (&gt;) 将结果重定向到第三个文本文件。 你可能还需要包含-d 选项，该选项将字节和分配计数从十六进制转换为十进制。 例如，若要比较 Log1.txt 和 Log2.txt，将比较结果保存到文件 LogCompare.txt，请使用以下命令： 1umdh log1.txt log2.txt &gt; logcompare.txt 5. 分析内存泄漏12+ 5320 ( f110 - 9df0) 3a allocs BackTrace00B53 Total increase == 5320 对于每个调用堆栈 (在 UMDH 日志文件中标记为 “BackTrace” ) ，这两个日志文件之间有比较。 在此示例中，第一个日志文件 (Log1.txt) 为 BackTrace00B53 分配的0x9DF0 字节，而第二个日志文件记录了0xF110 字节，这意味着在捕获两个日志的时间之间分配有0x5320 的额外字节。 这些字节来自 BackTrace00B53 标识的调用堆栈。 6. 查看泄漏堆栈若要确定该 backtrace 中的内容，请打开一个原始日志文件 (例如 Log2.txt) ，然后搜索 “BackTrace00B53”。结果类似于以下数据： 1234567891011121300005320 bytes in 0x14 allocations (@ 0x00000428) by: BackTrace00B53ntdll!RtlDebugAllocateHeap+0x000000FDntdll!RtlAllocateHeapSlowly+0x0000005Antdll!RtlAllocateHeap+0x00000808MyApp!_heap_alloc_base+0x00000069MyApp!_heap_alloc_dbg+0x000001A2MyApp!_nh_malloc_dbg+0x00000023MyApp!_nh_malloc+0x00000016MyApp!operator new+0x0000000EMyApp!DisplayMyGraphics+0x0000001EMyApp!main+0x0000002CMyApp!mainCRTStartup+0x000000FCKERNEL32!BaseProcessStart+0x0000003D 上述泄漏内存分析: 此 UMDH 输出显示有) (十进制21280从调用堆栈中分配的总字节数。 这些字节是从 0x14 (十进制 20) 单独分配的，每个 0x428 (十进制 1064) 字节。 将为调用堆栈提供 “BackTrace00B53” 的标识符，并显示此堆栈中的调用。 在检查调用堆栈时，可以看到 DisplayMyGraphics 例程正在通过 new 运算符分配内存，该运算符调用例程 malloc，后者使用 Visual C++ 运行时库从堆中获取内存。 确定要在源代码中显式显示的最后一个调用。 在这种情况下，它可能是 new 运算符，因为调用 malloc 是作为 新 的实现的一部分而不是作为单独的分配。 因此， DisplayMyGraphics例程中new运算符的此实例会重复分配未释放的内存。 参考链接使用 UMDH 查找用户模式内存泄漏 - Windows drivers | Microsoft Docs","tags":["内存","内存泄漏","UMDH","WinDbg"],"categories":["OS","Windows","内存泄漏"]},{"title":"内存泄漏分析实战","path":"/OS/Windows/内存泄漏/实战/内存泄漏分析实战/","content":"[toc] 前言本文为项目中服务程序的内存泄漏，挑了其中一部分比较常见的内存泄漏进行分析和修改。 关于内存泄漏和分析的文章可查看博客相关文章，有 UMDH 和 vld 两种方式，可根据个人需求展开分析。 泄漏分类# malloc 内存泄漏下述日志为一次 malloc 未正确释放导致的内存泄漏。这种问题比较常见，不用多说。 123ntdll.dll!RtlAllocateHeap()***\\heap\\malloc_base.cpp (34): XXX.dll!_malloc_base() + 0xF bytesXXX.dll!_event_debugx() + 0x1A7 bytes 解决方案： 根据提示的位置找到并释放该内存。 123char *ch = (char*)malloc(sizeof(8));free ch;ch = NULL; 另外，也可以使用智能指针管理该指针： 12char *ch = (char*)malloc(sizeof(8));shared_ptr&lt;char&gt; spCh(ch); # new 内存泄漏关于 new 的内存泄漏分析写了一段代码用来展示一下： 注：代码 Section2 部分为一个崩溃代码，堆内存申请后使用时一处，而在堆内存申请和释放时以及程序结束时释放堆内存时，都 存在堆溢出检查 ，检查点会抛出异常，导致程序奔溃。 1234567891011121314151617// 代码 Section2// 该函数代码还涉及奔溃问题int* test_heap_alloc()&#123;\tint* pTable = new int(256); // 申请一个int结构体变量，初始值为256;\tfor (int i = 0; i &lt; 256; i++) pTable[i] = i;\treturn pTable;&#125;int main ()&#123; test_heap_alloc(); // 执行上述代码之后再去下边这句申请堆内存会奔溃。 char* p = new char(0); // 申请一个字节，内容初始化为0\treturn 0;&#125; 以下为 vld 生成的泄漏日志： 123456789101112WARNING: Visual Leak Detector detected memory leaks!---------- Block 1 at 0x010AAC68: 4 bytes ---------- Leak Hash: 0x03729B3D, Count: 1, Total 4 bytes Call Stack (TID 33760): ucrtbase.dll!malloc() d:\\agent\\_work\\3\\s\\src\\vctools\\crt\\vcstartup\\src\\heap ew_scalar.cpp (35): vldforptr.exe!operator new() + 0x8 bytes d:\\code_source\\c++\\vs2019\\vldforptr\\vldforptr.cpp (45): vldforptr.exe!main() + 0x7 bytes KERNEL32.DLL!BaseThreadInitThunk() + 0x19 bytes ntdll.dll!RtlGetAppContainerNamedObjectPath() + 0x11E bytes ntdll.dll!RtlGetAppContainerNamedObjectPath() + 0xEE bytes Data: 00 00 00 00 ........ ........ 解决方案： 调用 delete 释放 new 出来的内存。 问题：不确定变量什么时候使用完的，如何释放？ 123// 使用智能指针char *ch = new char[256];std::shared_ptr&lt;char&gt; spCh(ch); # strdup 内存泄漏strdup函数说明： 功能：将字符串拷贝到新建的位置处 返回值 ：返回一个指向新字符串的指针，该字符串是字符串s的副本，如果分配空间失败，则返回NULL值。新字符串的内存由strdup函数原型内部的malloc（）获得，需用free（）释放。 123ntdll.dll!RtlAllocateHeap()minkernel\\crts\\ucrt\\src\\appcrt\\heap\\malloc_base.cpp (34): XXX.dll!_malloc_base() + 0xF bytesXXX.dll!BUF_strndup() + 0x8A bytes 把返回内存地址的释放权交给了别的变量，这就很容易忘记释放，所以 strdup 这个函数也很容易造成内存泄漏。 整理# _malloc_base_malloc_base 就是编译器编译之后的 malloc。 查看vld的log可以看到，堆栈显示的 _malloc_base 所在的文件夹为 minkernel\\crts\\ucrt\\src\\appcrt\\heap\\malloc_base.cpp，这个文件就是 malloc 声明和定义的文件。 1234567领导您好！以下内容为本次绩效期间我的工作概述以及自我评价。本次绩效期间，我的主要工作内容集中在零信任国信版本和天擎零信任插件部分，同时也负责了部分工行、标板的需求开发（SPA、异常告警、命令行登录等）。零信任国信版本共计发布版本两次，均在发布版本之前完成了需求的开发和bug的修复，涉及的需求十多项，需求提测均通过，在完成需求的同时，整理编写了相应的技术开发文档十多篇，同时也补充了零信任客户端部分配置文件的说明文档。开发同时，针对国信零信任版本的升级故障问题（升级失败，升级检测问题），优化了该部分的逻辑，对整个客户端的无逻辑代码和日志部分进行了优化，以便于后续快速定位和分析问题，国信发布版本期间，为保证出包顺利，解决临时出现的问题，与团队一起解决问题并完成版本发布的任务；零信任插件部分，插件的开发让我学习到了较多框架方面的知识，了解了插件的开发以及团队联调的过程，零信任插件的开发在团队帮助下开发较为顺利，并且按时提测，且完成度较高，故障部分相对较少，调整部分基本为业务方面的逻辑调整。工行和标板的需求也是在计划内完成了需求的开发并提测成功，本次绩效期间，工作充实，如期完成了各项需求开发。不足就是多个需求的开发和提测过程相对较慢，由于环境（tac）问题，在开发自测和提测过程中出现了效果不一致的情况，在以后开发中需要注意该方面问题对开发提测的影响，提测前尽量保证自测完整，需求完善。以上就是本期自我评价。","tags":["内存泄漏","实战"],"categories":["OS","Windows","内存泄漏","实战"]},{"title":"windbg 定位内存泄漏","path":"/OS/Windows/内存泄漏/WinDbg定位内存泄漏/","content":"概述：使用 Windbg 定位内存泄漏 [toc] windbg 定位内存泄漏主要使用 !heap 命令 使用Windbg检测Windows程序内存泄漏的步骤如下： 启动程序：使用Windbg启动需要检测内存泄漏的程序，可以通过在Windbg中选择“文件”-&gt;“打开程序”来打开程序。 设置符号路径：在Windbg中，可以通过设置符号路径来加载程序的符号信息，方便调试。可以通过在Windbg中输入“.sympath”命令来设置符号路径，例如： 1.sympath+ C:\\Symbols 其中，C:\\Symbols是符号文件的路径。 启用gflags：gflags是Windows提供的一个工具，可以用来设置程序的调试标志。可以通过在命令行中输入以下命令来启用gflags： 1gflags /i your_program.exe +ust 其中，your_program.exe是需要检测内存泄漏的程序的名称。 运行程序：在Windbg中，可以通过输入“g”命令来运行程序。 检测内存泄漏：在程序运行过程中，可以通过输入“!heap -s”命令来查看程序的堆内存使用情况，例如： 1!heap -s 该命令会输出程序的堆内存使用情况，包括已分配的内存块数量、已释放的内存块数量、已分配的内存块总大小、已释放的内存块总大小等信息。 输出内存泄漏信息：在程序运行结束后，可以通过输入“!heap -stat -h handle”命令来输出内存泄漏信息，例如： 1!heap -stat -h handle 该命令会输出程序中所有未释放的内存块的信息，包括内存块的大小、地址、分配位置等信息。 需要注意的是，使用Windbg检测内存泄漏需要一定的调试经验和技巧，对程序的性能也会产生一定的影响。因此，在正式发布程序之前，应该关闭gflags功能。可以通过在命令行中输入以下命令来关闭gflags： 1gflags /i your_program.exe -ust 其中，your_program.exe是需要关闭gflags功能的程序的名称。","tags":["windbg","内存泄漏"],"categories":["OS","Windows","内存泄漏"]},{"title":"【不敢说一文搞懂】VLD 内存泄漏定位","path":"/OS/Windows/内存泄漏/vld内存泄漏/","content":"[toc] 半学半练，定位了一把内存泄漏的问题。 内存泄漏工具的想必大家都知道了，主要使用 VLD 这个工具。 VLD 下载安装和使用1. 下载和安装Visual Leak Detector | Enhanced Memory Leak Detection for Visual C++ 点击上方链接下载和安装 vld 工具，记住安装的位置，后续有很多文件会使用到，需要拷贝移动到相应的文件中。 2. 使用 安装完成后，找到安装所在的文件夹 找到 vs studio 中 标准头文文件 所在的文件夹，一般会在对应的 windows kits 所在的文件夹中找到。如： C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt。拷贝安装目录下 include 中的 头文件到该目录，注意有几个 kits 环境就尽量拷贝几个，万一用到呢 找到 vs studio 中 库文件 所在的文件夹，一般会在对应的 windows kits 所在的文件夹中找到。如： C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\(kits 版本号)\\um\\。拷贝安装目录下 lib 目录下对应位数的 lib 文件到 kits 对应的 um\\x64或um\\x86 文件夹中。 到这一步，只要在程序中引入 vld 头文件就可以正常使用了。 1#include &lt;vld.h&gt; 3. 在 vs2015 以上的版本中使用 安装的时候就可以看到 vld 只支持到 vs2015。所以在 vs 更高的版本中使用时，需要一些额外的操作。 影响：在vs高版本中使用时，虽然能定位泄漏问题，但是不显示文件名和行号。 解决办法： 在 vs 工程设置中按下图设置： 4. release 模式下进行内存泄漏检测在 Debug 模式下，直接在工程中源文件中任意位置引入 &lt;vld.h&gt; 即可，编译之后的可执行文件就带有泄漏检测的功能。 但是在 Release 模式下则需要做一下额外的处理。 同 Debug 版本在 VS 中一样配置好 VLD 的相关信息 拷贝 VLD 安装目录下 bin\\win32 目录下所有的文件和 vld.ini 到工程目标路径下(可执行文件的目录)。 在程序入口处的 cpp 文件中，定义强制检测宏和包含 vld 头文件 12#define VLD_FORCE_ENABLE#include &lt;vld.h&gt; 在程序启动和退出时，分别增加以下函数调用 1234567&#123; ... VLDGlobalEnable(); VLDReportLeaks(); //some code... VLDGlobalDisable();&#125; 增加检测模块（如加载的 dll 文件） 以上配置后，默认情况下只会检测主线程的模块，要想增加其他模块的内存泄漏检测，需要配置 vld.ini 配置文件中的 ForceIncludeModules 配置项。在该配置项后增加需要检测的模块。如：ForceIncludeModules=demo1.dll;demo2.dll 配置输出方式 同样还是配置文件中修改。设置配置文件中 ReportTo 的值即可： debugger：控制台 file: 文件 （默认会输出在运行程序的目录下，也可能会输出在 syswow64 这个系统目录下，Win+R 输入 syswow64即可打开这个目录。默认文件名：memory_leak_report.txt） both：控制台和文件 关于 VLD 的配置文件： Vld 的库会检查程序所运行的当前目录是否存在 vld.ini 的配置文件，如果有，则加载里头的配置进行内存检测运行，如果没有取默认的配置参数运行，我们可以手动将 vld.ini 的文件拷贝到程序的运行目录中即可。 关于 vld.ini 的几个注意的参数： VLD = on 总开关，是否启用 VLD 功能，默认为 yes MaxDataDump = 256 用来显示检测到的内在泄露的块的地址大小，默认256，其实就是显示多少个byte的内容。 MaxTraceFrames = 64 设置 VLD 检测到堆栈的最大层极，也就是frame的深度 ReportFile = xxx设置 VLD 生成报告的位置和报告的文件名，默认为：.\\memory_leak_report.txt ，程序当前运行目录中。 ReportTo = debugger 设置 VLD 生成报告的方式，debugger为在控制台输出 VLD 的报告信息，file在指定目录下生成报告文件，both为即输出也生成报告。如果你的程序为带窗体的程序，需要设置为file或both. 问题1：不显示文件名和行号缺少 pdb 文件 如果程序运行之后生成的 memory_leak_report 中还是不显示行号，则试试把pdb文件放在程序的运行目录试试。 参考文章 【VS2019】C&#x2F;C++内存泄漏检测工具：Visual Leak Detector超详细安装教程（for windows）_执行x的博客-CSDN博客_vs2019内存泄漏检测 使用VLD进行内存泄漏检测(release + debug)_OH,CGWLMXUP的博客-CSDN博客_release vld","tags":["C++","内存泄漏","tools"],"categories":["OS","Windows","内存泄漏"]},{"title":"共享文件夹","path":"/OS/Windows/共享文件夹/","content":"最近由于项目需求，需要编写一个监控本机共享文件夹的变化的模块，经过查询资料，找到并实现了一个较为稳定的方式项目实现是使用Win32 C++的，测试平台是Win 7 64和Win 10 64，XP测试也是好使的。下面是具体实现 首先要获取并监控系统共享文件夹的路径，相关注册表路径为 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Share ,他的值的格式为如图所示， C++ 获取共享文件夹目录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091BOOL GetSharedFoldersList(map&lt;CString, HANDLE&gt; &amp;theList)&#123;\tBOOL bFlag = FALSE;\tHKEY hKey = NULL;\tdo\t&#123; //清空列表 theList.clear(); //HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Share //通过注册表获取共享文件夹列表 HKEY rootKey = REG_SHARE_KEY; CString szRegPath = REG_SHARE_PATH; int ErrCode; if (ERROR_SUCCESS != (ErrCode = RegOpenKeyEx(rootKey, szRegPath, 0, KEY_READ | KEY_WOW64_64KEY, &amp;hKey))) &#123; break; &#125; TCHAR szValue[MAX_VALUE_NAME] = &#123; 0 &#125;; DWORD dwValueSize = MAX_VALUE_NAME; int index = 0; DWORD dwBufferSize = 255; DWORD dwType; TCHAR *szValBuffer = NULL; DWORD dwSize; while (ERROR_NO_MORE_ITEMS != RegEnumValue ( hKey, index, szValue, &amp;dwValueSize, NULL, &amp;dwType, NULL, &amp;dwBufferSize)) &#123; //判断值类型 switch(dwType) &#123; //只找多个串的值 case REG_MULTI_SZ: &#123; dwSize = dwBufferSize + 1; szValBuffer = new TCHAR[dwSize]; ZeroMemory(szValBuffer, dwSize); if (ERROR_SUCCESS != RegQueryValueEx(hKey, szValue, 0, &amp;dwType, (LPBYTE)szValBuffer, &amp;dwBufferSize)) &#123; break; &#125; int j = 0; CString TmpValue; for(int i = 0;szValBuffer[i] != &#x27;\\0&#x27; ;i += j + 1) &#123; for (j = 0;szValBuffer[i + j] != &#x27;\\0&#x27;;j ++) &#123; TmpValue += szValBuffer[i + j]; &#125; //如果找到共享路径，则直接放入容器，然后进行下一个路径的查找 if (TmpValue.Find(_T(&quot;Path=&quot;)) == 0) &#123; //m_vSharedList.push_back(TmpValue.Right(TmpValue.GetLength() - 5)); CString Tmp = TmpValue.Right(TmpValue.GetLength() - 5); CString szTmp = Tmp; Tmp.MakeLower(); break; &#125; TmpValue = _T(&quot;&quot;); &#125; delete szValBuffer; szValBuffer = NULL; break; &#125; //其他类型跳过 default: &#123; break; &#125; &#125; dwValueSize = MAX_VALUE_NAME; dwBufferSize = 255; index ++; &#125; bFlag = TRUE;\t&#125;while(FALSE); if (hKey != NULL)\t&#123; RegCloseKey(hKey);\t&#125; return bFlag;&#125; C++监控共享注册表变化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//监控注册表项以更新共享文件夹列表DWORD WINAPI SharedMonitor::RefreshThread(LPVOID lpParam)&#123;\tSharedMonitor *pThis = (SharedMonitor *)lpParam; //只监控值的改变\tDWORD dwFilter = REG_NOTIFY_CHANGE_LAST_SET; HKEY hKey;\tHKEY rootKey = REG_SHARE_KEY;\tCString szRegPath = REG_SHARE_PATH; //等待10分钟\tint iWaitTime = 10 * 60 * 1000;\twhile (TRUE)\t&#123; //监控注册表项改变 //Sleep(iWaitTime); HANDLE hEvent; BOOL bFlag = FALSE; do &#123; if (ERROR_SUCCESS != RegOpenKeyEx(rootKey, szRegPath, 0, KEY_ALL_ACCESS | KEY_WOW64_64KEY, &amp;hKey)) &#123; MyDebugA (&quot;RegMonitorThread--- RegOpenKeyEx ERR!&quot;); break; &#125; if (NULL == (hEvent = CreateEvent(NULL, TRUE, FALSE, NULL))) &#123; MyDebugA (&quot;CreateEvent ERR&quot;); break; &#125; if (ERROR_SUCCESS != RegNotifyChangeKeyValue (hKey, TRUE, dwFilter, hEvent, TRUE)) &#123; MyDebugA (&quot;RegNotifyChangeKeyValue ERR&quot;); break; &#125; if (WAIT_FAILED == WaitForSingleObject (hEvent, INFINITE)) &#123; MyDebugA (&quot;WaitForSingleObject ERR&quot;); break; &#125; bFlag = TRUE; &#125;while(FALSE); RegCloseKey (hKey); CloseHandle (hEvent); //如果监控失败，则重新再来 if (!bFlag) &#123; continue; &#125; //等待系统将注册表消息发放完毕，否则有时候添加或删除的注册表项无法被枚举到 Sleep(200); //进行共享列表枚举和比较 map&lt;CString, HANDLE&gt; theNewList; //获取新列表 pThis-&gt;GetSharedFoldersList(theNewList); map&lt;CString, HANDLE&gt; &amp;theOldList = pThis-&gt;GetListInstance(); BOOL bFindNew = FALSE; //比较两个列表 //添加旧列表中没有的共享 for (map&lt;CString, HANDLE&gt;::iterator it = theNewList.begin(); it != theNewList.end(); ++it) &#123; if (theOldList.find(it-&gt;first) == theOldList.end()) &#123; MyDebug(_T(&quot;----------Find New Share----------&quot;)); MyDebug(it-&gt;first); theOldList[it-&gt;first] = 0; bFindNew = TRUE; &#125; &#125; //MyDebug(_T(&quot;---------Start Delete--------&quot;)); //需要删除的列表,map不支持循环删除多个元素 vector&lt;CString&gt; theDeleteList; //删除旧列表中已经取消的共享 for (map&lt;CString, HANDLE&gt;::iterator it = theOldList.begin(); it != theOldList.end(); ++it) &#123; if (theNewList.find(it-&gt;first) == theNewList.end()) &#123; //结束监控线程 if (!TerminateThread(it-&gt;second, 0)) &#123; MyDebug(_T(&quot;TerminateThread ERR&quot;)); MyDebug(it-&gt;first); &#125; //将线程占用的共享目录句柄释放 if (gs_mpDirHandleList[it-&gt;first]) &#123; CloseHandle(gs_mpDirHandleList[it-&gt;first]); &#125; CloseHandle(it-&gt;second); theDeleteList.push_back(it-&gt;first); &#125; &#125; MyDebug(_T(&quot;-----------DeleteList-------------&quot;)); //删除旧列表中的过期共享 for (vector&lt;CString&gt;::iterator it = theDeleteList.begin(); it != theDeleteList.end(); ++it) &#123; theOldList.erase(*it); MyDebug(*it); &#125; //如果有新的共享 if (bFindNew) &#123; pThis-&gt;SetSharedMonitor(); &#125;\t&#125; return 0;&#125; 共享文件夹内文件监控最后就是最终的目的，对共享文件夹内文件的变化进行监控操作。这里使用的是 WIN32 API ReadDirectoryChangesW ，这个的具体使用在我之前的一篇文章里有介绍，这里就不多说了，需要注意的一点是 ReadDirectoryChangesW 函数的第一个参数所需的句柄需要 CreateFile 去创建，而且创建后需要一直占用着不能释放，而创建时所需的权限(第三个参数) 必须设置为 “FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE”，因为如果少任意一个就有可能导致某些第三方软件的使用出现异常，例如迅雷下载，浏览器下载之类的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//监控线程DWORD WINAPI ATSharedMonitor::MonitorThread(LPVOID lpParam)&#123;\tCString szRootPath = *(CString *)lpParam; HANDLE hRootHandle = CreateFile( szRootPath, //监控路径 FILE_LIST_DIRECTORY, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS/* | FILE_FLAG_OVERLAPPED*/, NULL);\tif(FAILED_HANDLE(hRootHandle))\t&#123; MyDebug(_T(&quot;CreateFile Fail&quot;)); return 0;\t&#125; //将目录句柄放到线程对应容器中\tgs_mpDirHandleList[szRootPath] = hRootHandle; //\tOUTPUT_PARAM_DEBUGA(&quot;The CurrentThread:%X&quot;, GetCurrentThread()); szRootPath += _T(&quot;\\\\&quot;); wchar_t notify[1024];\tZeroMemory(notify, 1024);\tDWORD dwBytes;\tFILE_NOTIFY_INFORMATION *pNotify = (FILE_NOTIFY_INFORMATION *)notify; //过滤同一个文件的操作 CString szLastFile = _T(&quot;&quot;); while (TRUE)\t&#123; if (ReadDirectoryChangesW (hRootHandle, &amp;notify, sizeof(notify), TRUE, FILE_NOTIFY_CHANGE_CREATION | FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_LAST_WRITE, &amp;dwBytes, NULL, NULL)) &#123; MyDebug(_T(&quot;---------Change Happened!------------&quot;)); pNotify-&gt;FileName[pNotify-&gt;FileNameLength / 2] = &#x27;\\0&#x27;; //CString tmp = pNotify-&gt;FileName; //tmp.MakeLower (); CString TmpPath = szRootPath + pNotify-&gt;FileName; switch(pNotify-&gt;Action) &#123; //重命名获取 case FILE_ACTION_RENAMED_OLD_NAME: &#123; MyDebug (TEXT(&quot;文件更名 :&quot;) + TmpPath); PFILE_NOTIFY_INFORMATION p = (PFILE_NOTIFY_INFORMATION)((char*)pNotify+pNotify-&gt;NextEntryOffset); p-&gt;FileName[p-&gt;FileNameLength/2] = &#x27;\\0&#x27;; CString newName = szRootPath + p-&gt;FileName; MyDebug(newName); break; &#125; //删除// case FILE_ACTION_REMOVED:// &#123;// MyDebug (TEXT(&quot;文件删除 :&quot;) + TmpPath);// &#125; //修改..略过文件夹的修改,过滤同一个文件的修改 case FILE_ACTION_MODIFIED: &#123; if (!PathIsDirectory(TmpPath) /*&amp;&amp; szLastFile.CompareNoCase(pNotify-&gt;FileName) != 0*/) &#123; //szLastFile = pNotify-&gt;FileName; MyDebug (TEXT(&quot;文件修改 :&quot;) + TmpPath); &#125; break; &#125; //新建文件获取 case FILE_ACTION_ADDED: &#123; if (!PathIsDirectory(TmpPath) /*&amp;&amp; szLastFile.CompareNoCase(pNotify-&gt;FileName) != 0*/) &#123; MyDebug (TEXT(&quot;文件添加 :&quot;) + TmpPath); &#125; break; &#125; default: &#123; break; &#125; &#125; &#125;\t&#125;\treturn 0;&#125;","tags":["windows","共享文件夹"],"categories":["OS","Windows"]},{"title":"Windows聚焦不更新","path":"/OS/Windows/windows聚焦问题/","content":"[toc] 方案一在应用商店安装 dynamic theme 方案二先将个性化锁屏界面选项由”Windows 聚焦”改为”图片”。 然后去删除 C:\\Users\\你自己的用户名\\AppData\\Local\\Packages\\Microsoft.Windows.ContentDeliveryManager_***\\Settings (***为随机数字)目录下settings.dat 和 roaming.lock 这两个文件。（注：AppData 等是隐藏的文件夹或文件） 再然后回到个性化锁屏界面将选项由”图片”改回”Windows 聚焦”。 稍等，OK! 随后应该可以看到 :...\\Microsoft.Windows.ContentDeliveryManager_***\\LocalState\\Assets 文件夹里下载了一批聚焦图片 ..\\Microsoft.Windows.ContentDeliveryManager_***\\settings 目录下重新生成了 settings.dat 文件。","tags":["windows","bug"],"categories":["OS","Windows"]},{"title":"删除文件夹","path":"/OS/Windows/cmd/删除文件夹/","content":"12345678@echo offif &quot;%1&quot; == &quot;h&quot; goto beginmshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit:beginREMrd /Q /S %programdata%\\TrustAgent\\logs","tags":["bat","文件夹"],"categories":["OS","Windows","cmd"]},{"title":"cmd——route","path":"/OS/Windows/cmd/route/","content":"Route 命令 Route命令用于在本地IP路由表中显示和修改条目。在排除网络故障时常会用到。 使用不带参数的Route或 Route /? 可以显示帮助。 语法： route [-f] [-p] [command [destination] [mask netmask] [gateway] [metric] [if interface] -f 选项 Route –f 命令清除所有网关项的路由表。如果该参数与某个命令组合使用，路由表将在运行命令前清除。 如下图所示，执行 route –f 命令后，再用 route print 打印路由表时，可看到路由表为空。 -p 选项 与 route add 命令结合使用时，将路由设备为在系统引导期间保持不变。 默认情况下，重新启动系统时，不保存路由。 当在 route add 命令中加入-p参数时，route print 命令就能看到永久路由了。 route printPrint命令 接下来，我们将介绍Print、Add、Delete、Chance四个常用的Command命令。 Route print命令显示IP路由表的完整内容，如下图所示：首先显示了当前主机的所有接口列表，接下来显示IPv4路由表和IPv4永久路由，可以看到，我的IPv4路由表有两个默认网关，且无手动添加的IPv4永久路由。 使用route print命令时，目标或网关可以为通配符，通配符指定为星号“*”。 12345Route print -4命令只显示IPv4的路由表信息。Route print -6命令只显示IPv6的路由表信息。Route print 192*命令只显示那些匹配192*的项。 route add例1：若要添加带有 192.168.12.1 默认网关地址的默认路由， 1route add 0.0.0.0 mask 0.0.0.0 192.168.12.1 例2：若要向带有 255.255.0.0 子网掩码和 10.27.0.1 下一跃点地址的 10.41.0.0 目标中添加一个路由 1route add 10.41.0.0 mask 255.255.0.0 10.27.0.1 例3：若要向带有 255.255.0.0 子网掩码和 10.27.0.1 下一跃点地址的 10.41.0.0 目标中添加一个永久路由 1route -p add 10.41.0.0 mask 255.255.0.0 10.27.0.1 例4：若要向带有 255.255.0.0 子网掩码、10.27.0.1 下一跃点地址且其成本值标为 7 的 10.41.0.0 目标中添加一个路由 1route add 10.41.0.0 mask 255.255.0.0 10.27.0.1 metric 7 例5：若要向带有 255.255.0.0 子网掩码、10.27.0.1 下一跃点地址且使用 0x3 接口索引的 10.41.0.0 目标中添加一个路由 1route add 10.41.0.0 mask 255.255.0.0 10.27.0.1 if 0x3 如果未给出if，它将尝试查找给定网关的最佳接口。 例6：若本地的IP地址为172.16.1.100，网关为172.16.1.254，现有一条ADSL线路，路由器的地址为172.168.1.200，通过该地址可访问Internet。如何做到既想上网，又想访问网络内的资源？只需按以下三步操作即可 12345第一步：将本地的网关地址由172.16.1.254改为172.16.1.200第二步：route delete 0.0.0.0 mask 0.0.0.0 172.16.1.254第三步：route add 172.16.0.0 mask 255.255.0.0 172.16.1.100 -p metric 1 Delete命令 Route delete命令删除路由。 使用route delete命令时，目标或网关可以为通配符，通配符指定为星号“*”。 例1：若要删除到带有 255.255.0.0 子网掩码的 10.41.0.0 目标的路由 1route delete 10.41.0.0 mask 255.255.0.0 例2：若要删除以 10. 起始的 IP 路由表中的所有路由 1route delete 10.\\* Change命令 Route change命令只用于修改网关和&#x2F;或跃点数 例1：若要将带有 10.100.0.0 目标和 255.255.0.0 子网掩码的下一跃点地址从 10.100.0.1 修改为 10.100.0.254 1route change 10.100.0.0 mask 255.255.0.0 10.100.0.254","tags":["cmd","route"],"categories":["OS","Windows","cmd"]},{"title":"bcdedit 用法整理","path":"/OS/Windows/cmd/bcdedit/","content":"概述：bdcedit用法整理 更多命令：https://docs.microsoft.com/zh-cn/windows-hardware/drivers/devtest/bcdedit–bootdebug [toc] 禁用数字签名1bcdedit /set testsigning on windows操作提供内核调试12bcdedit /debug on # 启动bcdedit /debug off # 禁用 windows操作系统启动项的启动调试12bcdedit /bootdebug on # 启用bcdedit /bootdebug off # 禁用 永久禁用数字签名方法 管理员CMD 输入 bcdedit.exe /set nointegritychecks on，执行完毕就结束了 如果要恢复签名，执行 bcdedit.exe /set nointegritychecks off就行 windbg和虚拟机的远程调试和网络调试设置 参考：windbg和虚拟机下的远程调试和网络调试设置_windbg调试虚拟机_satadriver的博客-CSDN博客 微软官方文档：BCDEdit &#x2F;dbgsettings - Windows drivers | Microsoft Learn WDF双机调试 参考：WDK1.2. bcdedit调试配置_bcdedit &#x2F;dbgsettings hostip_ljymoonlight的博客-CSDN博客 双机调试基本步骤网络连接虚拟机设置1234567891011# 1. 打开调试模式bcdedit /debug on# 2. 设置网络方式调试# hostip：主机IP地址# port: 主机的端口# key：(可省略) 登录密码bcdedit /dbgsettings net hostip:192.168.0.102 port:50000 key:1.2.3.4#3. 设置数字签名bcdedit /set testsigning on 主机windbg连接虚拟机如下图所示填入上述得到key或自定义设置的key之后连接即可。 串口调试虚拟机设置 管理员cmd 依次输入以下指令 12345# 添加新的引导项bcdedit /copy &#123;current&#125; /d Debug# 设置引导项等待时间bcdedit /timeout 30 重启操作系统并再次管理员运行CMD 依次输入以下命令 12345bcdedit /dbgsettings SERIAL DEBUGPORT:1 BAUDRATE:115200bcdedit /bootdebug onbcdedit /debug on 运行 ‘msconfig’ win+R 输入 msconfig 查看引导项是否有Debug模式 查看高级选项，调试端口和波特率 到此为止，虚拟机设置完毕，启动后操作系统启动时选择 Debug Windbg连接 连接内核","categories":["OS","Windows","cmd"]},{"title":"windows 程序自动生成dump文件","path":"/OS/Windows/Windbg/windows-程序自动生成dump文件/","content":"[toc] 一、Windows 生成dump 本文主要说明windows操作系统下，程序如何自动生成dump文件 如果生成dump生成dump主要依赖于windowsapi函数 SetUnhandledExceptionFilter,参数为一个回调函数，主要依赖于该函数以及回调函数中的相关逻辑生成dump。 12LPTOP_LEVEL_EXCEPTION_FILTER WINAPI SetUnhandledExceptionFilter( _In_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter） 注意点： 最好是在程序开始处设置回调 如果回调不生效，也可使用 AddVectoredExceptionHandler 函数设置回调，其用法与 SetUnhandledExceptionFilter 基本一致，但是需要注意的是，使用 AddVectoredExceptionHandler 后，outpuydebugstring 也会触发回调，所以这个函数慎用。 dump回调函数dump回调函数可根据自己的需求去编写，以下为一个示例： 1234567891011121314151617181920212223242526272829303132LONG WINAPI MyUnhandledExceptionFilter( struct _EXCEPTION_POINTERS *ExceptionInfo )&#123; SYSTEMTIME st; GetLocalTime(&amp;st); CString time_now = _T(&quot;&quot;); time_now.Format(_T(&quot;%04d_%02d_%02d_%02d_%02d_%03d.dmp&quot;), st.wYear, st.wMonth, st.wDay,st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); CString dump_file_path = GetRootPath(); //获取程序所在的文件夹的路径 dump_file_path += _T(&quot;dump/&quot;); CreateDirectory(dump_file_path, NULL); dump_file_path += time_now; HANDLE hFile = CreateFile(dump_file_path, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if( hFile == INVALID_HANDLE_VALUE ) return EXCEPTION_CONTINUE_EXECUTION; // 往下传，继续交给 windows 默认的处理函数处理 MINIDUMP_EXCEPTION_INFORMATION mdei; mdei.ThreadId = GetCurrentThreadId(); mdei.ExceptionPointers = ExceptionInfo; mdei.ClientPointers = NULL; MINIDUMP_CALLBACK_INFORMATION mci; mci.CallbackRoutine = NULL; mci.CallbackParam = 0; MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &amp;mdei, NULL, &amp;mci); CloseHandle(hFile); return EXCEPTION_EXECUTE_HANDLER;&#125; 设置回调写完回调函数之后，调用 SetUnhandledExceptionFilter ，入参为回调函数。 1SetUnhandledExceptionFilter(MyUnhandledExceptionFilter); 到此，设置并捕获异常的接口完成，以下补充几点个人经验。 二、手写崩溃12345void CreteCrash()&#123; int *ptr = nullptr;\t*ptr = n;&#125; 三、回调不生效问题 SetUnhandledExceptionFilter 是无法捕获 printf, scan, strlen 等CRT函数的异常的，如printf(NULL) 异常;除此之外，在有的环境当中，因为软件被hook的问题，导致 函数不生效，设置的回调往往不起作用，此时可以修改设置 的函数地址来屏蔽其他软件的hook。 代码123456789101112131415161718192021void DisableSetUnhandledExceptionFilter()&#123; void* addr = (void*)GetProcAddress(LoadLibrary(_T(&quot;kernel32.dll&quot;)), &quot;SetUnhandledExceptionFilter&quot;); if (addr != NULL) &#123; unsigned char code[16]; int size = 0; code[size++] = 0x33; code[size++] = 0xC0; code[size++] = 0xC2; code[size++] = 0x04; code[size++] = 0x00; DWORD dwOldFlag, dwTempFlag; VirtualProtect(addr, size, PAGE_READWRITE, &amp;dwOldFlag); WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL); VirtualProtect(addr, size, dwOldFlag, &amp;dwTempFlag); &#125;&#125; 使用说明在程序启动并设置dump回调之后调用 DisableSetUnhandledExceptionFilter即可。 注意事项经本人测试，在部分机器上，使用 WriteProcessMemory和 VirtualProtect 可能会导致程序崩溃，并且不会生成dump。可尝试修改 VirtualProtect 和 WriteProcessMemory 函数的参数测试。 方案一修改 VirtualProtect 的 flag.设置为 PAGE_EXECUTE_READWRITE 1VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &amp;dwOldFlag); 方案二WriteProcessMemory 可直接使用 memcpy 替代。 1memcpy(addr, code, size); 代码总结123456789101112131415DWORD dwOldFlag = 0;VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &amp;dwOldFlag);#if 0HANDLE hProcess = GetCurrentProcess();if (!(hProcess == NULL || hProcess == INVALID_HANDLE_VALUE))&#123; WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL);&#125;else&#123; memcpy(addr, code, size);&#125;#endifmemcpy(addr, code, size);VirtualProtect(addr, size, dwOldFlag, &amp;dwOldFlag);","tags":["windows","windbg","dump"],"categories":["OS","Windows","Windbg"]},{"title":"windows 程序自动生成dump文件","path":"/OS/Windows/Windbg/生成dump/","content":"[toc] 一、Windows 生成dump 本文主要说明windows操作系统下，程序如何自动生成dump文件 如果生成dump生成dump主要依赖于windowsapi函数 SetUnhandledExceptionFilter,参数为一个回调函数，主要依赖于该函数以及回调函数中的相关逻辑生成dump。 12LPTOP_LEVEL_EXCEPTION_FILTER WINAPI SetUnhandledExceptionFilter( _In_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter） 注意点： 最好是在程序开始处设置回调 如果回调不生效，也可使用 AddVectoredExceptionHandler 函数设置回调，其用法与 SetUnhandledExceptionFilter 基本一致，但是需要注意的是，使用 AddVectoredExceptionHandler 后，outpuydebugstring 也会触发回调，所以这个函数慎用。 dump回调函数dump回调函数可根据自己的需求去编写，以下为一个示例： 1234567891011121314151617181920212223242526272829303132LONG WINAPI MyUnhandledExceptionFilter( struct _EXCEPTION_POINTERS *ExceptionInfo )&#123; SYSTEMTIME st; GetLocalTime(&amp;st); CString time_now = _T(&quot;&quot;); time_now.Format(_T(&quot;%04d_%02d_%02d_%02d_%02d_%03d.dmp&quot;), st.wYear, st.wMonth, st.wDay,st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); CString dump_file_path = GetRootPath(); //获取程序所在的文件夹的路径 dump_file_path += _T(&quot;dump/&quot;); CreateDirectory(dump_file_path, NULL); dump_file_path += time_now; HANDLE hFile = CreateFile(dump_file_path, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if( hFile == INVALID_HANDLE_VALUE ) return EXCEPTION_CONTINUE_EXECUTION; // 往下传，继续交给 windows 默认的处理函数处理 MINIDUMP_EXCEPTION_INFORMATION mdei; mdei.ThreadId = GetCurrentThreadId(); mdei.ExceptionPointers = ExceptionInfo; mdei.ClientPointers = NULL; MINIDUMP_CALLBACK_INFORMATION mci; mci.CallbackRoutine = NULL; mci.CallbackParam = 0; MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &amp;mdei, NULL, &amp;mci); CloseHandle(hFile); return EXCEPTION_EXECUTE_HANDLER;&#125; 设置回调写完回调函数之后，调用 SetUnhandledExceptionFilter ，入参为回调函数。 1SetUnhandledExceptionFilter(MyUnhandledExceptionFilter); 到此，设置并捕获异常的接口完成，以下补充几点个人经验。 二、手写崩溃12345void CreteCrash()&#123; int *ptr = nullptr;\t*ptr = n;&#125; 三、回调不生效问题 SetUnhandledExceptionFilter 是无法捕获 printf, scan, strlen 等CRT函数的异常的，如printf(NULL) 异常;除此之外，在有的环境当中，因为软件被hook的问题，导致 函数不生效，设置的回调往往不起作用，此时可以修改设置 的函数地址来屏蔽其他软件的hook。 代码123456789101112131415161718192021void DisableSetUnhandledExceptionFilter()&#123; void* addr = (void*)GetProcAddress(LoadLibrary(_T(&quot;kernel32.dll&quot;)), &quot;SetUnhandledExceptionFilter&quot;); if (addr != NULL) &#123; unsigned char code[16]; int size = 0; code[size++] = 0x33; code[size++] = 0xC0; code[size++] = 0xC2; code[size++] = 0x04; code[size++] = 0x00; DWORD dwOldFlag, dwTempFlag; VirtualProtect(addr, size, PAGE_READWRITE, &amp;dwOldFlag); WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL); VirtualProtect(addr, size, dwOldFlag, &amp;dwTempFlag); &#125;&#125; 使用说明在程序启动并设置dump回调之后调用 DisableSetUnhandledExceptionFilter即可。 注意事项经本人测试，在部分机器上，使用 WriteProcessMemory和 VirtualProtect 可能会导致程序崩溃，并且不会生成dump。可尝试修改 VirtualProtect 和 WriteProcessMemory 函数的参数测试。 方案一修改 VirtualProtect 的 flag.设置为 PAGE_EXECUTE_READWRITE 1VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &amp;dwOldFlag); 方案二WriteProcessMemory 可直接使用 memcpy 替代。 1memcpy(addr, code, size); 代码总结123456789101112131415DWORD dwOldFlag = 0;VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &amp;dwOldFlag);#if 0HANDLE hProcess = GetCurrentProcess();if (!(hProcess == NULL || hProcess == INVALID_HANDLE_VALUE))&#123; WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL);&#125;else&#123; memcpy(addr, code, size);&#125;#endifmemcpy(addr, code, size);VirtualProtect(addr, size, dwOldFlag, &amp;dwOldFlag);","tags":["windows","windbg","dump"],"categories":["OS","Windows","Windbg"]},{"title":"windbg手册","path":"/OS/Windows/Windbg/Windbg手册/","content":"? 0n 命令Windbg中的 ?0n 是一个命令，用来设置表达式的数制为十进制。具体来说，当你需要查看一个内存地址或者变量以十进制格式时，可以使用 ?0n 命令。 在Windbg中，数制的表示： 0x表示十六进制 0n表示十进制 0t表示八进制 0y表示二进制。 Windbg默认数制为十六进制。 切换线程在WinDbg中，可以使用以下命令来切换线程： ~ 命令：用于切换当前活动线程。例如，~0s将切换到线程ID为0的线程。 ~* 命令：用于切换到所有线程中的下一个线程。 ~[] 命令：用于切换到特定索引的线程。例如，~[3]s将切换到索引为3的线程。 请注意，使用这些命令时，要确保已经在调试会话中加载了适当的符号和源代码，并且已经打开了需要调试的进程和线程。 切换进程在WinDbg中，可以使用以下命令来切换进程： | 命令：用于切换当前活动进程。例如，|1s将切换到进程ID为1的进程。 ~* 命令：用于切换到所有进程中的下一个进程。 ~[] 命令：用于切换到特定索引的进程。例如，~[3]s将切换到索引为3的进程。 请注意，使用这些命令时，要确保已经在调试会话中加载了适当的符号和源代码，并且已经打开了需要调试的进程和线程。","categories":["OS","Windows","Windbg"]},{"title":"winuser说明","path":"/OS/Windows/WinUser/winuser介绍/","content":"Winuser.h 标头 - Win32 apps | Microsoft Learn [toc] winuser 相关函数说明GetSystemMetrics GetSystemMetrics 函数 (winuser.h) - Win32 apps | Microsoft Learn 检索指定的系统指标或系统配置设置。 请注意， GetSystemMetrics 检索的所有维度都以像素为单位。 12int iconWidth = GetSystemMetrics(SM_CXSMICON); // 图标基准宽度 int iconHeight = GetSystemMetrics(SM_CYSMICON); // 图标基准高度","tags":["windows","winuser"],"categories":["OS","Windows","WinUser"]},{"title":"Windbg 基础命令","path":"/OS/Windows/Windbg/Windbg基础命令/","content":"本文介绍windbg中的一些基础命令： [toc] 基础命令 说明 命令 用法 描述 说明 命令 用法 描述 帮助 ? ?? 表达式 显示常规命令计算表达式的值 .help .help 显示元命令(以 . 开头的命令) .hh .hh.hh bp 打开windbg help文档打开windbg help文档，并自动输入bp命令进行搜索 版本 version 显示调试器和调试目标版本 vercommand 显示调试器启动时的命令行 vertarget 显示调试目标系统信息 清空屏幕 .cls 查看异常信息 .ecxr 显示异常信息的上下文 .lastevent 显示最近一次发生的异常信息或事件 .exr -1 显示最近一次的异常记录 !analyze !analyze -v!analyze -hang!analyze -f 显示当前异常信息分析线程栈，看是否有线程blocking其他线程See an exception analysis even when the debugger does not detect an exception. 寄存器 r 显示各寄存器的值 时间 .time 显示system&#x2F;process&#x2F;kernel&#x2F;user time Switch between 32-bit and 64-bit mode !wow64exts.sw.load wow64exts 查看64位机器上生成的32位程序的dmp时，需要使用此命令转换一下模式!wow64exts.help 可查看相关帮助信息 调试命令 命令 说明 示例 g 继续执行 gu 执行到当前函数返回 step out p 单步调试 step over t step into q 结束调试会话&#x2F;退出 .restart 重新启动调试目标 .detach 分离调试目标 .attach 附加到存在的进程，参数为16进制的PID .attach 0x123 .create 创建一个新的进程进行调试 例如调试cmd.exe.create cmd .dbgdbg 启动另一个调试器来调试当前调试器 .opendump 打开dmp文件 .opendump d:\\dump\\360tray.dmp 模块信息 命令 说明 lm 显示加载的模块信息，exe和dll等 lmvm 模块名lm v m 模块名 查看指定模块详细信息，比如查看360tray.exe中加载的appd.dll的信息示例： lmvm appd 调试符号 命令 说明 示例 ld 加载模块的调试符号 ld appdld * ln 搜索相邻符号（距离指定地址最近的符号） ln 722d0000 x 显示匹配参数类型的符号 显示kernel32.dll所有以Create开头的符号x kernel32!Create* .sympath 设置符号文件路径 .sympath d:\\dump .symfix 设置系统符号存放位置 设置系统符号存放位置 .reload Reload symbol information for all modules** 进程 命令 说明 示例 .process 显示当前进程的EPROCESS !process EPROCESS 查看某个线程 !process 0 0 线程 命令 说明 示例 ~ 显示所有线程信息 * [Command]. [Command]~#[Command] 为所有线程执行指定命令为当前线程执行指定命令为导致当前异常或调试事件的线程执行指定命令 查看所有线程的栈信息：~* k Number Number s 显示序号为Number的线程切换当前线程为序号Number的线程 显示10号线程：10切换到10号线程： 10 s ~~[TID] 线程ID为TID的线程 ~ Number n~ Number m SuspendThread 增加线程的挂起计数ResumeThread 减少线程的挂起计数 ~ 10 n~10 m ~ Number f~ Number u Freeze thread 冻结线程Unfreeze thread 解冻线程控制被调试的线程的冻结状态, 与上面两个命令类似（处于冻结状态时恢复目标执行时这个线程不会恢复执行，这个状态是调试器维护的一个状态，执行~ 线程号 n 增加挂起计数后，执行g运行时该线程也不会运行） ~ Number s 在恢复执行命令g前加线程限定符，可以只恢复指定的线程执行（只对该线程调用ResumeThread使其恢复执行，其他线程仍处于挂起状态） !runaway 显示每个线程运行时间，可以方便找到消耗cpu时间长的线程 .ttime display thread times (user + kernel mode) !gle!gle -all displays the last error value for the current thread -&gt;GetLastErrordisplays the last error value for all threads !error decodes and displays information about an error value.Specifies one of the following error codes:Win32WinsockNTSTATUSNetAPI 栈 命令 说明 示例 k 显示EBP，返回地址和源文件信息（如果有私有符号的话） kb 显示EBP，返回地址，函数参数及源文件信息（如果有私有符号的话） k L L选项表示不显示源文件信息，也可以用于其他命令比如 kb L， kv L或写为 kL，kbL，kvL kv 在kb的基础上增加显示FPO（栈指针省略）信息和调用协议（调用协议仅支持On x86-based processors） kpkP 根据私有符号文件中的函数原型信息自动显示参数信息P为大写，表示每个参数占一行 kn 在k命令的基础上，每行前显示栈帧的序号 kn f f选项表示显示每两个相邻栈帧的内存距离，即栈帧基地址的差值 查看&#x2F;修改&#x2F;搜索内存数据 说明 命令 描述 示例 查看内存数据 命令格式：d{a|b|c|d|D|f|p|q|u|w|W} [Options] [Range]dy{b|d} [Options] [Range]d [Options] [Range] da ASCII字符 Range指定要显示的内存范围，有如下几种表示方法：起始地址+终止地址比如：dd 0012fd9c 0012fda8起始地址+L&#x2F;l+元素个数比如：dd 0012fd9c L4 或 dd 0012fd9c l4终止地址+L&#x2F;l+负号+元素个数比如：dd 0012fda8 L-4 或 dd 0012fda8 l-4 du Unicode字符 dc DWORD和ASCII码 dd DWORD dD 双精度浮点数 df 单精度浮点数 dp 指针 dq 四字&#x2F;8字节 dw 一个字&#x2F;2字节 查看局部变量dv [Flags] [Pattern] dv 查看局部变量 dv 02sample!gGlo*dv命令可以带有通配符, 来查看具有某命名模式的变量. dv &#x2F;i 查看局部变量, 并显示符号的类型和参数类型. dv &#x2F;t 查看局部变量, 并显示每个局部变量的数据类型 dv &#x2F;V 查看局部变量, 并显示变量的存储位置 dv &#x2F;V VariableName 查看指定名称的变量 查看复合类型变量 dt Display Type的缩写. 当变量的类型为复合类型, 比如说结构体或者类, 那么dv命令只会显示变量的地址. dt命令可以将一块内存按照某个数据类型来解析, 其中的数据类型需要作为参数被传递给dt命令.-b：递归显示所有子类型-r ：指定显示深度，-r0表示不显示子类型-y：附加搜索选项，只显示某个匹配的字段 编辑内存数据 按字符串方式编辑命令格式：e{a|u|za|zu} Address “String” 其中a和u分别代表不是以0结尾的ASCII和Unicode字符串，za和zu分别代表以0结尾的ASCII和Unicode字符串 ezu 12fc94 “Debug” 修改0012fc94地址的内容为Unicode字符串”Debug” 按数值方式编辑命令格式：e{b|d|D|f|p|q|w} Address [Values] Values指定新的值，如果命令中没有指定该值，则Windbg会以交互式方式让用户输入 ew 12fc94 41 41 41 41 41 将0012fc94地址开始的5个WORD都改为0x41 搜索内存数据 指定范围搜索任何ANSII或UNICODE字符串命令格式：s -[[Flags]] sa|su Range [Flags]用来指定搜索选项：L&#x2F;l+整数 指定字符串的最小长度s 将搜索结果保存起来r 在保存的结果中搜索 Range指定内存范围，写法与d命令的Range参数一样 s -[L5] sa poi(nt!PsInitialSystemProcess) L200在nt!PsInitialSystemProcess变量所指地址开始的512字节（0x200）范围内搜索任何长度不小于5的ANSII字符串 指定内存地址范围内搜索与指定对象相同类型的对象命令格式：s -[[Flags]]v Range Object Object ： Specifies the address of an object or the address of a pointer to an object 指定范围内搜索某一内容模式命令格式：s -[[[Flags]Type]] Range Pattern Type指定要搜索内容的数据类型，即决定匹配搜索内容的方式。取值可以为：b（字节），w（字），d（双字），q（四字），a（ASCII字符串），u（Unicode字符串）。如果不指定，默认为b。 Pattern指定要搜索的内容 s -u 0x400000 L2a000 “AdvDbg”从0x400000开始的2a000范围内搜索Unicode字符串”AdvDbg” 在当前进程的所有模块中进行搜索!for_each_module s-a @#Base @#End “Debugger” 在每个模块中搜索字符串” Debugger”其中@#Base和@#End是!for_each_module定义的别名，其他的还有：@#ModuleName（模块名称），@#SymbolFileName（符号文件名称），@#Size（模块大小），@#SymbolType（符号文件类型） 设置断点 命令 说明 示例 命令 说明 示例 bp 设置断点命令格式： bp[ID号] [Options] [Address [第几次命中断点时中断到调试器]] [“一组命令，用分号隔开”] Options选项可用的值：&#x2F;1 断点被命中一次后自动删除，即一次命中断点&#x2F;p 只用于内核调试中，&#x2F;p后跟一个EPROCESS结构的地址，即对指定的进程设置断点&#x2F;t 只用于内核调试中，&#x2F;t后跟一个ETHREAD结构的地址，即对指定的线程设置断点&#x2F;c 和 &#x2F;C 指定中断给用户的最大函数调用深度和最小函数调用深度举例：bp &#x2F;c5 MSVCR80D!printf 只有当函数调用栈深度浅于5时才中断。 Address表达方式：使用模块名加函数符号：bp LocalVar!FuncC 或带偏移值 bp LocalVar!FuncC+9直接使用内存地址：bp 00401089如果使用完全的调试符号，调试符号中包含源代码行信息，可以用： bp｀模块名!XXX.cpp:行号｀ ， 其中｀为重音符号对于C++的类方法，可以使用类名双冒号(::)或双下划线(__)来连接类名和方法名： bp MyClass::MyMethod 或 bp MyClass__MyMethod 或 bp @@(MyClass::MyMethod) （1）bp LocalVar!FuncC+9 其中 LocalVar为模块名称，FuncC为函数名称，9为偏移 （2）bp 00401089 在指定的地址上下断点 （3）bp MSVCR80D!printf + 3 2 “kv; da poi(ebp+8)” 在printf的入口偏移3的地址处下断点(为了让建立栈帧的代码执行完)，当第2次命中断点时中断到调试器，并自动执行kv和da poi(ebp+8)命令。 其中，da poi(ebp+8)用来显示printf的第一个参数所指定的字符串。 bu 用于对尚未被加载模块中的代码设置断点命令格式： bu[ID号] [Options] [Address [第几次命中断点时中断到调试器]] [“一组命令，用分号隔开”] 对于调试动态加载模块的入口函数和初始化代码比较有用，比如对于即插即用设备的驱动程序。可以使用如下命令在入口函数处设置断点： bu MyDriver!DriverEntry bm 用于设置一批断点命令格式：bm [Options] SymbolPattern [第几次命中断点时中断到调试器] [“一组命令，用分号隔开”] bm命令要求目标模块的调试符号有类型信息，这通常需要私有符号文件，如果对公共符号文件的模块使用bm命令，会提示错误信息。解决这个问题的方法是使用 &#x2F;a 开关，强制针对所有匹配的符号设置断点，无论是数据还是代码，建议只有在确信所有符号是函数时才使用。 bm MSVCR80D!print* 对MSVCR80D中所有print开头的函数设置断点 ba 设置读，写，执行断点命令格式：ba[ID号] Access Size [Options] [Address [第几次命中断点时中断到调试器]] [“一组命令，用分号隔开”]其中Access指定触发断点的访问方式，Size指定访问的长度。 Access的取值如下：e 读取和执行指令时触发断点，即访问代码硬件断点r 读取和写入数据时触发断点w 写入数据时触发断点i 执行I&#x2F;O访问时触发断点 Size的取值如下：对于访问代码硬件断点，它的值应该为1对于x86系统，可以为1，2，4，分别表示1字节访问，字访问和双字访问对于x64系统，可以为1，2，4， 8对于安腾系统，可以为1 - 0x80000000间的任意2次方值 ba r1 0041717c 对地址0041717c的1字节访问，字访问和双字访问（读写）都会触发该断点 bl 列出当前所有断点 bc 断点号 删除断点 断点号可以使用*来通配所有断点，使用 - 来表示一个范围，或者使用逗号来指定多个断点号 bd 断点号 禁用断点 be 断点号 启用断点 sxe ld:[dll名称] 加载某个DLL时下断点 bu wininet!DllMain 与 sxe ld:wininet 效果相同bp kernel32!LoadLibraryW &#x2F;bp kernel32!LoadLibraryA sxe ld:wininet加载wininet时下断点sxe ld:* &#x2F; sxe ud:* 匹配所有DLL模块 sxe ud:[dll名称] 卸载某个DLL时下断点 查看句柄信息 命令 说明 示例 !handle 扩展显示目标系统中一个或所有进程拥有的句柄的信息 !handle 4 f 用’f’表示显示最详细的信息：","tags":["Windows","Windbg"],"categories":["OS","Windows","Windbg"]},{"title":"Win7 使用未签名驱动程序","path":"/OS/Windows/Win7 驱动未签名如何使用/","content":"win7使用未签名驱动程序操作具体方法如下: 1、在 win7 64 位系统上，安装某些驱动程序无法成功时，考虑禁用数字签名，重新启动计算机；这是与 XP 系统不同的地方，XP 系统没有这个功能，不用考虑禁用数字签名； 2、在电脑启动的过程中，不用等到进去输入用户登陆框，按键盘上面的按键 F8，就会出现系统启动项，供我们进行选择； 3、然后选择，禁用数字签名，启动电脑，数字签名被禁用后，驱动就能成功安装了。但是重启电脑之后，设置又会恢复成启用数字签名。有些电脑的禁用，是一次性的； 4、我们也可以强制关闭数字签名，进入系统后，使用管理员，在 CMD 运行器中，输入 bcdedit.exe -set loadoptions DDISABLE_INTEGRITY_CHECKS ；然后会出现禁用成功的提示； 5、再重启电脑，那么系统就会一直默认关闭数字签名了。安装驱动就会成功了。 以上内容就是 win7 64 位系统禁用数字签名的详细步骤，关闭数字签名后，应用程序就可以安装成功了。 可能存在的问题win7 X64 系统中对驱动程序要求有数字签名，否则无法正常使用。但有时需要用到没有数字签名的驱动程序，可正常安装后驱动是无法使用的， 具体表现如下： 1、无法自动识别硬盘控制器 使用非正版的个别操作系统光盘，在安装系统时，容易出现此错误。原因是非正版光盘自动加载的硬盘控制器驱动不符合电脑自身需要的驱动。这种情况就建议换正版光盘安装操作系统。 2、手动更新错误的驱动程序 windows操作系统正常使用，但手动更新驱动程序把硬盘控制器的驱动程序更新错误，导致此故障。解决方法是进入windows系统高级菜单，选择最后一次的正常配置，即可正常进入系统。 3、bios 设置变化后所导致 windows 操作系统正常，但是由于某些原因，用户修改了 bios 设置，导致 0x0000007b 故障。 ①如果只是一次性禁用驱动程序的认证签名，可以在开机时按 F8 键，在弹出的菜单中有 禁用驱动程序签名强制 选项，使用上下键选中之后，再按回车键确认，进入系统即可使用自己的驱动程序更新设备的驱动程序了。 ②尤其是不需要微软的签名驱动程序，还可以这样打开系统属性进行设置： 运行中输入：sysdm.cpl → 确定 ③硬件→设备安装设置 ④从不安装来自 Windows Update 的驱动程序软件→保存更改 建议：使用完毕，再改回使用 Windows Update 更新驱动选项，毕竟很多设备都需要使用微软认证签名的驱动程序。 ⑤还可以使用命令： 开始→所有程序→附件→右键命令提示符→以管理员身份运行 ⑥打开命令提示符，复制以下的命令，右键点击空白处→粘贴→在按回车键： bcdedit.exe -set loadoptions DDISABLE_INTEGRITY_CHECKS 命令正确，有操作成功完成的提示。 ⑦除此之外，还可以在组策略中进行相关设置： 开始→运行→输入： gpedit.msc 回车打开组策略编辑器。 ⑧在窗体左侧选择： 用户配置→管理模板→系统→驱动程序安装→再双击右侧窗口的 设备驱动的代码签名 策略进行设置。 ⑨点选→已启用→这里还有三个选择项：警告、忽略、组织(默认是警告)→确定","tags":["Win7","签名"],"categories":["OS","Windows"]},{"title":"如何让控制台程序不显示界面","path":"/OS/Windows/Visual Studio/控制台程序不显示界面/","content":"[toc] windows控制台程序不显示界面的几种方式要使Windows控制台程序在后台运行，而不显示界面，可以使用以下几种方法： 1. 更改程序的后缀名将程序的后缀名修改为.com或者.pif，这会导致程序在后台运行时不显示控制台窗口。 2. 修改程序的子系统使用Visual Studio等开发工具，将程序的子系统修改为Windows而不是Console。这样可以使程序在后台以窗口应用程序的形式运行。具体步骤如下： 打开项目的属性（右键项目 -&gt; 属性）。 切换到“配置属性” -&gt; “链接器” -&gt; “系统”。 修改“子系统”属性为“Windows (&#x2F;SUBSYSTEM:WINDOWS)”。 编译和运行项目。 使用此方式可能会使程序编译报错： 12错误\tLNK2001\t无法解析的外部符号 _WinMain@16fatal error LNK1120: 1 个无法解析的外部命令 需要在文件中添加以下代码： 12// 设置连接器选项#pragma comment(linker, &quot;/entry:mainCRTStartup&quot;) 使用第三方工具可以使用第三方工具将控制台程序包装成无界面的应用程序。例如，可以使用nssm（Non-Sucking Service Manager）工具将控制台程序安装为服务，并设置该服务在后台运行而不显示界面。 以上是几种常用的方法，可以根据具体需求选择适合的方式来实现控制台程序在后台运行而不显示界面。","tags":["visual studio"],"categories":["OS","Windows","Visual Studio"]},{"title":"C++ 常见错误——无法解析的外部符号","path":"/OS/Windows/Visual Studio/无法解析的外部符号错误处理/","content":"关于C++常见错误“无法解析的外部符号”这一问题如何解决的思考与方法。 本文就使用libevent中遇到的相似问题着手进行分析该如何解决，其他情况仍需按实际情况进行分析处理。常见的原因无外乎缺少编译库。 如上图所示，报错为无法解析的外部符号，符号为 __imp__if_nametoindex@4， 一般这种符号就是缺少导出的接口，导出接口一般为 函数名@导出序号。基本可以确定是缺少一个链接库。其次 出现字符_imp，说明不是真正的静态库，而是某个动态库的导入库，导入函数和自己不同名，所以加了字符_imp。这里可以确定导出函数名为 if_nametoindex； 确定了导出函数名为 if_nametoindex 之后，可以百度查看一下有没有相关函数的信息； 一搜发现为windows系统函数，是网络相关的接口函数，负责将ANSI接口转换为接口的本地索引。其声明需要包含的静态库文件为 Netio.lib。但是笔者这边测试之后发现无法打开 Netio.lib 这个静态库，再查找，找到其相关索引为 IP Helper Functions。 至此，基本上可以确定其缺少的静态库和网络部分相关，找到相关函数（这里查看的函数为 AddIPAddress），查看其函数使用要求，需要引用 Iphlpapi.lib，引入到代码中，编译成功。","tags":["整理","思考","错误"],"categories":["OS","Windows","Visual Studio"]},{"title":"Procmon 过滤用法","path":"/OS/Windows/Procmon用法/","content":"Application Details – Process Name：产生事件的那个进程的名字 – Image Path：进程镜像的完整路径 – Command Line：命令行，用于启动进程 – Company Name：进程镜像文件中的企业名称。这个文本是由应用程序的开发者来定义的 – Description：进程镜像文件中的产品描述信息。这个文本是由应用程序的开发者定义的 – Version：进程镜像文件中的产品版本号。这个文本是由应用程序的开发者定义的 Event Details – Sequence Number：操作在全体事件中的相对位置，也包括当前的过滤 – Event Class：事件的类别（文件，注册表，进程） – Operation：特殊事件操作，比如Read、RegQueryValue等 – Date &amp; Time：操作的日期和时间 – Time of Day：只是操作的时间 – Path：一个事件引用资源的路径 – Detail：事件的附加信息 – Result：一个完成了的操作的状态码 – Relative Time：一个操作相对于Process Monitor的启动后的时间，或者相对于Process Monitor的信息清除后的时间 – Duration：一个已经完成了的操作所持续的时间 Process Management – User Name：正在执行操作的进程的用户账户名 – Session ID：正在执行操作的进程的Windows会话ID – Authentication ID：正在执行操作的进程的登录会话ID – Process ID：执行了操作的进程的进程ID – Thread ID：执行了操作的线程的线程ID – Integrity Level：正在运行的进程执行操作时的可信级别（仅支持Vista以上系统） – Virtualized：执行了操作的进程的虚拟化状态 删除文件 删除 _del. 重命名并删除 trustdservice.exe -&gt; trustservice_del.exe （以下文件均改为”文件名_del.ext”） trustfixservice.exe ServiceDetect.dll libgcommon.dll TrustAgent.exe TrustAgentApp.dll trustcore.dll trustnc.dll trustproxy.dll trustproxyserver.dll trustcheck.exe trustproxy64.sys trustproxy.sys vpnvnic.sys QInstUtils.exe ClientLogTool.exe QtWebEngineProcess.exe TrustAgent.config TrustAgentExtra.config 重命名完成之后会删除以上文件 结束进程 trustservice TrustAgent QtWebEngineProcess trustdservice trustfixservice 释放文件 文件 虚拟网卡驱动 代理驱动 trustservice trustfixservice.exe ServiceDetect.dll libgcommon.dll TrustAgent.exe TrustAgentApp.dll trustcore.dll trustnc.dll trustproxy.dll trustproxyserver.dll trustcheck.exe trustproxy64.sys trustproxy.sys vpnvnic.sys QInstUtils.exe ClientLogTool.exe QtWebEngineProcess.exe 目录 qtdepends oemdepends cert 删除旧的快捷方式 国信安全接入.lnk 青鸾安全接入.lnk TrustAgent.lnk 零信任客户端.lnk 清理路由调用安装目录下 ClearHost.exe 更新配置文件 TrustAgent.config TrustAgentExtra.config 更新注册表注册表路径 1!define PRODUCT_UNINST_KEY &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; 更新字段 DisplayName Publisher DisplayIcon UninstallString DisplayVersion InstallDir ProxyVersion InstParams 配置崩溃状态配置系统LocalDumps，设置相关注册表项 创建快捷方式以更新程序的快捷方式命名为主。 更新 TrustService调用 Trustservice.exe /update 更新。 更新TrustFixService调用 TrustFixservice.exe /update 更新。 启动 TrustService调用 Trustservice.exe /start 更新。 启动 YMDbg.exe直接启动 $INSTALLDIR\\Dbg\\Ymdbg.exe 1Exec YMDbg.exe -i1 刷新 Windows 图标缓存","categories":["OS","Windows"]},{"title":"批处理获取ip到剪切板","path":"/OS/Windows/PowerShell/获取IP到剪切板/","content":"获取当前ip到剪切板 客户端开发远程调试每次都需要获取机器的ip，然后手动填写，较为麻烦，因此简单做了一个可以获取ip到剪切板当中的批处理脚本，可以获取系统当前ip到剪切板中。 [toc] 获取ip获取ip的命令有多种，最终实现就是只要能打印出当前系统ip的命令都可以。 ipconfig route print 以下两个脚本就是从上述两个命令当中获取ip地址： ipconfig1234567@echo offfor /f &quot;tokens=2 delims=:&quot; %%a in (&#x27;ipconfig ^| findstr ^^IPv4&#x27;) do (set IP=%%a)echo %IP%pause route print1234567@echo offfor /f &quot;tokens=4&quot; %%a in (&#x27; route print ^| findstr 0.0.0.0.*0.0.0.0 ^| findstr /v &quot;默认&quot; &#x27;) do (set IP=%%a)echo 你的局域网IP是： %IP%pause for /f的用法： 在For命令语踞饽参数F中，最难理解的就是Delims和Tokens两个选项，本文简单的做一个比较和总拮。“For /f”常用来解析文本，读取字符串。分工上，delims负责切分字符串，而tokens负责提取字符串。如果把字符串当作蛋糕，Delims像刀子，用来切蛋糕，tokens像叉子，用来取切好的蛋糕。 powershell1(ipconfig|select-string &quot;IPv4&quot;|out-string).Split(&quot;:&quot;)[-1] 输入到剪切板剪切板的关键字为：clip 使用 clip \\? 可以查看帮助 1234567891011121314151617c:\\windows\\system32&gt;clip /? clip 描述: 将命令行工具的输出重定向到 windows 剪贴板。这个文本输出可以被粘贴 到其他程序中。 参数列表: /? 显示此帮助消息。 示例: dir | clip 将一份当前目录列表的副本放入 windows 剪贴板。 clip &lt; readme.txt 将 readme.txt 的一份文本放入 windows 剪贴板。 c:\\windows\\system32&gt; 结合以上两个命令，脚本稍微修改一下就能实现获取ip到剪切版的功能。","tags":["windows","批处理","剪切板"],"categories":["OS","Windows","PowerShell"]},{"title":"Visual Studio 通用配置","path":"/OS/Windows/Visual Studio/Visual Stdio 通用配置/","content":"工具集1$(DefaultPlatformToolset) SDK1$([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion(&#x27;Windows&#x27;, &#x27;10.0&#x27;)) Qt 版本需要设置注册表项，值为Qt安装路径 1$(QtPath) 生成事件1call $(SolutionDir)prompt.bat prompt.bat 123456789101112131415@echo offecho -----------------------------------------------------echo [TrustAgent.pro] 文件有更新时，请重新生成当前工程echo 以下配置并不适用于所有人，如有编译报错，请自行修改。echo 1. Qt工具集默认配置为环境变量QtPath: 当前系统QtPath:[%QtPath%] （推荐 5.9.9_msvc2015）echo 2. 工具集默认配置为: $(DefaultPlatformToolset) （推荐 10.0.19041.0及以上）echo 3. SDK默认配置为: $([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion(&#x27;Windows&#x27;, &#x27;10.0&#x27;)) （推荐 V142）echo -----------------------------------------------------@REM if &quot;%QtPath%&quot; == &quot;&quot; (@REM choice /c:yn /m &quot;当前未配置环境变量，是否打开系统配置页面：&quot;@REM if %errorlevel%==1 (@REM start ms-settings:about@REM )@REM )","tags":["Windows","Visual Studio"],"categories":["OS","Windows","Visual Studio"]},{"title":"Visual Studio中MD与MT的区别及运行库类型选择","path":"/OS/Windows/Visual Studio/VisualStudio中MD与MT的区别及运行库类型选择/","content":"[toc] 本篇主要总结一下自己在项目开发过程中经常遇到的一个问题，即Visual Studio编译过程中如何选择运行库的类型。希望对其它开发的伙伴们有一定的参考价值和帮助。 1.在Visual Studio中设置在Visual Studio 2019中，右键项目名称，打开项目属性页，选择“配置属性”-&gt;“C&#x2F;C++”-&gt;“代码生成”-&gt;“运行库”即可对运行库类型进行设置，如下图所示。 这里运行库类型主要包含四种：多线程(&#x2F;MT)、多线程调试(&#x2F;MTd)、多线程DLL(&#x2F;MD)、多线程调试(&#x2F;MDd)。其中带有d的类型是项目的调试版本，不带有d的类型是项目的Release版本。 2. MT与MD的区别 /MT：是multithread-static version，是多线程静态版本的意思，项目会使用运行时库的多线程静态版本，编译器会将LIBCMT.lib放入.obj文件中，以便链接器使用LIBCMT.lib解析外部符号； /MTd：是定义了_DEBUG和/MT，是/MT类型的debug版本； /MD：是multithread-dll version，是多线程dll版本的意思，项目会使用运行时库的多线程动态dll版本，编译器会将MSVCRT.lib放入.obj文件中，在编译项目时，它会静态链接MSVCRT.lib，但在实际运行过程中，它会链接使用MSVCR90.dll； MDd：是定义了_DEBUG和/MD，是/MD类型的debug版本； 因此，我们在编译时，对应的库一定要配套一致。比如你用CMake生成工程文件时，若CMake是用/MT类型生成的，则它所调用的运行时库为LIBCMT.lib；后面生成工程时，你必须也选择/MT类型，否则你选择/MD类型的话，工程在链接时会调用MSVCRT.lib和MSVCR90.dll，显然两次调用不同的运行时库，会出现重定义的错误。 总起来说，/MD类型表示运行时库不集成，生成的文件小，程序运行时动态加载对应的dll；/MT类型表示运行时库集成，生成的文件较大，在链接时将C/C++运行时库集成到程序中。 3. 使用在使用过程中，如果Release模式下使用MD编译的文件报错缺少 MSVCD140。dll，则可以使用 MT 选项编译，解决缺少动态库的问题。","tags":["Windows","Visual Studio"],"categories":["OS","Windows","Visual Studio"]},{"title":"修改网络配置的 InterfaceMetric","path":"/OS/Windows/PowerShell/修改ip接口的跃点数/","content":"使用脚本修改网卡跃点数 InterfaceMetric 使用到的接口 Get-NetIPInterface Set-NetIPInterface Get-NetAdapter 需求描述需要修改当前跃点数为 1 的ip接口，修改其跃点数为 90 解决方案 设置ip接口的跃点数均需要管理员权限 思路一源文件 通过 Get-NetIPInterface 获取需要修改的IP接口 通过 Set-NetIPInterface 修改跃点数 12345678910111213$ChangeIfm = 1$WangToChangeIfm = 90# 获取 InterfaceMetric 为 1 的 -InterfaceIndex$NetCard = (Get-NetIPInterface -InterfaceMetric $ChangeIfm).ifAlias$netInterfaceIndex = (Get-NetIPInterface -AddressFamily IPv4 -InterfaceMetric $ChangeIfm).ifIndexWrite-Output &quot;检索InterfaceMetric为 [$&#123;ChangeIfm&#125;] 列表: `n $&#123;NetCard&#125;&quot;Write-Output &quot;Index 为: $&#123;netInterfaceIndex&#125;&quot;Set-NetIPInterface -InterfaceIndex $netInterfaceIndex -InterfaceMetric $WangToChangeIfmWrite-Output &quot;已修改 $&#123;NetCard&#125; 的 InterfaceMetric 为 $&#123;WangToChangeIfm&#125;&quot; 思路二源文件 使用过滤器筛选需要修改的ip接口，再通过 Set-NetIPInterface 修改跃点数 12345678# 获取 InterfaceMetric 为 1 的 -InterfaceIndex$NetCard = (Get-NetAdapter | Where-Object -FilterScript &#123;$_.ifIndex -eq 10&#125;)Write-Output $NetCardSet-NetIPInterface -InterfaceIndex $NetCard.ifIndex -AddressFamily IPv6 -InterfaceMetric 90 官方demo修改 LinkSpeed 为 100 Mbps 的网络的 InterfaceMetric 为 21 1Get-NetAdapter | Where-Object -FilterScript &#123;$_.LinkSpeed -Eq &quot;100 Mbps&quot;&#125; | Set-NetIPInterface -InterfaceMetric 21 提升管理员权限cmd提权1234567891011@echo off::1 获取管理员权限%1 mshta vbscript:CreateObject(&quot;Shell.Application&quot;).ShellExecute(&quot;cmd.exe&quot;,&quot;/c %~s0 ::&quot;,&quot;&quot;,&quot;runas&quot;,1)(window.close)&amp;&amp;exit::2 执行操作set curpath=%~dp0set file=ModifyIfm.ps1set execPath=%curpath%%file%echo %execPath%powershell.exe -ExecutionPolicy ByPass -File %execPath% powershell 提权1234567if (-Not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] &#x27;Administrator&#x27;)) &#123; if ([int](Get-CimInstance -Class Win32_OperatingSystem | Select-Object -ExpandProperty BuildNumber) -ge 6000) &#123; $Command = &quot;-File `&quot;&quot; + $MyInvocation.MyCommand.Path + &quot;`&quot; &quot; + $MyInvocation.UnboundArguments Start-Process -FilePath PowerShell.exe -Verb RunAs -ArgumentList $Command Exit &#125;&#125; InterfaceMetric 是用于表示网络接口优先级的指标，它用于决定计算机在多个网络接口之间进行网络通信时所选择的默认接口。 在Windows操作系统中，InterfaceMetric是一个用于路由选择和接口优先级的整数值。较低的InterfaceMetric值表示较高的优先级，通常会被选择为默认接口。以下是InterfaceMetric的一些常用数值及其含义： 0：最高优先级。当存在多个可用的接口时，操作系统将优先使用此接口进行网络通信。 5：较高优先级。优先级稍低于0，但仍比较高，通常用于指定首选接口。 10：默认优先级。如果没有特殊指定优先级的情况下，操作系统通常将选择InterfaceMetric为10的接口作为默认接口。 大于10的值：较低优先级。这些值表示接口的优先级较低，只有在没有更高优先级的接口可用时才被选择。 请注意，InterfaceMetric值只在有多个可用的网络接口时才起作用。如果只有一个接口可用，则无论InterfaceMetric的值如何，该接口都将被选择为默认接口。 您可以通过以下步骤在Windows系统中修改接口的InterfaceMetric值： 打开网络连接设置：在Windows搜索栏中输入”控制面板”，打开控制面板后选择”网络和 Internet”，然后选择”网络和共享中心”。 打开适配器设置：在左侧面板中，点击”更改适配器设置”。 找到网络接口：在适配器设置窗口中，找到要修改InterfaceMetric的网络接口，右键点击该接口，然后选择”属性”。 修改接口属性：在接口属性窗口中，选择”Internet 协议版本 4 (TCP&#x2F;IPv4)”（或其他适用的协议版本），然后点击”属性”按钮。 修改InterfaceMetric值：在该接口的属性窗口中，点击”高级”按钮，在”适配器度量”部分，可以手动输入想要设置的InterfaceMetric值（整数）。 保存设置：保存修改后的设置，然后关闭所有窗口。 注意：更改InterfaceMetric值后，可能需要重启计算机或者启用&#x2F;禁用网络接口才能使更改生效。 希望这些信息能帮助您理解InterfaceMetric的含义及其在Windows系统中使用的方式。","categories":["OS","Windows","PowerShell"]},{"title":"清理DNS缓存","path":"/OS/Windows/PowerShell/清理DNS缓存/","content":"在Windows系统上清理DNS缓存有几种方法，以下是其中两种常用的方法： 方法一：使用ipconfig命令 打开命令提示符：按下Win + R键，在运行对话框中输入cmd，然后按下回车键。 在命令提示符窗口中，输入以下命令并按下回车键： 1ipconfig /flushdns 这将清除本地计算机上的DNS缓存。 在命令提示符窗口中，您将看到一条消息提示”DNS Resolver Cache successfully flushed”，表明DNS缓存已成功清除。 方法二：使用命令提示符和netsh命令 打开命令提示符：按下Win + R键，在运行对话框中输入cmd，然后按下回车键。 在命令提示符窗口中，输入以下命令并按下回车键： 1netsh winsock reset 这将重置Winsock目录，并清除DNS缓存。 在命令提示符窗口中，您将看到一条消息提示”Successfully reset the Winsock Catalog”，表明Winsock目录已成功重置。 在命令提示符窗口中，输入以下命令并按下回车键： 1ipconfig /flushdns 这将清除本地计算机上的DNS缓存。 在命令提示符窗口中，您将看到一条消息提示”DNS Resolver Cache successfully flushed”，表明DNS缓存已成功清除。 无论使用哪种方法，都需要以管理员权限运行命令提示符窗口（右键点击命令提示符图标，选择”以管理员身份运行”）才能执行清除DNS缓存的命令。 希望这些步骤能够帮助您清理Windows系统上的DNS缓存。","categories":["OS","Windows","PowerShell"]},{"title":"LoadLibrary加载失败，返回126","path":"/OS/Windows/GetLastError/126/","content":"[toc] 问题描述：在某一个windows环境中，安装了一个服务d，服务d的启动依赖于一个关键的dll文件(info.dll)，一直服务进程的dll也存在，但是在服务启动的时候，使用 LoadLibrary 函数会返回GetLastError 126。 排查手段记录已经尝试过的排查手段包括但不限于： 使用绝对路径加载dll1234// oldLoadLibrary(&quot;info.dll&quot;);// newLoadLibrary(&quot;C:\\\\info.dll&quot;); 问题关键","tags":["Windows","GetLastError","LoadLibrary"],"categories":["OS","Windows","GetLastError"]},{"title":"FormatMessage函数的使用","path":"/OS/Windows/FormatErrMessage/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344const char* SPErrMsg(int errcode)&#123; static char _g_inner_msg[1024]; memset(_g_inner_msg, 0, sizeof(_g_inner_msg));#if SP_PLATFORM==SP_PLATFORM_WINDOWS if (0==errcode) &#123; errcode = GetLastError(); &#125; LPTSTR buf = NULL; if (::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errcode, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) /* MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT) */, (LPTSTR)&amp;buf, 0, NULL)) &#123; // DWORD language_id // MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT) // MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) // MAKELANGID(LANG_CHINESE_SIMPLIFIED, SUBLANG_CHINESE_SIMPLIFIED) // MAKELANGID(LANG_CHINESE_TRADITIONAL, SUBLANG_CHINESE_TRADITIONAL) int len = snprintf(_g_inner_msg, sizeof(_g_inner_msg), &quot; [%d]%s&quot;, errcode, buf); if ( len&gt;2 &amp;&amp; _g_inner_msg[len-1]==&#x27; &#x27; &amp;&amp; _g_inner_msg[len-2]==&#x27;\\r&#x27; ) &#123; _g_inner_msg[len - 1] = &#x27;\\0&#x27;; _g_inner_msg[len - 2] = &#x27;\\0&#x27;; &#125; ::LocalFree(buf); &#125; else &#123; snprintf(_g_inner_msg, sizeof(_g_inner_msg), &quot; [%d]Unknown error %d&quot;, errcode, errcode); &#125;#else // https://stackoverflow.com/questions/3219393/stdlib-and-colored-output-in-c if (0==errcode) &#123; errcode = errno; errno = errcode; &#125; snprintf(_g_inner_msg, sizeof(_g_inner_msg), &quot; [%d]%s&quot;, (int)errcode, strerror(errcode));#endif return (_g_inner_msg);&#125;","tags":["windows"],"categories":["OS","Windows"]},{"title":"加载动态库 (loadlibrary)","path":"/OS/Windows/API_加载动态库/","content":"[toc] 加载 using的用法参考 使用using起别名 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &quot;PipeIPC/PipeIPC.h&quot;int main()&#123; std::cout &lt;&lt; &quot;--- DLL Test --- &quot;; HINSTANCE hDLL; // Handle to DLL using Face = int * (*)(int,int); hDLL = LoadLibrary(L&quot;mydll.dll&quot;); if (hDLL != NULL) &#123; Face faceSum = (Face)GetProcAddress(hDLL, &quot;mySum&quot;); if (!faceSum) &#123; // handle the error FreeLibrary(hDLL); return 0; &#125; else &#123; // call the function faceSum(1,1); &#125; &#125; return 0;&#125; 生成动态库dllmain.cpp1234567891011121314151617181920212223#ifdef __cplusplusextern &quot;C&quot;&#123;#endif #define MYIMAPI extern &quot;C&quot; __declspec(dllimport)#define MYEXAPI extern &quot;C&quot; __declspec(dllexport)#ifdef __cplusplus&#125;#endifMYEXAPI int Add(int numa, int numb)&#123; return numa + numb;&#125;MYEXAPI int Sub(int numa, int numb)&#123;\treturn (numa - numb);&#125;","tags":["Windows","DLL"],"categories":["OS","Windows"]},{"title":"windows 查看进程启动参数命令行","path":"/OS/Windows/CommandstartProcess/","content":"Windows 查看进程启动参数命令行使用wmic查看1wmic process where caption=&quot;【进程名】&quot; get caption,commandline /value 也可以通过打印所有的命令行参数之后进行筛选 1wmic process get caption,commandline /value | findstr &quot;【进程名，特征字符串等】&quot; 使用任务管理器查看打开任务管理器，在详细信息栏，右击标题列-&gt;选择列，找到命令行，勾选即可。","tags":["cmd","Windows"],"categories":["OS","Windows"]},{"title":"windows 系统获取系统主机域名","path":"/OS/Windows/API/获取系统域名/","content":"概述：windows操作系统下获取主机域名 1234567891011121314151617181920212223242526272829303132333435363738// GetDominName.cpp : 获取主机域名//#include &lt;Windows.h&gt;#include &lt;DSRole.h&gt;#pragma comment(lib, &quot;netapi32.lib&quot;)#include &lt;stdio.h&gt;int main(int argc, char ** argv)&#123;\tDSROLE_PRIMARY_DOMAIN_INFO_BASIC * info;\tDWORD dw;\tdw = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *)&amp;info);\tif (dw != ERROR_SUCCESS)\t&#123; wprintf(L&quot;DsRoleGetPrimaryDomainInformation: %u &quot;, dw); return dw;\t&#125;\tif (info-&gt;DomainNameDns == NULL)\t&#123; wprintf(L&quot;DomainNameDns is NULL &quot;);\t&#125;\telse\t&#123; wprintf(L&quot;DomainNameDns: %s &quot;, info-&gt;DomainNameDns);\t&#125;\tsystem(&quot;pause&quot;);\treturn 0;&#125; 输出示例：","tags":["windows","winapi"],"categories":["OS","Windows","API"]},{"title":"删除文件夹下所有文件","path":"/OS/Windows/API/删除文件目录下的所有文件/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// moveLogs.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;windows.h&gt;#include &lt;winbase.h&gt;#include &lt;WinUser.h&gt;#include &lt;strsafe.h&gt;#include &lt;ShObjIdl.h&gt;#include &lt;cstring&gt;#include &lt;shlobj.h&gt;#include &lt;comutil.h&gt; #include &lt;io.h&gt;#pragma comment(lib, &quot;comsuppw.lib&quot;)#pragma comment(linker, &quot;/entry:mainCRTStartup&quot;) bool _SetFileRebootDelete(const std::string&amp; file_path) &#123;\tif (MoveFileExA(file_path.c_str(), 0, MOVEFILE_DELAY_UNTIL_REBOOT)) &#123; // MessageBoxA(NULL, &quot;成功！&quot;, &quot;设置成功！&quot;, MB_OK); return true;\t&#125;\telse &#123; // MessageBoxA(NULL, &quot;失败！&quot;, &quot;设置失败！&quot;, MB_OK); return false;\t&#125;&#125;void getFiles(std::string path, std::vector&lt;std::string&gt;&amp; files, std::vector&lt;std::string&gt;&amp; names)&#123;\t//文件句柄，win10用long long，win7用long就可以了\tlong hFile = 0;\t//文件信息 struct _finddata_t fileinfo;\tstd::string p;\tif ((hFile = _findfirst(p.assign(path).append(&quot;\\\\*&quot;).c_str(), &amp;fileinfo)) != -1)\t&#123; do &#123; //如果是目录,迭代之 //如果不是,加入列表 if ((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if (strcmp(fileinfo.name, &quot;.&quot;) != 0 &amp;&amp; strcmp(fileinfo.name, &quot;..&quot;) != 0) &#123; getFiles(p.assign(path).append(&quot;\\\\&quot;).append(fileinfo.name), files, names); &#125; &#125; else &#123; files.push_back(p.assign(path).append(&quot;\\\\&quot;).append(fileinfo.name)); names.push_back(fileinfo.name); &#125; &#125; while (_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile);\t&#125;&#125;std::string GetLoactionDir()&#123;\tDWORD dwLen = 0;\tCHAR szAppDataDir[MAX_PATH];\tdwLen = ExpandEnvironmentStringsA(&quot;%programdata%&quot;, szAppDataDir, MAX_PATH);\tif (dwLen != 0) &#123; StringCchCatA(szAppDataDir, sizeof(szAppDataDir), (&quot;\\\\TrustAgent\\\\logs&quot;));\t&#125;\treturn szAppDataDir;&#125;int main()&#123; using namespace std;\tstd::string filepath = GetLoactionDir();\tvector&lt;string&gt; files;\tvector&lt;string&gt; names;\tgetFiles(filepath, files, names);\tfor (int i = 0; i &lt; files.size(); i++)\t&#123; printf(&quot;-----========files:%d========--- &quot;, i); // cout &lt;&lt; &quot;files&quot; &lt;&lt; i &lt;&lt; &#x27;:&#x27; &lt;&lt; files[i] &lt;&lt; endl; // wstring wsName; // wsName = string2wstring(files[i]); cout &lt;&lt; &quot;lnkPath: &quot; &lt;&lt; files[i] &lt;&lt; endl; // wstring wsDestPath = getLnkFormPath(wsName); // cout &lt;&lt; &quot;destPath:&quot;; // wcout &lt;&lt; wsDestPath; // cout &lt;&lt; endl; _SetFileRebootDelete(files[i]);\t&#125; return 0;&#125;// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单// 调试程序: F5 或调试 &gt;“开始调试”菜单// 入门使用技巧: // 1. 使用解决方案资源管理器窗口添加/管理文件// 2. 使用团队资源管理器窗口连接到源代码管理// 3. 使用输出窗口查看生成输出和其他消息// 4. 使用错误列表窗口查看错误// 5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目// 6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件","tags":["删除文件","API"],"categories":["OS","Windows","API"]},{"title":"FormatMessageA","path":"/OS/Windows/API/FormatMessageA/","content":"1234567891011121314151617181920212223242526272829string get_sys_error_msg(unsigned long err)&#123;\tchar _inner_msg[10240] = &#123; 0 &#125;;\tmemset(_inner_msg, 0, sizeof(_inner_msg));\tif (err == 0) err = GetLastError();\tLPSTR buf = NULL;\tif (::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, err, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), (LPSTR)&amp;buf, 0, NULL))\t&#123; sprintf_s(_inner_msg, sizeof(_inner_msg),&quot;[%d]%s&quot;, err, buf); ::LocalFree(buf);\t&#125;\telse\t&#123; snprintf(_inner_msg, sizeof(_inner_msg), &quot; [0x%x]Unknown error&quot;, err);\t&#125;\tstring str_error_msg(_inner_msg);\treturn str_error_msg;&#125;","categories":["OS","Windows","API"]},{"title":"ShellExecute","path":"/OS/Windows/API/ShellExecute/","content":"概述： ShellExecute 用法的整理和示例官方说明：shellExecuteA 函数 (shellapi.h) - Win32 apps | Microsoft Learn 一个完整的用法示例以下示例为一个完整的用法展示，实现了调用第三方工具 devocn.exe 安装虚拟网卡（不展示安装界面）并通过获取安装进程句柄判断安装结果。 SEE_MASK_NOCLOSEPROCESS 参数：表示要获取进程句柄 通过 GetExitCodeProcess 函数获取进程执行状态 SW_HIDE 参数: 不展示窗口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#define QREINSTALL_NETCARD_TOOLS_NAME L&quot;devcon.exe&quot;std::mutex g_mutex_nc_install;bool InstallNcDrive(bool &amp;bRes, bool &amp;bEnd)\t&#123; std::lock_guard&lt;std::mutex&gt; lock(g_mutex_nc_install); bool bOptRt = false; //触发重新安装虚拟网卡 TCHAR szPath[MAX_PATH]; ::GetModuleFileName(NULL, szPath, MAX_PATH); ::PathRemoveFileSpec(szPath); QLOG_INFO() &lt;&lt; &quot;tools[devcon.exe]&#x27;s path is&quot; &lt;&lt; QString::fromWCharArray(szPath); std::string command = &quot; install vpnvnic.inf vpnvnic&quot;; SHELLEXECUTEINFO ShExecInfoInstall = &#123; 0 &#125;; try &#123; ShExecInfoInstall.cbSize = sizeof(SHELLEXECUTEINFO); ShExecInfoInstall.fMask = SEE_MASK_NOCLOSEPROCESS; ShExecInfoInstall.hwnd = NULL; if (!isProcessAdmin()) &#123; ShExecInfoInstall.lpVerb = L&quot;runas&quot;; &#125; else &#123; ShExecInfoInstall.lpVerb = L&quot;open&quot;; &#125; ShExecInfoInstall.lpFile = QREINSTALL_NETCARD_TOOLS_NAME; ShExecInfoInstall.lpParameters = STDString2LPCWCH(command); ShExecInfoInstall.lpDirectory = szPath; ShExecInfoInstall.nShow = SW_HIDE; ShExecInfoInstall.hInstApp = NULL; ShExecInfoInstall.hProcess = NULL; bOptRt = ShellExecuteEx(&amp;ShExecInfoInstall); if (bOptRt) &#123; QLOG_INFO() &lt;&lt; &quot;驱动安装进程已启动！&quot;; // 等待进程结束 WaitForSingleObject(ShExecInfoInstall.hProcess, INFINITE); // 获取退出代码 DWORD exitCode; if (GetExitCodeProcess(ShExecInfoInstall.hProcess, &amp;exitCode)) &#123; // 判断进程是否成功退出 if (exitCode != STILL_ACTIVE) &#123; QLOG_INFO() &lt;&lt; &quot;驱动安装进程已退出，退出代码: &quot; &lt;&lt; exitCode; &#125; else &#123; QLOG_INFO() &lt;&lt; &quot;驱动安装进程未能正常退出，退出代码: &quot; &lt;&lt; exitCode; &#125; &#125; else &#123; QLOG_INFO() &lt;&lt; &quot;获取驱动安装进程退出代码失败！错误代码: &quot; &lt;&lt; GetLastError(); &#125; // 实测 1和0 的时候安装成功 bRes = exitCode == 1 || exitCode == 0 ? true : false; // 关闭句柄 CloseHandle(ShExecInfoInstall.hProcess); &#125; else &#123; QLOG_ERROR() &lt;&lt; &quot;启动驱动安装进程失败！错误代码: &quot; &lt;&lt; GetLastError(); &#125; &#125; catch (const std::exception&amp; e) &#123; QLOG_ERROR() &lt;&lt; __FUNCTION__ &lt;&lt; __LINE__ &lt;&lt; e.what(); bEnd = true; return bOptRt; &#125; bEnd = true; return bOptRt;&#125;","tags":["windows","winapi"],"categories":["OS","Windows","API"]},{"title":"Xcode 下载与安装","path":"/OS/Mac/Xcode/","content":"下载后得到 xip 文件 如 ： Xcode_13.xip 可以使用解压缩软件进行解压，如果有些压缩软件不支持会提示破损，可以考虑直接在命令行解压。 第一步：cd 到下载的目录 第二步：xip -x Xcode_13.xip 此时，会有一个很奇怪的提示，会误以为报错。 xip: signing certificate was “Software Update” (validation not attempted) 主要是 xcode 文件太大导致的，可以耐心多等待几分钟，将会收到以下信息： xip: expanded items from “&#x2F;Users&#x2F;ivychen&#x2F;Documents&#x2F;Xcode_13.xip” 将得到 Xcode 程序文件，将其拖动到访达的 Application 文件夹即可。","tags":["Mac","Xcode"],"categories":["OS","Mac"]},{"title":"Linux 进程管理","path":"/OS/Linux/操作系统及Linux内核/6 Linux进程管理/","content":"查看进程的运行状态 进程的结束控制 进程的执行顺序 [toc] 1 进程的查看不管在测试的时候、在实际的生产环境中，还是自己的使用过程中，难免会遇到一些进程异常的情况，所以 Linux 为我们提供了一些工具来查看进程的状态信息。我们可以通过 top 实时的查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查看当前的进程信息，同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。 1.1 top工具的使用","tags":["Linux","进程"],"categories":["OS","Linux","操作系统及Linux内核"]},{"title":"Linux进程概念","path":"/OS/Linux/操作系统及Linux内核/5 Linux进程概念/","content":"进程与程序 进程的衍生 工作管理 [toc] 1 概念理解首先程序与进程是什么？程序与进程又有什么区别？ 程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。 进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。 简单来说，程序是为了完成某种任务而设计的软件，比如 vim 是程序。什么是进程呢？进程就是运行中的程序。 程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性： 动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。 并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。 独立性：进程可以独立分配资源，独立接受调度，独立地运行。 异步性：进程以不可预知的速度向前推进。 结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。 并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过） 并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行 引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。 而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。就如下图所示： 2 进程的属性2.1 进程的分类 第一个角度来看，我们可以分为用户进程与系统进程： 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。 系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。 第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。 守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。 2.2 进程的衍生进程有这么多的种类，那么进程之间定是有相关性的，而这些有关联性的进程又是如何产生的，如何衍生的？ 就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？ 我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？ 关于父进程与子进程便会提及这两个系统调用 fork() 与 exec() fork-exec是由 Dennis M. Ritchie 创造的 fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等 exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段 子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少，感兴趣的同学可以查查为什么。 这就是子进程产生的由来。简单的实现逻辑就如下方所示【注释１】 123456789pid_t p;p = fork();if (p == (pid_t) -1) /* ERROR */else if (p == 0) /* CHILD */else /* PARENT */ 既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。 在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。 如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。（ ps 命令将在后续详解） 正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。 虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。 另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。 进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID&#x3D;1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。 通过以下的命令我们可以很明显的看到这样的结构 1pstree 或者从此图我们可以更加形象的看清子父进程的关系 通过以上的显示结果我们可以看的很清楚，init 为所有进程的父进程或者说是祖先进程 我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的 1ps －fxo user,ppid,pid,pgid,command 可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的 使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解） 就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶 2.3 进程组与Sessions每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。 一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。 与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的， Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。 前台（foreground）就是在终端中运行，能与你有交互的 后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程 2.4 工作管理bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。 并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job 我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它，但是若是在后台的话就不行了。 我们可以通过 &amp; 这个符号，让我们的命令在后台中运行 1ls &amp; 图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。 我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去 被停止并放置在后台的工作我们可以使用这个命令来查看 1jobs 其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令 我们可以通过这样的一个命令将后台的工作拿到前台来 123#后面不加参数提取预设工作，加参数提取指定工作的编号#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %fg [%jobnumber] 之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令 12#与fg类似，加参则指定，不加参则取预设bg [%jobnumber] 既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等 12345#kill的使用格式如下kill -signal %jobnumber#signal从1-64个信号值可以选择，可以这样查看kill －l 其中常用的有这些信号值 信号值 作用 -1 重新读取参数运行，类似与restart -2 如同 ctrl+c 的操作退出 -9 强制终止该任务 -15 正常的方式终止该任务 注意 若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作 若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID","tags":["Linux","进程"],"categories":["OS","Linux","操作系统及Linux内核"]},{"title":"Linux 导读大纲","path":"/OS/Linux/readme/","content":"命令行和工具 Linux基础入门 Linux内核分析配套实验 Linux RPC","tags":["Linux","导读"],"categories":["OS","Linux"]},{"title":"Linux RPC","path":"/OS/Linux/RPC/Linux_RPC/","content":"","tags":["linux","rpc"],"categories":["OS","Linux","RPC"]},{"title":"5 环境变量与文件查找","path":"/OS/Linux/Linux基础入门/5 环境变量与文件查找/","content":"[toc] 1. 环境变量简单理解了变量的概念，就很容易理解环境变量了。环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。 通常我们会涉及到的变量类型有三种： 当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。 Shell 本身内建的变量。 从自定义变量导出的环境变量。 也有三个与上述三种环境变量相关的命令：set，env，export。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表： 命 令 说 明 set 显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。 env 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。 export 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。 你可以更直观的使用 vimdiff 工具比较一下它们之间的差别： 12345temp=shiyanlouexport temp_env=shiyanlouenv|sort&gt;env.txtexport|sort&gt;export.txtset|sort&gt;set.txt 上述操作将命令输出通过管道 | 使用 sort 命令排序，再重定向到对象文本文件中。管道的概念后面我们会学到，现在你知道这是什么意思就行了。 1vimdiff env.txt export.txt set.txt 使用 vimdiff 工具比较导出的几个文件的内容，退出 vimdiff 需要按下 Esc 后输入 :q 即可退出。 关于哪些变量是环境变量，可以简单地理解成在当前进程的子进程有效则为环境变量，否则不是（有些人也将所有变量统称为环境变量，只是以全局环境变量和局部环境变量进行区分，我们只要理解它们的实质区别即可）。我们这里用 export 命令来体会一下，先在 Shell 中设置一个变量 temp=shiyanlou，然后再新创建一个子 Shell 查看 temp 变量的值： 注意：为了与普通变量区分，通常我们习惯将环境变量名设为大写。 永久生效但是问题来了，当你关机后，或者关闭当前的 shell 之后，环境变量就没了啊。怎么才能让环境变量永久生效呢？ 按变量的生存周期来划分，Linux 变量可分为两类： 永久的：需要修改配置文件，变量永久生效； 临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。 这里介绍两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件： 123# .profile 可以用 ls -a 查看cd /home/shiyanlouls -a 这个 .profile 只对当前用户永久生效。因为它保存在当前用户的 Home 目录下，当切换用户时，工作目录可能一并被切换到对应的目录中，这个文件就无法生效。而写在 /etc/profile 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 /etc/profile，在最后加上你想添加的环境变量就好啦。 1. 命令的查找路径与顺序查看 PATH 环境变量的内容： 1echo $PATH 默认情况下你会看到如下输出： 1/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games 如果你还记得 Linux 目录结构那一节的内容，你就应该知道上面这些目录下放的是哪一类文件了。通常这一类目录下放的都是可执行文件，当我们在 Shell 中执行一个命令时，系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。 2 添加自定义路径到 PATH 环境变量在前面我们应该注意到 PATH 里面的路径是以 : 作为分割符的，所以我们可以这样添加自定义路径： 1PATH=$PATH:/home/shiyanlou/mybin 注意这里一定要使用绝对路径。 3 修改和删除已有变量变量修改变量的修改有以下几种方式： 变量设置方式 说明 $&#123;变量名#匹配字串&#125; 从头向后开始匹配，删除符合匹配字串的最短数据 $&#123;变量名##匹配字串&#125; 从头向后开始匹配，删除符合匹配字串的最长数据 $&#123;变量名%匹配字串&#125; 从尾向前开始匹配，删除符合匹配字串的最短数据 $&#123;变量名%%匹配字串&#125; 从尾向前开始匹配，删除符合匹配字串的最长数据 $&#123;变量名/旧的字串/新的字串&#125; 将符合旧字串的第一个字串替换为新的字串 $&#123;变量名//旧的字串/新的字串&#125; 将符合旧字串的全部字串替换为新的字串 比如我们可以修改前面添加到 PATH 的环境变量，将添加的 mybin 目录从环境变量里删除。为了避免操作失误导致命令找不到，我们先将 PATH 赋值给一个新的自定义变量 mypath： 12345mypath=$PATHecho $mypathmypath=$&#123;mypath%/home/shiyanlou/mybin&#125;# 或使用通配符 * 表示任意多个任意字符mypath=$&#123;mypath%*/mybin&#125; 可以看到路径已经不存在了。 变量删除可以使用 unset 命令删除一个环境变量： 1unset mypath 4 让环境变量立即生效前面我们在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 .zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 source 命令来让其立即生效，如： 12cd /home/shiyanlousource .zshrc source 命令还有一个别名就是 .，上面的命令如果替换成 . 的方式就该是： 1. ./.zshrc 在使用 . 的时候，需要注意与表示当前路径的那个点区分开。 注意第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。 2 搜索文件与搜索相关的命令常用的有 whereis，which，find 和 locate。 whereis 简单快速 12whereis whowhereis find 你会看到 whereis find 找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。 whereis 只能搜索二进制文件（-b），man 帮助文件（-m）和源代码文件（-s）。如果想要获得更全面的搜索结果可以使用 locate 命令。 locate 快而全 使用 locate 命令查找文件也不会遍历硬盘，它通过查询 /var/lib/mlocate/mlocate.db 数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令来更新数据库。所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。注意这个命令也不是内置的命令，在部分环境中需要手动安装，然后执行更新。 123sudo apt-get updatesudo apt-get install locatesudo updatedb 它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件： 1locate /etc/sh 注意，它不只是在 &#x2F;etc 目录下查找，还会自动递归子目录进行查找。 查找 /usr/share/ 下所有 jpg 文件： 1locate /usr/share/*.jpg 环境里使用 zsh，在 ~/.zshrc 文件里添加了 setopt nonomatch 配置，这样就不会自动处理和修复命令，因此可以不使用 \\ 转义。如果其他环境中执行该命令提示 zsh: no matches found: /usr/share/*.jpg，则可以在 .zshrc 中添加上述配置，或者使用 \\ 转义。 如果想只统计数目可以加上 -c 参数，-i 参数可以忽略大小写进行查找，whereis 的 -b、-m、-s 同样可以使用。 which 小而精 which 本身是 Shell 内建的一个命令，我们通常使用 which 来确定是否安装了某个指定的程序，因为它只从 PATH 环境变量指定的路径中去搜索命令并且返回第一个搜索到的结果。也就是说，我们可以看到某个系统命令是否存在以及执行的到底是哪一个地方的命令。 123which manwhich nginxwhich ping find 精而细 find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。find 命令强大到，要把它讲明白至少需要单独好几节课程才行，我们这里只介绍一些常用的内容。 这条命令表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式，千万记住 find 的第一个参数是要搜索的地方。命令前面加上 sudo 是因为 shiyanlou 只是普通用户，对 /etc 目录下的很多文件都没有访问的权限，如果是 root 用户则不用使用。 1sudo find /etc/ -name interfaces 注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。 与时间相关的命令参数： 参数 说明 -atime 最后访问时间 -ctime 最后修改文件内容的时间 -mtime 最后修改文件属性的时间 下面以 -mtime 参数举例： -mtime n：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件 -mtime +n：列出在 n 天之前（不包含 n 天本身）被修改过的文件 -mtime -n：列出在 n 天之内（包含 n 天本身）被修改过的文件 -newer file：file 为一个已存在的文件，列出比 file 还要新的文件名 列出 home 目录中，当天（24 小时之内）有改动的文件： 1find ~ -mtime 0 列出用户家目录下比 &#x2F;etc 目录新的文件： 1find ~ -newer /etc","tags":["Linux"],"categories":["OS","Linux","Linux基础入门"]},{"title":"Linux 基础入门","path":"/OS/Linux/Linux基础入门/Readme/","content":"实验楼 Linux 基础入门学习整理 linux 基础入门 5 环境变量与文件查找 15 Linux 进程概念","tags":["Linux","内核"],"categories":["OS","Linux","Linux基础入门"]},{"title":"Linux 内核分析配套实验","path":"/OS/Linux/Linux内核分析配套实验/Readme/","content":"linux 内核分析配套实验学习记录本节记录实验楼Linux内核学习记录 1 完成一个简单的时间片轮转躲到程序内核代码 2 跟踪分析Linux内核的启动过程","tags":["Linux","内核"],"categories":["OS","Linux","Linux内核分析配套实验"]},{"title":"Linux基础入门15 Linux进程概念","path":"/OS/Linux/Linux基础入门/15 Linux 进程概念/","content":"Linux 进程概念 [toc] 1 概念的理解首先程序与进程是什么？程序与进程又有什么区别？ 程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。 进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的 UNIX、Linux 2.4 及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。 简单来说，程序是为了完成某种任务而设计的软件，比如 vim 是程序。什么是进程呢？进程就是运行中的程序。 程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性： 动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。 并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。 独立性：进程可以独立分配资源，独立接受调度，独立地运行。 异步性：进程以不可预知的速度向前推进。 结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。 并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过） 并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行 引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运作，也可以有交互（独立性、并发性）。 而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6 及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。 简而言之，一个程序至少有一个进程，一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 2 进程的属性2.1 进程的分类大概明白进程是个什么样的存在后，我们需要进一步了解的就是进程分类。可以从两个角度来分： 以进程的功能与服务的对象来分； 以应用程序的服务类型来分； 第一个角度来看，我们可以分为用户进程与系统进程： 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。 系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。 第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程： 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。 守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。 2.2 进程的衍生进程有这么多的种类，那么进程之间定是有相关性的，而这些有关联性的进程又是如何产生的，如何衍生的？ 就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？ 我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？ 关于父进程与子进程便会提及这两个系统调用 fork() 与 exec() fork-exec是由 Dennis M. Ritchie 创造的 fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等 exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段 子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork()，效率高了不少，感兴趣的同学可以查查为什么。 这就是子进程产生的由来。简单的实现逻辑就如下方所示： 123456789pid_t p;p = fork();if (p == (pid_t) -1) /* ERROR */else if (p == 0) /* CHILD */else /* PARENT */ 既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。 在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。 如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。（ ps 命令将在后续详解） 正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。 虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。 另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。 进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件，而该进程就是 PID&#x3D;1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。 通过以下的命令我们可以很明显的看到这样的结构 1pstree 或者从此图我们可以更加形象的看清子父进程的关系 通过以上的显示结果我们可以看的很清楚，init 为所有进程的父进程或者说是祖先进程 我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的 1ps －fxo user,ppid,pid,pgid,command 可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的 使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程，而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解） 就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶 2.3 进程组与Sessions每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。 一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者，也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的 PGID，直到进程组中最后一个进程终结。 与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的， Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。 前台（foreground）就是在终端中运行，能与你有交互的 后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程 2.4 工作管理bash(Bourne-Again shell)支持工作控制（job control），而 sh（Bourne shell）并不支持。 并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job 我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它，但是若是在后台的话就不行了。 我们可以通过 &amp; 这个符号，让我们的命令在后台中运行： 1ls &amp; 图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。 我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去 被停止并放置在后台的工作我们可以使用这个命令来查看： 1jobs 其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令。 我们可以通过这样的一个命令将后台的工作拿到前台来： 123# 后面不加参数提取预设工作，加参数提取指定工作的编号# ubuntu 在 zsh 中需要 %，在 bash 中不需要 %fg [%jobnumber] 之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令： 12#与fg类似，加参则指定，不加参则取预设bg [%jobnumber] 既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等。 12345# kill的使用格式如下kill -signal %jobnumber# signal从1-64个信号值可以选择，可以这样查看kill －l 其中常用的有这些信号值 信号值 作用 -1 重新读取参数运行，类似与 restart -2 如同 ctrl+c 的操作退出 -9 强制终止该任务 -15 正常的方式终止该任务 若是在使用 kill ＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作。 若是在使用 kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID。","tags":["Linux","进程与程序","进程的衍生","工作管理"],"categories":["OS","Linux","Linux基础入门"]},{"title":"linux 内核1 完成一个简单的时间片轮转躲到程序内核代码","path":"/OS/Linux/Linux内核分析配套实验/1 完成一个简单的时间片轮转躲到程序内核代码/","content":"使用实验楼的虚拟机打开 shell 12345678910111213# 注意路径是区分大小的$ cd ~/LinuxKernel/linux-3.9.4$ rm -rf mykernel$ patch -p1 &lt; ../mykernel_for_linux3.9.4sc.patch$ make allnoconfig# 编译内核请耐心等待$ make$ qemu -kernel arch/x86/boot/bzImage 然后 cd mykernel 您可以看到 qemu 窗口输出的内容的代码 mymain.c 和 myinterrupt.c 注意：修改代码后需要 make 重新编译之后才能生效哦。 使用自己的 Linux 系统环境搭建过程参见 mykernel，其中也可以找到一个简单的时间片轮转多道程序内核代码","tags":["linux","内核"],"categories":["OS","Linux","Linux内核分析配套实验"]},{"title":"Linux终端工具——zsh","path":"/OS/Linux/Command&Tools/zsh/","content":"[toc] zsh安装 查看当前系统装了哪些shell 1cat /etc/shell 当前正在运行的是哪个版本的shell 1echo $SHELL 安装zsh 1sudo apt-get -y install zsh 切换zsh 1chsh -s /bin/zsh（非实时，需重启） 查看zsh的主题有哪些 1ls ~/.oh-my-zsh/themes/","tags":["linux","shell","zsh"],"categories":["OS","Linux","Command&Tools"]},{"title":"Linux内核2 跟踪分析Linux内核的启动过程","path":"/OS/Linux/Linux内核分析配套实验/2 跟踪分析Linux内核的启动过程/","content":"使用实验楼的虚拟机打开 shell 12cd ~/LinuxKernel/qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img 内核启动完成后进入 menu程序（《软件工程 C 编码实践篇》的课程项目），支持三个命令 help、version 和 quit，您也可以添加更多的命令，对选修过《软件工程 C 编码实践篇》的童鞋应该是 a piece of cake. 使用 gdb 跟踪调试内核 12345678$ qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -S# 关于-s和-S选项的说明：# 1. -S# -S freeze CPU at startup (use ’c’ to start execution)# 2. -s# -s shorthand for -gdb tcp::1234# 若不想使用1234端口，则可以使用-gdb tcp:xxxx来取代-s选项 另开一个 shell 窗口 12345678910111213# 打开 GDB 调试器$ gdb# 在 GDB 中输入以下命令：# 在gdb界面中targe remote之前加载符号表（gdb）file linux-3.18.6/vmlinux# 建立gdb和gdbserver之间的连接,按c 让qemu上的Linux继续运行（gdb）target remote:1234# 断点的设置可以在target remote之前，也可以在之后（gdb）break start_kernel","tags":["Linux","内核"],"categories":["OS","Linux","Linux内核分析配套实验"]},{"title":"linux防火墙命令——ufw","path":"/OS/Linux/Command&Tools/ufw/","content":"防火墙是计算机安全的重要组成部分。在Linux中，UFW（Uncomplicated Firewall）是一个开源防火墙工具，可用于实现网络安全策略。它提供了一个简化的命令行接口，使得设置防火墙规则更加容易。在本文中，我们将介绍如何在Linux上使用UFW实现防火墙和安全策略。 [toc] 安装UFW许多Linux发行版都默认安装了UFW。如果你的Linux发行版没有安装，你可以使用以下命令来安装： 1$ sudo apt-get install ufw # Ubuntu和Debian 1$ sudo yum install ufw # CentOS和Fedora 设置UFW规则在使用UFW之前，必须启用它。使用以下命令来启用UFW： 1$ sudo ufw enable 默认情况下，UFW将拒绝所有传入连接和允许所有传出连接。要添加其他规则，可以使用以下命令： 1$ sudo ufw allow [port]/[protocol] 例如，启用SSH连接： 1$ sudo ufw allow ssh 默认情况下，UFW假定TCP协议。如果要允许其他协议，可以使用以下命令： 1$ sudo ufw allow [port]/[protocol] 例如，启用UDP连接： 1$ sudo ufw allow 53/udp 您还可以使用其他选项指定源地址，目标地址和应用程序。 限制IP访问除了端口，还可以使用UFW限制对特定IP的访问。例如，要拒绝来自IP地址为192.168.1.100的所有连接： 1$ sudo ufw deny from 192.168.1.100 或者，要允许仅该IP地址访问您的网站： 1$ sudo ufw allow from 192.168.1.100 to any port 80 修改默认策略您可以通过修改默认策略来更改UFW的行为。要允许所有传入连接并拒绝所有传出连接： 1$ sudo ufw default deny outgoing 1$ sudo ufw default allow incoming 或者，要拒绝所有传入连接并允许所有传出连接： 1$ sudo ufw default allow outgoing 1$ sudo ufw default deny incoming 撤消规则如果您需要删除规则，可以使用以下命令： 1$ sudo ufw delete [规则号] 规则号是规则列表中的数字序号，从1开始。 禁用UFW要禁用UFW并删除所有规则，可以使用以下命令： 1$ sudo ufw disable 1$ sudo ufw reset 结论在Linux上使用UFW可以轻松实现防火墙和安全策略。UFW提供了一种简单的方式来控制入站和出站流量，并且易于使用和配置。通过设置良好的规则，可以增强系统的安全性。","tags":["linux","防火墙"],"categories":["OS","Linux","Command&Tools"]},{"title":"Linux查询是否安装了某个软件","path":"/OS/Linux/Command&Tools/Linux查询是否安装某个软件/","content":"1、rpm包安装的，可以用rpm -qa看到，如果要查找某软件包是否安装，用 rpm -qa | grep “软件或者包的名字”。 1rpm -qa | grep ruby 2、以deb包安装的，可以用dpkg -l能看到。如果是查找指定软件包，用dpkg -l | grep “软件或者包的名字”； 1dpkg -l | grep ruby 3、yum方法安装的，可以用yum list installed查找，如果是查找指定包，命令后加 | grep “软件名或者包名”； 1yum list installed | grep ruby","tags":["linux","查询"],"categories":["OS","Linux","Command&Tools"]},{"title":"ls命令详解","path":"/OS/Linux/Command&Tools/ls/","content":"[toc] 参数 ls :列出文件或者目录 -l，使用长格式显示 -a，显示文件名以.开头的隐藏文件 -h，以human易读格式显示，主要是看容量的时候使用KB MB GB，指当前文件夹目录的大小 -lh ,文件或者目录大小的, 方便识别 -lhS ,文件从大到小排序 -lg ,不打印所有者信息 -ln ,打印UID和GID -l --si si以1000为单位，而-h以1024为单位。 -l --block-size=M: 设置文件显示单位 -li，显示inode号 -r，reverse，改变归类的顺序，例如和-t配合使用，-tr和-t显示顺序是颠倒的。 -R，递归列出子目录 -lX/ -l --sort=extension：扩展名排序 -t，按照修改时间顺序归类文件。 -d，列出目录本身的信息，而不是目录里边的内容。 字节 字节相关单位： K &#x3D; Kilobyte 千字节M &#x3D; Megabyte 兆字节G &#x3D; Gigabyte 十亿字节T &#x3D; Terabyte 兆兆字节P &#x3D; Petabyte 10的15次方字节E &#x3D; Exabyte 艾字节Z &#x3D; Zettabyte 泽它字节或皆字节Y &#x3D; Yottabyte 尧字节 命令 -a: 显示所有档案以及目录（ls内定将档案或目录名称为“.&#x2F;..”的视为隐藏） -A: 显示除隐藏文件“.&#x2F;..”以外的所有文件列表 -b: 将文件中的不可输出的字符以反斜线加字符编码的方式输出 -c : 与”-lt“ 选项连用时，按照文件状态时间排序输出目录内容， 排序的依据是文件的索引节点中的ctime 字段。 与”-l“连用时，排序的依据是文件的状态改变时间。 -C: 多列显示输出结果（只有文件名信息） -d : 仅显示目录名，而不显示目录下的内容列表， 显示符号链接文件本身， 而不显示其指定的目录列表。 -F: 在每个输出项后最佳文件的类型标识符， * 可执行权限的普通文件，&#x2F; 表示目录， @ 表示符号链接，|表示命令管道， &#x3D; 表示sockets 套接字， 普通文件不输出标识符。 -h: 以human易读格式显示， 文件大小以kb,mb显示 -i : 显示文件索引节点号（inode）,一个索引节点代表一个文件 -l : 以长格式显示目录下的内容列表，输出信息：文件名，文件类型，权限模式，硬链接数，所有者，组，文件大小， 文件最后修改时间。 ls - l 命令就是常用 ll -L : 如果遇到性质为符号链接的文件或目录， 直接列出该链接所造的原始文件或目录 -m: 以逗号分隔每个文件和目录的名称 -n : 以用户标志码和群组识别码替代其名称uid &#x2F;gid -r : 以文件名反序排序并输出目录内容列表 -R：递归处理，将制定目录下的所有文件及子目录一并处理 -s : 显示文件和目录的大小， 以区块为单位 -t : 用文件和目录的更改时间排序","tags":["linux","命令"],"categories":["OS","Linux","Command&Tools"]},{"title":"2352. 相等行列对 - 力扣（LeetCode）","path":"/LeetCode/2352. 相等行列对/","content":"2023_06_06 [toc] 2352. 相等行列对 - 力扣（LeetCode）给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。 如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。 示例 1： 输入：grid &#x3D; [[3,2,1],[1,7,6],[2,7,7]]输出：1解释：存在一对相等行列对： (第 2 行，第 1 列)：[2,7,7] 示例 2： 输入：grid &#x3D; [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]输出：3解释：存在三对相等行列对： (第 0 行，第 0 列)：[3,1,2,2] (第 2 行, 第 2 列)：[2,4,2,2] (第 3 行, 第 2 列)：[2,4,2,2] 提示： n &#x3D;&#x3D; grid.length &#x3D;&#x3D; grid[i].length1 &lt;&#x3D; n &lt;&#x3D; 2001 &lt;&#x3D; grid[i][j] &lt;&#x3D; 105 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/equal-row-and-column-pairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solutioncpp123456789101112131415161718192021222324252627282930class Solution &#123;public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int res = 0, n = grid.size(); for (int row = 0; row &lt; n; row++) &#123; for (int col = 0; col &lt; n; col++) &#123; if(equal(row, col, grid)) &#123; res++; &#125; &#125; &#125; return res; &#125; bool equal(int row, int col, vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123; int n = grid.size(); for (int i = 0; i &lt; n; i++) &#123; if(grid[row][i] != grid[i][col]) &#123; return false; &#125; &#125; return true; &#125;&#125;; Go1234567891011121314151617181920212223func equalPairs(grid [][]int) int &#123; n := len(grid) cnt := make(map[string]int) for _,row := range grid &#123; cnt[fmt.Sprint(row)]++ &#125; res := 0 for j := 0; j &lt; n; j++ &#123; var arr[] int for i := 0; i &lt; n; i++ &#123; arr = append(arr, grid[i][j]) &#125; if val,ok := cnt[fmt.Sprint(arr)]; ok &#123; res += val &#125; &#125; return res&#125;","tags":["LeetCode","数据","哈希表","矩阵","模拟","Go","C/C++"],"categories":["LeetCode"]},{"title":"2611. 老鼠和奶酪","path":"/LeetCode/2611. 老鼠和奶酪/","content":"2023年6月7日23:18:51 [toc] 2611. 老鼠和奶酪 - 力扣（LeetCode）有两只老鼠和 n 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。 下标为 i 处的奶酪被吃掉的得分为： 如果第一只老鼠吃掉，则得分为 reward1[i] 。如果第二只老鼠吃掉，则得分为 reward2[i] 。给你一个正整数数组 reward1 ，一个正整数数组 reward2 ，和一个非负整数 k 。 请你返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大 得分为多少。 示例 1： 输入：reward1 &#x3D; [1,1,3,4], reward2 &#x3D; [4,4,1,1], k &#x3D; 2输出：15解释：这个例子中，第一只老鼠吃掉第 2 和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。总得分为 4 + 4 + 3 + 4 &#x3D; 15 。15 是最高得分。示例 2： 输入：reward1 &#x3D; [1,1], reward2 &#x3D; [1,1], k &#x3D; 2输出：2解释：这个例子中，第一只老鼠吃掉第 0 和 1 块奶酪（下标从 0 开始），第二只老鼠不吃任何奶酪。总得分为 1 + 1 &#x3D; 2 。2 是最高得分。 提示： 1 &lt;&#x3D; n &#x3D;&#x3D; reward1.length &#x3D;&#x3D; reward2.length &lt;&#x3D; 1051 &lt;&#x3D; reward1[i], reward2[i] &lt;&#x3D; 10000 &lt;&#x3D; k &lt;&#x3D; n 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/mice-and-cheese著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution 思路贪心 + 排序 算出差值，取K 个最大值即可 代码 123456789101112131415161718192021class Solution &#123;public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) &#123; int ans = 0; int n = reward1.size(); vector&lt;int&gt; diffs(n); for (int i = 0; i &lt; n; i++) &#123; ans += reward2[i]; diffs[i] = reward1[i] - reward2[i]; &#125; sort(diffs.begin(), diffs.end()); for (int i = 1; i &lt;=k; i++) &#123; ans += diffs[n-i]; &#125; return ans; &#125;&#125;; 123456789101112131415161718func miceAndCheese(reward1 []int, reward2 []int, k int) int &#123; ans := 0 n := len(reward1) diffs := make([]int, n) for i:=0; i&lt;n; i++ &#123; ans += reward2[i] diffs[i] = reward1[i] - reward2[i] &#125; sort.Ints(diffs) for i:=1; i&lt;=k; i++ &#123; ans += diffs[n-i] &#125; return ans&#125;","tags":["LeetCode","贪心","排序"],"categories":["LeetCode"]},{"title":"1706. 球会落何处 - 力扣（LeetCode）","path":"/LeetCode/1706. 球会落何处/","content":"2022_02_24 [toc] 1706. 球会落何处用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。 箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。 将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。 将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。 在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。 返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。 示例 1： 12345678输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]输出：[1,-1,-1,-1,-1]解释：示例如图：b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。 示例 2： 123输入：grid = [[-1]]输出：[-1]解释：球被卡在箱子左侧边上。 示例 3： 12输入：grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]输出：[0,1,2,3,4,-1] 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 grid[i][j] 为 1 或 -1 Solution思路 我们依次判断每个球的最终位置。对于每个球，从上至下判断球位置的移动方向。在对应的位置，如果挡板向右偏，则球会往右移动；如果挡板往左偏，则球会往左移动。若移动过程中碰到侧边或者 \\text{V}V 型，则球会停止移动，卡在箱子里。如果可以完成本层的移动，则继续判断下一层的移动方向，直到落出箱子或者卡住。 作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/where-will-the-ball-fall/solution/qiu-hui-luo-he-chu-by-leetcode-solution-xqop/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; findBall(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid[0].size(); //箱子的列数 vector&lt;int&gt; ans(n); for(int i = 0; i &lt; n; i++)&#123; //分别求每个球掉到底部的位置下标 int col = i; //col表示球在下降过程中的纵坐标 for(auto&amp; row : grid)&#123; //分别求出球掉到每层的位置 int dir = row[col];　//dir表示球在下降过程中向左或向右下降 col += dir; //更新球在下一层的纵坐标,向右移动(纵坐标加1)/向左移动(纵坐标减1) if(col &lt; 0 || col == n || row[col] != dir )&#123; //row[col]表示球将要移动的方向上挡板的布置情况,dir表示当前球的移动方向，两者方向不一致会形成夹角 col = -1;　//当形成夹角或被挡在箱子侧边时,球将会卡在盒子里,所以该球下降的结果值直接赋值为-1; break; &#125; &#125; ans[i] = col; //col表示每个球掉落到底部的位置,即为结果值 &#125; return ans; &#125;&#125;; 123456789101112131415161718​func findBall(grid [][]int) []int &#123; n := len(grid[0]) ans := make([]int, n) for j := range ans &#123; col := j // 球的初始列 for _, row := range grid &#123; dir := row[col] col += dir // 移动球 if col &lt; 0 || col == n || row[col] != dir &#123; // 到达侧边或V型 col = -1 break &#125; &#125; ans[j] = col // col &gt;= 0 为成功到达底部 &#125; return ans&#125;","tags":["LeetCode","矩阵","模拟","Go","C/C++","数组","深度优先搜索","动态规划"],"categories":["LeetCode"]},{"title":"TCP/IP的四元组、五元组、七元组","path":"/Code/网络编程/四元组、五元组、七元组/","content":"TCP&#x2F;IP的四元组、五元组、七元组四元组是： 源IP地址、目的IP地址、源端口、目的端口 五元组是： 源IP地址、目的IP地址、协议号、源端口、目的端口 七元组是： 源IP地址、目的IP地址、协议号、源端口、目的端口、服务类型、接口索引","tags":["IP"],"categories":["Code","网络编程"]},{"title":"socket 长连接","path":"/Code/网络编程/windows Socket长连接/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041BOOL _KeepAlive(SP_SOCKET fd)&#123;\t//定义结构及宏\tstruct KeepAlive\t&#123; u_long onoff; u_long keepalivetime; u_long keepaliveinterval;\t&#125;;#define SIO_KEEPALIVE_VALS _WSAIOW(IOC_VENDOR,4)\t//KeepAlive实现\tKeepAlive inKeepAlive = &#123; 0 &#125;; //输入参数\tunsigned long ulInLen = sizeof(KeepAlive);\tKeepAlive outKeepAlive = &#123; 0 &#125;; //输出参数\tunsigned long ulOutLen = sizeof(KeepAlive);\tunsigned long ulBytesReturn = 0;\t//keepalive xp以前的系统发送5次，xp之后的系统发送10\tinKeepAlive.onoff = 1;\tinKeepAlive.keepaliveinterval = 5000; //两次KeepAlive探测间的时间间隔\tinKeepAlive.keepalivetime = 5000; //开始首次KeepAlive探测前的TCP空闭时间\tif (WSAIoctl((SOCKET)fd, SIO_KEEPALIVE_VALS, (LPVOID)&amp;inKeepAlive, ulInLen, (LPVOID)&amp;outKeepAlive, ulOutLen, &amp;ulBytesReturn, NULL, NULL) == SOCKET_ERROR)\t&#123; LOGT(&quot;Set Keep Alive FAILED.&quot;); return FALSE;\t&#125;\telse\t&#123; LOGT(&quot;Set Keep Alive OK.&quot;); return TRUE;\t&#125;&#125;","tags":["socket","网络"],"categories":["Code","网络编程"]},{"title":"tcp.flags 说明","path":"/Code/网络编程/tcp/tcp.flags/","content":"tcp.flags 说明在Wireshark的过滤器中,tcp.flags可以用于过滤各种TCP标志位。它包含以下项目: SYN: 标志位SYN&#x3D;1,用于TCP三次握手中的 SYN 数据包,请求建立连接 ACK: 标志位ACK&#x3D;1,确认接收到的数据 FIN: 标志位FIN&#x3D;1,请求关闭连接 RST: 标志位RST&#x3D;1,重置连接 PSH: 标志位PSH&#x3D;1,接收方应立即传送此报文的数据,而不等待其他数据 URG: 标志位URG&#x3D;1,此报文包含紧急数据 ECE: ECN Echo, 标志位ECE&#x3D;1,回复ECN设置的通知 CWR: Congestion Window Reduced,标志位CWR&#x3D;1,通知发送方拥塞窗口已经减少 这些标志位可以单独使用,也可以组合使用。例如: SYN+ACK: 服务端响应的SYN+ACK数据包,同意建立连接并确认SYN FIN+ACK: 确认对端的FIN的数据包,同时自身也请求关闭连接 在Wireshark的过滤器中,可以使用这些标志位进行过滤,例如:- SYN 过滤SYN数据包 ACK 过滤ACK数据包 FIN 过滤FIN数据包 RST 过滤RST数据包 tcp.flags.syn&#x3D;&#x3D;1 过滤SYN标志位为1的数据包 tcp.flags.syn&#x3D;&#x3D; &amp;&amp; tcp.flags.ack&#x3D;&#x3D;1 过滤同时包含SYN和ACK标志位的数据包 通过过滤不同的标志位或标志位组合,可以分析出TCP连接的握手、数据传输和释放过程。当然,除了这些标志位外,过滤器中 tcp 还包含其他字段,例如:- srcport 源端口 - dstport 目标端口 - seq 序列号 - ack 确认号 - window_size 窗口大小 - payload:可以过滤包含特定数据的包 - 等等","tags":["网络编程","tcp"],"categories":["Code","网络编程","tcp"]},{"title":"libevent http server","path":"/Code/网络编程/libevent/Libevent——httpserver/","content":"[toc] 实现http-server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;evhttp.h&gt;#include &lt;event.h&gt;#include &lt;string.h&gt;#include &quot;event2/http.h&quot;#include &quot;event2/event.h&quot;#include &quot;event2/buffer.h&quot;#include &quot;event2/bufferevent.h&quot;#include &quot;event2/bufferevent_compat.h&quot;#include &quot;event2/http_struct.h&quot;#include &quot;event2/http_compat.h&quot;#include &quot;event2/util.h&quot;#include &quot;event2/listener.h&quot;#pragma comment(lib,&quot;ws2_32.lib&quot;)#pragma comment(lib, &quot;Iphlpapi.lib&quot;)#define BUF_MAX 1024*16//解析post请求数据void get_post_message(char* buf, struct evhttp_request* req)&#123;\tsize_t post_size = 0;\tpost_size = evbuffer_get_length(req-&gt;input_buffer);//获取数据长度\tprintf(&quot;====line:%d,post len:%d &quot;, __LINE__, post_size);\tif (post_size &lt;= 0)\t&#123; printf(&quot;====line:%d,post msg is empty! &quot;, __LINE__); return;\t&#125;\telse\t&#123; size_t copy_len = post_size &gt; BUF_MAX ? BUF_MAX : post_size; printf(&quot;====line:%d,post len:%d, copy_len:%d &quot;, __LINE__, post_size, copy_len); memcpy(buf, evbuffer_pullup(req-&gt;input_buffer, -1), copy_len); buf[post_size] = &#x27;\\0&#x27;; printf(&quot;====line:%d,post msg:%s &quot;, __LINE__, buf);\t&#125;&#125;//解析http头，主要用于get请求时解析uri和请求参数char* find_http_header(struct evhttp_request* req, struct evkeyvalq* params, const char* query_char)&#123;\tif (req == NULL || params == NULL || query_char == NULL)\t&#123; printf(&quot;====line:%d,%s &quot;, __LINE__, &quot;input params is null.&quot;); return NULL;\t&#125;\tstruct evhttp_uri* decoded = NULL;\tchar* query = NULL;\tchar* query_result = NULL;\tconst char* path;\tconst char* uri = evhttp_request_get_uri(req);//获取请求uri\tif (uri == NULL)\t&#123; printf(&quot;====line:%d,evhttp_request_get_uri return null &quot;, __LINE__); return NULL;\t&#125;\telse\t&#123; printf(&quot;====line:%d,Got a GET request for &lt;%s&gt; &quot;, __LINE__, uri);\t&#125;\t//解码uri\tdecoded = evhttp_uri_parse(uri);\tif (!decoded)\t&#123; printf(&quot;====line:%d,It&#x27;s not a good URI. Sending BADREQUEST &quot;, __LINE__); evhttp_send_error(req, HTTP_BADREQUEST, 0); return;\t&#125;\t//获取uri中的path部分\tpath = evhttp_uri_get_path(decoded);\tif (path == NULL)\t&#123; path = &quot;/&quot;;\t&#125;\telse\t&#123; printf(&quot;====line:%d,path is:%s &quot;, __LINE__, path);\t&#125;\t//获取uri中的参数部分\tquery = (char*)evhttp_uri_get_query(decoded);\tif (query == NULL)\t&#123; printf(&quot;====line:%d,evhttp_uri_get_query return null &quot;, __LINE__); return NULL;\t&#125;\t//查询指定参数的值\tevhttp_parse_query_str(query, params);\tquery_result = (char*)evhttp_find_header(params, query_char);\treturn query_result;&#125;//处理get请求void http_handler_testget_msg(struct evhttp_request* req, void* arg)&#123;\tif (req == NULL)\t&#123; printf(&quot;====line:%d,%s &quot;, __LINE__, &quot;input param req is null.&quot;); return;\t&#125;\tchar* sign = NULL;\tchar* data = NULL;\tstruct evkeyvalq sign_params = &#123; 0 &#125;;\tsign = find_http_header(req, &amp;sign_params, &quot;sign&quot;);//获取get请求uri中的sign参数\tif (sign == NULL)\t&#123; printf(&quot;====line:%d,%s &quot;, __LINE__, &quot;request uri no param sign.&quot;);\t&#125;\telse\t&#123; printf(&quot;====line:%d,get request param: sign=[%s] &quot;, __LINE__, sign);\t&#125;\tdata = find_http_header(req, &amp;sign_params, &quot;data&quot;);//获取get请求uri中的data参数\tif (data == NULL)\t&#123; printf(&quot;====line:%d,%s &quot;, __LINE__, &quot;request uri no param data.&quot;);\t&#125;\telse\t&#123; printf(&quot;====line:%d,get request param: data=[%s] &quot;, __LINE__, data);\t&#125;\tprintf(&quot; &quot;);\t//回响应\tstruct evbuffer* retbuff = NULL;\tretbuff = evbuffer_new();\tif (retbuff == NULL)\t&#123; printf(&quot;====line:%d,%s &quot;, __LINE__, &quot;retbuff is null.&quot;); return;\t&#125;\tevbuffer_add_printf(retbuff, &quot;Receive get request,Thamks for the request!&quot;);\tevhttp_send_reply(req, HTTP_OK, &quot;Client&quot;, retbuff);\tevbuffer_free(retbuff);&#125;//处理post请求void http_handler_testpost_msg(struct evhttp_request* req, void* arg)&#123;\tif (req == NULL)\t&#123; printf(&quot;====line:%d,%s &quot;, __LINE__, &quot;input param req is null.&quot;); return;\t&#125;\tchar buf[BUF_MAX] = &#123; 0 &#125;;\tget_post_message(buf, req);//获取请求数据，一般是json格式的数据\tif (buf == NULL)\t&#123; printf(&quot;====line:%d,%s &quot;, __LINE__, &quot;get_post_message return null.&quot;); return;\t&#125;\telse\t&#123; //可以使用json库解析需要的数据 printf(&quot;====line:%d,request data:%s&quot;, __LINE__, buf);\t&#125;\t//回响应\tstruct evbuffer* retbuff = NULL;\tretbuff = evbuffer_new();\tif (retbuff == NULL)\t&#123; printf(&quot;====line:%d,%s &quot;, __LINE__, &quot;retbuff is null.&quot;); return;\t&#125;\tevbuffer_add_printf(retbuff, &quot;Receive Get request,Thamks for the request!&quot;);\tevhttp_send_reply(req, HTTP_OK, &quot;Client&quot;, retbuff);\tevbuffer_free(retbuff);&#125;int main()&#123;\tstruct evhttp* http_server = NULL;\tshort http_port = 8081;\tchar* http_addr = &quot;0.0.0.0&quot;;#ifdef _WIN32\t&#123; WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD(2, 2); err = WSAStartup(wVersionRequested, &amp;wsaData); if (err != 0) &#123; printf(&quot;WSAStartup failed with error: %d &quot;, err); return 0; &#125;\t&#125;#endif // _WIN32\t//初始化\tevent_init();\t//启动http服务端\thttp_server = evhttp_start(http_addr, http_port);\tif (http_server == NULL)\t&#123; printf(&quot;====line:%d,%s &quot;, __LINE__, &quot;http server start failed.&quot;); return -1;\t&#125;\t//设置请求超时时间(s)\tevhttp_set_timeout(http_server, 5);\t//设置事件处理函数，evhttp_set_cb针对每一个事件(请求)注册一个处理函数，\t//区别于evhttp_set_gencb函数，是对所有请求设置一个统一的处理函数\tevhttp_set_cb(http_server, &quot;/me/testpost&quot;, http_handler_testpost_msg, NULL);\tevhttp_set_cb(http_server, &quot;/me/testget&quot;, http_handler_testget_msg, NULL);\t//循环监听\tevent_dispatch();\t//实际上不会释放，代码不会运行到这一步\tevhttp_free(http_server);\treturn 0;&#125; 使用 postman 请求Get123456789// 接口127.0.0.1:8081/me/testpost// 请求体&#123; &quot;username&quot;: &quot;A&quot;, &quot;password&quot;: &quot;123123Qq&quot;, &quot;reqtime&quot;: &quot;2023年1月28日15:44:58&quot;&#125; http-server 控制台输出： ====line:65,Got a GET request for ====line:85,path is:/me/testget ====line:92,evhttp_uri_get_query return null ====line:118,request uri no param sign. ====line:65,Got a GET request for ====line:85,path is:/me/testget ====line:92,evhttp_uri_get_query return null ====line:128,request uri no param data. Post123456789# 接口127.0.0.1:8081/me/testpost// 请求体&#123; &quot;username&quot;: &quot;A&quot;, &quot;password&quot;: &quot;123123Qq&quot;, &quot;reqtime&quot;: &quot;2023年1月28日15:44:58&quot;&#125; http-server 控制台输出： ====line:27,post len:98 ====line:36,post len:98, copy_len:98 ====line:39,post msg:{ \"username\": \"A\", \"password\": \"123123Qq\", \"reqtime\": \"2023骞?鏈?8鏃?5:44:58\" } ====line:168,request data:{ \"username\": \"A\", \"password\": \"123123Qq\", \"reqtime\": \"2023骞?鏈?8鏃?5:44:58\" }","tags":["网络编程","libevent"],"categories":["Code","网络编程","libevent"]},{"title":"Curl使用的一些demo，记录","path":"/Code/网络编程/Curl使用教程/","content":"[toc] 1、编译及使用1.1 编译1.1.1下载GitHub - curl&#x2F;curl: A command line tool and library for transferring data with URL syntax, supporting DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP. libcurl offers a myriad of powerful features 点击链接下载，也可以使用git clone到本地 1git clone https://github.com/curl/curl.git 1.1.2 编译 方法一 VS编译器 如果需要使用vs编译，首先运行 project 目录下的 generate.bat 文件。然后在projects/Windwows 目录下打开对应的解决方案即可 方法二 nmake 在下载目录 winbuild 目录下，查看 README.md ，里边告诉了我们如何编译自己需要的包，以我本人使用的为例。 打开对应版本的vs命令行工具 进入对应的编译目录 curl-src\\winbuild，接着执行以下命令就好。具体的命令参数可以查看winbuild目录下的介绍，选择自己需要的环境就好。 1nmake /f Makefile.vc mode=dll vc=15 MACHINE=x86 执行以后就能在根目录 build 下看到生成了对应的文件夹，这时候就可以在项目中使用了。注意生成目录下有 bin、include、lib 三个文件夹。 1.2 使用将生成的文件拖动到项目所在文件夹目录下，这时候需要做以下几个步骤，打开项目的属性页面： 1.2.1 预处理器在预处理器中添加以下字段： 1;BUILDING_LIBCURL;HTTP_ONLY; 1.2.2 附加库 在链接器中附加库目录，把lib文件夹添加到附加库目录当中 添加lib文件 1libcurl_a.lib;Ws2_32.lib;Wldap32.lib;winmm.lib;Crypt32.lib;Normaliz.lib;%(AdditionalDependencies) 1.3.3 使用12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;curl/curl.h&quot;string UriHelper::Encode(const string&amp; source)&#123;\tCURL* curl = curl_easy_init();\tchar* cres = curl_easy_escape(curl, source.c_str(), source.length());\tstring res(cres);\tcurl_free(cres);\tcurl_easy_cleanup(curl);\treturn res;&#125;int main()&#123; std::cout &lt;&lt; &quot;Hello World! &quot;; std::cout &lt;&lt; Encode(R&quot;(https://10.92.4.117:8443/tac /download/client/com.qianxin.trustagent.win.standard.exe.bm-3.1.1.4585/ TrustAgent_standard_3.1.1.4585.aef031d09[10.92.4.117@443].exe)&quot;) &lt;&lt; std::endl;&#125; 输出：http0.0000000.0000000.000000www.baidu.com0.000000s0.000000ie%3Dutf-8 0.000000%3D8 %3Dbaidu%26wd%3D5.185438E-3164%B8%B48.694087E-3156%97%B65.190920E-3169%820.000000E5.12199E-31670.000000E%B1","tags":["C++","HTTP","Curl","网络编程"],"categories":["Code","网络编程"]},{"title":"OSI七层网络协议模型各层协议","path":"/Code/网络编程/OSI七层网络协议模型/","content":"","tags":["网络编程","协议"],"categories":["Code","网络编程"]},{"title":"IPv6","path":"/Code/网络编程/IPv6/","content":"[toc] IPv6地址格式IPv6的地址长度是128位（bit）。 将这128位的地址按每16位划分为一个段，将每个段转换成十六进制数字，并用冒号隔开。 例如：2000:0000:0000:0000:0001:2345:6789:abcd 这个地址很长，可以用两种方法对这个地址进行压缩， 前导零压缩法： 将每一段的前导零省略，但是每一段都至少应该有一个数字 例如：2000:0:0:0:1:2345:6789:abcd 双冒号法： 如果一个以冒号十六进制数表示法表示的IPv6地址中，如果几个连续的段值都是0，那么这些0可以简记为::。每个地址中只能有一个::。 例如：2000::1:2345:6789:abcd 单播地址（Unicast IPv6 Addresses）可聚合的全球单播地址（Aggregatable Global Unicast Addresses） 可在全球范围内路由和到达的，相当于IPv4里面的global addresses。前三个bit是001 例如：2000::1:2345:6789:abcd 链路本地地址（Link-Local Addresses） 用于同一个链路上的相邻节点之间通信，相当于IPv4里面的169.254.0.0&#x2F;16地址。Ipv6的路由器不会转发链路本地地址的数据包。前10个bit是1111 1110 10，由于最后是64bit的interface ID，所以它的前缀总是FE80::&#x2F;64 例如：FE80::1 站点本地地址（Site-Local Addresses） 对于无法访问internet的本地网络，可以使用站点本地地址，这个相当于IPv4里面的private address（10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, and 192.168.0.0&#x2F;16）。它的前10个bit是1111 1110 11，它最后是16bit的Subnet ID和64bit的interface ID，所以它的前缀是FEC0::&#x2F;48。 值得注意的是，在RFC3879中，最终决定放弃单播站点本地地址。放弃的理由是，由于其固有的二义性带来的单播站点本地地址的复杂性超过了它们可能带来的好处。它在RFC4193中被ULA取代。 唯一的本地IPv6单播地址（ULA，Unique Local IPv6 Unicast Address） 在RFC4193中标准化了一种用来在本地通信中取代单播站点本地地址的地址。ULA拥有固定前缀FD00::&#x2F;8，后面跟一个被称为全局ID的40bit随机标识符。 未指定地址（Unspecified address） 0:0:0:0:0:0:0:0 或者:: 当一个有效地址还不能确定，一般用未指定地址作为源地址。未指定地址不能作为一个目标地址来使用。 回环地址（Loopback address） 回环地址::1用于标识一个回环接口，可以使一个节点可以给自己发送数据包。相当于IPv4的回环地址127.0.0.1 兼容IPv4的地址（IPv4-compatible address） 形如::w.x,y.z，这里的w.x.y.z是IPv4公共地址的十进制点号表示法，用于IPv6&#x2F;IPv4节点们（同时支持）在使用仅支持IPv4的网络上用IPv6的协议进行通信。 但是事实证明这种技术不是个好主意，RFC4291中废弃了对这类地址的使用。 IPv4映射地址（IPv4-mapped address） 形如::FFFF:w.x.y.z，这里的w.x.y.z是IPv4公共地址的十进制点号表示法,用于一个仅支持IPv4的节点表现为一个IPv6的节点 6over4地址 [64bit-prefix]:0:0:WWXX:YYZZ,其中的WWXX:YYZZ是w.x.y.z IPv4公共地址的十进制点号表示法，用于一个使用6to4协议的隧道机制的节点。 6to4地址 2002:WWXX:YYZZ:[SLA ID]:[Interface ID],用于表示一个使用6to4协议的隧道机制节点。 多播IPv6地址（Multicast IPv6 Addresses）前8个bit为1111 1111， 其中FF01::到FF0F::的多播地址是保留专用地址 FF01::1 节点本地范围所有节点多播地址 FF02::1 链路本地范围所有节点多播地址 FF01::2 节点本地范围所有路由器多播地址 FF02::2 链路本地范围所有路由器多播地址 FF05::2 站点本地范围所有路由器多播地址 为 IPv6 划分子网在对 IPv6 地址空间进行子网划分时，需要使用子网划分技术，以一种允许将剩余地址空间的摘要和委派路由到 IPv6 Intranet 的不同部分的方式，为 48 位全局地址前缀划分 16 位子网 ID 字段。 您不需要以任何特定的方式进行子网划分。此处介绍的子网划分技术假定您是通过使用子网 ID 字段的高序位划分其地址空间的可变部分来进行子网划分的。虽然此方法有助于分层寻址和路由，但此方法并不是非用不可。例如，在只有少数子网的小型组织中，您可以通过为子网编号（从 0 开始），轻松地为全局地址创建平面寻址空间。 对全局地址前缀进行子网划分对于全局地址，Internet 编号分配机构 (IANA) 或 ISP 会分配一个前 48 位均为固定位的 IPv6 地址前缀。若要对 48 位全局地址前缀的子网 ID 字段进行子网划分，需要执行一个包含两步的过程： 1. 确定用于子网划分的位数。 2. 枚举出新的子网网络前缀。 确定用于子网划分的位数 用于子网划分的位数决定着您可以分配给您的网络各部分（基于地理区划或部门分类）的新子网网络前缀的可能的数量。在分层路由基础结构中，您必须确定您在层次结构的各层需要的网络前缀数，进而确定各层需要的位数。为层次结构的各层选择的位越多，您拥有的用于枚举层次结构最后一层中的单个子网的位越少。 例如，您可以实施一个包含两层的层次结构来反映地理&#x2F;部门结构，4 位用于地理层，6 位用于部门层。这一方案允许 16 个地理区域，各个区域中的各个部门只占剩余的子网划分空间的 6 (16 - 6 - 4) 位，或者说每个部门只有 64 (&#x3D;26) 个子网。 在层次结构中任何给定的层上，许多位已被层次结构中的上一层固定了 (f)，许多位被用来在层次结构中的当前层进行子网划分 (s)，还有许多位留给层次结构中的下一层使用 (r)。下面这个等式始终成立：f+s+r &#x3D; 16。 枚举子网网络前缀根据用于子网划分的位数，您必须列出新的子网网络前缀，您可以使用下面两种主要方法之一： • 使用子网 ID 和递增值的十六进制表示形式来枚举新的子网网络前缀。 • 使用子网 ID 和递增值的十进制表示形式来枚举新的子网网络前缀。 这两种方法产生的结果相同，都会生成子网网络前缀的一个枚举列表。 要使用十六进制方法创建子网网络前缀的枚举列表，请执行以下步骤： 1. 根据为子网划分选择的位数 s 和进行子网划分的网络前缀的前缀长度 m，计算以下各值：f &#x3D; m - 48f 是子网 ID 中已固定的位的数目。n &#x3D; 2sn 是您将获得的网络前缀的数目。i &#x3D; 216-(f+s) i 是以十六进制表示的各个连续子网 ID 之间的递增值。P &#x3D; m+s**P 是新的子网网络前缀的前缀长度。 2. 创建一个包含 n 行、两列的表。第一列存放网络前缀编号（从 1 开始），第二列存放新的子网网络前缀。 3. 将使用新的前缀长度的原始网络前缀放在第一行的第二列中。例如，根据进行子网划分的子网 ID 的十六进制值 F，子网网络前缀为 [48 位前缀]:F::&#x2F;P。 4. 将站点本地地址或全局地址的子网 ID 部分中的值加上 i，将结果放在下一行的第二列中。例如，在第二行中，子网前缀为 [48 位前缀]:F+i::&#x2F;P。 5. 重复步骤 4，直到您完成该表。 例如，要对全局地址前缀 3FFE:FFFF:0:C000::&#x2F;51 进行 3 位子网划分，首先计算前缀数量值、递增值和新前缀长度值。起始值是 F&#x3D;0xC000，s&#x3D;3，m&#x3D;51，因此 f&#x3D;51-48&#x3D;3。前缀的数量是 8 (n&#x3D;23)。递增值是 0x400 (i&#x3D;216-(3+3)&#x3D;1024&#x3D;0x400)。新的前缀长度是 54 (P&#x3D;51+3)。 接下来，构造一个包含 8 行的表，如表 4-12 所示。将 3FFE:FFFF:0:C000::&#x2F;54 放在网络前缀 1 所在的那一行的第二列，然后让网络前缀的子网 ID 部分依次递增 0x400，将结果分别填入后面的各行中。 下表为使用十六进制技术对 3FFE:FFFF:0:C000::&#x2F;51 进行 3 位子网划分： 网络前缀 子网网络前缀 1 3FFE:FFFF:0:C000::&#x2F;54 2 3FFE:FFFF:0:C400::&#x2F;54 3 3FFE:FFFF:0:C800::&#x2F;54 4 3FFE:FFFF:0:CC00::&#x2F;54 5 3FFE:FFFF:0:D000::&#x2F;54 6 3FFE:FFFF:0:D400::&#x2F;54 7 3FFE:FFFF:0:D800::&#x2F;54 8 3FFE:FFFF:0:DC00::&#x2F;54 要使用十进制方法创建子网网络前缀的枚举列表，请执行以下步骤： 1. 根据用于子网划分的位数 s、进行子网划分的网络前缀的前缀长度 m 和进行子网划分的子网 ID 的十六进制值 F，计算以下各值：f &#x3D; m - 48f 是子网 ID 中已固定的位的数目。n &#x3D; 2sn 是您将获得的网络前缀的数目。i &#x3D; 216-(f+s) i 是各个连续子网 ID 之间的递增值。P &#x3D; m+s**P 是新的子网网络前缀的前缀长度。D &#x3D; F 的十进制表示形式 2. 创建一个包含 n 行、三列的表。第一列存放网络前缀编号（从 1 开始），第二列存放新的子网网络前缀的子网 ID 部分的十进制表示形式，第三列存放新的子网网络前缀。 3. 将子网 ID 的十进制表示形式 (D) 放在第一行的第一列，将子网前缀 [48 位前缀]:F::&#x2F;P 放在第一行的第二列。 4. 用子网 ID 十进制表示形式的值加上 i，将结果放在下一行的第二列。例如，第二行的子网 ID 的十进制表示形式是 D+i。 5. 在第三列中，将子网 ID 的十进制表示形式转换为十六进制，并构造前缀 [48 位前缀]:[SubnetID]::&#x2F;P。例如，在第二行中，子网网络前缀为 [48 位前缀]:[D+i（转换为十六进制）]::&#x2F;P。 6. 重复步骤 4 和 5，直到您完成该表。 例如，要对站点本地网络前缀 3FFE:FFFF:0:C000::&#x2F;51 进行 3 位子网划分，首先计算前缀数量值、递增值、新前缀长度值和起始子网 ID 十进制表示形式。我们的起始值是 F&#x3D;0xC000，s&#x3D;3，m&#x3D;51，这样 f&#x3D;51-48&#x3D;3。前缀数量是 8 (n&#x3D;23)。递增值是 1024 (i&#x3D;216-(3+3))。新的前缀长度是 54 (P&#x3D;51+3)。起始子网 ID 的十进制表示形式是 49152 (D&#x3D;0xC000&#x3D;49152)。 接下来，构造一个包含 8 行的表，如表 4-13 所示。将 49192 放在网络前缀 1 所在的那一行的第一列，将 3FFE:FFFF:0:C000::&#x2F;54 放在该行的第二列。让网络前缀的子网 ID 部分（第四个十六进制块）依次递增 1024，然后将结果转换为十六进制并分别填入后面的各行中。 下表为使用十进制技术对 3FFE:FFFF:0:C000::&#x2F;51 进行 3 位子网划分： 网络前缀 子网 ID 的十进制表示形式 子网网络前缀 1 49192 3FFE:FFFF:0:C000::&#x2F;54 2 50176 3FFE:FFFF:0:C400::&#x2F;54 3 51200 3FFE:FFFF:0:C800::&#x2F;54 4 52224 3FFE:FFFF:0:CC00::&#x2F;54 5 53248 3FFE:FFFF:0:D000::&#x2F;54 6 54272 3FFE:FFFF:0:D400::&#x2F;54 7 55296 3FFE:FFFF:0:D800::&#x2F;54 8 56320 3FFE:FFFF:0:DC00::&#x2F;54 变量长度子网划分与 IPv4 相同的是，您可以对 IPv6 地址前缀循环进行子网划分来在组织 Intranet 的各个层次提供路由摘要，定义单个子网的地址前缀可达到 64 位。与 IPv4 不同的是，您无法使用可变长度子网划分来创建不同大小的子网，因为所有 IPv6 子网都使用 64 位网络 ID 和 64 位接口 ID。","tags":["网络编程","IPv6"],"categories":["Code","网络编程"]},{"title":"正则表达式反向引用","path":"/Code/正则表达式/匹配不等于/","content":"[^a]* 表示匹配除了a以外的所有字符[^abc]* 表示匹配除了a、b、c以外的所有字符，注意这里不是abc字符串，而是a、b、c任何一个字符都不匹配 当我们要不匹配某个字符串或者中文词组的时候，可以这样用((?!天空).)* 这个表示匹配出’天空’之外的所有字符 regex(?![0-9]+) 匹配不是regex，但后面不是数字","tags":["regex","正则表达式"],"categories":["Code","正则表达式"]},{"title":"Qt插件——使用 QtCipherSqlitePlugin 对数据库进行加密","path":"/Code/数据库/数据库加密/","content":"开源库介绍devbean&#x2F;QtCipherSqlitePlugin: A Qt plugin for cipher SQLite. (github.com) 该加密库是基于 SQLite 和 wxSQLite3 源代码开发的的一个加密 SQLite 的Qt插件。总结就是，可以使用该插件对 SQLite 的数据库进行加密。 开始 在开始之前，可以去仓库的 wiki 界面找到相应的开始教程，以下操作参考 wiki 。 拉取该库到本地后，打开 QtCipherSqlitePlugin.pro，就能看到如下图所示的工程结构。 demo 目录是一个如何使用该加密插件的工程，涉及数据库的加密、打开、创建等 sqlitecipher是我们编译 dll 的工程文件 为 Qt 的插件测试工程，里边有关于该加密库的详细使用方式介绍。 不论是使用上述测试工程中的哪个，我们第一步都需要编译插件的动态库出来使用。 单独sqlitecipher.pro 为 sqlitecipher.pro 调整 Qt kits ，笔者的环境为 MSVC 2015 32 bit, Release模式 右击项目文件，点击部署即可 到工程所在的文件夹，就能看到 build-sqlitecipher-Desktop_Qt_5_9_9_MSVC2015_32bit-Release 的文件夹，在 .\\plugins\\sqldrivers下就能看到生成的动态库文件，动态库 sqlitecipher.dll 拷贝该文件到你的 Qt 目录下 kits 对应的文件夹当中。如笔者的为 $Qt安装目录$\\5.9.9\\msvc2015\\plugins\\sqldrivers 使用到这一步，我们就需要查看一下动态库是否可用了。使用 Qt 的 #include &lt;QSqlDatabase&gt;中的方法即可： 1qDebug() &lt;&lt; QSqlDatabase::drivers(); 执行上述代码，如果加载成功的话，我们会在 qDebug() 的输出中看到相应的数据库名。 (&quot;QSQLITE&quot;, &quot;QMYSQL&quot;, &quot;QMYSQL3&quot;, &quot;QODBC&quot;, &quot;QODBC3&quot;, &quot;QPSQL&quot;, &quot;QPSQL7&quot;, &quot;SQLITECIPHER&quot;) 以上代码，在 demo 所在工程中都能找到对应的代码，不用读者编写。 另外，使用 SQLITECIPHER 数据库也可以打开普通未加密的 QSQLITE 创建的数据库。 加密加密数据库的使用也简单，区别于普通数据库的方式是需要设置连接属性。以该开源库为例，其主要通过三个连接属性去决定是否设置密码。主要涉及到的关键字为以下三个： Added by QtCipherSqlitePlugin QSQLITE_CREATE_KEY QSQLITE_UPDATE_KEY QSQLITE_REMOVE_KEY 还有其他几个继承自 SqlitePlugin 的关键字，用法与 SqlitePlugin 打开数据库设置一致。 Provided by Qt SqlitePlugin QSQLITE_BUSY_TIMEOUT QSQLITE_OPEN_READONLY QSQLITE_OPEN_URI QSQLITE_ENABLE_SHARED_CACHE 以下代码演示三种关键字的用法。 创建数据库密码 QSQLITE_CREATE_KEY如果输出中有 SQLITECIPHER 的名字，那么恭喜你，插件没有问题！为没有加密的数据库增加密码Qt 默认提供的 SQLite 插件是没有加密功能的。新版本的 QtCipherSqlitePlugin 支持为原本没有加密的数据库增加密码，使用方法如下：C++ 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_CREATE_KEY&quot;); if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 上面的代码，我们使用 test.db 数据库，将密码设置为 test，同时指定连接选项为 QSQLITE_CREATE_KEY 。此时，调用 open() 函数之后，QtCipherSqlitePlugin 将使用改密码为这个数据库进行加密。 删除数据库密码 QSQLITE_REMOVE_KEYQtCipherSqlitePlugin 可以删除数据库密码，此时需要提供原密码，并使用连接选项 QSQLITE_REMOVE_KEY ，如下： 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_REMOVE_KEY&quot;);if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 更新数据库密码 QSQLITE_UPDATE_KEYQtCipherSqlitePlugin 可以更新数据库原有密码，需要设置原密码，并且使用连接选项 QSQLITE_UPDATE_KEY 设置新密码，具体代码如下： 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_UPDATE_KEY=newtest&quot;); if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 如果原密码不正确，QtCipherSqlitePlugin 会直接返回错误。 如果新密码设置为空，例如 QSQLITE_UPDATE_KEY= ，则作用等同于删除密码。同样的，设置 setConnectOptions(&quot;&quot;) 也相当于清除设置的属性。 补充以下代码是我个人想写一个通用的设置属性的接口，后来思考一番不太现实以示众多读者，不要重蹈覆辙。 1234567891011121314151617bool setDBConfig(QSqlDatabase* dbconn, QMap&lt;ENUM_SQLKEY, QString&gt; qMapCfg)&#123;\tfor (auto it : qMapCfg.toStdMap())\t&#123; if (it.first &lt;= QSQLITE_REMOVE_KEY) &#123; dbconn-&gt;setPassword(it.second); dbconn-&gt;setConnectOptions(GETOBJNAME(it.first)); &#125; else if (it.first == QSQLITE_UPDATE_KEY) &#123; dbconn-&gt;setPassword(it.second); dbconn-&gt;setConnectOptions(QString(&quot;%1=%2&quot;).arg().arg()); &#125; &#125;&#125;","tags":["Qt","数据库","加密"],"categories":["Code","数据库"]},{"title":"MYSQL——数据类型","path":"/Code/数据库/MYSQL/数据类型/","content":"MYSQL 数据类型整理MySQL 中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL 支持多种类型，大致可以分为三类：数值、日期&#x2F;时间和字符串(字符)类型。 数值类型MySQL 支持所有标准 SQL 数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。 作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 Bytes (-128，127) (0，255) 小整数值 SMALLINT 2 Bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 Bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 Bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 Bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 Bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 Bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01&#x2F;9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’&#x2F;‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901&#x2F;2155 YYYY 年份值 DATETIME 8 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ YYYY-MM-DD hh:mm:ss 混合日期和时间值 TIMESTAMP 4 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYY-MM-DD hh:mm:ss 混合日期和时间值，时间戳 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。","categories":["Code","数据库","MYSQL"]},{"title":"TypeScript","path":"/Code/TypeScript/selfRecord/","content":"[Toc] 快速上手 安装 1npm add @netless/fastboard @netless/window-manager white-web-sdk 创建实时音频采集音视频相关1. 获取摄像头列表 调用 getMicrophones 获取可用的摄像头列表 getMicrophones 方法会通过 Promise 异步返回一个 MediaDeviceInfo 对象的数组。MediaDeviceInfo 对象复用了 WebRTC API 中的 MediaDeviceInfo 对象。因为是异步方法，你可以使用 then&#x2F;catch (ES6) 或 async&#x2F;await (ES7) 获取返回值。 123456789// 获取可用的麦克风设备列表。// 调用时，如果浏览器还没有获得麦克风访问权限，会在界面上提示你是否允许浏览器访问麦克风。AgoraRTC.getMicrophones().then((deviceInfoArray) =&gt; &#123; /* 返回 MediaDeviceInfo 数组对象之后的操作*/&#125;).catch((e) =&gt; &#123; console.log(&quot;Failed to get microphones!&quot;, e);&#125;); 2. 获取摄像头设备信息在此教程中，我们在 HTML 中创建一个下拉菜单来供用户选择使用的摄像头设备。在用户界面上使用 label 属性显示设备信息。deviceId 属性用于保存设备 ID，用于后续的摄像头访问。 label，即设备标签，返回一个 DOMString，代表描述对应设备的标签。如果浏览器没有获取设备权限，则返回 &quot;&quot;。 deviceId，即设备 ID，返回一个 DOMString，代表对应设备。设备 ID 对于应用是唯一的，只要浏览器的 cookie 没有被清除，即使你开启了新的浏览器会话（session），设备 ID 也会保持不变。如果你清除了浏览器 cookie，则设备 ID 会重置。同理，如果你开启了浏览器隐私模式，对于同一个设备，每个浏览器会话的设备 ID 都是不同的。因此，建议每次对设备进行操作时重新获取设备 ID。 HTML 123456789&lt;h1&gt;通过麦克风采集并在本地渲染音频&lt;/h1&gt;&lt;form&gt;&lt;b&gt; 选择你要使用的麦克风 &lt;/b&gt;&lt;select id = &quot;microphoneList&quot; onchange = &quot;getDeviceId()&quot; &gt;&lt;option&gt; ---选择麦克风--- &lt;/option&gt;&lt;/select&gt;&lt;/form&gt;&lt;p&gt;你选择设备的 deviceId 是：&lt;/p&gt;&lt;p id=&quot;deviceId&quot;&gt;&lt;/p&gt; JavaScript 1234567891011121314151617181920212223// 定义设备 ID 与标签的映射let dict = &#123;&#125;;// 获取摄像头列表AgoraRTC.getMicrophones().then((deviceInfoArray) =&gt; &#123; for (let deviceInfo of deviceInfoArray) &#123; let option = document.createElement(&quot;option&quot;); document.getElementById(&quot;microphoneList&quot;).appendChild(option); option.innerHTML = deviceInfo.label; dict[deviceInfo.label] = deviceInfo.deviceId; &#125;&#125;).catch((e) =&gt; &#123; console.log(&quot;Failed to get microphones!&quot;, e);&#125;);// 根据下拉菜单选择的设备标签，显示相应的设备 IDfunction getDeviceId() &#123; let microphoneList = document.getElementById(&quot;microphoneList&quot;); let deviceLabel = microphoneList.options[microphoneList.selectedIndex].text; document.getElementById(&quot;deviceId&quot;).innerHTML = dict[deviceLabel];&#125; 3. 创建麦克风音频轨道并渲染调用 createMicrophoneAudioTrack 创建麦克风音频轨道并调用成员方法 play 通过系统默认扬声器对视频进行渲染。这里轨道的概念和 WebRTC 中的 track 相似。一个轨道代表一路特定的视频源或音频源。声网 SDK 将不同来源的音视频轨道进行抽象，定义了摄像头视频轨道、屏幕采集视频轨道及自定义源视频轨道等。 这个步骤只是为了演示麦克风音频轨道的渲染。实际开发通话应用时，本地不需要播放本地麦克风采集的音频。 HTML 123456789&lt;h1&gt;通过麦克风采集并在本地渲染音频&lt;/h1&gt;&lt;form&gt;&lt;b&gt; 选择你要使用的麦克风 &lt;/b&gt;&lt;select id=&quot;microphoneList&quot; onchange=&quot;getDeviceId()&quot;&gt; &lt;option&gt; ---选择麦克风--- &lt;/option&gt;&lt;/select&gt;&lt;/form&gt;&lt;p&gt;你选择设备的 deviceId 是：&lt;/p&gt;&lt;p id=&quot;deviceId&quot;&gt;&lt;/p&gt; CSS 12body &#123;font-family: system-ui;background: #f06d06;color: white;text-align: center;&#125;div &#123;height: 200px;width: 50%;&#125; JavaScript 12345678910111213141516171819202122232425262728293031323334353637383940// 全局变量let dict = &#123;&#125;; // 使用 dict 映射设备标签和设备 IDlet selectedDeviceId = &quot;&quot;; // 下选框选择的设备对应的 IDlet microphoneAudioTrack = null; // 麦克风音频轨道对象// 获取本地麦克风列表AgoraRTC.getMicrophones().then((deviceInfoArray) =&gt; &#123; for (let deviceInfo of deviceInfoArray) &#123; let option = document.createElement(&quot;option&quot;); document.getElementById(&quot;microphoneList&quot;).appendChild(option); option.innerHTML = deviceInfo.label; dict[deviceInfo.label] = deviceInfo.deviceId; &#125;&#125;).catch((e) =&gt; &#123; console.log(&quot;Failed to get microphones!&quot;, e);&#125;);// 创建麦克风音频轨道AgoraRTC.createMicrophoneAudioTrack().then((microphoneAudioTrack) =&gt; &#123; // 渲染音频。SDK 使用系统默认的扬声器播放声音。 microphoneAudioTrack.play();&#125;).catch((e) =&gt; &#123; console.log(&quot;Failed to play audio!&quot;, e);&#125;);// 根据选择的设备标签，返回对应的设备 ID 并传给麦克风音频轨道function getDeviceId() &#123;let microphoneList = document.getElementById(&quot;microphoneList&quot;);let deviceLabel = microphoneList.options[microphoneList.selectedIndex].text;selectedDeviceId = dict[deviceLabel];document.getElementById(&quot;deviceId&quot;).innerHTML = selectedDeviceId;if (microphoneAudioTrack != null) &#123; microphoneAudioTrack.setDevice(selectedDeviceId);&#125;&#125; #音频回调 setAudioFrameCallback setAudioFrameCallback(audioFrameCallback: null | function, frameSize?: undefined | number): void 设置原始音频数据（PCM）回调。 设置成功后，SDK 会不断地将远端音频轨道的音频帧以 AudioBuffer 的形式通过回调返回。 你可以通过 frameSize 来设置每次回调中音频帧的大小。该设置也会影响回调的间隔，frameSize 越大，每次回调的音频数据越多，回调间隔越长。 1234567891011track.setAudioFrameCallback((buffer) =&gt; &#123; for (let channel = 0; channel &lt; buffer.numberOfChannels; channel += 1) &#123; // Float32Array with PCM data const currentChannelData = buffer.getChannelData(channel); console.log(&quot;PCM data in channel&quot;, channel, currentChannelData); &#125;&#125;, 2048);// ....// Stop getting the raw audio datatrack.setAudioFrameCallback(null); 音频回调解码AudioBuffer - Web API 接口参考 | MDN AudioBuffer 接口表示存在内存里的一段短小的音频资源，利用AudioContext.decodeAudioData()方法从一个音频文件构建，或者利用 AudioContext.createBuffer()从原始数据构建。把音频放入 AudioBuffer 后，可以传入到一个 AudioBufferSourceNode进行播放。 这些类型对象被设计来控制小音频片段，往往短于 45 秒。对于更长的声音，通过 MediaElementAudioSourceNode来实现更为合适。缓存区（buffer）包含以下数据：不间断的 IEEE754 32 位线性 PCM，从-1 到 1 的范围额定，就是说，32 位的浮点缓存区的每个样本在-1.0 到 1.0 之间。如果AudioBuffer有不同的频道，他们通常被保存在独立的缓存区。 1) 属性 AudioBuffer.sampleRate 只读 存储在缓存区的 PCM 数据的采样率：浮点数，单位为 sample&#x2F;s。 AudioBuffer.length 只读 返回存储在缓存区的 PCM 数据的采样帧数：整形。 AudioBuffer.duration 只读 返回存储在缓存区的 PCM 数据的时长：双精度型（单位为秒）。 AudioBuffer.numberOfChannels 只读 返回存储在缓存区的 PCM 数据的通道数：整形。 2) 方法 AudioBuffer.getChannelData() 返回一个 Float32Array，包含了带有频道的 PCM 数据，由频道参数定义（有 0 代表第一个频道） AudioBuffer.copyFromChannel() 从 AudioBuffer 的指定频道复制到数组终端。 AudioBuffer.copyToChannel() (en-US) 复制样品到原数组的 AudioBuffer 的指定频道 3) 例子以下的例子展示了如何构建一个 AudioBuffer 以及随机用白噪音填充。你可以在 audio-buffer demo库发现完整的源代码；一个running live 的版本也可获得。 123456789101112131415161718192021222324252627282930313233343536// Stereovar channels = 2;// Create an empty two second stereo buffer at the// sample rate of the AudioContextvar frameCount = audioCtx.sampleRate * 2.0;var myArrayBuffer = audioCtx.createBuffer(channels, frameCount, audioCtx.sampleRate);button.onclick = function() &#123; // Fill the buffer with white noise; // just random values between -1.0 and 1.0 for (var channel = 0; channel &lt; channels; channel++) &#123; // This gives us the actual array that contains the data var nowBuffering = myArrayBuffer.getChannelData(channel); for (var i = 0; i &lt; frameCount; i++) &#123; // Math.random() is in [0; 1.0] // audio needs to be in [-1.0; 1.0] nowBuffering[i] = Math.random() * 2 - 1; &#125; &#125; // Get an AudioBufferSourceNode. // This is the AudioNode to use when we want to play an AudioBuffer var source = audioCtx.createBufferSource(); // set the buffer in the AudioBufferSourceNode source.buffer = myArrayBuffer; // connect the AudioBufferSourceNode to the // destination so we can hear the sound source.connect(audioCtx.destination); // start the source playing source.start();&#125; 4) 规格参数 Specification Web Audio API # AudioBuffer 录音对象属性Agora Web API Reference - 语音通话 - 文档中心 - 声网Agora 音频编码AudioEncoderConfigurationPresetAudioEncoderConfigurationPreset: keyof typeof AUDIO_ENCODER_CONFIG_SETTINGS SDK 预设的 [AudioEncoderConfiguration](https://docs.agora.io/cn/Voice/API Reference&#x2F;web_ng&#x2F;interfaces&#x2F;audioencoderconfiguration.html) 配置。 你可以在以下方法中传入预设值来控制本地音频的编码配置： [AgoraRTC.createCustomAudioTrack](https://docs.agora.io/cn/Voice/API Reference&#x2F;web_ng&#x2F;interfaces&#x2F;iagorartc.html#createcustomaudiotrack) [AgoraRTC.createMicrophoneAudioTrack](https://docs.agora.io/cn/Voice/API Reference&#x2F;web_ng&#x2F;interfaces&#x2F;iagorartc.html#createmicrophoneaudiotrack) [AgoraRTC.createBufferSourceAudioTrack](https://docs.agora.io/cn/Voice/API Reference&#x2F;web_ng&#x2F;interfaces&#x2F;iagorartc.html#createbuffersourceaudiotrack) 下表列出了 SDK 所有内置的音频属性配置，SDK 默认使用 &quot;music_standard&quot;。 音频属性 配置 &quot;speech_low_quality&quot; 16 kHz 采样率，单声道，编码码率约 24 Kbps &quot;speech_standard&quot; 32 kHz 采样率，单声道，编码码率约 24 Kbps &quot;music_standard&quot; 48 kHz 采样率，单声道，编码码率约 40 Kbps &quot;standard_stereo&quot; 48 kHz 采样率，双声道，编码码率约 64 Kbps &quot;high_quality&quot; 48 kHz 采样率，单声道， 编码码率约 128 Kbps &quot;high_quality_stereo&quot; 48 kHz 采样率，双声道，编码码率约 192 Kbps 本地音频轨道Agora Web API Reference - 语音通话 - 文档中心 - 声网Agora 对接基于声网 Web SDK 实现视频通话场景 - 专栏 - 声网 Agora RTC 开发者社区","tags":["脚本","TypeScript","fastboard"],"categories":["Code","TypeScript"]},{"title":"音频房间创建及连接说明","path":"/Code/TypeScript/音频传输/","content":"声网开源通话代码API-Examples-Web&#x2F;Demo&#x2F;selfRendering at main · AgoraIO&#x2F;API-Examples-Web UI CSS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.banner &#123; padding: 0; background-color: #52575c; color: white;&#125;.banner-text &#123; padding: 8px 20px; margin: 0;&#125;#join-form &#123; margin-top: 10px;&#125;.tips &#123; font-size: 12px; margin-bottom: 2px; color: gray;&#125;.join-info-text &#123; margin-bottom: 2px;&#125;input &#123; width: 100%; margin-bottom: 2px;&#125;.player &#123; width: 480px; height: 320px;&#125;.player-name &#123; margin: 8px 0;&#125;#success-alert, #success-alert-with-token &#123; display: none;&#125;@media (max-width: 640px) &#123; .player &#123; width: 320px; height: 240px; &#125;&#125; HTML12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Video Self-Rendering -- Agora&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../assets/bootstrap.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container-fluid banner&quot;&gt; &lt;p class=&quot;banner-text&quot;&gt;Video Self-Rendering&lt;/p&gt; &lt;a style=&quot;color: rgb(255, 255, 255);fill: rgb(255, 255, 255);fill-rule: evenodd; position: absolute; right: 10px; top: 4px;&quot; class=&quot;Header-link &quot; href=&quot;https://github.com/AgoraIO/API-Examples-Web/tree/main/Demo&quot;&gt; &lt;svg class=&quot;octicon octicon-mark-github v-align-middle&quot; height=&quot;32&quot; viewBox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; width=&quot;32&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;success-alert&quot; class=&quot;alert alert-success alert-dismissible fade show&quot; role=&quot;alert&quot;&gt; &lt;strong&gt;Congratulations!&lt;/strong&gt;&lt;span&gt; You can invite others to watch your live by click &lt;/span&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot; aria-label=&quot;Close&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;form id=&quot;join-form&quot; name=&quot;join-form&quot;&gt; &lt;div class=&quot;row join-info-group&quot;&gt; &lt;div class=&quot;col-sm&quot;&gt; &lt;p class=&quot;join-info-text&quot;&gt;AppID&lt;/p&gt; &lt;input id=&quot;appid&quot; type=&quot;text&quot; placeholder=&quot;enter appid&quot; required&gt; &lt;p class=&quot;tips&quot;&gt;If you don`t know what is your appid, checkout &lt;a href=&quot;https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#a-nameappidaapp-id&quot;&gt;this&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt; &lt;p class=&quot;join-info-text&quot;&gt;Token(optional)&lt;/p&gt; &lt;input id=&quot;token&quot; type=&quot;text&quot; placeholder=&quot;enter token&quot;&gt; &lt;p class=&quot;tips&quot;&gt;If you don`t know what is your token, checkout &lt;a href=&quot;https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#a-namekeyadynamic-key&quot;&gt;this&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt; &lt;p class=&quot;join-info-text&quot;&gt;Channel&lt;/p&gt; &lt;input id=&quot;channel&quot; type=&quot;text&quot; placeholder=&quot;enter channel name&quot; required&gt; &lt;p class=&quot;tips&quot;&gt;If you don`t know what is your channel, checkout &lt;a href=&quot;https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#channel&quot;&gt;this&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt; &lt;p class=&quot;join-info-text&quot;&gt;User ID(optional)&lt;/p&gt; &lt;input id=&quot;uid&quot; type=&quot;text&quot; onkeyup=&quot;this.value=this.value.replace(/[^0-9]/g,&#x27;&#x27;)&quot; onafterpaste=&quot;this.value=this.value.replace(/[^0-9]/g,&#x27;&#x27;)&quot; placeholder=&quot;Enter the user ID&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-group&quot;&gt; &lt;button id=&quot;host-join&quot; type=&quot;submit&quot; class=&quot;btn btn-primary btn-sm&quot;&gt;Join as host&lt;/button&gt; &lt;div class=&quot;btn-group&quot;&gt; &lt;button id=&quot;audience-join&quot; type=&quot;button&quot; class=&quot;btn btn-primary btn-sm&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Join as audience &lt;/button&gt; &lt;div class=&quot;audience dropdown-menu&quot;&gt; &lt;a id=&quot;lowLatency&quot; class=&quot;dropdown-item&quot; label=&quot;Interactive Live Streaming Standard&quot; href=&quot;#&quot;&gt;Interactive Live Streaming Standard&lt;/a&gt; &lt;a id=&quot;ultraLowLatency&quot; class=&quot;dropdown-item&quot; label=&quot;Interactive Live Streaming Premium&quot; href=&quot;#&quot;&gt;Interactive Live Streaming Premium&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;button id=&quot;leave&quot; type=&quot;button&quot; class=&quot;btn btn-primary btn-sm&quot; disabled&gt;Leave&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- Single button --&gt; &lt;div class=&quot;row video-group&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;p id=&quot;local-player-name&quot; class=&quot;player-name&quot;&gt;&lt;/p&gt; &lt;div id=&quot;local-player&quot; class=&quot;player&quot;&gt;&lt;/div&gt; &lt;div id=&quot;local-player-mirror-area&quot; class=&quot;player video-mirror&quot; title=&quot;Video Mirror&quot; style=&quot;display: none; border: 2px dashed red ;&quot;&gt; &lt;div id=&quot;local-player-mirror&quot; style=&quot;width: 100%; height: 100%; position: relative; overflow: hidden; background-color: black;&quot;&gt; &lt;video id=&quot;local-player-mirror-video-track&quot; class=&quot;agora_video_player&quot; playsinline=&quot;&quot; muted=&quot;&quot; style=&quot;width: 100%; height: 100%; position: absolute; left: 0px; top: 0px; transform: rotateY(180deg); object-fit: cover;&quot;&gt; &lt;/video&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;w-100&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;div id=&quot;remote-playerlist&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../assets/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../assets/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://download.agora.io/sdk/release/AgoraRTC_N.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通话逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// create Agora clientvar client = AgoraRTC.createClient(&#123;mode: &quot;live&quot;, codec: &quot;vp8&quot;&#125;);AgoraRTC.enableLogUpload();var localTracks = &#123; videoTrack: null, audioTrack: null&#125;;var remoteUsers = &#123;&#125;;// Agora client optionsvar options = &#123; appid: null, channel: null, uid: null, token: null, role: &quot;audience&quot;, // host or audience audienceLatency: 2&#125;;// the demo can auto join channel with params in url$(() =&gt; &#123; var urlParams = new URL(location.href).searchParams; options.appid = urlParams.get(&quot;appid&quot;); options.channel = urlParams.get(&quot;channel&quot;); options.token = urlParams.get(&quot;token&quot;); options.uid = urlParams.get(&quot;uid&quot;); if (options.appid &amp;&amp; options.channel) &#123; $(&quot;#uid&quot;).val(options.uid); $(&quot;#appid&quot;).val(options.appid); $(&quot;#token&quot;).val(options.token); $(&quot;#channel&quot;).val(options.channel); $(&quot;#join-form&quot;).submit(); &#125;&#125;)$(&quot;#host-join&quot;).click(function (e) &#123; options.role = &quot;host&quot;&#125;)$(&quot;#lowLatency&quot;).click(function (e) &#123; options.role = &quot;audience&quot; options.audienceLatency = 1 $(&quot;#join-form&quot;).submit()&#125;)$(&quot;#ultraLowLatency&quot;).click(function (e) &#123; options.role = &quot;audience&quot; options.audienceLatency = 2 $(&quot;#join-form&quot;).submit()&#125;)$(&quot;#join-form&quot;).submit(async function (e) &#123; e.preventDefault(); $(&quot;#host-join&quot;).attr(&quot;disabled&quot;, true); $(&quot;#audience-join&quot;).attr(&quot;disabled&quot;, true); try &#123; options.appid = $(&quot;#appid&quot;).val(); options.token = $(&quot;#token&quot;).val(); options.channel = $(&quot;#channel&quot;).val(); options.uid = Number($(&quot;#uid&quot;).val()); await join(); if (options.role === &quot;host&quot;) &#123; $(&quot;#success-alert a&quot;).attr(&quot;href&quot;, `index.html?appid=$&#123;options.appid&#125;&amp;channel=$&#123;options.channel&#125;&amp;token=$&#123;options.token&#125;`); if (options.token) &#123; $(&quot;#success-alert-with-token&quot;).css(&quot;display&quot;, &quot;block&quot;); &#125; else &#123; $(&quot;#success-alert a&quot;).attr(&quot;href&quot;, `index.html?appid=$&#123;options.appid&#125;&amp;channel=$&#123;options.channel&#125;&amp;token=$&#123;options.token&#125;`); $(&quot;#success-alert&quot;).css(&quot;display&quot;, &quot;block&quot;); &#125; &#125; &#125; catch (error) &#123; console.error(error); &#125; finally &#123; $(&quot;#leave&quot;).attr(&quot;disabled&quot;, false); &#125;&#125;)$(&quot;#leave&quot;).click(function (e) &#123; leave();&#125;)async function join() &#123; // create Agora client if (options.role === &quot;audience&quot;) &#123; client.setClientRole(options.role, &#123;level: options.audienceLatency&#125;); // add event listener to play remote tracks when remote user publishs. client.on(&quot;user-published&quot;, handleUserPublished); client.on(&quot;user-unpublished&quot;, handleUserUnpublished); &#125; else&#123; client.setClientRole(options.role); &#125; // join the channel options.uid = await client.join(options.appid, options.channel, options.token || null, options.uid || null); if (options.role === &quot;host&quot;) &#123; // create local audio and video tracks localTracks.audioTrack = await AgoraRTC.createMicrophoneAudioTrack(); localTracks.videoTrack = await AgoraRTC.createCameraVideoTrack(); // play local video track localTracks.videoTrack.play(&quot;local-player&quot;); $(&quot;#local-player-name&quot;).text(`localTrack($&#123;options.uid&#125;)`); //create the mirror of local player $(&quot;#local-player-mirror-area&quot;).show(); var mirrorPlayer = document.getElementById(&quot;local-player-mirror-video-track&quot;); //get browser-native object MediaStreamTrack from WebRTC SDK const msTrack = localTracks.videoTrack.getMediaStreamTrack(); //generate browser-native object MediaStream with above video track const ms = new MediaStream([msTrack]) mirrorPlayer.srcObject = ms; mirrorPlayer.play(); // publish local tracks to channel await client.publish(Object.values(localTracks)); console.log(&quot;publish success&quot;); &#125;&#125;async function leave() &#123; for (trackName in localTracks) &#123; var track = localTracks[trackName]; if (track) &#123; track.stop(); track.close(); localTracks[trackName] = undefined; &#125; &#125; // remove remote users and player views remoteUsers = &#123;&#125;; $(&quot;#remote-playerlist&quot;).html(&quot;&quot;); // leave the channel await client.leave(); $(&quot;#local-player-name&quot;).text(&quot;&quot;); $(&quot;#host-join&quot;).attr(&quot;disabled&quot;, false); $(&quot;#audience-join&quot;).attr(&quot;disabled&quot;, false); $(&quot;#leave&quot;).attr(&quot;disabled&quot;, true); $(&quot;.video-mirror&quot;).hide(); console.log(&quot;client leaves channel success&quot;);&#125;async function subscribe(user, mediaType) &#123; const uid = user.uid; // subscribe to a remote user await client.subscribe(user, mediaType); console.log(&quot;subscribe success&quot;); if (mediaType === &#x27;video&#x27;) &#123; const player = $(` &lt;div id=&quot;player-wrapper-$&#123;uid&#125;&quot;&gt; &lt;p class=&quot;player-name&quot;&gt;remoteUser($&#123;uid&#125;)&lt;/p&gt; &lt;div id=&quot;player-$&#123;uid&#125;&quot; class=&quot;player&quot;&gt;&lt;/div&gt; &lt;p class=&quot;player-name&quot;&gt;Video Mirror&lt;/p&gt; &lt;div id=&quot;player-$&#123;uid&#125;-mirror-area&quot; class=&quot;player&quot; style=&quot;border: 2px dashed red ;&quot;&gt; &lt;div style=&quot;width: 100%; height: 100%; position: relative; overflow: hidden; background-color: black;&quot;&gt; &lt;video id=&quot;video_track-video-$&#123;uid&#125;-mirror&quot; class=&quot;agora_video_player&quot; playsinline=&quot;&quot; muted=&quot;&quot; style=&quot;width: 100%; height: 100%; position: absolute; left: 0px; top: 0px; object-fit: contain;&quot;&gt; &lt;/video&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; `); $(&quot;#remote-playerlist&quot;).append(player); user.videoTrack.play(`player-$&#123;uid&#125;`, &#123;fit:&quot;contain&quot;&#125;); //handling the mirror video $(`#player-$&#123;uid&#125;-mirror-area`).show(); var mirrorRemotePlayer = document.getElementById(`video_track-video-$&#123;uid&#125;-mirror`); //get browser-native object MediaStreamTrack from WebRTC SDK const msTrack = user.videoTrack.getMediaStreamTrack(); //generate browser-native object MediaStream with above video track const ms = new MediaStream([msTrack]) mirrorRemotePlayer.srcObject = ms; mirrorRemotePlayer.play(); &#125; if (mediaType === &#x27;audio&#x27;) &#123; user.audioTrack.play(); &#125;&#125;function handleUserPublished(user, mediaType) &#123; const id = user.uid; remoteUsers[id] = user; subscribe(user, mediaType);&#125;function handleUserUnpublished(user, mediaType) &#123; if (mediaType === &#x27;video&#x27;) &#123; const id = user.uid; delete remoteUsers[id]; $(`#player-wrapper-$&#123;id&#125;`).remove(); &#125;&#125; 改动点新建一个配置页面，由用户进入房间时填写 AppId,token,channel等 js 代码改动点： 1234options.appid = $(&quot;#appid&quot;).val();options.token = $(&quot;#token&quot;).val();options.channel = $(&quot;#channel&quot;).val();options.uid = Number($(&quot;#uid&quot;).val());","categories":["Code","TypeScript"]},{"title":"Ubuntu22.04安装 MYSQL 并使用 navicat 连接","path":"/Code/数据库/MYSQL/README/","content":"[toc] 安装Ubuntu 安装 mysql 的教程网上一大堆。 1sudo apt-get install mysql-server 配置 修改配置文件 1sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 在 [mysqld] 添加 skip-grant-tables 重启数据库 12345sudo systemctl restart mysql# 或者sudo service mysql restart 修改用户属性 进入 mysql 1234sudo mysql -u root# 切换到 mysql 数据库use mysql; 更新用户密码 12345alter user root identified with mysql_native_password by &#x27;Admin1234&#x27;;# 或者update user set authentication_string=&#x27;Admin1234&#x27; where user=&#x27;admin&#x27;; 到此就可以使用用户登录了。 1mysql -u root -p 补充，创建其他用户 1CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;; 授权远程使用 更改授权后，一定要执行 flush priviledges;。 1grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;; 执行上一步可能会报错，因为在 上一步 修改用户密码时，设置了地址为 localhost。所以这里不能直接授权其他主机访问，需要先把root账号的host修改为可以访问所有主机，再去授权。 修改root账户 123update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;flush priviledges; 授权远程使用 123grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;;flush priviledges; 重启数据库 12345sudo systemctl restart mysql# 或者sudo service mysql restart 使用 navicat 连接数据库 如果出现连接时报错 1130-host ... is not allowed to connect to this MySql server。则说明是服务器端口权限没开放。简单改动可直接使用ufw命令。如下所示： sudo ufw allow 3306 如下图所示： 连接名：随便起名，用来区分连接的数据库 主机：192.168.0.102 为虚拟机的ip地址 端口：3306,mysql默认端口 用户名：root 密码：密码","tags":["ubuntu","navicat"],"categories":["Code","数据库","MYSQL"]},{"title":"Qt 键盘长按","path":"/Code/Qt/鼠标键盘/Qt键盘长按/","content":"KeyPressEvent 事件键盘事件是重写 keypressevent 函数，详见代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//keyLongPress.cpp #include &quot;keyLongPress.h&quot;#include &quot;ui_keyLongPress.h&quot; KeyLongPress::KeyLongPress(QWidget *parent) : QWidget(parent), ui(new Ui::KeyLongPress)&#123; ui-&gt;setupUi(this);&#125; KeyLongPress::~KeyLongPress()&#123; delete ui;&#125; //QMouseEvent没有isAutoRepeat()方法...无语了，//这样有些操作就不方便实现了，//比如长按鼠标多少秒呼出某个(登录)窗口啥的。 //! [按键按下事件-Begin]void KeyLongPress::keyPressEvent(QKeyEvent *event)&#123; if(event-&gt;isAutoRepeat())&#123; qDebug() &lt;&lt; &quot;按键长按中...&quot;; &#125; else&#123; qDebug() &lt;&lt; &quot;按键按下&quot;; &#125;&#125;//! [按键按下事件-End] //! [按键释放事件-Begin]void KeyLongPress::keyReleaseEvent(QKeyEvent *event)&#123; if(event-&gt;isAutoRepeat())&#123; qDebug() &lt;&lt; &quot;按键不断释放...&quot;; &#125; else&#123; qDebug() &lt;&lt; &quot;按键释放&quot;; &#125;&#125;//! [按键释放事件-End] 运行之后，测试效果：你Click看下输出：是只有1次Press和1次Release的， 长按看下输出：是Press和Release一直在不停的输出的。 示意图：","tags":["Qt","键盘"],"categories":["Code","Qt","鼠标键盘"]},{"title":"Qt 圆形进度条","path":"/Code/Qt/动画/Qt圆形进度条/","content":"[toc] 实现效果 h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#ifndef _QROUNDPROGRESSBAR_H_#define _QROUNDPROGRESSBAR_H_ #include &lt;QWidget&gt; class QRoundProgressBar : public QWidget&#123; Q_OBJECTpublic: //进度条形状 enum BarStyle &#123; //圆环状 StyleDonut = 0, //圆饼状 StylePie, //圆线状 StyleLine &#125;; public: QRoundProgressBar(QWidget *parent , BarStyle style = StyleLine); ~QRoundProgressBar(); public: //设置扫描弧度起始角度 void setStartAngle(double position); //设置轮廓画笔的宽度 void setOutlinePenWidth(double penWidth); //设置画笔宽度 void setDataPenWidth(double penWidth); //设置进度条精度 88.88%,几位小数 void setDecimals(int count); //设置进度条风格 void setBarStyle(BarStyle style); //设置范围 void setRange(double min, double max); //设置当前值 void setValue(int val); //设置当前值 void setValue(double val); //设置最小值 void setMinimum(double min); //设置最大值 void setMaximum(double max); protected: void paintEvent(QPaintEvent *event); //画基础图形 void drawBase(QPainter&amp; p, const QRectF&amp; baseRect, const QRectF &amp;innerRect); //根据值画出进度条 void drawValue(QPainter&amp; p, const QRectF&amp; baseRect, double value, double arcLength, const QRectF &amp; innerRect , double innerDiameter); //画中心文字 void drawText(QPainter&amp; p, const QRectF&amp; innerRect, double value); private: double m_min; //最小值 double m_max; //最大值 double m_value; //当前值 BarStyle m_barStyle; //进度条风格 int m_decimals; //进度条精度 double m_startAngel; //扫描弧度起始角度 double m_outlinePenWidth; //轮廓画笔的宽度 double m_dataPenWidth; //画笔宽度&#125;; #endif // _QROUNDPROGRESSBAR_H_ cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285#include &quot;QRoundProgressBar.h&quot;#include &lt;QPainter&gt;#include &lt;QPointF&gt;#include &lt;QtMath&gt; QRoundProgressBar::QRoundProgressBar(QWidget *parent , BarStyle style) : QWidget(parent) , m_min(0) , m_max(100) , m_value(0) , m_startAngel(90) , m_barStyle(style) , m_outlinePenWidth(0) , m_dataPenWidth(0) , m_decimals(0)&#123;&#125; QRoundProgressBar::~QRoundProgressBar()&#123;&#125; void QRoundProgressBar::setStartAngle(double angle)&#123; if (angle != m_startAngel) &#123; m_startAngel = angle; update(); &#125;&#125; void QRoundProgressBar::setOutlinePenWidth(double penWidth)&#123; if (penWidth != m_outlinePenWidth) &#123; m_outlinePenWidth = penWidth; update(); &#125;&#125; void QRoundProgressBar::setDataPenWidth(double penWidth)&#123; if (penWidth != m_dataPenWidth) &#123; m_dataPenWidth = penWidth; update(); &#125;&#125; void QRoundProgressBar::setDecimals(int count)&#123; if (count &gt;= 0 &amp;&amp; count != m_decimals) &#123; m_decimals = count; update(); &#125;&#125; void QRoundProgressBar::setBarStyle(BarStyle style)&#123; if (style != m_barStyle) &#123; m_barStyle = style; update(); &#125;&#125; void QRoundProgressBar::setRange(double min, double max)&#123; m_min = min; m_max = max; if (m_max &lt; m_min) &#123; qSwap(m_max, m_min); &#125; if (m_value &lt; m_min) &#123; m_value = m_min; &#125; else if (m_value &gt; m_max) &#123; m_value = m_max; &#125; update();&#125; void QRoundProgressBar::setValue(double val)&#123; if (m_value != val) &#123; if (val &lt; m_min) &#123; m_value = m_min; &#125; else if (val &gt; m_max) &#123; m_value = m_max; &#125; else &#123; m_value = val; &#125; update(); &#125;&#125; void QRoundProgressBar::setValue(int val)&#123; setValue(double(val));&#125; void QRoundProgressBar::setMinimum(double min)&#123; setRange(min, m_max);&#125; void QRoundProgressBar::setMaximum(double max)&#123; setRange(m_min, max);&#125; void QRoundProgressBar::paintEvent(QPaintEvent* /*event*/)&#123; //外圈直径 double outerDiameter = this-&gt;width(); //外圈矩形 QRectF baseRect(0, 0, outerDiameter, outerDiameter); QPainter p(this); p.setRenderHints(QPainter::Antialiasing | QPainter::SmoothPixmapTransform); //画背景矩形填充白色 p.fillRect(baseRect, QBrush(QColor(&quot;#FFFFFF&quot;))); //内圆直径 double innerDiameter = width() * 0.9; //内圈矩形 QRectF innerRect; //计算内圈矩形 if (m_barStyle == StyleLine) &#123; innerDiameter = outerDiameter - m_outlinePenWidth; &#125; else if(m_barStyle == StyleDonut) &#123; innerDiameter = outerDiameter * 0.9; &#125; double delta = (outerDiameter - innerDiameter) / 2; innerRect = QRectF(delta, delta, innerDiameter, innerDiameter); //画基础图形 drawBase(p, baseRect, innerRect); //计算当前步长比例 double arcStep = 360.0 / (m_max - m_min) * m_value; //根据值画出进度条 drawValue(p, baseRect, m_value, arcStep, innerRect, innerDiameter); //画文字 drawText(p, baseRect, m_value); p.end();&#125; void QRoundProgressBar::drawBase(QPainter &amp;p, const QRectF &amp;baseRect, const QRectF &amp;innerRect)&#123; switch (m_barStyle) &#123; case StyleDonut: &#123; QPainterPath dataPath; dataPath.setFillRule(Qt::OddEvenFill); dataPath.moveTo(baseRect.center()); dataPath.addEllipse(innerRect); QPen pen; pen.setColor(QColor(&quot;#DEE3E7&quot;)); pen.setWidth(10); p.setPen(pen); p.setBrush(QBrush(QColor(&quot;#FFFFFF&quot;))); p.drawPath(dataPath); break; &#125; case StylePie: &#123; p.setPen(QPen(QColor(&quot;#FFFFFF&quot;), m_outlinePenWidth)); p.setBrush(QBrush(QColor(&quot;#DEE3E7&quot;))); p.drawEllipse(baseRect); break; &#125; case StyleLine: &#123; p.setPen(QPen(QColor(&quot;#FFFFFF&quot;), m_outlinePenWidth)); p.setBrush(Qt::NoBrush); p.drawEllipse(baseRect.adjusted(m_outlinePenWidth / 2, m_outlinePenWidth / 2, -m_outlinePenWidth / 2, -m_outlinePenWidth / 2)); break; &#125; default: &#123; break; &#125; &#125;&#125; void QRoundProgressBar::drawValue(QPainter &amp;p, const QRectF &amp;baseRect , double value, double arcLength , const QRectF &amp; innerRect, double innerDiameter)&#123; if (value == m_min) &#123; return; &#125; if (m_barStyle == StyleLine) &#123; p.setPen(QColor(&quot;#2F8DED&quot;)); p.setBrush(Qt::NoBrush); p.drawArc(baseRect,m_startAngel * 16, -arcLength * 16); &#125; else if (m_barStyle == StyleDonut) &#123; QPen pen; pen.setColor(QColor(&quot;#2F8DED&quot;)); pen.setWidth(8); pen.setCapStyle(Qt::RoundCap); p.setPen(pen); p.drawArc(innerRect, m_startAngel*16 , -16*arcLength); &#125; else &#123; //获取中心点坐标 QPointF centerPoint = baseRect.center(); QPainterPath dataPath; dataPath.setFillRule(Qt::WindingFill); dataPath.moveTo(centerPoint); //逆时针画弧长 dataPath.arcTo(baseRect, m_startAngel, -arcLength); if (m_barStyle == StylePie) &#123; dataPath.lineTo(centerPoint); p.setPen(QPen(QColor(&quot;#2F8DED&quot;), m_dataPenWidth)); &#125; p.setBrush(QBrush(QColor(&quot;#2F8DED&quot;))); p.drawPath(dataPath); &#125; &#125; void QRoundProgressBar::drawText(QPainter &amp;p, const QRectF &amp;rect, double value)&#123; QString textToDraw = &quot;%&quot;; double percent = (value - m_min) / (m_max - m_min) * 100.0; textToDraw = QString::number(percent, &#x27;f&#x27;, m_decimals) + textToDraw; QFont f; f.setFamily(&quot;微软雅黑&quot;); f.setPixelSize(20); p.setFont(f); p.setPen(QColor(&quot;#606266&quot;)); p.drawText(rect, Qt::AlignCenter, textToDraw);&#125;","tags":["Qt","进度条","圆"],"categories":["Code","Qt","动画"]},{"title":"Qt动画类","path":"/Code/Qt/动画/Qt动画效果/","content":"[toc] 动画框架结构动画框架由基类 QAbstractAnimation 以及它的两个子类 QVariantAnimation 、QAnimationGroup 组成。基础动画由QVariantAnimation的子类QPropertyAnimation来设置，再通过将多个QPropertyAnimation和QPauseAnimation组合成为动画组（QParallelAnimationGroup、QSequentialAnimationGroup），完成一个连续的动画。 QPropertyAnimation QPropertyAnimation 类能够修改Qt的属性值，如pos、geometry等属性。设置好动画的初值和末值，以及持续的时间后，一个属性动画就基本完成了。 缩放通过修改控件的geometry属性可以实现缩放效果，也可以实现位移的动画，该属性的前两个值确定了控件左上角的位置，后两个值确定了控件的大小。 12345//scaleQPropertyAnimation *pScaleAnimation1 = new QPropertyAnimation(ui-&gt;scaleButton, &quot;geometry&quot;);pScaleAnimation1-&gt;setDuration(1000);pScaleAnimation1-&gt;setStartValue(QRect(190, 230, 0, 0));pScaleAnimation1-&gt;setEndValue(QRect(120, 160, 140, 140)); 位移如果只是需要位移动画的话，修改控件的pos属性即可。pos属性就是控件的左上角所在的位置。 123456//posQPropertyAnimation *pPosAnimation1 = new QPropertyAnimation(ui-&gt;posButton, &quot;pos&quot;);pPosAnimation1-&gt;setDuration(1000);pPosAnimation1-&gt;setStartValue(QPoint(360, 160));pPosAnimation1-&gt;setEndValue(QPoint(360, 350));pPosAnimation1-&gt;setEasingCurve(QEasingCurve::InOutQuad); 不透明度Qt的控件没有单独的透明度属性，要修改控件的透明度可以通过 QGraphicsOpacityEffect 类来实现。 123456789//opacityQGraphicsOpacityEffect *pButtonOpacity = new QGraphicsOpacityEffect(this);pButtonOpacity-&gt;setOpacity(1);ui-&gt;opasityButton-&gt;setGraphicsEffect(pButtonOpacity);QPropertyAnimation *pOpacityAnimation1 = new QPropertyAnimation(pButtonOpacity, &quot;opacity&quot;);pOpacityAnimation1-&gt;setDuration(1000);pOpacityAnimation1-&gt;setStartValue(1);pOpacityAnimation1-&gt;setEndValue(0); 动画曲线动画还可以设置时间的插值曲线，默认是linear，即线性运动，通过设置QEasingCurve即可。Qt提供了40种已经定义好的曲线（如果有需要也可以自定义曲线）： 1pScaleAnimation1-&gt;setEasingCurve(QEasingCurve::InOutQuad);","tags":["Qt","动画"],"categories":["Code","Qt","动画"]},{"title":"Qt 启动动画","path":"/Code/Qt/动画/Qt启动动画/","content":"[toc] QSplashScreen设置图片 Qt内置了用于程序启动的动画直接使用QSplashScreen即可。 12345678910111213141516171819202122QPixmap pixmap(&quot;:load.gif&quot;); //读取图片QSplashScreen splash(pixmap); //splash.setWindowOpacity(0.8); // 设置窗口透明度splash.show();splash.showMessage(&quot;程序正在加载......&quot;, Qt::AlignCenter, Qt::red); //显示文字// 可选项#ifdeg DEBUGQDateTime time = QDateTime::currentDateTime();QDateTime currentTime = QDateTime::currentDateTime(); //记录当前时间while (time.secsTo(currentTime) &lt;= 5) // 5为需要延时的秒数&#123; currentTime = QDateTime::currentDateTime(); a.processEvents();&#125;;#endifwidget w;w.show();splash.finish(&amp;w); //在主体对象初始化完成后结束启动动画 以上代码放在程序的入口main函数中即可。 widget就是我们需要启动的程序。 自定义启动动画 自定义启动动画的方式网上有几种重写 QSplashScreen 的。笔者也尝试使用了一下，发现并不好用，于是按照一开始的方案，准备用一个 widget 去写启动动画。 参考 QSplashScreen 的方式，还是使用 finish(QWidget *mainWin) 的接口去作为窗体关闭的入口。 finish(Qwidget *mainWin)关于 finished(QWidget *mainWin) 直接把 QSplashScreen 的源码搬过来即可。 源码一般在你使用的版本的 src 文件夹下： $&#123;install dir&#125;\\5.9.9\\Src\\qtbase\\src\\widgets\\widgets QSplashScreen 源码中的 finish() 如下所示： 1234567891011121314/*! Makes the splash screen wait until the widget \\a mainWin is displayed before calling close() on itself.*/// 这个接口我们需要复制到自定义的启动动画窗体中。void QSplashScreen::finish(QWidget *mainWin)&#123; if (mainWin) &#123; if (!mainWin-&gt;windowHandle()) mainWin-&gt;createWinId(); waitForWindowExposed(mainWin-&gt;windowHandle()); &#125; close();&#125; 上述代码，唯一的问题在于 waitForWindowExposed 这个函数我没有找到实现，也没有仔细找，但是在 Qt 的 testlib 库中有一个类似的接口 QTest::qwaitForWindowExposed() 两个接口的作用应该是一致的。上述代码中 waitForWindowExposed(mainWin-&gt;windowHandle()); 经笔者测试哈（不一定准确），即使去掉也不会影响 finish() 接口的作用。^2022年7月27日08:39:40^ 去掉还是会有影响的，相当于判断窗口的逻辑没了。关于 waitForWindowExposed() 在 Qt源码中的实现，笔者在调试程序的时候发现去掉这行代码，怎么看启动动画和运行的程序之间的衔接都不太合理，遂决定找一下这个 waitForWindowExposed() 的源码，这一找，真的是远在天边，近在眼前。函数的实现就在 qsplashscreen.cpp 中。这里贴一下其源码。 1234567891011121314151617181920212223// A copy of Qt Test&#x27;s qWaitForWindowExposed() and qSleep().inline static bool waitForWindowExposed(QWindow *window, int timeout = 1000)&#123; enum &#123; TimeOutMs = 10 &#125;; QElapsedTimer timer; timer.start(); while (!window-&gt;isExposed()) &#123; const int remaining = timeout - int(timer.elapsed()); if (remaining &lt;= 0) break; QCoreApplication::processEvents(QEventLoop::AllEvents, remaining); QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);#if defined(Q_OS_WINRT) WaitForSingleObjectEx(GetCurrentThread(), TimeOutMs, false);#elif defined(Q_OS_WIN) Sleep(uint(TimeOutMs));#else struct timespec ts = &#123; TimeOutMs / 1000, (TimeOutMs % 1000) * 1000 * 1000 &#125;; nanosleep(&amp;ts, NULL);#endif &#125; return window-&gt;isExposed();&#125; 如果要使用你源码中的实现，则需要引入两个头问题。 12#include &lt;QElapsedTimer&gt;#include &lt;QtGui/QWindow&gt; *设置窗体设置窗体的逻辑也比较简单，就是创建一个widget、Dialog专门用来实现启动动画的逻辑。如下所示为Qt程序的入口函数： 123456789101112int main(int argc, char *argv[])&#123; QApplication a(argc, argv);\tDialog d; // 启动动画的窗台 d.show(); Widget w; w.show();\td.finish(&amp;w); // 复制的 QSplashScreen 中的 finished()\treturn a.exec();&#125; 其中的 Dialog d 就是我们创建的一个自定义的启动动画窗口，至于窗口内要实现什么，依据你个人的业务和需求去实现即可。 问题1 上文中的 Dialog 还没有主界面就展示了，或者 Dialog 展示了但是没有画面。 关于这个问题，我认为是主界面的刷新太快了（大家可以调试代码去观察一下现象），也就是 finish 相当于是瞬间调用了。导致 Dialog没有展示和来得及刷新 。这个问题网友也给出了方案，让 main 做一些别的操作延时一下。目前笔者用过的最好的不是在 main 中 sleep 。而是执行以下 processEvent() 具体的代码就是在 Widget::show() 之前调用，如下所示： 12345678// 这里的时间只是为了做一个判断，只调用一下 a.processEvents(); 应该也是可以的QDateTime time = QDateTime::currentDateTime();QDateTime currentTime = QDateTime::currentDateTime(); //记录当前时间while (time.secsTo(currentTime) &lt;= 5) //5为需要延时的秒数&#123; currentTime = QDateTime::currentDateTime(); a.processEvents();&#125;; 问题2 Dialog 结束的时候界面关闭和主界面的展示会中断一下，强迫症难以接受这种突然闪现怎么办？ 还是会到 finish() 。 在 closed() 的位置 sleep()，让关闭的窗口稍微等一等，等主界面展示出来之后再关闭。1s 的时间足够主界面刷新出来了 。代码如下： 12345678910void Dialog::finish(QWidget *mainWin) // 这里已经是我们自定义的启动动画窗口 Dialog 了&#123; if (mainWin) &#123; if (!mainWin-&gt;windowHandle()) mainWin-&gt;createWinId(); waitForWindowExposed(mainWin-&gt;windowHandle()); &#125; QThread::sleep(1); // sleep 的单位是秒 close();&#125; 完整代码 widget 的代码不展示 main.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;widget.h&quot;#include &quot;dialog.h&quot;#include &lt;QApplication&gt;#include &lt;QLabel&gt;#include &lt;QPixmap&gt;#include &lt;QSplashScreen&gt;#include &lt;QThread&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv);#ifdef QT_DEBUG // 使用 QSplashScreen 的启动动画 QPixmap pixmap(&quot;:/test.gif&quot;); QSplashScreen splash(pixmap,10); splash.show(); QDateTime time = QDateTime::currentDateTime(); QDateTime currentTime = QDateTime::currentDateTime(); //记录当前时间 while (time.secsTo(currentTime) &lt;= 5) //5为需要延时的秒数 &#123; currentTime = QDateTime::currentDateTime(); a.processEvents(); &#125;;#endif Dialog d; // 使用自定义的启动动画 d.show(); QDateTime time = QDateTime::currentDateTime(); QDateTime currentTime = QDateTime::currentDateTime(); //记录当前时间 while (time.secsTo(currentTime) &lt;= 5) //5为需要延时的秒数 &#123; currentTime = QDateTime::currentDateTime(); a.processEvents(); &#125;; Widget w; // 主程序 w.show();#ifdef QT_DEBUG // 使用 QSplashScreen 的启动动画\tsplash.finish(&amp;w);#endif d.finish(&amp;w); return a.exec();&#125; dialog.h1234567891011121314151617181920212223#ifndef DIALOG_H#define DIALOG_H#include &lt;QDialog&gt;namespace Ui &#123;class Dialog;&#125;class Dialog : public QDialog&#123; Q_OBJECTpublic: explicit Dialog(QWidget *parent = nullptr); ~Dialog(); void finish(QWidget *mainWin);private: Ui::Dialog *ui;&#125;;#endif // DIALOG_H dialog.cpp12345678910111213141516171819202122232425262728293031#include &quot;dialog.h&quot;#include &quot;ui_dialog.h&quot;Dialog::Dialog(QWidget *parent) : QDialog(parent), ui(new Ui::Dialog)&#123; ui-&gt;setupUi(this); // setWindowFlags(Qt::FramelessWindowHint | Qt::Tool | Qt::WindowStaysOnTopHint | Qt::Window); //setAttribute(Qt::WA_TranslucentBackground); setStyleSheet(&quot;#Dialog&#123;&quot; &quot;border-image: url(:/bgimg_334.png);&quot; // 自己添加一个图片到程序，不添加也不影响程序运行 &quot;background-position: center;&quot; &quot;backgroun d-repeat: no-repeat;&quot; &quot;&#125;&quot;);&#125;Dialog::~Dialog()&#123; delete ui;&#125;void Dialog::finish(QWidget* mainWin)&#123; if (mainWin) &#123; if (!mainWin-&gt;windowHandle()) mainWin-&gt;createWinId(); //\tQTest::qWaitForWindowExposed(mainWin-&gt;windowHandle()); &#125; close();&#125; dialog.ui123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;Dialog&lt;/class&gt; &lt;widget class=&quot;QDialog&quot; name=&quot;Dialog&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;400&lt;/width&gt; &lt;height&gt;300&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;Dialog&lt;/string&gt; &lt;/property&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout&quot;&gt; &lt;item row=&quot;2&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QDialogButtonBox&quot; name=&quot;buttonBox&quot;&gt; &lt;property name=&quot;orientation&quot;&gt; &lt;enum&gt;Qt::Horizontal&lt;/enum&gt; &lt;/property&gt; &lt;property name=&quot;standardButtons&quot;&gt; &lt;set&gt;QDialogButtonBox::Cancel|QDialogButtonBox::Ok&lt;/set&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item row=&quot;1&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QFrame&quot; name=&quot;frame&quot;&gt; &lt;property name=&quot;frameShape&quot;&gt; &lt;enum&gt;QFrame::StyledPanel&lt;/enum&gt; &lt;/property&gt; &lt;property name=&quot;frameShadow&quot;&gt; &lt;enum&gt;QFrame::Raised&lt;/enum&gt; &lt;/property&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_2&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;layout class=&quot;QVBoxLayout&quot; name=&quot;verticalLayout&quot;&gt; &lt;item&gt; &lt;widget class=&quot;QStackedWidget&quot; name=&quot;stackedWidget&quot;&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page&quot;&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;widget&quot; native=&quot;true&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;-101&lt;/x&gt; &lt;y&gt;-10&lt;/y&gt; &lt;width&gt;231&lt;/width&gt; &lt;height&gt;51&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/widget&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page_2&quot;/&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class=&quot;QStackedWidget&quot; name=&quot;stackedWidget_2&quot;&gt; &lt;property name=&quot;currentIndex&quot;&gt; &lt;number&gt;1&lt;/number&gt; &lt;/property&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page_3&quot;/&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page_4&quot;/&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections&gt; &lt;connection&gt; &lt;sender&gt;buttonBox&lt;/sender&gt; &lt;signal&gt;accepted()&lt;/signal&gt; &lt;receiver&gt;Dialog&lt;/receiver&gt; &lt;slot&gt;accept()&lt;/slot&gt; &lt;hints&gt; &lt;hint type=&quot;sourcelabel&quot;&gt; &lt;x&gt;248&lt;/x&gt; &lt;y&gt;254&lt;/y&gt; &lt;/hint&gt; &lt;hint type=&quot;destinationlabel&quot;&gt; &lt;x&gt;157&lt;/x&gt; &lt;y&gt;274&lt;/y&gt; &lt;/hint&gt; &lt;/hints&gt; &lt;/connection&gt; &lt;connection&gt; &lt;sender&gt;buttonBox&lt;/sender&gt; &lt;signal&gt;rejected()&lt;/signal&gt; &lt;receiver&gt;Dialog&lt;/receiver&gt; &lt;slot&gt;reject()&lt;/slot&gt; &lt;hints&gt; &lt;hint type=&quot;sourcelabel&quot;&gt; &lt;x&gt;316&lt;/x&gt; &lt;y&gt;260&lt;/y&gt; &lt;/hint&gt; &lt;hint type=&quot;destinationlabel&quot;&gt; &lt;x&gt;286&lt;/x&gt; &lt;y&gt;274&lt;/y&gt; &lt;/hint&gt; &lt;/hints&gt; &lt;/connection&gt; &lt;/connections&gt;&lt;/ui&gt;","tags":["Qt","动画"],"categories":["Code","Qt","动画"]},{"title":"Qt任务栏显示进度条","path":"/Code/Qt/动画/Qt任务栏进度条/","content":"Qt 任务栏显示进度条 注意事项： 修改pro文件 界面展示后再 new QWinTaskbarButton，否则会不显示 # Qt 官方demo1234567QWinTaskbarButton *button = new QWinTaskbarButton(widget);button-&gt;setWindow(widget-&gt;windowHandle());button-&gt;setOverlayIcon(QIcon(&quot;:/loading.png&quot;));QWinTaskbarProgress *progress = button-&gt;progress();progress-&gt;setVisible(true);progress-&gt;setValue(50); # Demo1 修改pro文件1win32:QT += winextras 2 .h12345678910111213141516171819202122232425262728293031323334353637#ifndef TASKBARPROGRESS_H#define TASKBARPROGRESS_H #include &lt;QMainWindow&gt;#include &lt;QTimer&gt;#include &lt;QAbstractButton&gt;#include &lt;QWinTaskbarProgress&gt;#include &lt;QWinTaskbarButton&gt; namespace Ui &#123;class TaskbarProgress;&#125; class TaskbarProgress : public QMainWindow&#123; Q_OBJECT public: explicit TaskbarProgress(QWidget *parent = 0); ~TaskbarProgress(); void onButtonClicked(); void onTimeout(); private: Ui::TaskbarProgress *ui; QTimer *timer; QWinTaskbarButton *windowsTaskbarButton; QWinTaskbarProgress *windowsTaskbarProgress;&#125;; #endif // TASKBARPROGRESS_H 3 .cpp12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;taskbarprogress.h&quot;#include &quot;ui_taskbarprogress.h&quot; TaskbarProgress::TaskbarProgress(QWidget *parent) : QMainWindow(parent), ui(new Ui::TaskbarProgress)&#123; ui-&gt;setupUi(this); timer = new QTimer; timer-&gt;setInterval(1000); //设置时间间隔 //创建显示进度的任务栏按钮 windowsTaskbarButton = new QWinTaskbarButton(this); connect(timer, &amp;QTimer::timeout, this, &amp;TaskbarProgress::onTimeout); connect(ui-&gt;Btn_Start, &amp;QAbstractButton::clicked, this, &amp;TaskbarProgress::onButtonClicked);&#125; TaskbarProgress::~TaskbarProgress()&#123; delete ui;&#125; void TaskbarProgress::onButtonClicked() &#123; //将任务栏按钮关联到进度栏，假设进度栏是它自己的窗口 windowsTaskbarButton-&gt;setWindow(windowHandle()); windowsTaskbarProgress = windowsTaskbarButton-&gt;progress(); windowsTaskbarProgress-&gt;setRange(0, 100); timer-&gt;start();&#125; void TaskbarProgress::onTimeout() &#123; //当进度条的值发生变化时，更改任务栏中的进度值 windowsTaskbarProgress-&gt;setValue(windowsTaskbarProgress-&gt;value() + 20); windowsTaskbarProgress-&gt;show(); if (windowsTaskbarProgress-&gt;value() &gt; 99) &#123; windowsTaskbarProgress-&gt;setValue(0); timer-&gt;stop(); &#125;&#125;","tags":["Qt","动画","任务栏"],"categories":["Code","Qt","动画"]},{"title":"Qt 动画效果 （抖动、下坠、透明度）","path":"/Code/Qt/动画/Qt动画/","content":"收集整理的一些 Qt 常用动画 [toc] 下坠效果通过计算桌面的宽度、高度，来设置动画的起始值和结束值。 123456789101112void MainWindow::onDropWindow()&#123; QPropertyAnimation *pAnimation = new QPropertyAnimation(this, &quot;geometry&quot;); QDesktopWidget *pDesktopWidget = QApplication::desktop(); int x = (pDesktopWidget-&gt;availableGeometry().width() - width()) / 2; int y = (pDesktopWidget-&gt;availableGeometry().height() - height()) / 2; pAnimation-&gt;setDuration(1000); pAnimation-&gt;setStartValue(QRect(x, 0, width(), height())); pAnimation-&gt;setEndValue(QRect(x, y, width(), height())); pAnimation-&gt;setEasingCurve(QEasingCurve::OutElastic); pAnimation-&gt;start(QAbstractAnimation::DeleteWhenStopped);&#125; 抖动效果获取界面的坐标，然后进行上、下、左、右坐标浮动，通过setKeyValueAt()来设置每一时刻的位置，实现抖动效果。 123456789101112131415161718void MainWindow::onShakeWindow()&#123; QPropertyAnimation *pAnimation = new QPropertyAnimation(this, &quot;pos&quot;); pAnimation-&gt;setDuration(500); pAnimation-&gt;setLoopCount(2); pAnimation-&gt;setKeyValueAt(0, QPoint(geometry().x() - 3, geometry().y() - 3)); pAnimation-&gt;setKeyValueAt(0.1, QPoint(geometry().x() + 6, geometry().y() + 6)); pAnimation-&gt;setKeyValueAt(0.2, QPoint(geometry().x() - 6, geometry().y() + 6)); pAnimation-&gt;setKeyValueAt(0.3, QPoint(geometry().x() + 6, geometry().y() - 6)); pAnimation-&gt;setKeyValueAt(0.4, QPoint(geometry().x() - 6, geometry().y() - 6)); pAnimation-&gt;setKeyValueAt(0.5, QPoint(geometry().x() + 6, geometry().y() + 6)); pAnimation-&gt;setKeyValueAt(0.6, QPoint(geometry().x() - 6, geometry().y() + 6)); pAnimation-&gt;setKeyValueAt(0.7, QPoint(geometry().x() + 6, geometry().y() - 6)); pAnimation-&gt;setKeyValueAt(0.8, QPoint(geometry().x() - 6, geometry().y() - 6)); pAnimation-&gt;setKeyValueAt(0.9, QPoint(geometry().x() + 6, geometry().y() + 6)); pAnimation-&gt;setKeyValueAt(1, QPoint(geometry().x() - 3, geometry().y() - 3)); pAnimation-&gt;start(QAbstractAnimation::DeleteWhenStopped);&#125; 透明度效果设置每一时刻的透明度值，动画结束时界面还原（透明度再为1）。 123456789void MainWindow::onOpacityWindow()&#123; QPropertyAnimation *pAnimation = new QPropertyAnimation(this, &quot;windowOpacity&quot;); pAnimation-&gt;setDuration(1000); pAnimation-&gt;setKeyValueAt(0, 1); pAnimation-&gt;setKeyValueAt(0.5, 0); pAnimation-&gt;setKeyValueAt(1, 1); pAnimation-&gt;start(QAbstractAnimation::DeleteWhenStopped);&#125; 是不是很有趣，还不快点儿，实现属于自己的动画。","tags":["Qt","动画"],"categories":["Code","Qt","动画"]},{"title":"QStackWidget动画(2)","path":"/Code/Qt/动画/QStackWidget动画2/","content":"QStackWidget 切换动画的实现方式，通过重写 QWidget 实现 使用重写实现的切换动画使用和展示上更稳定，推荐使用当前这个。 .h 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#ifndef MYSTACKWIDGET_H#define MYSTACKWIDGET_H#include &lt;QPropertyAnimation&gt;class MyStackWidget : public QWidget&#123; Q_OBJECTpublic: MyStackWidget(QWidget *parent); ~MyStackWidget(); int addWidget(QWidget *widget); //添加控件 int insertWidget(int index, QWidget *widget); //插入控件 void removeWidget(QWidget *widget); //删除控件 int count() const; //目前控件数 void setWidgetsVisible(); //设置控件可见 void setCurrentWidget(QWidget *widget); //设置当前widget显示 void setCurrentIndex(int index); int currentIndex() const; //获取当前显示位置 QWidget *currentWidget() const; //获取当前显示的控件 QWidget *widget(int index) const; int indexOf(QWidget *widget) const; //获取widget所在位置 void setDuration(int duration); //设置动画时长protected: void resizeEvent(QResizeEvent *event);signals: void widgetRemoved(int); void currentChanged(int);private slots: void onValueChanged(const QVariant &amp;value);private: QList&lt;QWidget *&gt; m_widgetLst; //加入的控件链表 QPropertyAnimation *m_moveAnimation; //动画类 int m_curIndex = 0; //当前显示位置 int m_offset = 0; //需要显示的位置与当前显示的位置的偏差 int m_lastIndex = 0; //最后位置 int m_duration = 500; //动画显示时长，单位:ms void moveAnimationStart(); //启动移动动画&#125;;#endif // MYSTACKWIDGET_H .cpp 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &quot;mystackwidget.h&quot;#include &lt;QDebug&gt;#include &lt;QPropertyAnimation&gt;MyStackWidget::MyStackWidget(QWidget *parent) : QWidget(parent)&#123; m_offset = 0; m_curIndex = 0; m_lastIndex = 0; m_duration = 500; m_moveAnimation = new QPropertyAnimation(this, &quot;&quot;); m_moveAnimation-&gt;setDuration(m_duration); connect(m_moveAnimation, &amp;QPropertyAnimation::valueChanged, this, &amp;MyStackWidget::onValueChanged);&#125;MyStackWidget::~MyStackWidget()&#123;&#125;int MyStackWidget::count() const&#123; return m_widgetLst.size();&#125;int MyStackWidget::currentIndex() const&#123; return m_curIndex;&#125;void MyStackWidget::setDuration(int duration)&#123; m_duration = duration;&#125;int MyStackWidget::addWidget(QWidget * widget)&#123; int index = indexOf(widget); if (index &gt;= 0)&#123; return index; &#125; widget-&gt;setParent(this); m_widgetLst.append(widget); return count() - 1;&#125;int MyStackWidget::indexOf(QWidget * widget) const&#123; return m_widgetLst.indexOf(widget);&#125;int MyStackWidget::insertWidget(int index, QWidget * widget)&#123; int curindex = indexOf(widget); if (curindex &gt;= 0) &#123; return curindex; &#125; widget-&gt;setParent(this); m_widgetLst.insert(index, widget); return index;&#125;QWidget * MyStackWidget::currentWidget() const&#123; if (m_curIndex &gt;= 0 &amp;&amp; m_curIndex &lt; count())&#123; return m_widgetLst.at(m_curIndex); &#125; return nullptr;&#125;QWidget * MyStackWidget::widget(int index) const&#123; if (index &gt;= 0 &amp;&amp; index &lt; count()) &#123; return m_widgetLst.at(index); &#125; return nullptr;&#125;void MyStackWidget::removeWidget(QWidget * widget)&#123; int index = indexOf(widget); if (index &gt;= 0) &#123; m_widgetLst.removeAll(widget); emit widgetRemoved(index); &#125;&#125;void MyStackWidget::setCurrentWidget(QWidget * widget)&#123; int index = indexOf(widget); if (index &gt;= 0 &amp;&amp; m_curIndex != index) &#123; setCurrentIndex(index); &#125;&#125;void MyStackWidget::setCurrentIndex(int index)&#123; if (index &gt;= 0 &amp;&amp; m_curIndex != index) &#123; m_lastIndex = m_curIndex; m_curIndex = index; moveAnimationStart(); emit currentChanged(index); &#125;&#125;void MyStackWidget::resizeEvent(QResizeEvent *event)&#123; QWidget::resizeEvent(event); int size = count(); for (int i = 0; i &lt; size; i++) &#123; m_widgetLst.at(i)-&gt;resize(this-&gt;width(), this-&gt;height()); &#125; if (m_moveAnimation-&gt;state() == QAbstractAnimation::Running) &#123; moveAnimationStart(); &#125; else &#123; setWidgetsVisible(); &#125;&#125;void MyStackWidget::onValueChanged(const QVariant &amp;value)&#123; m_offset = value.toInt(); m_widgetLst.at(m_curIndex)-&gt;move(m_offset, 0); if (m_curIndex &gt; m_lastIndex) &#123; m_widgetLst.at(m_lastIndex)-&gt;move(m_offset - this-&gt;width(), 0); &#125; else &#123; m_widgetLst.at(m_lastIndex)-&gt;move(this-&gt;width() + m_offset, 0); &#125;&#125;void MyStackWidget::moveAnimationStart()&#123; m_moveAnimation-&gt;stop(); setWidgetsVisible(); int startOffset = m_offset; if (m_curIndex &gt; m_lastIndex) &#123; if (startOffset == 0) startOffset = this-&gt;width(); else startOffset = this-&gt;width() - qAbs(startOffset); &#125; else &#123; if (startOffset == 0) startOffset = -this-&gt;width(); else startOffset = qAbs(startOffset) - this-&gt;width(); &#125; m_moveAnimation-&gt;setDuration(qAbs(startOffset) * m_duration / this-&gt;width()); m_moveAnimation-&gt;setStartValue(startOffset); m_moveAnimation-&gt;setEndValue(0); m_moveAnimation-&gt;start();&#125;void MyStackWidget::setWidgetsVisible()&#123; int size = count(); for (int i = 0; i &lt; size; i++) &#123; if (m_lastIndex == i || m_curIndex == i) m_widgetLst.at(i)-&gt;setVisible(true); else &#123; m_widgetLst.at(i)-&gt;setVisible(false); &#125; &#125;&#125;","tags":["Qt","动画","QStackWidget"],"categories":["Code","Qt","动画"]},{"title":"QStackWidget动画（1）","path":"/Code/Qt/动画/QStackWidget动画/","content":"使用直接提升为组件为当前组件即可。 .h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#ifndef QANIMATIONSTACKEDWIDGET_H#define QANIMATIONSTACKEDWIDGET_H#include &lt;QStackedWidget&gt;#include &lt;QVariant&gt;class QPropertyAnimation;class QGraphicsOpacityEffect;class QParallelAnimationGroup;//class QVariant;class QAnimationStackedWidget : public QStackedWidget&#123; Q_OBJECTpublic: explicit QAnimationStackedWidget(QWidget *parent = Q_NULLPTR); ~QAnimationStackedWidget(); void Next(); void SwitchToIndex(int NextIndex, bool bFront = true); void setCurrentWidget(QWidget* widget);protected: void paintEvent(QPaintEvent *e);private: QParallelAnimationGroup* m_ParlGroup; QPropertyAnimation *m_pAnimPrty; QGraphicsOpacityEffect* m_pAnimGraphicsEffect; QPropertyAnimation* m_pAnimGraphics; bool m_bAnimation; int m_nDuration; int m_nWidgetCount; int m_nNextIndex; QVariant m_nCurValue; bool m_bMoveFront;private: void Init(); void paintPrevious(QPainter &amp;paint, int currentIndex); void paintNext(QPainter &amp;paint, int nextIndex); void moveAnimationStart(bool bEnter);private slots: void slotAnimationValueChanged(QVariant value); void slotAnimationFinished();&#125;;#endif // QANIMATIONSTACKEDWIDGET_H .cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &quot;QAnimationStackedWidget.h&quot;#include &lt;QPropertyAnimation&gt;#include &lt;QPainter&gt;#include &lt;QParallelAnimationGroup&gt;#include &lt;QGraphicsOpacityEffect&gt;QAnimationStackedWidget::QAnimationStackedWidget(QWidget *parent) : QStackedWidget(parent)&#123; Init();&#125;QAnimationStackedWidget::~QAnimationStackedWidget()&#123;&#125;void QAnimationStackedWidget::Init()&#123; m_bAnimation = false; m_nDuration = 350; m_ParlGroup = new QParallelAnimationGroup(); m_pAnimGraphicsEffect = new QGraphicsOpacityEffect(this); m_pAnimGraphicsEffect-&gt;setOpacity(1);\tthis-&gt;setGraphicsEffect(m_pAnimGraphicsEffect);\tm_pAnimGraphics = new QPropertyAnimation(m_pAnimGraphicsEffect, &quot;opacity&quot;); m_pAnimPrty = new QPropertyAnimation(this, QByteArray()); connect(m_pAnimPrty, SIGNAL(valueChanged(QVariant)), this, SLOT(slotAnimationValueChanged(QVariant))); connect(m_pAnimPrty, SIGNAL(finished()), this, SLOT(slotAnimationFinished())); m_pAnimPrty-&gt;setEasingCurve(QEasingCurve::InOutQuad); m_pAnimGraphics-&gt;setEasingCurve(QEasingCurve::InOutQuad);\tm_ParlGroup-&gt;addAnimation(m_pAnimPrty);\tm_ParlGroup-&gt;addAnimation(m_pAnimGraphics);&#125;void QAnimationStackedWidget::slotAnimationValueChanged(QVariant value)&#123; m_nCurValue = value; update();&#125;void QAnimationStackedWidget::slotAnimationFinished()&#123; m_bAnimation = false; widget(currentIndex())-&gt;show(); setCurrentIndex(m_nNextIndex);&#125;void QAnimationStackedWidget::paintEvent(QPaintEvent *e)&#123; Q_UNUSED(e) if(m_bAnimation) &#123; QPainter paint(this); if (m_bMoveFront) &#123; //绘制当前Widget paintPrevious(paint, currentIndex()); //绘制下一个widget paintNext(paint, m_nNextIndex); &#125; else &#123; //绘制当前Widget paintPrevious(paint, m_nNextIndex); //绘制下一个widget paintNext(paint, currentIndex()); &#125; &#125;&#125;void QAnimationStackedWidget::paintPrevious(QPainter &amp;paint, int currentIndex)&#123; //获得当前页面的Widget QWidget *w = widget(currentIndex); // 切换过程窗口的背景色 QString strStyle = QString(&quot;#%1&#123;background-color: #FFFFFF&#125;&quot;).arg(w-&gt;objectName()); w-&gt;setStyleSheet(strStyle); QPixmap pixmap(w-&gt;size()); //将Widget的内容渲染到QPixmap对象中，即将Widget变成一张图片 w-&gt;render(&amp;pixmap); QRect r = w-&gt;geometry(); //绘制当前的Widget double value = m_nCurValue.toDouble(); QRectF r1(0.0, 0.0, value, r.height()); QRectF r2(r.width() - value, 0, value, r.height()); paint.drawPixmap(r1, pixmap, r2);&#125;void QAnimationStackedWidget::paintNext(QPainter &amp;paint, int nextIndex)&#123; QWidget *nextWidget = widget(nextIndex); QString strStyle = QString(&quot;#%1&#123;background-color: #FFFFFF&#125;&quot;).arg(nextWidget-&gt;objectName()); nextWidget-&gt;setStyleSheet(strStyle); QRect r = geometry(); //这行代码不加会有bug，第一次切换的时候，QStackedWidget并没有为child分配大小 nextWidget-&gt;resize(r.width(), r.height()); QPixmap nextPixmap(nextWidget-&gt;size()); nextWidget-&gt;render(&amp;nextPixmap); double value = m_nCurValue.toDouble(); QRectF r1(value, 0.0, r.width() - value, r.height()); QRectF r2(0.0, 0.0, r.width() - value, r.height()); paint.drawPixmap(r1, nextPixmap, r2);&#125;void QAnimationStackedWidget::moveAnimationStart(bool bEnter)&#123;\tif (bEnter)\t&#123; m_pAnimPrty-&gt;setStartValue(this-&gt;width()); m_pAnimPrty-&gt;setEndValue(0); m_pAnimGraphics-&gt;setDuration(m_nDuration); m_pAnimGraphics-&gt;setStartValue(0); m_pAnimGraphics-&gt;setEndValue(1);\t&#125;\telse\t&#123; m_pAnimPrty-&gt;setStartValue(0); m_pAnimPrty-&gt;setEndValue(this-&gt;width()); m_pAnimGraphics-&gt;setDuration(m_nDuration); m_pAnimGraphics-&gt;setStartValue(0); m_pAnimGraphics-&gt;setEndValue(1);\t&#125;\tm_pAnimPrty-&gt;setDuration(m_nDuration);\t// m_pAnimPrty-&gt;start();\tm_ParlGroup-&gt;start();&#125;void QAnimationStackedWidget::SwitchToIndex(int index, bool bFront)&#123; //如果正在动画，那么return int curIndex = currentIndex(); m_bMoveFront = bFront; m_bAnimation = true; m_nWidgetCount = count(); m_nNextIndex = index; //隐藏当前的widget widget(curIndex)-&gt;hide(); //开始动画并设置间隔和开始、结束值 QRect g = geometry(); int width = g.width(); bFront = index &gt;= curIndex; moveAnimationStart(bFront);&#125;void QAnimationStackedWidget::setCurrentWidget(QWidget* widget)&#123;\tint index = indexOf(widget); SwitchToIndex(index);&#125;void QAnimationStackedWidget::Next()&#123; //如果正在动画，那么return if(m_bAnimation) &#123; return; &#125; m_bAnimation = true; m_nWidgetCount = count(); int nIndex = currentIndex(); //计算下一页的索引 m_nNextIndex = (nIndex + 1) % m_nWidgetCount; //隐藏当前的widget widget(nIndex)-&gt;hide(); //开始动画并设置间隔和开始、结束值 QRect g = geometry(); int x = g.x(); int width = g.width(); m_pAnimPrty-&gt;setStartValue(width); m_pAnimPrty-&gt;setEndValue(0); m_pAnimPrty-&gt;setDuration(m_nDuration); m_pAnimPrty-&gt;start(); Q_UNUSED(x)&#125;","tags":["动画","QStackWidget"],"categories":["Code","Qt","动画"]},{"title":"Qt 国际化","path":"/Code/Qt/中英文切换/","content":"支持国际化是软件发布的基本项。现阶段我所在的项目也是有了这一需求，基于Qt实现这一需求也相对比较简单。 [toc] # Qt支持国际化Qt安装时，带了一个 Qt Linguist 的软件，这个软件就是 Qt 用来实现软件翻译的工具。在 Qt 中，所有的输入不见和文本绘制方式对Qt支持的所有语言都提供了内置的支持。Qt内置的字体引擎可以在同一时间正确而且精确地绘制不同的文本，这些文本可以包含来自众多不同书写系统的字符。 # 使用 Qt Linguist 翻译工具tr()函数在Qt中编写代码时要对需要显示的字符串调用 tr() 函数，完成代码编写后对这个应用程序的翻译主要包含以下几个步骤： 使用tr()函数 -&gt; 修改pro文件 -&gt; 更新语言文件 -&gt; 发布语言文件 -&gt; 使用语言文件（QTranslator）","categories":["Code","Qt"]},{"title":"Qt 因为槽函数问题或者逻辑问题导致重复new问题解决办法及建议","path":"/Code/Qt/内存/重复new问题/","content":"[toc] 槽函数中重复 new这个问题比骄常见，举一个简单的例子： 12345678connect(timer, &amp;QTimer::timeout, this, &amp;this::slotCreateItem);void slotCreateItem()&#123; QWidget *widget = new QWidget();&#125;timer-&gt;start(1000); 上边只是为了说明一下类似的这种情况，由于一些特殊原因导致的槽函数中会多次触发 new 操作。 解决办法 设置为成员变量，在进入函数时，先执行 delete ，再去 new 123456789void slotCreateItem()&#123; if(nullptr == m_widget) &#123; delete m_widget; m_widget = nullptr; &#125; m_widget = new QWidget();&#125; 第二种办法就是设置控件属性 12345void slotCreateItem()&#123; QWidget *widget = new QWidget(); widget-&gt;setAttribute(WA_DeleteOnClose);&#125; 槽函数多次绑定问题123456connect(timer, &amp;QTimer::timeout, this, &amp;this::slotCreateItem);void slotCreateItem()&#123;\tconnect(timer, &amp;QTimer::timeout, this, &amp;this::slotRePaint); // 每进入一次就会绑定一次，每绑定一次，触发次数就会增加一次&#125; 解决办法使用 Qt 的第五个参数控制。将上述代码改为以下形式 1connect(timer, &amp;QTimer::timeout, this, &amp;this::slotRePaint, Qt::UniqueConnection); // （modify）每进入一次就会绑定一次，每绑定一次，触发次数就会增加一次 Qt::UniqueConnection：这是一个标记，可以使用位或与上述任何一种连接类型结合使用。当 Qt::UniqueConnection 被设置后，如果连接已经存在，QObject::connect() 将会失败(即，如果相同的信号已经为同一对对象连接到相同的槽位)。这个标志是在Qt 4.6中引入的。 以下为 Qt 第五个参数各个含义： 常量 值 描述 Qt::AutoConnection 0 (默认)如果接收器位于发出信号的线程中，则使用Qt::DirectConnection。否则，使用Qt::QueuedConnection。连接类型是在信号发出时确定的。 Qt::DirectConnection 1 发出信号时立即调用插槽。槽在信令线程中执行。 Qt::QueuedConnection 2 当控制返回到接收方线程的事件循环时，将调用插槽。插槽在接收方的线程中执行。 Qt::BlockingQueuedConnection 3 与Qt::QueuedConnection相同，除了信令线程阻塞直到插槽返回。如果接收端位于信令线程中，则绝不能使用此连接，否则应用程序将死锁。 Qt::UniqueConnection 0x80 这是一个标记，可以使用位或与上述任何一种连接类型结合使用。当Qt::UniqueConnection被设置后，如果连接已经存在，QObject::connect()将会失败","tags":["new","内存"],"categories":["Code","Qt","内存"]},{"title":"Qt pro文件用法","path":"/Code/Qt/pro文件用法/","content":"[toc] 宏判断12345if(contains(DEFINES,OEM_Config)) &#123; FORMS += $$PWD/Form.ui HEADERS += $$PWD/Form.h SOURCES += $$PWD/Form.cpp&#125; pro文件转vcproj之后的配置 常规项 1234# 设置工具集为$(DefaultPlatformToolset)# 设置sdk版本$([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion(&#x27;Windows&#x27;, &#x27;10.0&#x27;)) 生成前事件 1call $(SolutionDir)prompt.bat prompt.bat 123456789101112131415@echo offecho -----------------------------------------------------echo [TrustAgent.pro] 文件有更新时，请重新生成当前工程echo 以下配置并不适用于所有人，如有编译报错，请自行修改。echo 1. Qt工具集默认配置为环境变量QtPath: 当前系统QtPath:[%QtPath%] （推荐 5.9.9_msvc2015）echo 2. 工具集默认配置为: $(DefaultPlatformToolset) （推荐 10.0.19041.0及以上）echo 3. SDK默认配置为: $([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion(&#x27;Windows&#x27;, &#x27;10.0&#x27;)) （推荐 V142）echo -----------------------------------------------------@REM if &quot;%QtPath%&quot; == &quot;&quot; (@REM choice /c:yn /m &quot;当前未配置环境变量，是否打开系统配置页面：&quot;@REM if %errorlevel%==1 (@REM start ms-settings:about@REM )@REM )","tags":["Qt","配置"],"categories":["Code","Qt"]},{"title":"Qt 重启","path":"/Code/Qt/Qt重启/","content":"Qt 实现电脑重启（需要管理员）12345678inline void reboot()&#123; QString program = QApplication::applicationFilePath();\tQStringList arguments = QApplication::arguments();\tQString workingDirectory = QDir::currentPath();\tQProcess::startDetached(program, arguments, workingDirectory);\tQApplication::exit();&#125;","tags":["Qt"],"categories":["Code","Qt"]},{"title":"Qt获取控件位置","path":"/Code/Qt/Qt获取控件位置/","content":"Qt 获取窗口、系统屏幕大小尺寸信息，Qt获取控件位置坐标、屏幕坐标，相对父窗体坐标 [toc] 一、获取窗口大小尺寸信息Qt 窗口尺寸，窗口大小和大小改变引起的事件 QResizeEvent。 涉及坐标、长宽的接口12345678910111213//窗口左上角的位置(含边框)qDebug() &lt;&lt; this-&gt;frameGeometry().x() &lt;&lt; this-&gt;frameGeometry().y() &lt;&lt; ;//1qDebug() &lt;&lt; this-&gt;x() &lt;&lt; this-&gt;y();//2qDebug() &lt;&lt; this-&gt;pos().x() &lt;&lt; this-&gt;pos().y();//3//窗口的宽度和高度(含边框)qDebug() &lt;&lt; this-&gt;frameGeometry().width() &lt;&lt; this-&gt;frameGeometry().height();//窗口左上角的位置(不含边框)qDebug() &lt;&lt; this-&gt;geometry().x() &lt;&lt; this-&gt;geometry().y();//窗口的宽度和高度(不含边框)qDebug() &lt;&lt; this-&gt;geometry().width() &lt;&lt; this-&gt;geometry().height();//1qDebug() &lt;&lt; this-&gt;width() &lt;&lt; this-&gt;height();//2qDebug() &lt;&lt; this-&gt;rect().width() &lt;&lt; this-&gt;rect().height();//3qDebug() &lt;&lt; this-&gt;size().width() &lt;&lt; this-&gt;size().height();//4 Qt获取系统屏幕大小QDesktopWidget 提供了详细的位置信息，其能够自动返回窗口在用户窗口的位置和应用程序窗口的位置。 1234567QDesktopWidget* pDesktopWidget = QApplication::desktop();//获取可用桌面大小QRect deskRect = QApplication::desktop()-&gt;availableGeometry();//获取主屏幕分辨率QRect screenRect = QApplication::desktop()-&gt;screenGeometry();//获取屏幕数量int nScreenCount = QApplication::desktop()-&gt;screenCount(); Qt5开始， QDesktopWidget官方不建议使用，改为 QScreen 12345678#include&lt;QScreen&gt;#include&lt;QRect&gt; QList&lt;QScreen *&gt; list_screen = QGuiApplication::screens(); //多显示器QRect rect = list_screen.at(0)-&gt;geometry();desktop_width = rect.width();desktop_height = rect.height();qDebug() &lt;&lt; desktop_width &lt;&lt;desktop_height; 三、设置窗体大小1234567void setGeometry(int x, int y, int w, int h)void setGeometry(const QRect &amp;)void resize(int w, int h)void resize(const QSize &amp;) 四、Qt获取控件位置坐标、屏幕坐标、相对父窗体坐标 这个只是返回相对这个 widget （重载了QMouseEvent的widget）的位置。 1QPoint QMouseEvent::pos() 窗口坐标，这个是返回鼠标的全局坐标 1QPoint QMouseEvent::globalPos() 相对显示器的全局坐标 1QPoint QCursor::pos() [static] 将窗口坐标转换成显示器坐标 1QPoint QWidget::mapToGlobal(const QPoint &amp; pos) const 将显示器坐标转换成窗口坐标 1QPoint QWidget::mapFromGlobal(const QPoint &amp; pos) const 将窗口坐标获得的pos转成父类widget的坐标 1QPoint QWidget::mapFromParent(const QPoint &amp; pos) const 将当前窗口坐标转换成指定parent坐标 1QPoint QWidget::mapTo(const QWidget * parent, const QPoint &amp;pos) const 这个属性获得的是当前目前控件在父窗口中的位置 1const QPointF &amp;QMouseEvent::screenPos() const Returns the position of the mouse cursor asa QPointF, relative to the screen that received the event.和 QPoint QMouseEvent::globalPos() 值相同，但是类型更高精度的 QPointFThis function was introduced in Qt 5.0. 1const QPointF &amp;QMouseEvent::screenPos() const 获取全局坐标 1QCursor::pos() == QMouseEvent::globalPos() 将鼠标的坐标转换成全局坐标 1QMouseEvent::globalPos() == ui.posBtn-&gt;mapToGlobal(ui.posBtn-&gt;pos()); 将鼠标坐标（鼠标当前坐标，QCursor::pos()）直接转换成当前窗口相对坐标 1ui.posBtn-&gt;mapFromGlobal(QCursor::pos());","tags":["Qt"],"categories":["Code","Qt"]},{"title":"SQLite3 数据库加密","path":"/Code/Qt/SQLite加密/","content":"Set Connect options Provided by Qt SqlitePlugin QSQLITE_BUSY_TIMEOUT QSQLITE_OPEN_READONLY QSQLITE_OPEN_URI QSQLITE_ENABLE_SHARED_CACHE Added by QtCipherSqlitePlugin QSQLITE_CREATE_KEY QSQLITE_UPDATE_KEY QSQLITE_REMOVE_KEY 创建数据库密码 QSQLITE_CREATE_KEY如果输出中有 SQLITECIPHER 的名字，那么恭喜你，插件没有问题！为没有加密的数据库增加密码Qt 默认提供的 SQLite 插件是没有加密功能的。新版本的 QtCipherSqlitePlugin 支持为原本没有加密的数据库增加密码，使用方法如下：C++ 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_CREATE_KEY&quot;); if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 上面的代码，我们使用 test.db 数据库，将密码设置为 test，同时指定连接选项为 QSQLITE_CREATE_KEY 。此时，调用 open() 函数之后，QtCipherSqlitePlugin 将使用改密码为这个数据库进行加密。 删除数据库密码 QSQLITE_REMOVE_KEYQtCipherSqlitePlugin 可以删除数据库密码，此时需要提供原密码，并使用连接选项 QSQLITE_REMOVE_KEY ，如下： 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_REMOVE_KEY&quot;);if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 更新数据库密码 QSQLITE_UPDATE_KEYQtCipherSqlitePlugin 可以更新数据库原有密码，需要设置原密码，并且使用连接选项 QSQLITE_UPDATE_KEY 设置新密码，具体代码如下： 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_UPDATE_KEY=newtest&quot;); if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 如果原密码不正确，QtCipherSqlitePlugin 会直接返回错误。 如果新密码设置为空，例如 QSQLITE_UPDATE_KEY= ，则作用等同于删除密码。 1234567891011121314151617bool QUpdateDB::setDBConfig(QSqlDatabase* dbconn, QMap&lt;ENUM_SQLKEY, QString&gt; qMapCfg)&#123;\tfor (auto it : qMapCfg.toStdMap())\t&#123; if (it.first &lt;= QSQLITE_REMOVE_KEY) &#123; dbconn-&gt;setPassword(it.second); dbconn-&gt;setConnectOptions(GETOBJNAME(it.first)); &#125; else if (it.first == QSQLITE_UPDATE_KEY) &#123; dbconn-&gt;setPassword(it.second); dbconn-&gt;setConnectOptions(QString(&quot;%1=%2&quot;).arg().arg()); &#125; &#125;&#125;","tags":["Qt","SQLite3","数据库","开源"],"categories":["Code","Qt"]},{"title":"Qt实现窗口拖拽","path":"/Code/Qt/Qt窗口拖拽/","content":"[toc] QT窗口默认可以直接鼠标点住窗口的标题栏实现拖拽移动，如果需要鼠标点住窗口客户区域实现窗口的拖拽移动，可以通过QMouseEvent事件来实现。 .h文件12345678910111213141516171819202122#include &lt;QWidget&gt; class QMouseEvent;class Widget : public QWidget&#123; Q_OBJECT public: Widget(QWidget *parent = 0); ~Widget(); protected: //拖拽窗口 void mousePressEvent(QMouseEvent *event); void mouseMoveEvent(QMouseEvent *event); void mouseReleaseEvent(QMouseEvent *event); private: bool m_bDrag; QPoint mouseStartPoint; QPoint windowTopLeftPoint;&#125;; .cpp文件123456789101112131415161718192021222324252627282930313233//拖拽操作void Widget::mousePressEvent(QMouseEvent *event)&#123; if(event-&gt;button() == Qt::LeftButton) &#123; m_bDrag = true; //获得鼠标的初始位置 mouseStartPoint = event-&gt;globalPos(); //mouseStartPoint = event-&gt;pos(); //获得窗口的初始位置 windowTopLeftPoint = this-&gt;frameGeometry().topLeft(); &#125;&#125; void Widget::mouseMoveEvent(QMouseEvent *event)&#123; if(m_bDrag) &#123; //获得鼠标移动的距离 QPoint distance = event-&gt;globalPos() - mouseStartPoint; //QPoint distance = event-&gt;pos() - mouseStartPoint; //改变窗口的位置 this-&gt;move(windowTopLeftPoint + distance); &#125;&#125; void Widget::mouseReleaseEvent(QMouseEvent *event)&#123; if(event-&gt;button() == Qt::LeftButton) &#123; m_bDrag = false; &#125;&#125;","tags":["Qt","拖拽"],"categories":["Code","Qt"]},{"title":"Qt 截图","path":"/Code/Qt/Qt截图/","content":"转载自： QT 截图 - 灰信网（软件开发博客聚合） (freesion.com) QT 截图 一、简要说明 简单的实现截图功能，包括全屏截图，矩形区域截图，主要环境：win7-32bit，QT Creator5.2。 工程源代码 链接：https://pan.baidu.com/s/1xt-oyaz4pWNNFG4q85nmSA 密码：6uky 二、效果运行效果 1、 全屏截图1234567891011//获取全屏截图 QPixmapfullScreen = QPixmap::grabWindow(QApplication::desktop()-&gt;winId()); //打开文件对话框 QStringfileName = QFileDialog::getSaveFileName(this, &quot;文件另存为&quot;,&quot;&quot;,tr(&quot;ConfigFiles (*.jpg)&quot;)); //保存截图 fullScreen.save(fileName,&quot;jpg&quot;); 2、 矩形截图：在全屏截图的基础上，在全屏截图选取一个矩形区域1234567fullScreen.copy(rect).save(fileName);//rect是一个矩形 或者是fullScreen.copy(x,y,width,height).save(fileName);//x,y为矩形左上角坐标， width为矩形宽度，height为矩形的高度。 需要注意的是 屏幕左上角为（0,0），x,y分别向右、下递增。 那么如何实现任意的矩形区域呢？ 四、改进1、 任意矩形区域 按下鼠标左键不放得到一个点P(x1,y1) 拖动鼠标 释放鼠标左键得到另外一个点Q(x2,y2) 如此得到一个以P、Q为对角的矩形 2、 实现动态矩形效果 拉上一层半透明的遮罩(其实就是一个半透明的showFullScreen窗体) 注意：拉上遮罩之前应将父窗体隐去，不然每一张全屏截图都会有父窗体 1setWindowState(Qt::WindowMinimized);//最小化父窗体。 （可能需要延时） 将矩形局域重绘(达到去除矩形区域部分的遮罩的效果) 3、 右键菜单(复制到剪切板+另存为+退出)以及增加快捷键 复制到剪切板：QGuiApplication::clipboard()-&gt;setPixmap(fullScreen.copy(rect)); **组合快捷键Ctrl+C：**if(****e-&gt;key()&#x3D;&#x3D;Qt::Key_C&amp;&amp;e-&gt;modifiers()&#x3D;&#x3D;Qt::ControlModifier) 4、 矩形截图时，实时显示鼠标的位置、矩形截图的位置以及大小信息 通过鼠标移动事件(设置鼠标轨迹跟踪：setMouseTracking(true); update()触发paintEvent重绘事件 5、 无边框窗体拖动123456789101112//实现无边框 (Qt::FramelessWindowHint去边框) 、Qt::WindowStaysOnTopHint窗体置顶 防止拖到任务栏下面 this-&gt;setWindowFlags(Qt::FramelessWindowHint| Qt::WindowSystemMenuHint |Qt::WindowMinMaxButtonsHint|Qt::WindowStaysOnTopHint); //拖动(实际上是根据鼠标的移动 来移动窗体) //当前鼠标相对窗体的位置-刚按下左键时的相对位置=鼠标移动的大小 move(e-&gt;pos()-beginPos+this-&gt;pos()); //鼠标移动的大小+窗体原来的位置=窗体移动后的位置 6、 窗体贴边(当窗体靠在屏幕上边，并且鼠标离开窗体时，窗体贴边，当鼠标进入窗体时，窗体全部展示)1234567891011//窗体贴边if(this-&gt;pos().y()&lt;=0)//窗体贴在屏幕上边&#123; move(pos().x(),-29);//贴边&#125; //窗体弹出if(this-&gt;pos().y()&lt;=0)//鼠标进入并且已经贴边&#123; move(pos().x(),0);//弹出整个窗体&#125; 五、工程结构 六、源文件screen.h文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#ifndef SCREEN_H#define SCREEN_H #include &lt;QWidget&gt;#include &lt;QPoint&gt;#include &lt;QMouseEvent&gt;#include &lt;QContextMenuEvent&gt;#include &lt;QMenu&gt;//右键菜单#include &lt;QPaintEvent&gt;#include &lt;QPainter&gt;//画笔#include &lt;QPixmap&gt;#include &lt;QDebug&gt;#include &lt;QDesktopWidget&gt;#include &lt;QApplication&gt;#include &lt;QFileDialog&gt;#include &lt;QShowEvent&gt;#include &lt;QClipboard&gt;#include &lt;QKeyEvent&gt;#include &lt;QRect&gt;#include &lt;QFile&gt; class Screen : public QWidget&#123; Q_OBJECTpublic: explicit Screen(QWidget *parent = 0); signals: public slots: void saveScreenOther();//截图另存为 void grapFullScreen();//全屏截图 void copyScreen(); //右键复制到粘贴板protected: void contextMenuEvent(QContextMenuEvent *); //--右键菜单事件 void mousePressEvent(QMouseEvent *e); //--鼠标按下事件 void mouseMoveEvent(QMouseEvent *e); //--鼠标移动事件 void mouseReleaseEvent(QMouseEvent *e); //--鼠标释放（松开）事件 void paintEvent(QPaintEvent *); //--画图事件 void showEvent(QShowEvent *); //--窗体show事件 void keyPressEvent(QKeyEvent *e); //--按键事件 private: QPoint beginPos;//记录鼠标的起始位置 QPoint endPos;//记录鼠标的结束位置 QMenu *menu; //右键菜单对象 bool leftPres;//记录鼠标左键是否按下，按下为true QRect * rect; //矩形截图区域public: QPixmap fullScreen;//全屏截图 public: QPoint getBeginPos();//获取鼠标的起始位置 QPoint getEndPos();//获取鼠标的结束位置 void setBeginPos(QPoint p);//设置鼠标的起始位置 void setEndPos(QPoint p);//设置鼠标的结束位置 &#125;; #endif // SCREEN_H widgets.h文件 12345678910111213141516171819202122232425262728293031323334353637383940#ifndef WIDGET_H#define WIDGET_H #include &lt;QWidget&gt; namespace Ui &#123;class Widget;&#125; class Widget : public QWidget&#123; Q_OBJECT public: explicit Widget(QWidget *parent = 0); ~Widget(); private slots: void on_pushButton_clicked(); void on_pushButton_2_clicked(); void on_pushButton_4_clicked(); void on_pushButton_3_clicked(); protected: void enterEvent(QEvent *e); //--鼠标进入事件 void leaveEvent(QEvent *e); //--鼠标离开事件 void mousePressEvent(QMouseEvent *e); //--鼠标按下事件 void mouseMoveEvent(QMouseEvent *e); //--鼠标移动事件 void mouseReleaseEvent(QMouseEvent *e); //--鼠标释放（松开）事件private: Ui::Widget *ui;private: bool leftPress; QPoint beginPos;&#125;; #endif // WIDGET_H screen.cpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &quot;screen.h&quot; Screen::Screen(QWidget *parent) : QWidget(parent)&#123; beginPos = QPoint(-1,-1); endPos = beginPos; leftPres = false; setMouseTracking(true);//开启鼠标实时追踪，实时的显示鼠标的位置 rect = new QRect(0,0,QApplication::desktop()-&gt;width(),QApplication::desktop()-&gt;height()); menu = new QMenu(this);//创建右键菜单 menu-&gt;addAction(&quot;复制(CTRL+C)&quot;, this, SLOT(copyScreen())); menu-&gt;addAction(&quot;截图另存为(ALT+C)&quot;, this, SLOT(saveScreenOther())); menu-&gt;addAction(&quot;全屏截图(ALT+A)&quot;, this, SLOT(grapFullScreen())); menu-&gt;addAction(&quot;退出截图(ESC)&quot;, this, SLOT(hide()));&#125; void Screen::copyScreen() //右键复制到粘贴板&#123; QGuiApplication::clipboard()-&gt;setPixmap(fullScreen.copy(*rect));&#125;void Screen::contextMenuEvent(QContextMenuEvent *) //右键菜单事件&#123; this-&gt;setCursor(Qt::ArrowCursor); menu-&gt;exec(cursor().pos());&#125;void Screen::mousePressEvent(QMouseEvent *e) //--鼠标按下事件&#123; if (e-&gt;button() == Qt::LeftButton)//鼠标左键按下 &#123; leftPres = true; setBeginPos(e-&gt;pos());//鼠标相对窗体的位置 &#125; &#125;void Screen::mouseMoveEvent(QMouseEvent *e) //--鼠标移动事件&#123; if(leftPres) &#123; setEndPos(e-&gt;pos()); &#125; update();//重绘、触发画图事件 &#125;void Screen::mouseReleaseEvent(QMouseEvent *e) //--鼠标释放（松开）事件&#123; leftPres = false; setEndPos(e-&gt;pos()); //使得起始点在左上角，结束点在右下角 if(beginPos.x()&gt;endPos.x()) &#123; beginPos.setX(beginPos.x() + endPos.x()); endPos.setX(beginPos.x() - endPos.x()); beginPos.setX(beginPos.x() - endPos.x()); &#125; if(beginPos.y()&gt;endPos.y()) &#123; beginPos.setY(beginPos.y() + endPos.y()); endPos.setY(beginPos.y() - endPos.y()); beginPos.setY(beginPos.y() - endPos.y()); &#125; rect-&gt;setRect(beginPos.x(),beginPos.y(),endPos.x()-beginPos.x(),endPos.y()-beginPos.y()); &#125; QPoint Screen::getBeginPos()//获取鼠标的起始位置&#123; return beginPos;&#125;QPoint Screen::getEndPos()//获取鼠标的结束位置&#123; return endPos;&#125;void Screen::setBeginPos(QPoint p)//设置鼠标的起始位置&#123; this-&gt;beginPos = p;&#125;void Screen::setEndPos(QPoint p)//设置鼠标的结束位置&#123; this-&gt;endPos = p;&#125; void Screen::paintEvent(QPaintEvent *) //--画图事件 &#123; QPainter painter(this); //将当前窗体对象设置为画布 QPen pen; pen.setColor(Qt::red);//设置笔色 pen.setWidth(1); //画笔线条宽度 painter.setPen(pen);//设置画笔 int lx = beginPos.x()&lt;endPos.x()?beginPos.x():endPos.x();//矩形截图区域左上角x坐标 int ly = beginPos.y()&lt;endPos.y()?beginPos.y():endPos.y();//矩形截图区域右上角x坐标 int w = beginPos.x()&lt;endPos.x()?endPos.x()-beginPos.x():beginPos.x()-endPos.x();//矩形截图区域宽度 int h = beginPos.y()&lt;endPos.y()?endPos.y()-beginPos.y():beginPos.y()-endPos.y();//矩形截图区域高度 QRect rect = QRect(lx,ly,w,h);//矩形截图区域 if(lx!=-1 &amp;&amp; w&gt;0 &amp;&amp; h&gt;0)//防止第一次就重绘 并且宽高大于0时才进行截图操作 &#123; painter.drawPixmap(rect,fullScreen,rect);//重绘截图矩形部分，即恢复原图，达到去除幕布效果 painter.drawRect(lx, ly, w, h);//画截图矩形 //截图区域大小位置提示 if(ly&gt;10)//避免看不到提示,在截图矩形上边不接近屏幕上边时，提示在截图矩形的上边的上面 &#123; painter.drawText(lx + 2, ly - 8, tr(&quot;截图范围(%1,%2) - (%3,%4) 截图大小：(%5 x %6)&quot;) .arg(lx).arg(ly).arg(lx + w).arg(ly + h).arg(w).arg(h)); &#125; else//在截图矩形上边接近屏幕上边时，提示在截图矩形的上边的下面 &#123; painter.drawText(lx + 2, ly + 12, tr(&quot;截图范围(%1,%2) - (%3,%4) 截图大小：(%5 x %6)&quot;) .arg(lx).arg(ly).arg(lx + w).arg(ly + h).arg(w).arg(h)); &#125; &#125; //实时显示鼠标的位置 painter.drawText(cursor().pos().x(), cursor().pos().y(), tr(&quot;(%1,%2)&quot;) .arg(cursor().pos().x()).arg(cursor().pos().y())); &#125; void Screen::showEvent(QShowEvent *) //--窗体show事件 &#123; //设置透明度实现模糊背景 setWindowOpacity(0.7); &#125; void Screen::saveScreenOther() &#123; QString fileName = QFileDialog::getSaveFileName(this, &quot;截图另存为&quot;, &quot;&quot;, &quot;Image (*.jpg *.png *.bmp)&quot;); if (fileName.length() &gt; 0) &#123; fullScreen.copy(*rect).save(fileName,&quot;bmp&quot;); close(); &#125; &#125; void Screen::grapFullScreen() &#123; endPos.setX(-1);//此时避免画截图矩形 QString fileName = QFileDialog::getSaveFileName(this, &quot;保存全屏截图&quot;, &quot;&quot;, &quot;JPEG Files (*.jpg)&quot;); if (fileName.length() &gt; 0) &#123; fullScreen.save(fileName, &quot;jpg&quot;); close(); &#125; this-&gt;hide(); &#125; void Screen::keyPressEvent(QKeyEvent *e) //按键事件 &#123; /// Esc 键退出截图; if (e-&gt;key() == Qt::Key_Escape) &#123; hide(); &#125;///CTRL+C 复制 else if(e-&gt;key() == Qt::Key_C &amp;&amp; e-&gt;modifiers() == Qt::ControlModifier) &#123; QGuiApplication::clipboard()-&gt;setPixmap(fullScreen.copy(*rect)); &#125;///截图另存为(ALT+C) else if(e-&gt;key() == Qt::Key_C &amp;&amp; e-&gt;modifiers() == Qt::AltModifier) &#123; saveScreenOther(); &#125;///全屏截图(ALT+A) else if(e-&gt;key() == Qt::Key_A &amp;&amp; e-&gt;modifiers() == Qt::AltModifier) &#123; grapFullScreen(); &#125; else &#123; e-&gt;ignore(); &#125; &#125; widget.cpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QMessageBox&gt;#include &lt;QDesktopWidget&gt;#include &lt;QFileDialog&gt;#include &lt;QScreen&gt;#include &lt;QString&gt;#include &lt;QDebug&gt;#include &lt;QPoint&gt;#include &lt;QTime&gt;#include &quot;screen.h&quot; Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); beginPos = this-&gt;pos(); leftPress = false; this-&gt;setProperty(&quot;CanMove&quot;, true); //实现无边框 (Qt::FramelessWindowHint去边框) Qt::WindowStaysOnTopHint 窗体置顶 防止拖到任务栏下面 this-&gt;setWindowFlags(Qt::FramelessWindowHint | Qt::WindowSystemMenuHint | Qt::WindowMinMaxButtonsHint|Qt::WindowStaysOnTopHint);&#125; Widget::~Widget()&#123; delete ui;&#125; void Widget::mousePressEvent(QMouseEvent *e) //--鼠标按下事件&#123; if (e-&gt;button() == Qt::LeftButton)//鼠标左键按下 &#123; leftPress = true; beginPos = e-&gt;pos();//鼠标相对窗体的位置 &#125;&#125;void Widget::mouseMoveEvent(QMouseEvent *e) //--鼠标移动事件&#123; if (leftPress) &#123;//当前鼠标相对窗体的位置-刚按下左键时的相对位置=鼠标移动的大小 move(e-&gt;pos() - beginPos + this-&gt;pos()); // 鼠标移动的大小+窗体原来的位置=窗体移动后的位置 &#125; &#125;void Widget::mouseReleaseEvent(QMouseEvent *e) //--鼠标释放（松开）事件&#123; leftPress = false;&#125;void Widget::enterEvent(QEvent *e) //--鼠标进入事件&#123; if(this-&gt;pos().y()&lt;=0)//鼠标进入并且已经贴边 &#123; move(pos().x(),0);//弹出整个窗体 &#125; &#125;void Widget::leaveEvent(QEvent *e) //--鼠标离开事件&#123; if(this-&gt;pos().y()&lt;=0)//窗体贴在屏幕上边 &#123; move(pos().x(),-29);//贴边 &#125;&#125; void Widget::on_pushButton_2_clicked()&#123; //截图之前隐去窗体，不然截图之中就会有窗体的存在 if( windowState() != Qt::WindowMinimized ) &#123; setWindowState( Qt::WindowMinimized );//最小化父窗体 &#125; //延时等待父窗体最小化 延时250毫秒 QTime _Timer = QTime::currentTime().addMSecs(250); while( QTime::currentTime() &lt; _Timer ) &#123; QCoreApplication::processEvents(QEventLoop::AllEvents, 100); &#125; //先获取全屏截图，再拉上幕布 Screen *m = new Screen(); m-&gt;fullScreen = QPixmap::grabWindow(QApplication::desktop()-&gt;winId()); m-&gt;showFullScreen(); &#125; void Widget::on_pushButton_clicked()&#123; //获取全屏截图 QPixmap p = QPixmap::grabWindow(QApplication::desktop()-&gt;winId()); //打开文件对话框 QString fileName = QFileDialog::getSaveFileName(this, &quot;文件另存为&quot;,&quot;&quot;,tr(&quot;Config Files (*.bmp)&quot;)); //保存截图 if(fileName.length() &gt; 0 &amp;&amp; p.save(fileName,&quot;bmp&quot;)) &#123; QMessageBox::information(this, &quot;提示&quot;, &quot;保存成功!&quot;,QMessageBox::Ok); &#125; &#125; void Widget::on_pushButton_4_clicked()&#123; if( windowState() != Qt::WindowMinimized ) &#123; setWindowState( Qt::WindowMinimized );//最小化窗体 &#125;&#125; void Widget::on_pushButton_3_clicked()&#123; this-&gt;close();//关闭窗体&#125; main.cpp文件 12345678910111213#include &quot;widget.h&quot;#include &lt;QApplication&gt;#include &lt;screen.h&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); Widget w; w.show(); return a.exec();&#125; 七、注意事项 ****update()触发***paintEvent重绘事件，不是直接调用*paintEvent()。","tags":["Qt","截图"],"categories":["Code","Qt"]},{"title":"Qt 鼠标 hover 操作时弹出文字气泡","path":"/Code/Qt/Qt气泡/","content":"[TOC] 需求描述：鼠标 hover 在一个控件上时，展示设置好的气泡信息 演示 相关说明Qt5之前的版本要设置气泡需要通过C++中其他的类库去实现，在Qt5中则已经实现了相关的Qt类。并且除了设置文字气泡之外，还可以通过重写 QToolTip 类实现自己需要的气泡样式。 从 Qt 5.9.9 已经支持 QToolTip。基本所有继承于 QWidget 的组件都可以通过 setToolTip()设置气泡信息。以下所展示的Qt基类都可以设置气泡信息。 setToolTip: QAction QGraphicsItem QListWidgetItem QStandardItem QSystemTrayIcon QTableWidgetItem QTextCharFormat QTreeWidgetItem QWidget QWinThumbnailToolButton setToolTipDuration: QWidget setToolTipsVisible: QMenu 基本上所有继承于 QWidget 的Qt控件类都支持设置气泡，本文以 QLabel 和 QPushButton 为例演示文字气泡功能。 支持 SetToolTip的控件 代码代码很简单，在ui界面拖一个 QLabel 和一个 QPushbutton 即可，信号槽直接在ui界面右击转到槽即可。 1234567891011121314151617181920212223242526272829303132#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QImage&gt;#include &lt;QPixmap&gt;Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); QPixmap img(&quot;:/Win11.jpg&quot;); ui-&gt;label-&gt;setPixmap(img); ui-&gt;label-&gt;setScaledContents(true); ui-&gt;label-&gt;setToolTip(QString(&quot;壁纸《Win11.png》&quot;)); ui-&gt;pushButton-&gt;setToolTip(QString(&quot;隐藏或显示图片&quot;));&#125;Widget::~Widget()&#123; delete ui;&#125;void Widget::on_pushButton_clicked()&#123; if(ui-&gt;label-&gt;isVisible()) ui-&gt;label-&gt;hide(); else ui-&gt;label-&gt;setVisible(true);&#125;","tags":["Qt","气泡"],"categories":["Code","Qt"]},{"title":"Qt 窗口居中显示","path":"/Code/Qt/Qt窗口居中/","content":"一、进行界面布局的时候，往往需要将界面显示在整个桌面的中心位置，所以需要进行一下处理 二、加上头文件 1#include &lt;QDesktopWidget&gt; 三、再在构造函数中加上代码 12QDesktopWidget *deskdop=QApplication::desktop();move((deskdop-&gt;width()-this-&gt;width())/2, (deskdop-&gt;height()-this-&gt;height())/2);","tags":["Qt","布局"],"categories":["Code","Qt"]},{"title":"Qt图片旋转","path":"/Code/Qt/Qt图片旋转/","content":"Qt loading 样式 图片旋转图片旋转可以使用paintevent时间，也可以使用过滤器实现。如下为使用过滤器的方式实现图片旋转。 首先在 UI 中绘制 一个 QLabel 用于承载旋转图片。 1ui-&gt;labelLoadIcon 然后给载体安装过滤器事件，保证其可触发的状态 1ui-&gt;labelLoadIcon-&gt;installEventFilter(this); 写过滤器要实现的功能，旋转 123456789101112131415161718bool QAuthInit::eventFilter(QObject* watched, QEvent* event)&#123; if (watched == ui-&gt;labelLoadIcon &amp;&amp; event-&gt;type() == QEvent::Paint &amp;&amp; !this-&gt;parentWidget()-&gt;isHidden()) &#123; QImage loading = QImage(&quot;:/loading.jpg&quot;); QPainter painter_inner(ui-&gt;labelLoadIcon); painter_inner.setPen(Qt::NoPen); painter_inner.setBrush(Qt::NoBrush); painter_inner.setRenderHint(QPainter::SmoothPixmapTransform); painter_inner.translate(loading.width() / qreal(2) + 0, loading.height() / qreal(2) + 0); //设置旋转中心 painter_inner.rotate(-m_nAngle_ring); //旋转 painter_inner.translate(-(loading.width() / qreal(2) + 0), -(loading.height() / qreal(2) + 0)); //将原点复位 painter_inner.drawImage(QPointF(0, 0), loading); &#125; // 事件仍然抛给QT return QWidget::eventFilter(watched, event);&#125; 定时调用，使过滤器中旋转的角度变化，从而达到旋转的效果 1234567QTimer* timerLoading = new QTimer(this);timerLoading-&gt;setInterval(5);connect(timerLoading, &amp;QTimer::timeout, this, &amp;LoadingWidget::onTimeOut); // 在槽函数中修改 m_nAngle_ring 的值timerLoading-&gt;start(); 定时器槽函数 1234567891011121314void LoadingWidget::onTimeOut()&#123; if (!this-&gt;parentWidget()-&gt;isHidden()) &#123; //每次间隔转2度,也就是说转一圈需要180次 if (m_nAngle_ring == 360) &#123; m_nAngle_ring = 0; &#125; m_nAngle_ring += 2; ui-&gt;labelLoadIcon-&gt;update(); &#125; &#125;","tags":["Qt","旋转"],"categories":["Code","Qt"]},{"title":"Qt常用基础代码汇总","path":"/Code/Qt/Qt开发经验/Qt常用基础代码汇总/","content":"[toc] 1、show() 与 exec()show显示的是非模态对话框；exec显示的是模态对话框。 2、设置无边框窗口1this-&gt;setWindowFlags(Qt::FramelessWindowHint); //设置为无边框窗口 3、设置窗体透明1this-&gt;setAttribute(Qt::WA_TranslucentBackground); //设置窗体透明 4、Qt字符串转换123456789101112131415#ifdef UNICODE #define QStringToTCHAR(x) (wchar_t*) x.utf16()#define PQStringToTCHAR(x) (wchar_t*) x-&gt;utf16()#define TCHARToQString(x) QString::fromUtf16((x))#define TCHARToQStringN(x,y) QString::fromUtf16((x),(y)) #else #define QStringToTCHAR(x) x.local8Bit().constData()#define PQStringToTCHAR(x) x-&gt;local8Bit().constData()#define TCHARToQString(x) QString::fromLocal8Bit((x))#define TCHARToQStringN(x,y) QString::fromLocal8Bit((x),(y)) #endif 5、Qss读取123456789101112131415161718192021void Widget::InitStyle(int i)&#123; m_LCD_Hour-&gt;setStyleSheet(&quot; font: 18px black;&quot;); if(i != 0) &#123; QFile file(QString(&quot;:/Assert/qss/style%1.qss&quot;).arg(i)); file.open(QFile::ReadOnly); this-&gt;setStyleSheet(file.readAll()); file.close(); return; &#125; // m_LCD_Min-&gt;setStyleSheet(&quot;color: black; &quot;); // m_LCD_Sec-&gt;setStyleSheet(&quot;color: black; &quot;); QFile file(QString(&quot;:/Assert/qss/main.qss&quot;)); file.open(QFile::ReadOnly); this-&gt;setStyleSheet(file.readAll()); file.close();&#125; 6、QWidget自动列宽12// TreeWidget 自动列宽 add by mingming.shi 2021-10-23ui.treeWidget-&gt;header()-&gt;setSectionResizeMode(QHeaderView::ResizeToContents); 7、Qss写法参考QSS单独设置某控件样式 8、Qt正则表达式123456789101112131415161718QRegExp rx(&quot;\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b&quot;); //IP的正则表达式if(!rx.exactMatch(m_lineEdit-&gt;text()))&#123; QMessageBox::critical(this, tr(&quot;Error&quot;), tr(&quot;IP WRONG. &quot; &quot;Please Make Sure Input Correct IP!&quot;), QMessageBox::Ok); return ;&#125;if(m_lineEdit-&gt;text().toInt() &lt;= 0)&#123; QMessageBox::information(this, tr(&quot;Info&quot;), tr(&quot;IP Correct. &quot; &quot;Input Correct IP is Saved!&quot;), QMessageBox::Ok); return;&#125; 9、字体相关 查询系统支持的字体 1234QFontDatabase database;foreach (const QString &amp;family, database.families()) &#123; qDebug()&lt;&lt;family;&#125; 设置全局字体font内容为family查询到的字体名称12QFont font(&quot;family&quot;);QApplication::setFont(font); 外部加载字体 字体支持ttc或ttf格式加载； 使用addApplicationFont可以为系统路径，也可以资源文件。123456789int fontId = QFontDatabase::addApplicationFont(&quot;font.ttc&quot;);QStringList fontIDs = QFontDatabase::applicationFontFamilies(fontId);if (! fontIDs.isEmpty()) &#123; QFont font(fontIDs.first()); QApplication::setFont(font);&#125;else &#123; qDebug()&lt;&lt;&quot;Failed to load font.&quot;;&#125; 10. Qt锁123456789101112131415161718QMutex mutex;int number = 6;void method1()&#123; mutex.lock(); number *= 5; number /= 4; mutex.unlock();&#125;void method2()&#123; mutex.lock(); number *= 3; number /= 2; mutex.unlock();&#125; 11、 计时器 定时器计时器123456789QTimer *timer = new QTimer;connect(timer, SIGNAL(timeout()), this, SLOT(slotTimeOut()));// 或者connect(timer, &amp;QTimer::timeout, this, [=]()mutable&#123; slotTimeOut();&#125;);timer-&gt;start(1000); 单次定时器1234// 3秒后 启用下载按钮QTimer::singleShot(3 * 1000, this, [=]() &#123;\tui-&gt;pushBtnUpgrade-&gt;setDisabled(false);\t&#125;); 12、乱码问题在头文件添加以下代码即可。 123#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600)\t#pragma execution_character_set(&quot;utf-8&quot;)#endif 13、 QTextBrower 设置字体颜色12345#define TEXT_COLOR_RED(STRING) &quot;&lt;font color=red&gt;&quot; + STRING + &quot;&lt;/font&gt;&quot; &quot;&lt;font color=black&gt; &lt;/font&gt;&quot;#define TEXT_COLOR_BLUE(STRING) &quot;&lt;font color=blue&gt;&quot; + STRING + &quot;&lt;/font&gt;&quot; &quot;&lt;font color=black&gt; &lt;/font&gt;&quot;#define TEXT_COLOR_GREEN(STRING) &quot;&lt;font color=green&gt;&quot; + STRING + &quot;&lt;/font&gt;&quot; &quot;&lt;font color=black&gt; &lt;/font&gt;&quot;ui-&gt;textBrowser-&gt;setText(TEXT_COLOR_BLUE(content)); 14 Qt http下载网络中断问题 使用 QNetworkAccessManager 下载文件时，网络中断返回的异常吗仍然是200，需要判断 slotFinished 函数中需要判断 error 的状态来判断下载是否正常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void QHttpDownloadObject::Init()&#123; QNetworkAccessManager *m_pManager = new QNetworkAccessManager(this); m_pOnlinemanager = new QNetworkConfigurationManager(this); // (&quot;ftp&quot;, &quot;file&quot;, &quot;qrc&quot;, &quot;http&quot;, &quot;https&quot;, &quot;data&quot;) qDebug() &lt;&lt; m_pManager-&gt;supportedSchemes(); m_pManager-&gt;setNetworkAccessible(QNetworkAccessManager::Accessible); QNetworkConfigurationManager manager; m_pManager-&gt;setConfiguration(manager.defaultConfiguration());\tconnect(m_pManager, SIGNAL(finished(QNetworkReply*)), this, SLOT(slotRequestFinished(QNetworkReply*)));&#125;void QHttpDownloadObject::PerformRequest(QString strUrl)&#123; QNetworkRequest request; request.setUrl(QUrl(strUrl)); request.setHeader(QNetworkRequest::ContentTypeHeader, &quot;application/x-www-form-urlencoded&quot;); m_fileTmp.setFileName(m_DestFilePath); m_fileTmp.open(QIODevice::Append); m_pReply = m_pManager-&gt;get(request); // get 方式 connect(m_pReply, &amp;QNetworkReply::readyRead, this, &amp;QHttpDownloadObject::onReadyRead); connect(m_pReply, &amp;QNetworkReply::downloadProgress, this, &amp;QHttpDownloadObject::downloadProgress); // 使用当前接口判断下载时否异常\tconnect(m_pReply, static_cast&lt;void(QNetworkReply::*)(QNetworkReply::NetworkError)&gt;(&amp;QNetworkReply::error), this, &amp;QHttpDownloadObject::onError);&#125;void QHttpDownloadObject::slotRequestFinished(QNetworkReply *reply)&#123; disconnect(m_pReply, SIGNAL(downloadProgress(qint64, qint64)), this, SIGNAL(downloadProgress(qint64, qint64))); if (m_fileTmp.isOpen()) &#123; m_fileTmp.close(); &#125; // 获取响应的信息，状态码为200表示正常\tQVariant statusCode = reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute); QString strError = reply-&gt;errorString(); QNetworkReply::NetworkError error = reply-&gt;error(); qDebug() &lt;&lt; &quot;+++++++++&quot; &lt;&lt; statusCode &lt;&lt; strError &lt;&lt; error; // QVariant(int, 200) &quot;Connection closed&quot; QNetworkReply::NetworkError(RemoteHostClosedError)\tif (statusCode.toInt() &gt;= 400 || error != QNetworkReply::NoError) &#123; QLOG_INFO() &lt;&lt; &quot;无法下载文件，错误状态码:&quot; &lt;&lt; statusCode &lt;&lt; &quot;错误信息:&quot; &lt;&lt; strError &lt;&lt; error; emit sigDownloadFinished(DOWNLOAD_CODE_NETBAD, QString(ERRORTITLE_APPACCESS_NETFAULT).arg(strError));\t&#125; else &#123; emit sigDownloadFinished(statusCode.toInt(), strError); &#125; reply-&gt;close(); reply-&gt;deleteLater(); m_pManager-&gt;deleteLater(); m_pOnlinemanager-&gt;deleteLater();&#125; 15 管理员运行程序 管理员运行程序，限定在MSVC编译器，在项目pro文件中增加如下代码。 12QMAKE_LFLAGS += /MANIFESTUAC:&quot;level=&#x27;requireAdministrator&#x27; uiAccess=&#x27;false&#x27;&quot; #以管理员运行QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,&quot;5.01&quot; #VS2013 在XP运行 16 QLabel 点击事件重写 QLabel 事件 123456void QCycleProgress::mousePressEvent(QMouseEvent* event)&#123;\temit clicked();\tQLabel::mousePressEvent(event);&#125; 17 程序防重入123456789101112131415161718192021222324#include &quot;qrcode.h&quot;#include &lt;QSharedMemory&gt;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); //创建运行时只允许存在一个程序 static QSharedMemory *shareMem = new QSharedMemory(&quot;SingleAPP&quot;); //判断如果存在存直接退出 if(!shareMem-&gt;create(1))&#123; qApp-&gt;quit(); return -1; &#125;else&#123; int result = -1; while (result !=0) &#123; Create_qrcode w; w.setWindowIcon(QIcon(&quot;:/images/main_logo.ico&quot;)); w.show(); result= a.exec(); //!退出时如果为零，正常退出，否则重启程序 &#125; return result; &#125;&#125; 18 弹窗显示在屏幕中间使用 12345678void QTrayTooltipForm::show()&#123; placeTip(QCursor::pos()); UpdateStatus(); return QWidget::show();&#125; 1234567891011121314151617181920void QTrayTooltipForm::placeTip(const QPoint&amp; pos)&#123;\tQRect screen = QApplication::desktop()-&gt;screenGeometry(QApplication::desktop()-&gt;screenNumber(pos));\tQPoint p = pos;\tp += QPoint(2,16);\tif (p.x() + this-&gt;width() &gt; screen.x() + screen.width()) p.rx() -= 4 + this-&gt;width();\tif (p.y() + this-&gt;height() &gt; screen.y() + screen.height()) p.ry() -= 24 + this-&gt;height();\tif (p.y() &lt; screen.y()) p.setY(screen.y());\tif (p.x() + this-&gt;width() &gt; screen.x() + screen.width()) p.setX(screen.x() + screen.width() - this-&gt;width());\tif (p.x() &lt; screen.x()) p.setX(screen.x());\tif (p.y() + this-&gt;height() &gt; screen.y() + screen.height()) p.setY(screen.y() + screen.height() - this-&gt;height());\tthis-&gt;move(p);&#125;","tags":["手册","Qt"],"categories":["Code","Qt","Qt开发经验"]},{"path":"/Code/Qt/Qt 获取cmd输出 /","content":"Qt 使用 QProcess 执行命令行脚本，并通过 readAllStandardOutput 获取其输出。 123456789101112131415161718192021222324252627#include &lt;QCoreApplication&gt;#include &lt;QProcess&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); // 创建一个QProcess对象 QProcess cmdProcess; // 设置要执行的命令 QString command = &quot;your_cmd_command&quot;; // 启动命令并等待它完成 cmdProcess.start(command); cmdProcess.waitForFinished(); // 获取命令输出 QByteArray output = cmdProcess.readAllStandardOutput(); // 将输出转换为字符串并输出 QString outputStr = QString::fromLocal8Bit(output); qDebug() &lt;&lt; outputStr; return a.exec();&#125;","tags":["Qt","cmd"],"categories":["Code","Qt"]},{"title":"Qt事件过滤器（eventFilter）","path":"/Code/Qt/Qt 过滤器/","content":"[toc] 事件过滤器1void QObject::installEventFilter(QObject *filterObj) 1bool eventFilter(QObject *obj, QEvent *event); Qt的事件过滤由以上两个方法实现，首先安装一个事件过滤器，然后重写 bool eventFilter(QObject *obj, QEvent *event)。 filterObj表示事件筛选器对象，它接收发送到此QObject对象的所有事件。筛选器可以停止事件，也可以将事件转发给此QObject对象。事件过滤器filterObj通过它的eventFilter()函数接收事件。 简单实现 当鼠标进入 lineEdit 的时候并且操作时 HoverEnter 的时候，则修改 QLabel 的颜色。 安装事件过滤器 1ui-&gt;lineEdit-&gt;installEventFilter(this); 重写 eventFilter() 1234567891011121314151617181920bool Widget::eventFilter(QObject *wcg, QEvent *event)&#123; if (wcg == ui-&gt;lineEdit) &#123; if(event-&gt;type() == QEvent::HoverEnter) &#123; ui-&gt;label_2-&gt;setText(QString(&quot;进入&quot;)); ui-&gt;label_2-&gt;setStyleSheet(&quot;QLabel&#123;color:red;&#125;&quot;); qDebug() &lt;&lt; &quot;进入&quot; &lt;&lt; endl; &#125; else if(event-&gt;type() == QEvent::HoverLeave) &#123; ui-&gt;label_2-&gt;setText(QString(&quot;离开&quot;)); ui-&gt;label_2-&gt;setStyleSheet(&quot;QLabel&#123;color:green;&#125;&quot;); qDebug() &lt;&lt; &quot;离开&quot; &lt;&lt; endl; &#125; &#125; return QWidget::eventFilter(wcg,event);&#125;","tags":["Qt"],"categories":["Code","Qt"]},{"title":"随机字符串","path":"/Code/Qt/Qt 随机字符串/","content":"Qt生成自定义字符串 1234567891011121314151617qsrand(QDateTime::currentMSecsSinceEpoch());const char ch[] = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;int size = sizeof(ch);char* str = new char[nLen + 1];int num = 0;for (int nIndex = 0; nIndex &lt; nLen; ++nIndex)&#123;\tnum = rand() % (size - 1);\tstr[nIndex] = ch[num];&#125;str[nLen] = &#x27;\\0&#x27;;QString res(str); QLOG_INFO() &lt;&lt; __FUNCTION__ &lt;&lt; __LINE__ &lt;&lt; res; m_RandomCode = res;","tags":["字符串"],"categories":["Code","Qt"]},{"title":"Qt Http 下载（转载）","path":"/Code/Qt/QtHttp下载/","content":"QT之HTTP请求下载标签： Qt HTTP 简述最近在研究了一下用Qt 的方法来实现http下载，Qt 中的Http请求主要用到了QNetworkAccessManager、QNetworkReply、QNetworkRequest 这三块。本篇文章主要叙述如何用Qt 的方法进行HTTP 请求下载文件，能够支持****断点续传****（断点续传即能够手动停止下载，下次可以从已经下载的部分开始继续下载未完成的部分，而没有必要从头开始上传下载），并且实时更新下载信息。整体代码考虑十分周到，对各种情况也做了相应的处理，并且有通俗易懂的注释。好了，代码走起！ 代码之路在讲解代码之前先看一下效果图： 效果： 从图中可以看出点击start按钮，进行下载，stop按钮暂停当前下载，close按钮停止当前下载，并删除已经下载的临时文件，并将所有参数重置， 这里界面中下载链接输入框为空是因为我在代码中默认了url，也可以在输入框中输入url进行下载。 代码主要包含两个部分： 1、DownLoadManager ： 用来请求下载，向界面传递下载信息，并将下载的内容保存到文件中 2、MyHttpDownload ： 用来接收下载链接，利用DownLoadManager进行下载，更新界面，并对当前下载进行操作（包括：开始、暂停、停止下载）。 1、DOWNLOADMANAGER123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &quot;downloadmanager.h&quot;#include &lt;QFile&gt;#include &lt;QDebug&gt;#include &lt;QFileInfo&gt;#include &lt;QDir&gt; #define DOWNLOAD_FILE_SUFFIX &quot;_tmp&quot; DownLoadManager::DownLoadManager(QObject *parent) : QObject(parent) , m_networkManager(NULL) , m_url(QUrl(&quot;&quot;)) , m_fileName(&quot;&quot;) , m_isSupportBreakPoint(false) , m_bytesReceived(0) , m_bytesTotal(0) , m_bytesCurrentReceived(0) , m_isStop(true)&#123; m_networkManager = new QNetworkAccessManager(this);&#125; DownLoadManager::~DownLoadManager()&#123;&#125; // 设置是否支持断点续传;void DownLoadManager::setDownInto(bool isSupportBreakPoint)&#123; m_isSupportBreakPoint = isSupportBreakPoint;&#125; // 获取当前下载链接;QString DownLoadManager::getDownloadUrl()&#123; return m_url.toString();&#125; // 开始下载文件，传入下载链接和文件的路径;void DownLoadManager::downloadFile(QString url , QString fileName)&#123; // 防止多次点击开始下载按钮，进行多次下载，只有在停止标志变量为true时才进行下载; if (m_isStop) &#123; m_isStop = false; m_url = QUrl(url); // 这里可用从url中获取文件名，但不是对所有的url都有效;// QString fileName = m_url.fileName(); // 将当前文件名设置为临时文件名，下载完成时修改回来; m_fileName = fileName + DOWNLOAD_FILE_SUFFIX; // 如果当前下载的字节数为0那么说明未下载过或者重新下载 // 则需要检测本地是否存在之前下载的临时文件，如果有则删除 if (m_bytesCurrentReceived &lt;= 0) &#123; removeFile(m_fileName); &#125; QNetworkRequest request; request.setUrl(m_url); // 如果支持断点续传，则设置请求头信息 if (m_isSupportBreakPoint) &#123; QString strRange = QString(&quot;bytes=%1-&quot;).arg(m_bytesCurrentReceived); request.setRawHeader(&quot;Range&quot;, strRange.toLatin1()); &#125; // 请求下载; m_reply = m_networkManager-&gt;get(request); connect(m_reply, SIGNAL(downloadProgress(qint64, qint64)), this, SLOT(onDownloadProgress(qint64, qint64))); connect(m_reply, SIGNAL(readyRead()), this, SLOT(onReadyRead())); connect(m_reply, SIGNAL(finished()), this, SLOT(onFinished())); connect(m_reply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onError(QNetworkReply::NetworkError))); &#125; &#125; // 下载进度信息;void DownLoadManager::onDownloadProgress(qint64 bytesReceived, qint64 bytesTotal)&#123; if (!m_isStop) &#123; m_bytesReceived = bytesReceived; m_bytesTotal = bytesTotal; // 更新下载进度;(加上 m_bytesCurrentReceived 是为了断点续传时之前下载的字节) emit signalDownloadProcess(m_bytesReceived + m_bytesCurrentReceived, m_bytesTotal + m_bytesCurrentReceived); &#125; &#125; // 获取下载内容，保存到文件中;void DownLoadManager::onReadyRead()&#123; if (!m_isStop) &#123; QFile file(m_fileName); if (file.open(QIODevice::WriteOnly | QIODevice::Append)) &#123; file.write(m_reply-&gt;readAll()); &#125; file.close(); &#125; &#125; // 下载完成;void DownLoadManager::onFinished()&#123; m_isStop = true; // http请求状态码; QVariant statusCode = m_reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute); if (m_reply-&gt;error() == QNetworkReply::NoError) &#123; // 重命名临时文件; QFileInfo fileInfo(m_fileName); if (fileInfo.exists()) &#123; int index = m_fileName.lastIndexOf(DOWNLOAD_FILE_SUFFIX); QString realName = m_fileName.left(index); QFile::rename(m_fileName, realName); &#125; &#125; else &#123; // 有错误输出错误; QString strError = m_reply-&gt;errorString(); qDebug() &lt;&lt; &quot;__________&quot; + strError; &#125; emit signalReplyFinished(statusCode.toInt());&#125; // 下载过程中出现错误，关闭下载，并上报错误，这里未上报错误类型，可自己定义进行上报;void DownLoadManager::onError(QNetworkReply::NetworkError code)&#123; QString strError = m_reply-&gt;errorString(); qDebug() &lt;&lt; &quot;__________&quot; + strError; closeDownload(); emit signalDownloadError();&#125; // 停止下载工作;void DownLoadManager::stopWork()&#123; m_isStop = true; if (m_reply != NULL) &#123; disconnect(m_reply, SIGNAL(downloadProgress(qint64, qint64)), this, SLOT(onDownloadProgress(qint64, qint64))); disconnect(m_reply, SIGNAL(readyRead()), this, SLOT(onReadyRead())); disconnect(m_reply, SIGNAL(finished()), this, SLOT(onFinished())); disconnect(m_reply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onError(QNetworkReply::NetworkError))); m_reply-&gt;abort(); m_reply-&gt;deleteLater(); m_reply = NULL; &#125;&#125; // 暂停下载按钮被按下,暂停当前下载;void DownLoadManager::stopDownload()&#123; // 这里m_isStop变量为了保护多次点击暂停下载按钮，导致m_bytesCurrentReceived 被不停累加; if (!m_isStop) &#123; //记录当前已经下载字节数 m_bytesCurrentReceived += m_bytesReceived; stopWork(); &#125; &#125; // 重置参数;void DownLoadManager::reset()&#123; m_bytesCurrentReceived = 0; m_bytesReceived = 0; m_bytesTotal = 0;&#125; // 删除文件;void DownLoadManager::removeFile(QString fileName)&#123; // 删除已下载的临时文件; QFileInfo fileInfo(fileName); if (fileInfo.exists()) &#123; QFile::remove(fileName); &#125;&#125; // 停止下载按钮被按下，关闭下载，重置参数，并删除下载的临时文件;void DownLoadManager::closeDownload()&#123; stopWork(); reset(); removeFile(m_fileName);&#125; 2、MYHTTPDOWNLOAD123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include &quot;myhttpdownload.h&quot;#include &quot;downloadmanager.h&quot;#include &lt;QDebug&gt; #define UNIT_KB 1024 //KB#define UNIT_MB 1024*1024 //MB#define UNIT_GB 1024*1024*1024 //GB #define TIME_INTERVAL 300 //0.3s MyHttpDownload::MyHttpDownload(QWidget *parent) : QWidget(parent) , m_downloadManager(NULL) , m_url(&quot;&quot;) , m_timeInterval(0) , m_currentDownload(0) , m_intervalDownload(0)&#123; ui.setupUi(this); initWindow();&#125; MyHttpDownload::~MyHttpDownload()&#123; &#125; void MyHttpDownload::initWindow()&#123; ui.progressBar-&gt;setValue(0); connect(ui.pButtonStart, SIGNAL(clicked()), this, SLOT(onStartDownload())); connect(ui.pButtonStop, SIGNAL(clicked()), this, SLOT(onStopDownload())); connect(ui.pButtonClose, SIGNAL(clicked()), this, SLOT(onCloseDownload())); // 进度条设置样式; ui.progressBar-&gt;setStyleSheet(&quot;\\ QProgressBar\\ &#123;\\ border-width: 0 10 0 10;\\ border-left: 1px, gray;\\ border-right: 1px, gray;\\ border-image:url(:/Resources/progressbar_back.png);\\ &#125;\\ QProgressBar::chunk\\ &#123;\\ border-width: 0 10 0 10;\\ border-image:url(:/Resources/progressbar.png);\\ &#125;&quot;);&#125; // 开始下载;void MyHttpDownload::onStartDownload()&#123; // 从界面获取下载链接; m_url = ui.downloadUrl-&gt;text(); if (m_downloadManager == NULL) &#123; m_downloadManager = new DownLoadManager(this); connect(m_downloadManager , SIGNAL(signalDownloadProcess(qint64, qint64)), this, SLOT(onDownloadProcess(qint64, qint64))); connect(m_downloadManager, SIGNAL(signalReplyFinished(int)), this, SLOT(onReplyFinished(int))); &#125; // 这里先获取到m_downloadManager中的url与当前的m_url 对比，如果url变了需要重置参数,防止文件下载不全; QString url = m_downloadManager-&gt;getDownloadUrl(); if (url != m_url) &#123; m_downloadManager-&gt;reset(); &#125; m_downloadManager-&gt;setDownInto(true); m_downloadManager-&gt;downloadFile(m_url, &quot;F:/MyHttpDownload/MyDownloadFile.zip&quot;); m_timeRecord.start(); m_timeInterval = 0; ui.labelStatus-&gt;setText(QStringLiteral(&quot;正在下载&quot;));&#125; // 暂停下载;void MyHttpDownload::onStopDownload()&#123; ui.labelStatus-&gt;setText(QStringLiteral(&quot;停止下载&quot;)); if (m_downloadManager != NULL) &#123; m_downloadManager-&gt;stopDownload(); &#125; ui.labelSpeed-&gt;setText(&quot;0 KB/S&quot;); ui.labelRemainTime-&gt;setText(&quot;0s&quot;);&#125; // 关闭下载;void MyHttpDownload::onCloseDownload()&#123; m_downloadManager-&gt;closeDownload(); ui.progressBar-&gt;setValue(0); ui.labelSpeed-&gt;setText(&quot;0 KB/S&quot;); ui.labelRemainTime-&gt;setText(&quot;0s&quot;); ui.labelStatus-&gt;setText(QStringLiteral(&quot;关闭下载&quot;)); ui.labelCurrentDownload-&gt;setText(&quot;0 B&quot;); ui.labelFileSize-&gt;setText(&quot;0 B&quot;);&#125; // 更新下载进度;void MyHttpDownload::onDownloadProcess(qint64 bytesReceived, qint64 bytesTotal)&#123; // 输出当前下载进度; // 用到除法需要注意除0错误; qDebug() &lt;&lt; QString(&quot;%1&quot;).arg(bytesReceived * 100 / bytesTotal + 1); // 更新进度条; ui.progressBar-&gt;setMaximum(bytesTotal); ui.progressBar-&gt;setValue(bytesReceived); // m_intervalDownload 为下次计算速度之前的下载字节数; m_intervalDownload += bytesReceived - m_currentDownload; m_currentDownload = bytesReceived; uint timeNow = m_timeRecord.elapsed(); // 超过0.3s更新计算一次速度; if (timeNow - m_timeInterval &gt; TIME_INTERVAL) &#123; qint64 ispeed = m_intervalDownload * 1000 / (timeNow - m_timeInterval); QString strSpeed = transformUnit(ispeed, true); ui.labelSpeed-&gt;setText(strSpeed); // 剩余时间; qint64 timeRemain = (bytesTotal - bytesReceived) / ispeed; ui.labelRemainTime-&gt;setText(transformTime(timeRemain)); ui.labelCurrentDownload-&gt;setText(transformUnit(m_currentDownload)); ui.labelFileSize-&gt;setText(transformUnit(bytesTotal)); m_intervalDownload = 0; m_timeInterval = timeNow; &#125;&#125; // 下载完成;void MyHttpDownload::onReplyFinished(int statusCode)&#123; // 根据状态码判断当前下载是否出错; if (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400) &#123; qDebug() &lt;&lt; &quot;Download Failed&quot;; &#125; else &#123; qDebug() &lt;&lt; &quot;Download Success&quot;; &#125;&#125; // 转换单位;QString MyHttpDownload::transformUnit(qint64 bytes , bool isSpeed)&#123; QString strUnit = &quot; B&quot;; if (bytes &lt;= 0) &#123; bytes = 0; &#125; else if (bytes &lt; UNIT_KB) &#123; &#125; else if (bytes &lt; UNIT_MB) &#123; bytes /= UNIT_KB; strUnit = &quot; KB&quot;; &#125; else if (bytes &lt; UNIT_GB) &#123; bytes /= UNIT_MB; strUnit = &quot; MB&quot;; &#125; else if (bytes &gt; UNIT_GB) &#123; bytes /= UNIT_GB; strUnit = &quot; GB&quot;; &#125; if (isSpeed) &#123; strUnit += &quot;/S&quot;; &#125; return QString(&quot;%1%2&quot;).arg(bytes).arg(strUnit);&#125; // 转换时间;QString MyHttpDownload::transformTime(qint64 seconds)&#123; QString strValue; QString strSpacing(&quot; &quot;); if (seconds &lt;= 0) &#123; strValue = QString(&quot;%1s&quot;).arg(0); &#125; else if (seconds &lt; 60) &#123; strValue = QString(&quot;%1s&quot;).arg(seconds); &#125; else if (seconds &lt; 60 * 60) &#123; int nMinute = seconds / 60; int nSecond = seconds - nMinute * 60; strValue = QString(&quot;%1m&quot;).arg(nMinute); if (nSecond &gt; 0) strValue += strSpacing + QString(&quot;%1s&quot;).arg(nSecond); &#125; else if (seconds &lt; 60 * 60 * 24) &#123; int nHour = seconds / (60 * 60); int nMinute = (seconds - nHour * 60 * 60) / 60; int nSecond = seconds - nHour * 60 * 60 - nMinute * 60; strValue = QString(&quot;%1h&quot;).arg(nHour); if (nMinute &gt; 0) strValue += strSpacing + QString(&quot;%1m&quot;).arg(nMinute); if (nSecond &gt; 0) strValue += strSpacing + QString(&quot;%1s&quot;).arg(nSecond); &#125; else &#123; int nDay = seconds / (60 * 60 * 24); int nHour = (seconds - nDay * 60 * 60 * 24) / (60 * 60); int nMinute = (seconds - nDay * 60 * 60 * 24 - nHour * 60 * 60) / 60; int nSecond = seconds - nDay * 60 * 60 * 24 - nHour * 60 * 60 - nMinute * 60; strValue = QString(&quot;%1d&quot;).arg(nDay); if (nHour &gt; 0) strValue += strSpacing + QString(&quot;%1h&quot;).arg(nHour); if (nMinute &gt; 0) strValue += strSpacing + QString(&quot;%1m&quot;).arg(nMinute); if (nSecond &gt; 0) strValue += strSpacing + QString(&quot;%1s&quot;).arg(nSecond); &#125; return strValue;&#125; 标注： 代码注释中提到可以根据URL来获取文件名，下方给予解释说明。 QString QUrl::fileName(ComponentFormattingOptions options &#x3D; FullyDecoded) constReturns the name of the file, excluding the directory path.Note that, if this QUrl object is given a path ending in a slash, the name of the file is considered empty.If the path doesn’t contain any slash, it is fully returned as the fileName. 在Qt助手中我们找到此方法，根据加粗的字段可以看出fileName()方法也可能返回为空，所以不是都有效。","tags":["HTTP","QNetWork","QNetworkRequest"],"categories":["Code","Qt"]},{"title":"Qt在Win系统上的消息通知","path":"/Code/Qt/Qt Win消息通知/","content":"[TOC] 需求描述： Qt应用程序在windows系统上发送win消息通知 演示 代码代码实现很简单，主要调用的接口为QSystemTrayIcon.showMessage() 使用的Demo为 【Qt】 鼠标 hover 操作时弹出文字气泡_欧恩意的博客-CSDN博客 这篇文章，结合图片隐藏显示，在系统显示通知。 widget.h1234567891011121314151617181920212223242526272829303132#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QImage&gt;#include &lt;QPixmap&gt;#include &lt;QSystemTrayIcon&gt;#include &lt;QMenu&gt;#include &lt;QIcon&gt;#include &lt;QAction&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget();public: QSystemTrayIcon *trayIcon;private slots: void stTrayIconActive(QSystemTrayIcon::ActivationReason acReason); void on_pushButton_clicked();private: Ui::Widget *ui;&#125;;#endif // WIDGET_H widget.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); QPixmap img(&quot;:/Win11.jpg&quot;); ui-&gt;label-&gt;setPixmap(img); ui-&gt;label-&gt;setScaledContents(true); ui-&gt;label-&gt;setToolTip(QString(&quot;壁纸《Win11.png》&quot;)); ui-&gt;pushButton-&gt;setToolTip(QString(&quot;隐藏或显示图片&quot;)); QIcon icon = QApplication::style()-&gt;standardIcon((QStyle::StandardPixmap)0); QIcon icon1 = QApplication::style()-&gt;standardIcon((QStyle::StandardPixmap)9); //设置通知栏的图标 trayIcon = new QSystemTrayIcon(this); trayIcon-&gt;setIcon(icon); //设置通知栏的单击事件 connect(trayIcon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)), this, SLOT(stTrayIconActive(QSystemTrayIcon::ActivationReason))); //设置通知栏的右键菜单 QMenu * menu = new QMenu(); //设置菜单项目 QAction *actionHide = new QAction(icon, &quot;Hide&quot;, menu); menu-&gt;addAction(actionHide); trayIcon-&gt;setContextMenu(menu); // 设置Action的响应 connect(actionHide, SIGNAL(triggered()), this, SLOT(stActionHide())); trayIcon-&gt;show(); //托盘的消息提示 trayIcon-&gt;showMessage(&quot;title&quot;, &quot;this is a message&quot;, icon1);&#125;Widget::~Widget()&#123; delete ui;&#125;void Widget::stTrayIconActive(QSystemTrayIcon::ActivationReason acReason)&#123; switch (acReason) &#123; case QSystemTrayIcon::Trigger: &#123; showNormal(); break; &#125; default: ; &#125;&#125;void Widget::on_pushButton_clicked()&#123; QIcon icon = QApplication::style()-&gt;standardIcon((QStyle::StandardPixmap)0); QIcon icon1 = QApplication::style()-&gt;standardIcon((QStyle::StandardPixmap)9); if(ui-&gt;label-&gt;isVisible()) &#123; trayIcon-&gt;showMessage(&quot;提醒&quot;, &quot;隐藏图片&quot;, icon1); ui-&gt;label-&gt;hide(); &#125; else &#123; trayIcon-&gt;showMessage(&quot;提醒&quot;, &quot;显示图片&quot;, icon1); ui-&gt;label-&gt;setVisible(true); &#125;&#125; widget.ui","tags":["Qt","win","通知"],"categories":["Code","Qt"]},{"title":"Qt 自定义气泡","path":"/Code/Qt/Qt 自定义气泡/","content":"[toc] Qt 自定义气泡 效果 实现逻辑1. 绘制弹出的气泡 弹出气泡的主要部分已经用ui文件生成了，剩下的就是气泡的三角区域，也是比较难的一个部分 1.1 ui文件代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;qFloatWidget&lt;/class&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;qFloatWidget&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;191&lt;/width&gt; &lt;height&gt;105&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;Form&lt;/string&gt; &lt;/property&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_2&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QStackedWidget&quot; name=&quot;stackedWidget&quot;&gt; &lt;property name=&quot;currentIndex&quot;&gt; &lt;number&gt;0&lt;/number&gt; &lt;/property&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_4&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label_2&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;2&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page_2&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_3&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;1&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt; 1.2绘制三角区域代码三角区域的位置可以根据自己的需求修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162QPainter painter(this); QPainterPath drawPath; painter.setRenderHint(QPainter::Antialiasing, true); // painter.setPen(QPen(Qt::blue, 1)); painter.setPen(Qt::NoPen); painter.setBrush(Qt::white); // 小三角区域; QPolygon trianglePolygon; QRect myRect(ui-&gt;stackedWidget-&gt;x(), ui-&gt;stackedWidget-&gt;y(), ui-&gt;stackedWidget-&gt;width(), ui-&gt;stackedWidget-&gt;height()); // 设置小三的具体位置 int tri_pos_x, tri_pos_y; m_offset = ui-&gt;stackedWidget-&gt;width() / 2 - m_triangleWidth / 2; switch (derect) &#123; case up:&#123; // 小三角左边的点的位置 tri_pos_x = myRect.x() + m_offset; tri_pos_y = myRect.y(); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); // 小三角起点 trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth / 2, tri_pos_y - m_triangleHeight); &#125; break; case left:&#123; // 小三上边点的位置 tri_pos_x = myRect.x(); tri_pos_y = myRect.y() + m_offset; trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x - m_triangleHeight, tri_pos_y + m_triangleWidth / 2); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y + m_triangleWidth); &#125; break; case right:&#123; // 小三上边点的位置 tri_pos_x = myRect.x() + myRect.width(); tri_pos_y = myRect.y() + m_offset; trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleHeight, tri_pos_y + m_triangleWidth / 2); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y + m_triangleWidth); &#125; break; case down:&#123; // 小三左边点的位置 tri_pos_x = myRect.x() + m_offset; tri_pos_y = myRect.y() + myRect.height(); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth / 2, tri_pos_y + m_triangleHeight); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth, tri_pos_y); &#125; break; default: break; &#125; drawPath.addRoundedRect(myRect, BORDER_RADIUS, BORDER_RADIUS); drawPath.addPolygon(trianglePolygon); painter.drawPath(drawPath); 以上就是主要的绘图事件，创建了一个带三角的气泡界面。接下来就是在主界面去响应了。 2. 鼠标事件鼠标时间还是用到了QLabel的过滤器，监听 QEvent::Enter 和 QEvent::Leave 两个事件。具体代码如下所示： 12345678910111213141516171819202122232425262728293031bool Widget::eventFilter(QObject *obj, QEvent *event)&#123; QString str = QString(&quot;&lt;style&gt; span &#123;text-decoration: none; color: #006FFF;font-family: Microsoft YaHei;&#125;&lt;/style&gt; &lt;span&gt;连接%1&lt;/span&gt; &lt;br&gt; 虚拟地址：%2&lt;br&gt;登录地址：%3&quot;).arg(&quot;已成功&quot;).arg(&quot;192.168.0.0&quot;).arg(&quot;192.168.0.1&quot;); static int x = 0; static int y = 0; static uint8_t flag=0; if(obj == ui-&gt;label) &#123; if(event-&gt;type() == QEvent::Enter) &#123; ui-&gt;label-&gt;setText(&quot;进入&quot;); QPoint GlobalPoint(ui-&gt;label-&gt;mapToGlobal(QPoint(0, 0)));//获取控件在窗体中的坐标 x = GlobalPoint.x(); y = GlobalPoint.y() + ui-&gt;label-&gt;height(); qDebug() &lt;&lt; x &lt;&lt; &quot;:&quot; &lt;&lt; y ; m_widget-&gt;myMove(x, y); m_widget-&gt;setDerection(qFloatWidget::up); m_widget-&gt;show(); &#125; else if(event-&gt;type() == QEvent::Leave) &#123; ui-&gt;label-&gt;setText((&quot;离开&quot;)); m_widget-&gt;hide(); &#125; &#125; return QWidget::eventFilter(obj,event);&#125; 3. 动画动画内容比较简单，只需要创建一个简单的位移动画就可以了，当然也可以去掉动画，直接让气泡弹出。 12345678// 添加动画// 位移QPropertyAnimation *pPosAnimation1 = new QPropertyAnimation(m_widget, &quot;pos&quot;);pPosAnimation1-&gt;setDuration(1000);pPosAnimation1-&gt;setStartValue(QCursor::pos());pPosAnimation1-&gt;setEndValue(QPoint(x,y));pPosAnimation1-&gt;setEasingCurve(QEasingCurve::InOutQuad);pPosAnimation1-&gt;start(); 完整代码QFloatWidget.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#ifndef QFLOATWIDGET_H#define QFLOATWIDGET_H#include &lt;QWidget&gt;#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600) #pragma execution_character_set(&quot;utf-8&quot;)#endifconst int SHADOW_WIDTH = 30; // 窗口阴影宽度;const int TRIANGLE_WIDTH = 30; // 小三角的宽度;const int TRIANGLE_HEIGHT = 10; // 小三角的高度;const int BORDER_RADIUS = 15; // 窗口边角的弧度;namespace Ui &#123;class qFloatWidget;&#125;class qFloatWidget : public QWidget&#123; Q_OBJECTpublic: qFloatWidget(QWidget *parent = nullptr); ~qFloatWidget(); enum Derection&#123; left, right, up, down &#125;; // 设置小三角起始位置; void setStartPos(int startX); // 设置小三角宽和高; void setTriangleInfo(int width, int height); // 设置小三角的位置 void setDerection(Derection d); // 比起左上角的位置 用户更关心小三角的尖尖的位置 重载move以便用户更容易定位气泡框的位置 // x,y 是气泡窗口小贱贱的坐标 void myMove(int x, int y); void setWidgetIndex(int i);protected: void paintEvent(QPaintEvent *);private: // 小三角的偏移量; int m_offset; // 小三角的宽度; int m_triangleWidth; // 小三角高度; int m_triangleHeight; Derection derect; Ui::qFloatWidget *ui;&#125;;#endif // QFLOATWIDGET_H QFloatWidget.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &quot;qfloatwidget.h&quot;#include &quot;ui_qfloatwidget.h&quot;#include &lt;QGraphicsDropShadowEffect&gt;#include &lt;QHBoxLayout&gt;#include &lt;QPoint&gt;#include &lt;QPainter&gt;#include &lt;QImage&gt;#include &lt;QVariant&gt;#include &lt;QPropertyAnimation&gt;qFloatWidget::qFloatWidget(QWidget *parent) : QWidget(parent), m_offset(50), m_triangleWidth(TRIANGLE_WIDTH), m_triangleHeight(TRIANGLE_HEIGHT), ui(new Ui::qFloatWidget)&#123; ui-&gt;setupUi(this); setWindowFlags(Qt::FramelessWindowHint); setAttribute(Qt::WA_TranslucentBackground); setAttribute(Qt::WA_NoSystemBackground); //设置具体阴影 QGraphicsDropShadowEffect *shadow_effect = new QGraphicsDropShadowEffect(this); shadow_effect-&gt;setOffset(0, 0); shadow_effect-&gt;setColor(QColor(0, 133, 255)); shadow_effect-&gt;setBlurRadius(5); this-&gt;setGraphicsEffect(shadow_effect);&#125;qFloatWidget::~qFloatWidget()&#123; delete ui;&#125;void qFloatWidget::setStartPos(int startX)&#123; m_offset = startX; repaint();&#125;void qFloatWidget::setTriangleInfo(int width, int height)&#123; m_triangleWidth = width; m_triangleHeight = height;&#125;void qFloatWidget::setDerection(Derection d)&#123; derect = d;&#125;void qFloatWidget::myMove(int x, int y)&#123; int top_left_x, top_left_y; switch (derect) &#123; case down: top_left_x = x - m_offset - m_triangleWidth / 2 - ui-&gt;stackedWidget-&gt;x(); top_left_y = y - m_triangleHeight - ui-&gt;stackedWidget-&gt;height() - ui-&gt;stackedWidget-&gt;y(); move(QPoint(top_left_x, top_left_y)); break; case up: top_left_x = x - m_offset - m_triangleWidth / 2 - ui-&gt;stackedWidget-&gt;x(); top_left_y = y + m_triangleHeight - ui-&gt;stackedWidget-&gt;y(); move(QPoint(top_left_x, top_left_y)); break; case left: top_left_x = x + m_triangleHeight - ui-&gt;stackedWidget-&gt;x(); top_left_y = y - m_offset - m_triangleWidth / 2 - ui-&gt;stackedWidget-&gt;y(); move(QPoint(top_left_x, top_left_y)); break; case right: top_left_x = x - m_triangleHeight - ui-&gt;stackedWidget-&gt;width() - ui-&gt;stackedWidget-&gt;x(); top_left_y = y - m_triangleWidth / 2 - m_offset - ui-&gt;stackedWidget-&gt;y(); move(QPoint(top_left_x, top_left_y)); break; default: break; &#125;&#125;void qFloatWidget::setWidgetIndex(int i)&#123; ui-&gt;stackedWidget-&gt;setCurrentIndex(i);&#125;void qFloatWidget::paintEvent(QPaintEvent *)&#123; QPainter painter(this); QPainterPath drawPath; painter.setRenderHint(QPainter::Antialiasing, true); // painter.setPen(QPen(Qt::blue, 1)); painter.setPen(Qt::NoPen); painter.setBrush(Qt::white); // 小三角区域; QPolygon trianglePolygon; QRect myRect(ui-&gt;stackedWidget-&gt;x(), ui-&gt;stackedWidget-&gt;y(), ui-&gt;stackedWidget-&gt;width(), ui-&gt;stackedWidget-&gt;height()); // 设置小三的具体位置 int tri_pos_x, tri_pos_y; m_offset = ui-&gt;stackedWidget-&gt;width() / 2 - m_triangleWidth / 2; switch (derect) &#123; case up:&#123; // 小三角左边的点的位置 tri_pos_x = myRect.x() + m_offset; tri_pos_y = myRect.y(); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); // 小三角起点 trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth / 2, tri_pos_y - m_triangleHeight); &#125; break; case left:&#123; // 小三上边点的位置 tri_pos_x = myRect.x(); tri_pos_y = myRect.y() + m_offset; trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x - m_triangleHeight, tri_pos_y + m_triangleWidth / 2); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y + m_triangleWidth); &#125; break; case right:&#123; // 小三上边点的位置 tri_pos_x = myRect.x() + myRect.width(); tri_pos_y = myRect.y() + m_offset; trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleHeight, tri_pos_y + m_triangleWidth / 2); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y + m_triangleWidth); &#125; break; case down:&#123; // 小三左边点的位置 tri_pos_x = myRect.x() + m_offset; tri_pos_y = myRect.y() + myRect.height(); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth / 2, tri_pos_y + m_triangleHeight); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth, tri_pos_y); &#125; break; default: break; &#125; drawPath.addRoundedRect(myRect, BORDER_RADIUS, BORDER_RADIUS); drawPath.addPolygon(trianglePolygon); painter.drawPath(drawPath);&#125; QFloatWidget.ui123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;qFloatWidget&lt;/class&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;qFloatWidget&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;191&lt;/width&gt; &lt;height&gt;105&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;Form&lt;/string&gt; &lt;/property&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_2&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QStackedWidget&quot; name=&quot;stackedWidget&quot;&gt; &lt;property name=&quot;currentIndex&quot;&gt; &lt;number&gt;0&lt;/number&gt; &lt;/property&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_4&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label_2&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;2&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page_2&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_3&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;1&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt; widget.h12345678910111213141516171819202122232425262728293031323334#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QMouseEvent&gt;#include &quot;qmylabel.h&quot;#include &quot;qfloatwidget.h&quot;#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600) #pragma execution_character_set(&quot;utf-8&quot;)#endifQT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget();protected: bool eventFilter(QObject *obj, QEvent *event);private: Ui::Widget *ui; qFloatWidget *m_widget;&#125;;#endif // WIDGET_H widget.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QDebug&gt;#include&lt;QPropertyAnimation&gt;#include &lt;QGraphicsEffect&gt;Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); m_widget = new qFloatWidget(); ui-&gt;label-&gt;installEventFilter(this);&#125;Widget::~Widget()&#123; delete ui;&#125;bool Widget::eventFilter(QObject *obj, QEvent *event)&#123; QString str = QString(&quot;&lt;style&gt; span &#123;text-decoration: none; color: #006FFF;font-family: Microsoft YaHei;&#125;&lt;/style&gt; &lt;span&gt;连接%1&lt;/span&gt; &lt;br&gt; 虚拟地址：%2&lt;br&gt;登录地址：%3&quot;).arg(&quot;已成功&quot;).arg(&quot;192.168.0.0&quot;).arg(&quot;192.168.0.1&quot;); static int x = 0; static int y = 0; static uint8_t flag=0; if(obj == ui-&gt;label) &#123; if(event-&gt;type() == QEvent::Enter) &#123; ui-&gt;label-&gt;setText(&quot;进入&quot;); QPoint GlobalPoint(ui-&gt;label-&gt;mapToGlobal(QPoint(0, 0)));//获取控件在窗体中的坐标 x = GlobalPoint.x(); y = GlobalPoint.y() + ui-&gt;label-&gt;height(); qDebug() &lt;&lt; x &lt;&lt; &quot;:&quot; &lt;&lt; y ; m_widget-&gt;myMove(x, y); m_widget-&gt;setDerection(qFloatWidget::up); m_widget-&gt;show(); &#125; else if(event-&gt;type() == QEvent::Leave) &#123; ui-&gt;label-&gt;setText((&quot;离开&quot;)); m_widget-&gt;hide(); &#125; &#125; // 添加动画 // 位移 QPropertyAnimation *pPosAnimation1 = new QPropertyAnimation(m_widget, &quot;pos&quot;); pPosAnimation1-&gt;setDuration(1000); pPosAnimation1-&gt;setStartValue(QCursor::pos()); pPosAnimation1-&gt;setEndValue(QPoint(x,y)); pPosAnimation1-&gt;setEasingCurve(QEasingCurve::InOutQuad); pPosAnimation1-&gt;start(); return QWidget::eventFilter(obj,event);&#125; widget.ui12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;Widget&lt;/class&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;Widget&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;497&lt;/width&gt; &lt;height&gt;252&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;Widget&lt;/string&gt; &lt;/property&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;123123123123&lt;/string&gt; &lt;/property&gt; &lt;property name=&quot;textFormat&quot;&gt; &lt;enum&gt;Qt::PlainText&lt;/enum&gt; &lt;/property&gt; &lt;property name=&quot;wordWrap&quot;&gt; &lt;bool&gt;false&lt;/bool&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt;","tags":["Qt","气泡","自定义控件"],"categories":["Code","Qt"]},{"title":"【一文搞懂】qss","path":"/Code/Qt/Qss/","content":"QssQss的写法参考css即可。 网站推荐： Qt Style Sheets Reference | Qt 4.8 书籍推荐： 《Qt样式葵花宝典》提取码：nod5 工具推荐： Qss Editor 0.6.1 提取码：yzbi Qss Stylesheet Editor 1.7 提取码：4r3i Qss加载的常规操作 在资源文件夹中添加style.qss的文件 以文件IO的方式读取并设置即可。 读取的代码： 1234567891011121314151617181920void Widget::InitStyle(int i)&#123; m_LCD_Hour-&gt;setStyleSheet(&quot; font: 18px black;&quot;); if(i != 0) &#123; QFile file(QString(&quot;:/Assert/qss/style%1.qss&quot;).arg(i)); file.open(QFile::ReadOnly); this-&gt;setStyleSheet(file.readAll()); file.close(); return; &#125; // m_LCD_Min-&gt;setStyleSheet(&quot;color: black; &quot;); // m_LCD_Sec-&gt;setStyleSheet(&quot;color: black; &quot;); QFile file(QString(&quot;:/Assert/qss/main.qss&quot;)); file.open(QFile::ReadOnly); this-&gt;setStyleSheet(file.readAll()); file.close();&#125; 感兴趣的朋友可以看看我整理的一些Qt小项目常用的一些代码：[【Qt】常用基础代码汇总（随时更新）_欧恩意的博客-CSDN博客_qt代码整理]https://blog.csdn.net/Fuel_Ming/article/details/122830341) 选择器一般情况下，在ui文件中的控件有效，而在代码中声明的则无效，因为Qt是根据objectName来识别的，所以自己声明的控件需要设置对象名。 1m_btn-&gt;setObjectName(&quot;BtnOK&quot;); 在QSS文件中： 1234567QPushButton#BtnOK&#123; color:white; background-color:rgb(0,112,210);&#125;QPushButton#BtnOK::hover&#123; background-color: rgb(0,134,252);&#125; 通用选择器即 * 表示的css对象。作用于所有的界面控件 123* &#123; color: red;&#125; 类型选择器 作用于自己及子类 类名（Qt类）作为选择器，作用于其自身和他所有的子类 123QFrame &#123;\tbackground: gray;&#125; 使用了类型选择器 QFrame，所以 QFrame 和它的子类 QLable，QLCDNumber，QTableWidget 等的背景会是灰色的，QPushButton 不是 QFrame 的子类，所以不受影响。在Qt的类图或者帮助手册中可以看到一个Qt类的子类和父类。 只作用于自己 即 . + 类名 的形式。作用对象只有它自己。子类不受影响。 1234QWidget *window = new QWidget();window-&gt;setStylesheet(&quot;.QWidget &#123; &quot; &quot;color:red;&quot; &quot;&#125;&quot;); ID选择器# + objectname作为选择器。只作用于此 objectname 的对象（多个对象可以设置同一个 objectname，但不推荐这么写）。 1234567891011121314QPushButton *btn = new QPushButton;// 设置属性名btn-&gt;setObjectName(&quot;openButton&quot;);// 设置样式// 1btn-&gt;setStylesheet(&quot;#openButton &#123; &quot; &quot;color:red;&quot; &quot;&#125;&quot;);// 2btn-&gt;setStylesheet(&quot;QPushButton#openButton &#123; &quot; &quot;color:red;&quot; &quot;&#125;&quot;); 属性选择器[属性 = 值]的形式设置样式。需要通过object-&gt;property()接口设置Qt控件的属性值（Dynamic Properties）。 12345app.setStyleSheet(&quot;.QWidget &#123; background: gray; &#125;&quot; &quot;QPushButton[level=\\&quot;dangerous\\&quot;] &#123; background: magenta; &#125;&quot;); openButton-&gt;setProperty(&quot;level&quot;, &quot;dangerous&quot;);closeButton-&gt;setProperty(&quot;level&quot;, &quot;dangerous&quot;); 包含选择器也就是对控件内的控件的类进行设置，一看就懂，选择器之间用空格隔开，包含选择器和子元素选择器需要区分： 12345678910QFrame &#123; background: gray;&#125; QFrame QPushButton &#123; border: 2px solid magenta; border-radius: 10px; background: white; padding: 2px 15px;&#125; 子元素选择器选择器之间用 &gt; 隔开，作用于Widget的 直接 子Widget 12345678910QFrame &#123; background: gray;&#125; QFrame &gt; QPushButton &#123; border: 2px solid magenta; border-radius: 10px; background: white; padding: 2px 15px;&#125; 伪类选择器选择器:状态 作为选择器。支持!操作。 123QPushButton:hover &#123; color: white &#125;QCheckBox:checked &#123; color: white &#125;QCheckBox:!checked &#123; color: red &#125; 常见的伪类选择器如下所示： 伪类 说明 :disabled Widget 被禁用时 :enabled Widget 可使用时 :focus Widget 得到输入焦点 :hover 鼠标放到 Widget 上 :pressed 鼠标按下时 :checked 被选中时 :unchecked 未选中时 :has-children Item 有子 item，例如 QTreeView 的 item 有子 item 时 :has-siblings Item 有 兄弟，例如 QTreeView 的 item 有兄弟 item 时 :open 打开或展开状态，例如 QTreeView 的 item 展开，QPushButton 的菜单弹出时 :closed 关闭或者非展开状态 :on Widget 状态是可切换的（toggle）, 在 on 状态 :off Widget 状态是可切换的（toggle）, 在 off 状态 SubControl选择器选择器::subcontrol 作为选择 Subcontrol 的选择器。 有些 Widget 是由多个部分组合成的，例如 QCheckBox 由 icon(indicator) 和 text 组成，可以使用 选择器::subcontrol 来设置 subcontrol 的样式： 12345678QCheckBox::indicator &#123; width: 20px; height: 20px;&#125;QCheckBox &#123; spacing: 8px;&#125; 常用的 Subcontrol 有： Subcontrol 说明 ::indicator A QCheckBox, QRadioButton, checkable QMenu item, or a checkable QGroupBox’s indicator ::menu-indicator A QPushButton’s menu indicator ::item A QMenu, QMenuBar, or QStatusBar’s item ::up-button A QSpinBox or QScrollBar’s up button ::down-button A QSpinBox or QScrollBar’s down button ::up-arrow A QSpinBox, QScrollBar, or QHeaderView’s up arrow ::down-arrow A QSpinBox, QScrollBar, or QHeaderView’s down arrow ::drop-down A QComboBox’s drop-down arrow ::title A QGroupBox or QDockWidget’s title ::groove A QSlider’s groove ::chunk A QProgressBar’s progress chunk ::branch A QTreeView’s branch indicator 补充一些其他写法的参考demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448/* ================================================ *author:leilastedited:2020.2* ================================================ */$text = #222;$background = #FDFDFD;$border = #999999;$selected = #8BF; /*hover*/$pressed = #59F;$focused = #EA2; /*actived*/$grad1a = #EEEEEF; /*gradient start*/$grad1b = #DADADF; /*gradient end*/QWidget&#123; color: $text; background-color: $background;&#125;QFrame&#123; color: $text; background-color: $background;/*不能设置为transparent*/&#125;QMainWindow::separator&#123; border: 1px solid $border; border-style: outset; width: 4px; height: 4px;&#125;QMainWindow::separator:hover&#123; background: $selected;&#125;QSplitter::handle&#123; border: 1px solid $border; border-style: outset; width: 4px; height: 4px;&#125;QSplitter::handle:hover&#123;/*splitter-&gt;handle(1)-&gt;setAttribute(Qt::WA_Hover, true);才生效*/ border-color: $focused;&#125;QSplitter::handle:pressed&#123; border-color: $pressed;&#125;QSizeGrip&#123; background-color: none;&#125;/* =============================================== *//* Label *//* =============================================== */QLabel &#123; background: transparent; border: 1px solid transparent; padding: 1px;&#125;/* A QLabel is a QFrame ... *//* A QToolTip is a QLabel ... */QToolTip &#123; border: 1px solid $border; padding: 5px; border-radius: 3px; opacity:210;&#125;/* =============================================== *//* TextBox *//* =============================================== */QLineEdit &#123; background: $background;/*不建议设为透明，否则table编辑时会字显示*/ selection-background-color: $selected; border: 1px solid $border; border-radius: 2px; border-style: inset; padding: 0 1px;&#125;QLineEdit:hover&#123; border-color: $selected;&#125;QLineEdit:focus&#123; border-color: $focused;&#125;/*QLineEdit[readOnly=&quot;true&quot;] &#123; color: gray &#125;*/QLineEdit[echoMode=&quot;2&quot;]&#123; lineedit-password-character: 9679;/*字符的ascii码35 88等 */&#125;QLineEdit:read-only &#123; color: lightgray;&#125;QLineEdit:disabled&#123; color: lightgray; background: lightgray;&#125;QTextEdit&#123; selection-background-color:$selected; border: 1px solid $border; border-style: inset;&#125;QTextEdit:hover&#123; border-color: $selected;&#125;QTextEdit:focus&#123; border-color: $focused;&#125;/* =============================================== *//* Button *//* =============================================== */QPushButton &#123; border: 1px solid $border; border-radius: 2px; /*background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 $grad1a, stop: 0.05 $grad1b,stop: 0.5 $grad1b, stop: 0.9 $grad1a, stop: 1 $grad1a);*/ padding: 1px 4px; min-width: 50px; min-height: 16px;&#125;QPushButton:hover&#123; background-color: $selected; border-color: $pressed;&#125;QPushButton:pressed&#123; border-width: 1px; background-color: $pressed; border-color: $border;&#125;QPushButton:focus, QPushButton:default &#123; border-color: $focused; /* make the default button prominent */&#125;QToolButton,QToolButton:unchecked &#123; /* ToolBar里的按钮和带下拉菜单的按钮 */ border: 1px solid transparent; border-radius: 3px; background-color: transparent; margin: 1px;&#125;QToolButton:checked&#123; background-color: $selected; border-color: $pressed;&#125;QToolButton:hover&#123; background-color: $selected; border-color: $pressed;&#125;QToolButton:pressed,QToolButton:checked:hover&#123; background-color: $pressed; border-color: $focused;&#125;QToolButton:checked:pressed&#123; background-color: $selected;&#125;/* only for MenuButtonPopup */QToolButton[popupMode=&quot;1&quot;]&#123; padding-left: 1px; padding-right: 15px; /* make way for the popup button */ border: 1px solid $border; min-height: 15px; /*background: qlineargradient(x1:0, y1:0 ,x2:0, y2:1 stop: 0 $grad1a, stop: 0.05 $grad1b, stop: 0.5 $grad1b stop: 0.95 $grad1a stop: 1$grad1a)*/&#125;QToolButton[popupMode=&quot;1&quot;]:hover&#123; background-color: $selected; border-color: $pressed;&#125;QToolButton[popupMode=&quot;1&quot;]:pressed&#123; border-width: 1px; background-color: $pressed; border-color: $border;&#125;QToolButton::menu-button &#123; border: 1px solid $border; border-top-right-radius: 2px; border-bottom-right-radius: 2px; width: 16px;&#125;/* =============================================== *//* Slider ProgressBar *//* =============================================== */QProgressBar &#123; border: 1px solid $border; border-radius: 4px; text-align: center;&#125;QProgressBar::chunk &#123; background-color: $focused; width: 4px; margin: 1px;&#125;QSlider&#123; border: 1px solid transparent;&#125;QSlider::groove&#123; border: 1px solid $border; background: $background;&#125;QSlider::handle &#123;/*设置中间的那个滑动的键*/ border: 1px solid $border; background: $selected;&#125;QSlider::groove:horizontal &#123; height: 3px; /* the groove expands to the size of the slider by default. by giving it a height, it has a fixed size */ left:5px; right: 5px;&#125;QSlider::groove:vertical&#123; width: 3px; top: 5px; bottom: 5px;&#125;QSlider::handle:horizontal&#123; width: 6px; margin: -7px; /* height */&#125;QSlider::handle:vertical&#123; height: 6px; margin: -7px; /* height */&#125;QSlider::add-page&#123;/*还没有滑上去的地方*/ border: 1px solid $border; background:$grad1a;&#125;QSlider::sub-page&#123;/*已经划过的从地方*/ background: $focused;&#125;/* =============================================== *//* ScrollBar *//* =============================================== */QScrollBar&#123; background-color: $background; border: 1px solid $border; border-radius: 5px; padding: 1px; height: 10px; width: 10px;&#125;QScrollBar:hover&#123; border-color:$selected;&#125;QScrollBar::handle&#123; border-radius: 3px; background: $pressed; min-width: 16px; min-height: 16px;&#125;QScrollBar::handle:hover &#123; background: $focused;&#125;QScrollBar::add-line, QScrollBar::sub-line,QScrollBar::add-page, QScrollBar::sub-page &#123; width: 0px; background: transparent;&#125;QScrollArea&#123; border: none;&#125;/*QScrollArea QAbstractSlider&#123; border-radius: 0px;&#125;*//* =============================================== *//* DockWidget *//* =============================================== */QDockWidget, QDockWidget &gt; QWidget/*not work*/&#123; border-color: $border;/*qt bug*/ background: transparent;&#125;QDockWidget::title &#123; border-bottom: 1px solid $border; border-style: inset; text-align: left; /* align the text to the left */ padding: 6px;&#125;/* =============================================== *//* GroupBox *//* =============================================== */QGroupBox &#123; background-color: $background; border: 1px solid $border; border-radius: 4px; margin-top: 0.5em;&#125;QGroupBox::title &#123; subcontrol-origin: margin; subcontrol-position: top left; left: 1em;\ttop: 0.1em; background-color: $background;&#125;/* =============================================== *//* ToolBox *//* =============================================== */QToolBox&#123; border: 1px solid $border;&#125;QToolBox::tab &#123; background: $grad1a; border: 1px solid $border; border-radius: 1px;&#125;QToolBox::tab:hover &#123; background-color: $selected; border-color: transparent;&#125;QToolBox::tab:pressed &#123; background-color: $pressed; border-color: transparent;&#125;QToolBox::tab:selected &#123; font-weight: bold; border-color: $selected;&#125;/* =============================================== *//* TabWidget *//* =============================================== */QTabWidget&#123; margin-top:10px;&#125;QTabWidget::pane&#123; border: 1px solid $border;&#125;QTabWidget::tab-bar &#123; left: 0px;&#125;QTabBar::tab &#123; background: $background; border: 1px solid $border; padding: 3px 5px; &#125;QTabBar::tab:hover &#123; background: $selected; border-color: transparent;&#125;QTabBar::tab:selected &#123; background: $selected; border-color: $pressed;&#125;QTabBar::tab:pressed &#123; background: $pressed; border-color: transparent;&#125;QTabBar::tab:focus &#123; border-color: $focused;&#125;QTabBar::tab:top&#123; margin-top: 3px; border-bottom: transparent; margin-right: 1px;&#125;QTabBar::tab:bottom&#123; margin-bottom: 3px; border-top: transparent; margin-right: 1px;&#125;QTabBar::tab:left&#123; border-right: transparent; margin-bottom: 1px;&#125;QTabBar::tab:right&#123; border-left: transparent; margin-bottom: 1px;&#125;/* =============================================== *//* QHeaderView for list table *//* =============================================== */QHeaderView &#123;\tborder: none;\tmargin: 0px;\tpadding: 0px;&#125;QHeaderView::section, QTableCornerButton::section &#123;/*设置表头属性*//*左上角*/\tbackground-color: $grad1a;\tpadding: 0 3px;\tborder-right: 1px solid $border;\tborder-bottom: 1px solid $border;\tborder-radius: 0px;&#125;QHeaderView::section:hover, QTableCornerButton::section:hover&#123; background-color: $selected;&#125;QHeaderView::section:pressed&#123; background-color: $pressed;&#125;QHeaderView::section:checked &#123; background-color: $focused;&#125;/* =============================================== *//* QTableWidget *//* =============================================== */QTableWidget, QTableView&#123; gridline-color: $border; /*表格中的网格线条颜色*/ background: $background; /*设置交替颜色，需要在函数属性中设置:tableWidget-&gt;setAlternatingRowColors(true)*/ alternate-background-color: $grad1a; /*selection-color:$background; 鼠标选中时前景色：文字颜色*/ selection-background-color:$selected; /*鼠标选中时背景色*/ border:1px solid $border; /*边框线的宽度、颜色*/ /*border:none; 去除边界线*/ /*border-radius:5px;*/ /*padding:10px 10px;*/ /*表格与边框的间距*/&#125;QTableView::item, QTabWidget::item&#123; background: transparent;\toutline-style: none;\tborder: none;&#125;QTableView::item:hover &#123;\tbackground: $selected; border: 1px solid $focused;&#125;QTableView::item:selected &#123;\tbackground: $selected;\tcolor: $grad1a;&#125;QTableView::item:selected:active &#123;\tbackground: $pressed;\tcolor: $grad1a;&#125;QTableWidget QComboBox&#123; margin: 2px; border: none;&#125;","tags":["Qt","css"],"categories":["Code","Qt"]},{"title":"窗体不显示或半透明","path":"/Code/Qt/QWebEngineView/窗体不显示或窗体半透明/","content":"使用 QWebEnginueView 控件后，如果父窗体设置了一下属性，就会导致窗口不显示或半透明。 12setWindowFlags(Qt::FramelessWindowHint);setAttribute(Qt::WA_TranslucentBackground); 解决办法： QWebEngineView在顶层窗口为透明无标题栏的情况下有问题_shanql的博客-CSDN博客","tags":["Qt","QWebEngineView"],"categories":["Code","Qt","QWebEngineView"]},{"title":"使用 QWebEngineView 加载网页慢的问题","path":"/Code/Qt/QWebEngineView/网页加载慢/","content":"[toc] 定位把 QWebEngineview 发起的每个网络请求全部打印，看看是哪个请求慢： 重写 QWebEngineUrlRequestInterceptor123456789101112131415161718192021class CustomUrlRequestInterceptor : public QWebEngineUrlRequestInterceptor&#123;public: CustomUrlRequestInterceptor(QObject* parent = nullptr) : QWebEngineUrlRequestInterceptor(parent) &#123;&#125; void interceptRequest(QWebEngineUrlRequestInfo&amp; info) override &#123; // 可在发送请求前对URL进行修改 if (info.requestUrl().host() == &quot;www.example.com&quot;) &#123; QUrl newUrl = info.requestUrl(); newUrl.setHost(&quot;www.newexample.com&quot;); info.setUrl(newUrl); &#125; // 可添加自定义Header info.setHttpHeader(&quot;User-Agent&quot;, &quot;Custom User-Agent&quot;); // 打印日志 LogUtils::info(info.requestUrl().toString().toStdString().c_str());//输出日志 &#125;&#125;; 关闭系统代理设置关闭系统自动代理即可： 1QNetworkProxyFactory::setUseSystemConfiguration(false);","tags":["Qt","QWebEngineView"],"categories":["Code","Qt","QWebEngineView"]},{"title":"Qt窗口适配系统缩放","path":"/Code/Qt/QWin/Qt窗口适配系统缩放/","content":"代码1234567891011121314151617181920212223struct DpiCompatible&#123;\tstatic double GetDpiScale()\t&#123; double dDpi = 1.0; HDC desktopDc = GetDC(NULL); float horizontalDPI = GetDeviceCaps(desktopDc, LOGPIXELSX); float verticalDPI = GetDeviceCaps(desktopDc, LOGPIXELSY); int dpi = (horizontalDPI + verticalDPI) / 2; dDpi = 1 + ((dpi - 96) / 24) * 0.25; if (dDpi &lt; 1) &#123; dDpi = 1; &#125; ReleaseDC(NULL, desktopDc); return dDpi;\t&#125;\tstatic void InitQtDPICompatible()\t&#123; SetProcessDPIAware(); qputenv(&quot;QT_SCALE_FACTOR&quot;, QString::number(GetDpiScale()).toLatin1());\t&#125;&#125;; 使用12//设置该属性解决在不同缩放比例的显示器之间移动时布局混乱和不跟随windows系统缩放的问题DpiCompatible::InitQtDPICompatible();","tags":["Qt","win","缩放"],"categories":["Code","Qt","QWin"]},{"title":"QListWidget 用法整理","path":"/Code/Qt/QListWidget 用法整理/","content":"设置显示模式12QListView::ListModeQListView::IconMode 调用接口： 1setViewMode(QListWidget::IconMode); //显示模式 添加控件效果 新建项目的时候创建一个带ui的项目，新建完成后，在界面拖拽一个QListWidget。 Widget.h1234567891011121314151617181920212223242526272829303132333435#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QListWidget&gt;#include &lt;QStringList&gt;#include &lt;QString&gt;#include &lt;QDebug&gt;#include &lt;QListWidgetItem&gt;#include &lt;QGridLayout&gt;#include &lt;QToolButton&gt;#include &lt;QLineEdit&gt;#include &lt;QRadioButton&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget();private: void initListWidget();private: Ui::Widget *ui;&#125;;#endif // WIDGET_H Widget.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); initListWidget();&#125;Widget::~Widget()&#123; delete ui;&#125;void Widget::initListWidget()&#123; ui-&gt;listWidget-&gt;setCurrentRow(2); QStringList StrListHeader; StrListHeader &lt;&lt; QString(&quot;选中&quot;) &lt;&lt; QString(&quot;序号&quot;) &lt;&lt; QString(&quot;文件名&quot;); new QListWidgetItem(tr(&quot;Oak&quot;), ui-&gt;listWidget); new QListWidgetItem(tr(&quot;Fir&quot;), ui-&gt;listWidget); new QListWidgetItem(tr(&quot;Pine&quot;), ui-&gt;listWidget); QListWidgetItem *ListItem = new QListWidgetItem; // ListItem-&gt;setText(); QListWidgetItem *WContainerItem = new QListWidgetItem(ui-&gt;listWidget); QWidget *WContainer = new QWidget(ui-&gt;listWidget);//新建一个QWidget窗口 QGridLayout*Glayout = new QGridLayout;/*************start*****************//* 在这里添加需要的控件 */ QLineEdit *lineEdit = new QLineEdit; QLineEdit *lineEdit_1 = new QLineEdit; QToolButton *toolButton = new QToolButton; QRadioButton *radioButton = new QRadioButton; QRadioButton *radioButton_1 = new QRadioButton; Glayout-&gt;addWidget(lineEdit,0,0); Glayout-&gt;addWidget(radioButton,0,1); Glayout-&gt;addWidget(lineEdit_1,0,2); Glayout-&gt;addWidget(radioButton_1,0,3); WContainer-&gt;setLayout(Glayout);/******************end****************/ WContainerItem-&gt;setSizeHint(QSize(40,40)); ui-&gt;listWidget-&gt;setItemWidget(WContainerItem, WContainer);//将WContainer赋予WContainerItem&#125;","tags":["Qt","QListWidget"],"categories":["Code","Qt"]},{"title":"QTableWidget 遍历","path":"/Code/Qt/QTableWidget/QTableWidget遍历/","content":"123456789101112for(int row=0; row&lt;ui-&gt;tableWidget-&gt;rowCount(); row++)&#123;\tfor(int col=0; col&lt;ui-&gt;tableWidget-&gt;columnCount(); col++)\t&#123; QTableWidgetItem* item = ui-&gt;tableWidget_right-&gt;item(row,col);\t&#125;&#125;for(int row=0; row&lt;ui-&gt;tableWidget-&gt;rowCount(); row++)&#123;\tQTableWidgetItem* item = ui-&gt;tableWidget_right-&gt;item(row,0);&#125;","tags":["Qt","QTableWidget"],"categories":["Code","Qt","QTableWidget"]},{"title":"QLineEdit 修改部分文本样式","path":"/Code/Qt/QLineEdit/QLineEdit修改部分文本样式/","content":"功能描述： 修改QLineEdit中部分文本的样式 预期效果： windows系统路径不允许有？等符号，高亮显示不允许的符号。 [toc] 实现12345678910111213141516171819202122static void setLineEditTextFormat(QLineEdit* lineEdit, const QList&lt;QTextLayout::FormatRange&gt;&amp; formats)&#123; if(!lineEdit) return; QList&lt;QInputMethodEvent::Attribute&gt; attributes; foreach(const QTextLayout::FormatRange&amp; fr, formats) &#123; QInputMethodEvent::AttributeType type = QInputMethodEvent::TextFormat; int start = fr.start - lineEdit-&gt;cursorPosition(); int length = fr.length; QVariant value = fr.format; attributes.append(QInputMethodEvent::Attribute(type, start, length, value)); &#125; QInputMethodEvent event(QString(), attributes); QCoreApplication::sendEvent(lineEdit, &amp;event);&#125;static void clearLineEditTextFormat(QLineEdit* lineEdit)&#123; setLineEditTextFormat(lineEdit, QList&lt;QTextLayout::FormatRange&gt;());&#125; 示例1234567891011121314151617181920212223242526// Usage example:QLineEdit* lineEdit = new QLineEdit;lineEdit-&gt;setText(tr(&quot;Task Tracker - Entry&quot;));QList&lt;QTextLayout::FormatRange&gt; formats;QTextCharFormat f;f.setFontWeight(QFont::Bold);QTextLayout::FormatRange fr_task;fr_task.start = 0;fr_task.length = 4;fr_task.format = f;f.setFontItalic(true);f.setBackground(Qt::darkYellow);f.setForeground(Qt::white);QTextLayout::FormatRange fr_tracker;fr_tracker.start = 5;fr_tracker.length = 7;fr_tracker.format = f;formats.append(fr_task);formats.append(fr_tracker);setLineEditTextFormat(lineEdit, formats);","categories":["Code","Qt","QLineEdit"]},{"title":"QAction Icon 大小问题","path":"/Code/Qt/QAction Icon 大小/","content":"[toc] 问题描述 右键托盘弹出菜单，这个菜单是是通过 QMenu 实现的，通过添加 QAction 实现了几个子项。后续 UI 优化，提出需要修改 Icon的大小，设置 Icon 的大小为 24*24，遂进行了一番尝试，因影响颇多，暂且记录于此。 关于我这个右键托盘弹出选项框的肯定有别的方案，但是第一时间是想找一种比较简单的方案去实现，因此一直在搜索如何设置Icon大小的问题，目前看到的解决方案有以下几种： 通过设置 Style 实现 通过 QWidgetAction 实现 新建一个 Widget，实现 QMenu 的效果 1 通过设置 Style，修改icon size 新建样式类 123456789101112131415161718192021222324252627282930313233343536373839404142434445#pragma once#include &lt;QCommonStyle&gt;#include &lt;QStyleOption&gt;// 自定义一个style类，通过setStyle设置给menu，以此设置iconsizeclass QCustonIconStyle : public QCommonStyle&#123;\tQ_OBJECTpublic:\tQCustonIconStyle(int size) : QCommonStyle(), size_(size) &#123;&#125;protected:\tint QCustonIconStyle::pixelMetric(PixelMetric metric, const QStyleOption* option, const QWidget* widget) const override\t&#123; if (metric == QStyle::PM_SmallIconSize) &#123; return size_; &#125;#if 1 // 一下内容是我尝试修改UI的，改了size之后会导致icon移位，需要修改间距和边距 else if (metric == QStyle::PM_LayoutLeftMargin) &#123; return 1; &#125; else if (metric == QStyle::PM_MenuHMargin) &#123; return 1; &#125; else if (metric == QStyle::PM_LayoutHorizontalSpacing) &#123; return 1; &#125;#endif return QCommonStyle::pixelMetric(metric, option, widget);\t&#125;private:\tint size_;&#125;; 使用方法： 12QCustonIconStyle* style = new QCustonIconStyle(20);QMenu-&gt;setStyle(style); 遗留问题，使用该方法之后，QAction的 horverd() 信号就不会触发了 关于这个问题的解决方法也很简单，尝试了一天，最终选择继承重写 QProxyStyle 就能解决这个问题。 2 使用 QWidgetAction1234action_ = new QPushButton(menu);QWidgetAction* action = new QWidgetAction(this);action-&gt;setDefaultWidget(action_ );menu-&gt;addAction(action); 3 新建界面","categories":["Code","Qt"]},{"title":"QLineEdit 修改密码模式及其样式","path":"/Code/Qt/QLineEdit/QLineEdit 修改密码显示及其显示样式/","content":"[toc] Qt设置为密码模式参考 QLineEdit::setEchoMode。密码模式总共有两种 QLineEdit::Password QLineEdit::PasswordEchoOnEdit 修改样式QLineEdit 密码样式使用 Unicode 字符表示,密码样式修改在QLineEdit::Password 、QLineEdit::PasswordEchoOnEdit 有效Unicode 值查询网址： https://unicode-table.com/cn/search/ 1. 默认样式默认样式是实心圆点 ，Unicode值 9769 2. 自定义样式参考 Qt 助手 中的提升，搜索 Qt Style Sheets Examples 中关于 QLineEdit 的提示设置即可。 * 的 unicode 编码为 9679。 1234QLineEdit[echoMode=&quot;2&quot;] &#123; lineedit-password-character: 9679; &#125;","tags":["Qt","QLineEdit"],"categories":["Code","Qt","QLineEdit"]},{"path":"/Code/Python/python解析Json/","content":"解析Json的常见代码1import json # 导入json解析需要的包 1. json.loads()读取字符串到json objectjson.loads()是将str\\bytes\\bytearray等格式的文件读取到json object中。但是在使用的时候往往会因为一些小问题导致读取错误等。 1234567891011121314151617181920212223242526272829303132Docstring:Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instancecontaining a JSON document) to a Python object.``object_hook`` is an optional function that will be called with theresult of any object literal decode (a ``dict``). The return value of``object_hook`` will be used instead of the ``dict``. This featurecan be used to implement custom decoders (e.g. JSON-RPC class hinting).``object_pairs_hook`` is an optional function that will be called with theresult of any object literal decoded with an ordered list of pairs. Thereturn value of ``object_pairs_hook`` will be used instead of the ``dict``.This feature can be used to implement custom decoders. If ``object_hook``is also defined, the ``object_pairs_hook`` takes priority.``parse_float``, if specified, will be called with the stringof every JSON float to be decoded. By default this is equivalent tofloat(num_str). This can be used to use another datatype or parserfor JSON floats (e.g. decimal.Decimal).``parse_int``, if specified, will be called with the stringof every JSON int to be decoded. By default this is equivalent toint(num_str). This can be used to use another datatype or parserfor JSON integers (e.g. float).``parse_constant``, if specified, will be called with one of thefollowing strings: -Infinity, Infinity, NaN.This can be used to raise an exception if invalid JSON numbersare encountered.To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``kwarg; otherwise ``JSONDecoder`` is used. data.json文件链接 链接：https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA提取码：ysly复制这段内容后打开百度网盘手机App，操作更方便哦 上述文件相对常见的Json文件来说，还是有点区别的，用python的json库操作相对有点困难。 报错Expection \\，delimiter，看了好些解决办法仍然没能成功解决： 1234# 输入文件&#123;&#x27;asin&#x27;: &#x27;0000032069&#x27;, &#x27;title&#x27;: &#x27;Adult Ballet Tutu Cheetah Pink&#x27;, &#x27;price&#x27;: 7.89, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/51EzU6quNML._SX342_.jpg&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;0000032034&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00EXVN9PU&#x27;, &#x27;B0041EOTJO&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B001GTKPDQ&#x27;, &#x27;B00EON0SJ2&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002XZMGGQ&#x27;], &#x27;also_viewed&#x27;: [&#x27;B00D0F450I&#x27;, &#x27;0000032050&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;0000032042&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B0071KR2LC&#x27;, &#x27;B00GOR07RE&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B0079MCIMU&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00H3RYN3I&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B007IEFT84&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B007R2RM8W&#x27;, &#x27;B007VM3AMK&#x27;, &#x27;B00C0PLENA&#x27;, &#x27;B00BJGG6VG&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00IIK61WA&#x27;, &#x27;B009UC638W&#x27;, &#x27;B00KZN6RVI&#x27;, &#x27;B00CSFEENY&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00HSOJJ94&#x27;, &#x27;B00LIPP4VG&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B00E87F196&#x27;, &#x27;B005HMHOQY&#x27;, &#x27;B00J6S9MSS&#x27;, &#x27;0000032034&#x27;, &#x27;B00CJQGNJK&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B0056LG7GY&#x27;, &#x27;B00DPQWCZ2&#x27;, &#x27;B00I3PV0US&#x27;, &#x27;B00KZN6IVW&#x27;, &#x27;B0054TBWKO&#x27;, &#x27;B00I2S01I8&#x27;, &#x27;B00BXF12P8&#x27;, &#x27;B00GVHU678&#x27;, &#x27;B005NWENGC&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B00JK8MQ4Q&#x27;, &#x27;B00FZIMVQS&#x27;, &#x27;B008BB19VE&#x27;, &#x27;B00GTEXPOE&#x27;, &#x27;B009WPT2RQ&#x27;, &#x27;B00E37SBBG&#x27;], &#x27;bought_together&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;]&#125;, &#x27;brand&#x27;: &#x27;BubuBibi&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]&#125;&#123;&#x27;asin&#x27;: &#x27;0000031909&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;0000031895&#x27;, &#x27;B00D2K1M3O&#x27;, &#x27;0000031852&#x27;, &#x27;B00D0WDS9A&#x27;, &#x27;B00D10CLVW&#x27;, &#x27;B00D103F8U&#x27;, &#x27;B003AVEU6G&#x27;, &#x27;B00D2K0PA0&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00D0ZF44Y&#x27;, &#x27;B008F0SMUC&#x27;, &#x27;B00D0GCI8S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B002YSCPZY&#x27;, &#x27;0448408775&#x27;, &#x27;B002R0FABA&#x27;, &#x27;B008GHWNWC&#x27;, &#x27;B002R0FA24&#x27;, &#x27;B001GTKPEK&#x27;, &#x27;B006XA7KZO&#x27;, &#x27;B001GZUQ9S&#x27;, &#x27;B00613VNL0&#x27;, &#x27;B003IEDM9Q&#x27;, &#x27;B003LTOZK8&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B008UBQZKU&#x27;, &#x27;B001AQD8VQ&#x27;, &#x27;B003ILA0L2&#x27;, &#x27;B00AFDOPDA&#x27;, &#x27;B002R0F7FE&#x27;], &#x27;also_viewed&#x27;: [&#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00AFDOPDA&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00CEUWY8K&#x27;, &#x27;B003IEDM9Q&#x27;, &#x27;B00HSOJB9M&#x27;, &#x27;0000031895&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B008F0SMUC&#x27;, &#x27;B00362QGW0&#x27;, &#x27;B008UD01L2&#x27;, &#x27;B00FAZ5ZE6&#x27;, &#x27;B008F0SY6O&#x27;, &#x27;B00DPLLQR2&#x27;, &#x27;B00CEUWUZC&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B00CEUX0D8&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D10CLVW&#x27;, &#x27;B00D23MC6W&#x27;, &#x27;B007XAI53E&#x27;, &#x27;B008X6CBS2&#x27;, &#x27;B004PEI45U&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002C3Y6WG&#x27;, &#x27;B00HSC8O74&#x27;, &#x27;B008BMGHM4&#x27;, &#x27;B00CEUWTFS&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B00CYBU84G&#x27;, &#x27;B00D9C32NI&#x27;, &#x27;B0046W9T8C&#x27;, &#x27;B008UBG5IW&#x27;, &#x27;B001YHX45G&#x27;, &#x27;B00CEV8366&#x27;, &#x27;B00I2UHSZA&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B001GTKPEK&#x27;, &#x27;B004TU1VPU&#x27;, &#x27;B00CBPIO7S&#x27;, &#x27;B00CHHXJ0M&#x27;, &#x27;B00538F5OK&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B00CEUX4QQ&#x27;, &#x27;B003XRKA7A&#x27;, &#x27;0000031852&#x27;, &#x27;B002C3R5XI&#x27;, &#x27;B00C6Q1Z6E&#x27;], &#x27;bought_together&#x27;: [&#x27;B002BZX8Z6&#x27;]&#125;, &#x27;title&#x27;: &#x27;Girls Ballet Tutu Neon Pink&#x27;, &#x27;price&#x27;: 7.0, &#x27;salesRank&#x27;: &#123;&#x27;Toys &amp; Games&#x27;: 201847&#125;, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/41xBoP0FVzL._SY300_.jpg&#x27;, &#x27;brand&#x27;: &#x27;Unknown&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;]], &#x27;description&#x27;: &#x27;High quality 3 layer ballet tutu. 12 inches in length&#x27;&#125; 1234567891011121314151617181920212223242526# 常见的Json读取JsonText = open(&#x27;data.json&#x27;,encoding=&#x27;utf-8&#x27;) # 打开data.jsonJson = JsonText.readlines() # 把json中的文件全部读取到Json对象中。# 读取上述data.json为json对象的代码list_data = list()def read_Json_file(i,x): # 返回有效的Json字段 print(&quot;第&quot; + i + &quot;行:&quot;) print(x) # 关于expectint的报错，我这处理就是但凡报错，直接返回空字段，如果你有别的解决办法，一定指教一下，不胜感激 try: JsonStr = x.replace(&quot;&#x27;&quot;, &#x27;&quot;&#x27;).replace(&#x27;/ &#x27;, &#x27;/&#x27;).replace(&#x27;, &#x27;,&#x27;,&#x27;) ret = json.loads(JsonStr,strict=False) except json.JSONDecodeError: return &#x27; &#x27; if(&#x27;categories&#x27; in ret): print(ret[&#x27;categories&#x27;]) return ret[&#x27;categories&#x27;] else: return &#x27; &#x27; list_data = list()for i in range(0,len(Json)):\tlist_data.append(read_Json_file(str(i+1),Json[i])) 程序输出12345678第1行:&#123;&#x27;asin&#x27;: &#x27;0000032069&#x27;, &#x27;title&#x27;: &#x27;Adult Ballet Tutu Cheetah Pink&#x27;, &#x27;price&#x27;: 7.89, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/51EzU6quNML._SX342_.jpg&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;0000032034&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00EXVN9PU&#x27;, &#x27;B0041EOTJO&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B001GTKPDQ&#x27;, &#x27;B00EON0SJ2&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002XZMGGQ&#x27;], &#x27;also_viewed&#x27;: [&#x27;B00D0F450I&#x27;, &#x27;0000032050&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;0000032042&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B0071KR2LC&#x27;, &#x27;B00GOR07RE&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B0079MCIMU&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00H3RYN3I&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B007IEFT84&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B007R2RM8W&#x27;, &#x27;B007VM3AMK&#x27;, &#x27;B00C0PLENA&#x27;, &#x27;B00BJGG6VG&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00IIK61WA&#x27;, &#x27;B009UC638W&#x27;, &#x27;B00KZN6RVI&#x27;, &#x27;B00CSFEENY&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00HSOJJ94&#x27;, &#x27;B00LIPP4VG&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B00E87F196&#x27;, &#x27;B005HMHOQY&#x27;, &#x27;B00J6S9MSS&#x27;, &#x27;0000032034&#x27;, &#x27;B00CJQGNJK&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B0056LG7GY&#x27;, &#x27;B00DPQWCZ2&#x27;, &#x27;B00I3PV0US&#x27;, &#x27;B00KZN6IVW&#x27;, &#x27;B0054TBWKO&#x27;, &#x27;B00I2S01I8&#x27;, &#x27;B00BXF12P8&#x27;, &#x27;B00GVHU678&#x27;, &#x27;B005NWENGC&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B00JK8MQ4Q&#x27;, &#x27;B00FZIMVQS&#x27;, &#x27;B008BB19VE&#x27;, &#x27;B00GTEXPOE&#x27;, &#x27;B009WPT2RQ&#x27;, &#x27;B00E37SBBG&#x27;], &#x27;bought_together&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;]&#125;, &#x27;brand&#x27;: &#x27;BubuBibi&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]&#125;[[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]第2行:&#123;&#x27;asin&#x27;: &#x27;0000031909&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;0000031895&#x27;, &#x27;B00D2K1M3O&#x27;, &#x27;0000031852&#x27;, &#x27;B00D0WDS9A&#x27;, &#x27;B00D10CLVW&#x27;, &#x27;B00D103F8U&#x27;, &#x27;B003AVEU6G&#x27;, &#x27;B00D2K0PA0&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00D0ZF44Y&#x27;, &#x27;B008F0SMUC&#x27;, &#x27;B00D0GCI8S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B002YSCPZY&#x27;, &#x27;0448408775&#x27;, &#x27;B002R0FABA&#x27;, &#x27;B008GHWNWC&#x27;, &#x27;B002R0FA24&#x27;, &#x27;B001GTKPEK&#x27;, &#x27;B006XA7KZO&#x27;, &#x27;B001GZUQ9S&#x27;, &#x27;B00613VNL0&#x27;, &#x27;B003IEDM9Q&#x27;, &#x27;B003LTOZK8&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B008UBQZKU&#x27;, &#x27;B001AQD8VQ&#x27;, &#x27;B003ILA0L2&#x27;, &#x27;B00AFDOPDA&#x27;, &#x27;B002R0F7FE&#x27;], &#x27;also_viewed&#x27;: [&#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00AFDOPDA&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00CEUWY8K&#x27;, &#x27;B003IEDM9Q&#x27;, &#x27;B00HSOJB9M&#x27;, &#x27;0000031895&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B008F0SMUC&#x27;, &#x27;B00362QGW0&#x27;, &#x27;B008UD01L2&#x27;, &#x27;B00FAZ5ZE6&#x27;, &#x27;B008F0SY6O&#x27;, &#x27;B00DPLLQR2&#x27;, &#x27;B00CEUWUZC&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B00CEUX0D8&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D10CLVW&#x27;, &#x27;B00D23MC6W&#x27;, &#x27;B007XAI53E&#x27;, &#x27;B008X6CBS2&#x27;, &#x27;B004PEI45U&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002C3Y6WG&#x27;, &#x27;B00HSC8O74&#x27;, &#x27;B008BMGHM4&#x27;, &#x27;B00CEUWTFS&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B00CYBU84G&#x27;, &#x27;B00D9C32NI&#x27;, &#x27;B0046W9T8C&#x27;, &#x27;B008UBG5IW&#x27;, &#x27;B001YHX45G&#x27;, &#x27;B00CEV8366&#x27;, &#x27;B00I2UHSZA&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B001GTKPEK&#x27;, &#x27;B004TU1VPU&#x27;, &#x27;B00CBPIO7S&#x27;, &#x27;B00CHHXJ0M&#x27;, &#x27;B00538F5OK&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B00CEUX4QQ&#x27;, &#x27;B003XRKA7A&#x27;, &#x27;0000031852&#x27;, &#x27;B002C3R5XI&#x27;, &#x27;B00C6Q1Z6E&#x27;], &#x27;bought_together&#x27;: [&#x27;B002BZX8Z6&#x27;]&#125;, &#x27;title&#x27;: &#x27;Girls Ballet Tutu Neon Pink&#x27;, &#x27;price&#x27;: 7.0, &#x27;salesRank&#x27;: &#123;&#x27;Toys &amp; Games&#x27;: 201847&#125;, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/41xBoP0FVzL._SY300_.jpg&#x27;, &#x27;brand&#x27;: &#x27;Unknown&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;]], &#x27;description&#x27;: &#x27;High quality 3 layer ballet tutu. 12 inches in length&#x27;&#125;[[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;]] 打印了json中categories对象的值： [[‘Sports &amp; Outdoors’, ‘Other Sports’, ‘Dance’, ‘Clothing’, ‘Girls’, ‘Skirts’]], [[‘Sports &amp; Outdoors’, ‘Other Sports’, ‘Dance’]], [[‘Sports &amp; Outdoors’, ‘Other Sports’, ‘Dance’, ‘Clothing’, ‘Girls’, ‘Skirts’]] 2. 常见错误及解决办法 Expecting property name enclosed in double quotes: line 1 column 2 (char 1) Json文件的单双引号不对，如下所示Python中的一个str，Json中的Key值都是用单引号&#39;括起来的，就会报错Expecting property name enclosed in double quotes： 1&quot;&#123;&#x27;asin&#x27;: &#x27;0000032069&#x27;, &#x27;title&#x27;: &#x27;Adult Ballet Tutu Cheetah Pink&#x27;, &#x27;price&#x27;: 7.89, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/51EzU6quNML._SX342_.jpg&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;0000032034&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00EXVN9PU&#x27;, &#x27;B0041EOTJO&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B001GTKPDQ&#x27;, &#x27;B00EON0SJ2&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002XZMGGQ&#x27;], &#x27;also_viewed&#x27;: [&#x27;B00D0F450I&#x27;, &#x27;0000032050&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;0000032042&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B0071KR2LC&#x27;, &#x27;B00GOR07RE&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B0079MCIMU&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00H3RYN3I&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B007IEFT84&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B007R2RM8W&#x27;, &#x27;B007VM3AMK&#x27;, &#x27;B00C0PLENA&#x27;, &#x27;B00BJGG6VG&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00IIK61WA&#x27;, &#x27;B009UC638W&#x27;, &#x27;B00KZN6RVI&#x27;, &#x27;B00CSFEENY&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00HSOJJ94&#x27;, &#x27;B00LIPP4VG&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B00E87F196&#x27;, &#x27;B005HMHOQY&#x27;, &#x27;B00J6S9MSS&#x27;, &#x27;0000032034&#x27;, &#x27;B00CJQGNJK&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B0056LG7GY&#x27;, &#x27;B00DPQWCZ2&#x27;, &#x27;B00I3PV0US&#x27;, &#x27;B00KZN6IVW&#x27;, &#x27;B0054TBWKO&#x27;, &#x27;B00I2S01I8&#x27;, &#x27;B00BXF12P8&#x27;, &#x27;B00GVHU678&#x27;, &#x27;B005NWENGC&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B00JK8MQ4Q&#x27;, &#x27;B00FZIMVQS&#x27;, &#x27;B008BB19VE&#x27;, &#x27;B00GTEXPOE&#x27;, &#x27;B009WPT2RQ&#x27;, &#x27;B00E37SBBG&#x27;], &#x27;bought_together&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;]&#125;, &#x27;brand&#x27;: &#x27;BubuBibi&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]&#125;&quot; 替换掉str中的&#39;为&quot;，替换/_（空格）为/: 1text.replace(&quot;&#x27;&quot;, &#x27;&quot;&#x27;).replace(&#x27;/ &#x27;, &#x27;/&#x27;) 再接着读取就不会报错了！！！ 1JsonValue[&#x27;categories&#x27;] 结果： 1[[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]] expecting , delimiter 这个问题真的被搞得头疼，到目前还没解决，Json字段是没有问题的，但是loads()函数就是会报错 解决办法","categories":["Code","Python"]},{"title":"python 开启http服务","path":"/Code/Python/python开启http服务/","content":"概述：使用python开启http服务 [toc] python 开启 http 服务在需要开启http服务的文件件运行一下命令即可： 123python -m SimpleHTTPServer 8080# 或者python -m http.server 8080","tags":["python","http"],"categories":["Code","Python"]},{"title":"Python 界面实现 Gui 界面自动输入","path":"/Code/Python/gui界面自动输入/","content":"开发过程中使用后台时，每次都需要输入用户名和密码，很麻烦，尝试解决这个麻烦的过程中使用了 pyautogui 这个库，整理记录一下，实际登录web网站时，自动输入还有别的方法，可以使用油猴脚本实现，详见文末使用油猴自动登录网站。 [toc] 使用 python 实现 Gui 自动登录需求界面主动输入 admin 后跳转到密码栏再自动输入 Admin@2022 思路主要是使用 pyautogui 库， pyautogui封装了界面的相关操作，包括鼠标和键盘事件。 源码 pyautogui.typewrite 可以模拟输入字符的输入 pyautogui.press 可以模拟其他操作类型的键的输入 基于以上两点，我们只需要构建一个输入的队列，然后遍历队列执行响应的操作即可 构建输入队列队列的键值的键值如下所示，先输入需要录入的单词，紧接着执行对应的操作即可： 1234567891011# &#123;pyautogui.typewrite， pyautogui.press&#125;tac = &#123; &#x27;admin&#x27;:&#x27;tab&#x27;, &#x27;Admin@2022&#x27;:&#x27;enter&#x27;&#125;wiki = &#123; &#x27;admin&#x27;:&#x27;tab&#x27;, &#x27;Admin@2022&#x27;:&#x27;enter&#x27;&#125; 遍历输入队列1234for key in tac: print(key, &quot;:&quot;, tac[key]) pyautogui.typewrite(key, interval=interval) pyautogui.press(tac[key], interval=interval) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;&quot;&quot;python -m PyInstaller -F -w -n auto_input ./auto_input.py&quot;&quot;&quot;import pathlibimport pyautogui# 控制速度interval = 0.05tac = &#123; &#x27;admin&#x27;:&#x27;tab&#x27;, &#x27;Admin@2022&#x27;:&#x27;enter&#x27;&#125;wiki = &#123; &#x27;admin&#x27;:&#x27;tab&#x27;, &#x27;Admin@2022&#x27;:&#x27;enter&#x27;&#125;text_alert = &quot;&quot;&quot;开始前请确保完成以下操作 1. 请切换为英文输入法 2. 请打开输入界面 3. 将光标放至开始输入的位置 4. 选择要输入的代码&quot;&quot;&quot;def main(): global codes option = pyautogui.confirm(text=text_alert, title=&#x27;自动输入小工具&#x27;, buttons=[&#x27;tac&#x27;,&#x27;wiki&#x27;]) if option == &#x27;tac&#x27;: for key in tac: print(key, &quot;:&quot;, tac[key]) pyautogui.typewrite(key, interval=interval) pyautogui.press(tac[key], interval=interval) elif option == &#x27;wiki&#x27;: for key in tac: print(key, &quot;:&quot;, wiki[key]) pyautogui.typewrite(key, interval=interval) pyautogui.press(wiki[key], interval=interval)if __name__ == &#x27;__main__&#x27;: main() web网站使用油猴脚本实现自动登录123456789101112131415161718192021222324252627282930313233343536373839// ==UserScript==// @name 零信任TAC一键登录// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author BladeHiker// @match https://*/admin/*// @match https://*/tap/admin/*// @icon https://www.google.com/s2/favicons?sz=64&amp;domain=57.171// @grant none// ==/UserScript==(function() &#123; &#x27;use strict&#x27;; window.onload = () =&gt; &#123; setInterval(()=&gt;&#123; if(window.location.pathname==&#x27;/admin/login&#x27;)&#123; setTimeout(()=&gt;&#123; document.getElementsByName(&quot;username&quot;)[0].value = &#x27;admin&#x27;; document.getElementsByName(&quot;password&quot;)[0].value = &#x27;Admin@2022&#x27;; document.getElementsByName(&quot;username&quot;)[0].dispatchEvent(new InputEvent(&quot;input&quot;)) document.getElementsByName(&quot;password&quot;)[0].dispatchEvent(new InputEvent(&quot;input&quot;)) document.getElementsByTagName(&quot;button&quot;)[0].click() &#125;,200) &#125; else if(window.location.pathname==&#x27;/tap/admin/dist/login&#x27;)&#123; setTimeout(()=&gt;&#123; document.getElementsByName(&quot;username&quot;)[0].value = &#x27;admin&#x27;; document.getElementsByName(&quot;password&quot;)[0].value = &#x27;admin@1234&#x27;; document.getElementsByName(&quot;username&quot;)[0].dispatchEvent(new InputEvent(&quot;input&quot;)) document.getElementsByName(&quot;password&quot;)[0].dispatchEvent(new InputEvent(&quot;input&quot;)) document.getElementsByTagName(&quot;button&quot;)[0].click() &#125;,200) &#125;&#125;,1000) &#125; // Your code here...&#125;)();","tags":["Python"],"categories":["Code","Python"]},{"title":"【管道】（一） 初识管道","path":"/Code/IPC/初识管道/","content":"[toc] 自己的理解， 首先要区分概念：管道和管道通信 所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件 （是一种特殊的文件，这就意味着你可以向操作文件一样操作无名管道，无名管道在内核中对应的是一段特殊的内存空间，这段内存空间由操作系统进行管理，对用户是不可见的，在用户空间的应用程序中只能通过系统调用来访问它。在这段内存空间中以循环队列的方式来临时存储一个进程发往另外一个进程的信息，并且在通信完成后就会自动释放相应的空间。） 而管道通信是消息传递的一种特殊方式。 即管道是文件，是服务于管道通信的特殊文件，而管道通信是一种通信方式，这种通信方式比较特殊，是半双工的通信方式，即数据只能单向流动，数据传递的方式是字符流形式，它一般是应用在具有共同祖先的进程间使用。 管道通信是什么？ 用于进程之间通信的一种通信方式。 管道通信有哪些特点？ 半双工的通信方式，数据只能单向流动，数据传递的方式是字符流形式。 管道通信的应用场合？ 具有共同祖先的进程间使用。 1、什么是管道管道：—就像现实中的水管，水就像数据。（连接进程，相当于在进程间连接一个通路，用来传递信息）—管道是一种半双工的通信方式—数据只能单向流动，而且只能在具有共同祖先的进程间使用。 所谓半双工的模式 （假设通信双方是甲方和乙方，双工通信方式的意思是甲可以向乙发送数据，乙也可以向甲发送数据，即数据流通是双向的。而半双工的通信方式是指甲乙两方不能同时向对方发送数据，也就是甲向乙发送数据时，乙只能接收不能发送，而乙向甲发送数据时，甲只能接收不能向乙发送数据） 举个例子：形象来说类似一个单刀双掷开关，有两个选择，但是二者是互斥的，当选择了一方另一方就失效。而对于此处的管道，可以把它想成是管道的一端，一次只能调用一种功能读入或者写入，二者也是互斥的。 管道通信是消息传递的一种特殊方式，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。 2、为什么要有管道在一个多进程操作系统所提供的运行环境下，可以通过两种不同的途径或者说采用两种不同的策略，来建立起复杂的大型应用系统。一种途径就是通过一个孤立的,大型的，复杂的进程提供所需的全部服务，另外一种途径就是通过由若干相互联系的，小型的。相对简单的进程构成的组合来提供所需的功能。早期的操作系统往往倾向与前者，而Unix以及其衍生的各种操作系统往往倾向于后者。相比之下，后者有着各种好处：1.模块化，2.各个进程都得到保护，在相当程度上排除了相互干扰的可能性，3.灵活性更强。当然这种好处也是要付出代价的，也有缺点，但是相比之下，这种途径的优点远远超出了其缺点。Unix（从而Linux）向应用软件提供了一些进程间通信的手段，早期的Unix提供了：管道（pipe），信（signal），跟踪（trace）。 进程之间的通信，从物理上分，可以分为同主机的进程之间的通信和不同主机间的进程之间的通信。从通信内容方式上分，可以分为数据交互、同步通信、异步通信。 Linux 教程 系统进程之间的通信方式大致如下图所示 集合上述两种从物理和内容方式的划分，可以这样理解上图： （1）同主机进程间数据交互机制：无名管道（PIPE）、有名管道（FIFO）、消息队列（Message Queue）和共享内存（Shared Memory）。 （2）同主机进程间同步通信机制：信号量（Semaphore）。 （3）同主机进程间异步通信机制：信号（Signal）。 （4）不同主机间进程数据交互机制：套接字（Socket）、远程调用RPC（Remote Procedure Call）。 管道通信 管道又可以分为无名管道和命名管道，两者的用途是不一样的。 无名管道PIPE：主要用于具有亲缘关系的进程之间的通信，无名管道的通信是单向的，只能由一段到另外一段；无名管道是临时性的，完成通信后将自动消失。一般采用先创建无名管道，再创建子进程，使子进程继承父进程的管道文件描述符，从而实现父子进程间的通信；在非亲缘关系管道之间，如果想利用无名管道进行通信，则需要借助另外的文件描述符传递机制。 有名管道FIFO：有名管道是一个实际存在的特殊文件，利用有名管道可以实现同主机任意进程之间的数据交互。 无名管道是一种特殊的文件，这就意味着你可以向操作文件一样操作无名管道，无名管道在内核中对应的是一段特殊的内存空间，这段内存空间由操作系统进行管理，对用户是不可见的，在用户空间的应用程序中只能通过系统调用来访问它。在这段内存空间中以循环队列的方式来临时存储一个进程发往另外一个进程的信息，并且在通信完成后就会自动释放相应的空间。 即无名管道主要用于具有亲缘关系的父子进程之间的通信，是临时性的，需要先创建管道，再创建子进程；管道都是单向的，若要实现双向通信，则需要两个管道。命名管道是实际存在的文件，使用前需要先打开，管道默认的read和write操作都是阻塞式的。 3、如何建立进程间管道？这里我们只谈管道：父进程与子进程，或者两个兄弟进程之间，可以通过系统调用建立起一个单向的通信管道。但是，这种管道只能由父进程来建立，所以对于子进程来说是静态的，与生俱来的。管道两端的进程各自将该管道视作一个文件。一个进程往通道中写的内容由另一个进程从通道读出，通过通道传递的内容遵循“先入先出”（FIFO）的规则。每个通道都是单向的，需要双向通信时要建立起两个通道。 下面说一说进程间管道的建立，在这之前我们要说到fork()函数，在Linux系统中一个新的进程是由一个已经存在的进程“复制”出来的，而不是“创造”出来的（而所谓的“创建”实际上就是复制）。管道机制的主体是系统调用pipe()，但是由pipe（）所建立的管道的两端都在同一个进程中，这样的管道起不到进程间通信的作用。所以必须在fork（）的配合下，才能在父子进程间或者两个子进程之间建立起进程间的通信管道。 下面就介绍一下怎样将管道用于进程间通信：（1）进程A创建了一个管道，创建完成时代表管道两端的两个已打开文件都在进程A中。 (2)进程A通过frok（）创建出进程B，在fork（）的过程中进程A的打开文件表按原样复制到进程B中。 (3)进程A关闭管道的读端，而进程B关闭管道的写段。于是，管道的写段在进程A中而读端在进程B中，成为了父子进程之间的通信管道。 (4)进程A又通过frok（）创建进程C，而后关闭其管道写段而与管道脱离关系，使得管道的写段在进程C中而读端在进程B中，成为两个兄弟进程之间的管道。 人们在认识到管道机制也存在一些缺点和不足。由于管道是一种“无名”，“无形”的文件，它可以通过fork（）的过程创建于“近亲” 的进程之间，而不能成为可以在任意两个进程之间建立通信的机制，更不可能成为一种一般的，通用的进程间通信模型，同时，管道机制的这种缺点本身强烈的暗示着人们，只要用“有名”，“有形”的文件来实现管道，就能克服这种缺点。所以有了管道之后，“命名管道”的出现时必然的。为了实现“命名管道”，在“普通文件”，“块设备文件”，“字符设备文件”之外，又设立了一种文件类型，称为FIFO文件。对这种文件的访问严格遵循“先进先出”的原则。这样就可以像在磁盘上建立一个文件一样建立一个命名管道，具体可以使用命令mknod来建立。 函数介绍：¢int read(intfd, void *buf, int count);—功能：从参数fd指定的读端读取管道数据到大小为count的缓存buf中，返回实际读取到的字节数。—参数¢fd:管道读端¢buf:缓存区，保存读到的数据¢count:读取字节数 •intwrite(intfd, void *buf, intcount);•功能：向参数fd指定的写端从缓存buf中取出count个字节到管道中，返回值为实际写入的字节数。 •参数•fd:管道写端•buf:缓存区，将要写入管道的数据•count:写入的字节数 参考来源： http://blog.csdn.net/followingturing/article/details/6071937 ​ http://c.biancheng.net/cpp/html/2592.html ​ http://www.2cto.com/os/201410/343247.html","tags":["《深入理解Windows操作系统》","IPC","Pipe"],"categories":["Code","IPC"]},{"title":"文件大小换算方法","path":"/Code/LeetCode/ConvertFileSize/","content":"文件大小转换方法1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string convertSize(double size)&#123; string strSize[6] = &#123; &quot;B&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;, &quot;PB&quot; &#125;; unsigned int flag = 1024; for (int i = 0; i &lt; _countof(strSize); i++) &#123; if ((size / flag) &lt; 1) &#123; char strTemp[1024]; string strRet; sprintf_s(strTemp, &quot;%.2f&quot;, size); return strRet.append(strTemp).append(strSize[i]); &#125; else &#123; size = size / flag; &#125; &#125; return &quot;&quot;;&#125;int main()&#123; std::cout &lt;&lt; &quot;Hello World! &quot;; double FlieSize_1 = 224945; double FlieSize_2 = 2249450; double FlieSize_3 = 2249450000; cout &lt;&lt; &quot;FlieSize_1：&quot; &lt;&lt; convertSize(FlieSize_1) &lt;&lt; endl; cout &lt;&lt; &quot;FlieSize_2：&quot; &lt;&lt; convertSize(FlieSize_2) &lt;&lt; endl; cout &lt;&lt; &quot;FlieSize_3：&quot; &lt;&lt; convertSize(FlieSize_3) &lt;&lt; endl;\t&#125;","tags":["C++","Demo"],"categories":["Code","LeetCode"]},{"title":"【管道】（二） 管道通信","path":"/Code/IPC/使用管道通信/","content":"本文所讲管道通信主要是进程间管道通信。 [toc] 管道 命名管道的通信是在一个命名管道服务器和一个命名管道客户之间进行的。命名管道服务器是指创建爱你命名管道的应用程序，客户可以连接到它所创建的命名管道上。命名管道的 名称的格式 是 \\\\Server\\pipe\\PipeName。 名称中的Server部分指定了此命名管道服务器当前执行所在的计算机（需要注意的是：命名管道服务器不能创建远程系统上的命名管道）。但是这个名称可以是一个DNS名称（比如，mspress.microsoft.com）、一个NetBIOS名称（mspress）或者一个IP地址（131.107.0.1）。 名称中的 Pipe 部分必须是字符串 Pipe。而 PipeName 则是分配给此命名管道的唯一名。命名管道名称中的唯一名部分可以包含子目录。如：\\\\MyComputer\\Pipe\\MyServerApp\\ConnectionPipe 是一个包含子目录的命名管道名称的例子。 综上，我们在一个示例程序中创建的管道可以命名为 \\\\.\\pipe\\DemoApp\\test.pip （使用转义也就是\\\\\\\\.\\\\pipe\\\\DemoApp\\\\test_pip），这里的 \\ 代表的是本地计算机。 而以上的管道名，也就是我们后续调用API的参数之一，也是我们唯一可以标识管道的标志。 创建管道的方式一 CreateNamedPipe原型12345678910HANDLE CreateNamedPipeA( [in] LPCSTR lpName, [in] DWORD dwOpenMode, [in] DWORD dwPipeMode, [in] DWORD nMaxInstances, [in] DWORD nOutBufferSize, [in] DWORD nInBufferSize, [in] DWORD nDefaultTimeOut, [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes); 参数说明 lpName要创建的管道名。 dwOpenMode dwPipeMod nMaxInstances nOutBufferSize nInBufferSize nDefaultTimeOut lpSecurityAttributes 用法创建管道的方式二 CreateFile原型1 参数说明用法Demo1——管道客户端和服务端的控制台程序Demo2——管道类知识来源： 《深入解析Windows操作系统》 Qt笔记-Windows管道通信_IT1995的博客-CSDN博客_qt管道通信 多进程通信之管道demo_Sunbigwang的博客-CSDN博客_多进程管道","tags":["《深入理解Windows操作系统》","IPC","Pipe"],"categories":["Code","IPC"]},{"title":"Go面向对象编程1——面向对象编程","path":"/Code/GO/Go简明手册/面向对象编程/面向对象编程/README/","content":"Go 语言的代码是以包结构来组织的，且如果标示符（变量名，函数名，自定义类型等）如果以大写字母开头那么这些标示符是可以导出的，可以在任何导入了定义该标示符的包的包中直接使用。Go 语言中的面向对象和 C++，Java 中的面向对象不同，因为 Go 语言不支持继承，Go 语言只支持组合。 自定义类型Go 语言的中结构体 struct 与 C++、JAVA 中的类 class 相似，但 Go 放弃了传统面向对象的诸多特性，只保留了组合。 type typeName typeSpecification 其中，typeName 可以是一个包或者函数内唯一合法的 Go 标示符。typeSpecification 可以是任何内置的类型，一个接口或者是一个结构体。所谓结构体，它的字段是由其他类型或者接口组成。例如我们通过结构体定义了一下类型： 1234type ColorPoint struct &#123; color.Color // 匿名字段(嵌入) x, y int // 具名字段(聚合)&#125; 以上代码我们通过结构体自定义了类型 ColorPoint，结构体中 color.Color 字段是 Color 包的类型 color，这个字段没有名字，所以被称为匿名的，也是嵌入字段。字段 x 和 y 是有变量名的，所以被称为具名字段。假如我们创建了类型 ColorPoint 的一个值 point（通过语法：point := ColorPoint&#123;&#125; 创建），那么这些字段可以通过 point.Color、point.x、point.y 访问。其他面向对象语言中的”类 (class)”、”对象 (object)”、”实例 (instance)”在 Go 语言中我们完全避开使用。相反的我们使用”类型 (type)”和其对应的”值”，其中自定义类型的值可以包含方法。 定义了结构体后如何创建并初始化一个对象实例呢？Go 语言支持以下几种方法进行实现： 12345678910//先定义一个结构体Mantype Man struct&#123; name string age int&#125;//对象创建与初始化man := new(Man)man := &amp;Man&#123;&#125;man := &amp;Man&#123;&quot;Tom&quot;, 18&#125;man := &amp;Man&#123;name: &quot;Tom&quot;, age: 18&#125; 为了更加方便的创建对象，我们一般会使用一个全局函数来完成对象的创建，这和传统的“构造函数”类似。 123func NewMan(name string, age int) *Man &#123; return &amp;Man&#123;name, age&#125;&#125;","tags":["Go简明手册"],"categories":["Code","GO","Go简明手册","面向对象编程","面向对象编程"]},{"title":"Go面向对象编程3——组合","path":"/Code/GO/Go简明手册/面向对象编程/组合/README/","content":"Go 语言虽然抛弃了继承，但是却提供了一个更加方便的组合特性。相对于继承的编译期确定实现，组合的运行态指定实现，更加灵活。下面通过一段代码来了解组合的基本属性以及它与继承的不同之处。 先定义一个结构体 Base, 并为它添加两个方法 Foo() 和 Bar()： 1234567891011121314151617type Base struct&#123; Name string&#125;func (b *Base) Foo() &#123;...&#125;func (b *Base) Bar() &#123;...&#125;type Seed struct &#123; Base ...&#125;func (s *Seed) Foo() &#123; s.Base.Foo() s.Bar() ...&#125; 上面代码先定义了一个 Base 类，然后定义了一个 Seed 类。Seed 类“继承”了 Base 类的所有成员属性和方法并重写了 Foo() 方法。同时在重写 Foo() 方法时调用了 Base 类的 Foo() 方法和 Bar() 方法。需要注意的是，若此时 Seed 的对象通过 s.Foo() 调用 Foo() 方法时，实际调用的是 Seed 重写过后的 Foo() 方法，而不是基类 Base 的 Foo() 方法，若想调用 Base 类的 Foo() 方法则要使用 s.Base.Foo，而调用没有重写的 Bar() 方法时，使用 s.Bar() 和s.Base.Bar() 效果是一样的。","categories":["Code","GO","Go简明手册","面向对象编程","组合"]},{"title":"Go面向对象编程2——方法","path":"/Code/GO/Go简明手册/面向对象编程/方法/README/","content":"Demo 方法 方法是作用在自定义类型上的一类特殊函数，通常自定义类型的值会被传递给该函数，该值可能是以指针或者复制值的形式传递。定义方法和定义函数几乎相同，只是需要在 func 关键字和方法名之间必须写上接接受者。例如我们给类型 Count 定义了以下方法： 12345type Count intfunc (count *Count) Increment() &#123; *count++ &#125; // 接受者是一个 `Count` 类型的指针func (count *Count) Decrement() &#123; *count-- &#125;func (count Count) IsZero() bool &#123; return count == 0 &#125; 以上代码中，我们在内置类型 int 的基础上定义了自定义类型 Count，然后给该类型添加了 Increment()、Decrement() 和 IsZero() 方法，其中前两者的接受者为 Count 类型的指针，后一个方法接收 Count 类型的值。 Demo: 类型的方法集是指可以被该类型的值调用的所有方法的集合。 一个指向自定义类型的值的指针，它的方法集由该类型定义的所有方法组成，无论这些方法接受的是一个值还是一个指针。如果在指针上调用一个接受值的方法，Go 语言会聪明地将该指针解引用。 一个自定义类型值的方法集合则由该类型定义的接收者为值类型的方法组成，但是不包括那些接收者类型为指针的方法。 其实这些限制 Go 语言帮我们解决的非常好，结果就是我们可以在值类型上调用接收者为指针的方法。假如我们只有一个值，仍然可以调用一个接收者为指针类型的方法，这是因为 Go 语言会自动获取值的地址传递给该方法，前提是该值是可寻址的。 在以上定义的类型 Count 中，*Count 方法集是 Increment(), Decrement() 和 IsZero()，Count 的值的方法集是 IsZero()。但是因为 Count 类型的是可寻址的，所以我们可以使用 Count 的值调用全部的方法。 另外如果结构体的字段也有方法，我们也可以直接通过结构体访问字段中的方法。下面让我们练习下，创建源文件 struct_t.go，输入以下代码： 123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;type Count int // 创建自定义类型 Countfunc (count *Count) Increment() &#123; *count++ &#125; // Count类型的方法func (count *Count) Decrement() &#123; *count-- &#125;func (count Count) IsZero() bool &#123; return count == 0 &#125;type Part struct &#123; // 基于结构体创建自定义类型 Part stat string Count // 匿名字段&#125;func (part Part) IsZero() bool &#123; // 覆盖了匿名字段Count的IsZero()方法 return part.Count.IsZero() &amp;&amp; part.stat == &quot;&quot; // 调用了匿名字段的方法&#125;func (part Part) String() string &#123; // 定义String()方法，自定义了格式化指令%v的输出 return fmt.Sprintf(&quot;&lt;&lt;%s, %d&gt;&gt;&quot;, part.stat, part.Count)&#125;func main() &#123; var i Count = -1 fmt.Printf(&quot;Start \\&quot;Count\\&quot; test: Origin value of count: %d &quot;, i) i.Increment() fmt.Printf(&quot;Value of count after increment: %d &quot;, i) fmt.Printf(&quot;Count is zero t/f? : %t &quot;, i.IsZero()) fmt.Println(&quot;Start: \\&quot;Part\\&quot; test:&quot;) part := Part&#123;&quot;232&quot;, 0&#125; fmt.Printf(&quot;Part: %v &quot;, part) fmt.Printf(&quot;Part is zero t/f? : %t &quot;, part.IsZero()) fmt.Printf(&quot;Count in Part is zero t/f?: %t &quot;, part.Count.IsZero()) // 尽管覆盖了匿名字段的方法，但还是可以访问&#125; 以上代码中，我们创建了 Count 类型，然后在其基础上又创建了结构体类型 Part。我们为 Count 类型定义了 3 个方法，并在 Part 类型中创建了方法 IsZero() 覆盖了其匿名字段 Count 中 IsZero() 方法。但是我们还是可以二次访问到匿名字段中被覆盖的方法。执行代码，输出如下： 123456789101112$ go run struct_t.goStart &quot;Count&quot; test:Origin value of count: -1Value of count after increment: 0Count is zero t/f? : trueStart: &quot;Part&quot; test:Part: &lt;&lt;232, 0&gt;&gt;Part is zero t/f? : falseCount in Part is zero t/f?: true","categories":["Code","GO","Go简明手册","面向对象编程","方法"]},{"title":"Go面向对象编程5——接口变量值的类型","path":"/Code/GO/Go简明手册/面向对象编程/接口变量值的类型/README/","content":"Demo 接口在 Go 中，接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。它与 oop 非常相似。接口指定类型应具有的方法，类型决定如何实现这些方法。 接口基础之所以说 Go 语言的面向对象很灵活，很大一部分原因是由于接口的存在。接口是一个自定义类型，它声明了一个或者多个方法签名，任何实现了这些方法的类型都实现这个接口。infterface&#123;&#125; 类型是声明了空方法集的接口类型。任何一个值都满足 interface&#123;&#125; 类型，也就是说如果一个函数或者方法接收 interface&#123;&#125; 类型的参数，那么任意类型的参数都可以传递给该函数。接口是完全抽象的，不能实例化。接口能存储任何实现了该接口的类型。直接看例子吧，创建源文件 interface_t.go，输入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport &quot;fmt&quot;type Human struct &#123; // 结构体 name string age int phone string&#125;//Human实现SayHi方法func (h Human) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s you can call me on %s &quot;, h.name, h.phone)&#125;//Human实现Sing方法func (h Human) Sing(lyrics string) &#123; fmt.Println(&quot;La la la la...&quot;, lyrics)&#125;type Student struct &#123; Human //匿名字段 school string loan float32&#125;type Employee struct &#123; Human //匿名字段 company string money float32&#125;// Employee重载Human的SayHi方法func (e Employee) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s &quot;, e.name, e.company, e.phone)&#125;// Interface Men被Human,Student和Employee实现// 因为这三个类型都实现了这两个方法type Men interface &#123; SayHi() Sing(lyrics string)&#125;func main() &#123; mike := Student&#123;Human&#123;&quot;Mike&quot;, 25, &quot;222-222-XXX&quot;&#125;, &quot;MIT&quot;, 0.00&#125; paul := Student&#123;Human&#123;&quot;Paul&quot;, 26, &quot;111-222-XXX&quot;&#125;, &quot;Harvard&quot;, 100&#125; sam := Employee&#123;Human&#123;&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;&#125;, &quot;Golang Inc.&quot;, 1000&#125; Tom := Employee&#123;Human&#123;&quot;Tom&quot;, 37, &quot;222-444-XXX&quot;&#125;, &quot;Things Ltd.&quot;, 5000&#125; //定义Men类型的变量i var i Men //i能存储Student i = mike fmt.Println(&quot;This is Mike, a Student:&quot;) i.SayHi() i.Sing(&quot;November rain&quot;) //i也能存储Employee i = Tom fmt.Println(&quot;This is Tom, an Employee:&quot;) i.SayHi() i.Sing(&quot;Born to be wild&quot;) //定义了slice Men fmt.Println(&quot;Let&#x27;s use a slice of Men and see what happens&quot;) x := make([]Men, 3) //这三个都是不同类型的元素，但是他们实现了interface同一个接口 x[0], x[1], x[2] = paul, sam, mike for _, value := range x &#123; value.SayHi() &#125;&#125; 接口变量值的类型* 接口类型声明的变量里能存储任何实现了该接口的类型的值。 有的时候我们需要知道这个变量里的值的类型，那么需要怎么做呢？可以使用类型断言，或者是 switch 类型判断分支。以下的例子 interface_t1.go 我们使用了 switch 类型判断分支。 123456789101112131415161718192021222324252627282930313233343536373839404142/*使用了switch 类型判断分支*/package mainimport (\t&quot;fmt&quot;\t&quot;strconv&quot;)type Element interface&#123;&#125;type List []Elementtype Person struct &#123;\tname string\tage int&#125;// 实现了fmt.Stringer接口func (p Person) String() string &#123;\treturn &quot;(name: &quot; + p.name + &quot;- age: &quot; + strconv.Itoa(p.age) + &quot; years)&quot;&#125;func main() &#123;\tlist := make(List, 4)\tlist[0] = 1\tlist[1] = &quot;Hello&quot;\tlist[2] = Person&#123;&quot;Dennis&quot;, 70&#125;\tlist[3] = 1 + 2i\tfor index, element := range list &#123; switch value := element.(type) &#123; case int: fmt.Printf(&quot;list[%d] is an int and its value is %d &quot;, index, value) case string: fmt.Printf(&quot;list[%d] is an int and its value is %s &quot;, index, value) case Person: fmt.Printf(&quot;list[%d] is an int and its value is %s &quot;, index, value) default: fmt.Printf(&quot;list[%d] is of a different type&quot;, index) &#125;\t&#125;&#125; 嵌入interface结构体中可以嵌入匿名字段，其实在接口里也可以再嵌入接口。如果一个 interface1 作为 interface2 的一个嵌入字段，那么 interface2 隐式的包含了 interface1 里的方法。如下例子中，Interface2 包含了 Interface1 的所有方法。 123456789type Interface1 interface &#123; Send() Receive()&#125;type Interface2 interface &#123; Interface1 Close()&#125;","categories":["Code","GO","Go简明手册","面向对象编程","接口变量值的类型"]},{"title":"Go面向对象编程6——嵌入 interface","path":"/Code/GO/Go简明手册/面向对象编程/嵌入interface/README/","content":"在前面的课程中我们已经知道在结构体中可以嵌入匿名字段，其实在接口里也可以再嵌入接口。如果一个 interface1 作为 interface2 的一个嵌入字段，那么 interface2 隐式的包含了 interface1 里的方法。如下例子中，Interface2 包含了 Interface1 的所有方法。 123456789type Interface1 interface &#123; Send() Receive()&#125;type Interface2 interface &#123; Interface1 Close()&#125;","categories":["Code","GO","Go简明手册","面向对象编程","嵌入interface"]},{"title":"Go面向对象编程4——接口","path":"/Code/GO/Go简明手册/面向对象编程/接口/README/","content":"Demo 接口在 Go 中，接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。它与 oop 非常相似。接口指定类型应具有的方法，类型决定如何实现这些方法。 接口基础之所以说 Go 语言的面向对象很灵活，很大一部分原因是由于接口的存在。接口是一个自定义类型，它声明了一个或者多个方法签名，任何实现了这些方法的类型都实现这个接口。infterface&#123;&#125; 类型是声明了空方法集的接口类型。任何一个值都满足 interface&#123;&#125; 类型，也就是说如果一个函数或者方法接收 interface&#123;&#125; 类型的参数，那么任意类型的参数都可以传递给该函数。接口是完全抽象的，不能实例化。接口能存储任何实现了该接口的类型。直接看例子吧，创建源文件 interface_t.go，输入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport &quot;fmt&quot;type Human struct &#123; // 结构体 name string age int phone string&#125;//Human实现SayHi方法func (h Human) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s you can call me on %s &quot;, h.name, h.phone)&#125;//Human实现Sing方法func (h Human) Sing(lyrics string) &#123; fmt.Println(&quot;La la la la...&quot;, lyrics)&#125;type Student struct &#123; Human //匿名字段 school string loan float32&#125;type Employee struct &#123; Human //匿名字段 company string money float32&#125;// Employee重载Human的SayHi方法func (e Employee) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s &quot;, e.name, e.company, e.phone)&#125;// Interface Men被Human,Student和Employee实现// 因为这三个类型都实现了这两个方法type Men interface &#123; SayHi() Sing(lyrics string)&#125;func main() &#123; mike := Student&#123;Human&#123;&quot;Mike&quot;, 25, &quot;222-222-XXX&quot;&#125;, &quot;MIT&quot;, 0.00&#125; paul := Student&#123;Human&#123;&quot;Paul&quot;, 26, &quot;111-222-XXX&quot;&#125;, &quot;Harvard&quot;, 100&#125; sam := Employee&#123;Human&#123;&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;&#125;, &quot;Golang Inc.&quot;, 1000&#125; Tom := Employee&#123;Human&#123;&quot;Tom&quot;, 37, &quot;222-444-XXX&quot;&#125;, &quot;Things Ltd.&quot;, 5000&#125; //定义Men类型的变量i var i Men //i能存储Student i = mike fmt.Println(&quot;This is Mike, a Student:&quot;) i.SayHi() i.Sing(&quot;November rain&quot;) //i也能存储Employee i = Tom fmt.Println(&quot;This is Tom, an Employee:&quot;) i.SayHi() i.Sing(&quot;Born to be wild&quot;) //定义了slice Men fmt.Println(&quot;Let&#x27;s use a slice of Men and see what happens&quot;) x := make([]Men, 3) //这三个都是不同类型的元素，但是他们实现了interface同一个接口 x[0], x[1], x[2] = paul, sam, mike for _, value := range x &#123; value.SayHi() &#125;&#125; 接口变量值的类型* 接口类型声明的变量里能存储任何实现了该接口的类型的值。 有的时候我们需要知道这个变量里的值的类型，那么需要怎么做呢？可以使用类型断言，或者是 switch 类型判断分支。以下的例子 interface_t1.go 我们使用了 switch 类型判断分支。 123456789101112131415161718192021222324252627282930313233343536373839404142/*使用了switch 类型判断分支*/package mainimport (\t&quot;fmt&quot;\t&quot;strconv&quot;)type Element interface&#123;&#125;type List []Elementtype Person struct &#123;\tname string\tage int&#125;// 实现了fmt.Stringer接口func (p Person) String() string &#123;\treturn &quot;(name: &quot; + p.name + &quot;- age: &quot; + strconv.Itoa(p.age) + &quot; years)&quot;&#125;func main() &#123;\tlist := make(List, 4)\tlist[0] = 1\tlist[1] = &quot;Hello&quot;\tlist[2] = Person&#123;&quot;Dennis&quot;, 70&#125;\tlist[3] = 1 + 2i\tfor index, element := range list &#123; switch value := element.(type) &#123; case int: fmt.Printf(&quot;list[%d] is an int and its value is %d &quot;, index, value) case string: fmt.Printf(&quot;list[%d] is an int and its value is %s &quot;, index, value) case Person: fmt.Printf(&quot;list[%d] is an int and its value is %s &quot;, index, value) default: fmt.Printf(&quot;list[%d] is of a different type&quot;, index) &#125;\t&#125;&#125; 嵌入interface结构体中可以嵌入匿名字段，其实在接口里也可以再嵌入接口。如果一个 interface1 作为 interface2 的一个嵌入字段，那么 interface2 隐式的包含了 interface1 里的方法。如下例子中，Interface2 包含了 Interface1 的所有方法。 123456789type Interface1 interface &#123; Send() Receive()&#125;type Interface2 interface &#123; Interface1 Close()&#125;","categories":["Code","GO","Go简明手册","面向对象编程","接口"]},{"title":"Go简明手册——词频统计综合案例","path":"/Code/GO/Go简明手册/词频统计综合案例/README/","content":"wordcount.go 实现词频统计的程序逻辑很简单。我们首先会创建一个映射，然后读取文件的每一行，提取单词，然后更新映射中单词所对应的数量即可。 为了演示面向对象和 goroutine 的使用，我们将基础映射类型封装成了一个统计单词频率的包。我们在基础映射类型上创建了类型 WordCound，然后为该类型了实现了关键方法 UpdateFreq() 和 WordFreqCounter()，其中前者会读取一个文件并统计该文件中的所有单词的词频，后者通过 goroutine 实现了并发统计。 其并发逻辑是：对于每一个文件，创建一个 goroutine，在这个 goroutine 内部调用 UpdateFreq() 方法统计对应文件的词频，当统计完成以后会将映射中每一对键值转化为 Pair 结构发送到 results 通道，并在发送完成时候发送一个空结构体的值到 done 通道以表示自己的任务已经完成。由于 map 映射结构不支持并发写操作，所以我们通过 result 通道来保证每次只有一个 goroutine 能更新映射。又因为当所有的 goroutine 结束以后，有可能 results 通道中还有没来得及处理的数据，所以在 WordFreqCounter() 的结尾我们又开启了一个 for 循环处理 results 通道中的剩余数据。说了这么多，我们直接写代码吧。 在 $GOPATH/src/wordcount 目录中创建文件 wordcount.go，输入以下源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package wordcountimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;os&quot; &quot;sort&quot; &quot;strings&quot; &quot;unicode&quot; &quot;unicode/utf8&quot;)type Pair struct &#123; Key string Value int&#125;// PariList实现了sort接口，可以使用sort.Sort对其排序type PairList []Pairfunc (p PairList) Swap(i, j int) &#123; p[i], p[j] = p[j], p[i] &#125;func (p PairList) Len() int &#123; return len(p) &#125;func (p PairList) Less(i, j int) bool &#123; return p[j].Value &lt; p[i].Value &#125; // 逆序// 提取单词func SplitOnNonLetters(s string) []string &#123; notALetter := func(char rune) bool &#123; return !unicode.IsLetter(char) &#125; return strings.FieldsFunc(s, notALetter)&#125;/* 基于map实现了类型WordCount, 并对期实现了Merge(), Report(), SortReport(), UpdateFreq(), WordFreqCounter() 方法*/type WordCount map[string]int// 用于合并两个WordCountfunc (source WordCount) Merge(wordcount WordCount) WordCount &#123; for k, v := range wordcount &#123; source[k] += v &#125; return source&#125;// 打印词频统计情况func (wordcount WordCount) Report() &#123; words := make([]string, 0, len(wordcount)) wordWidth, frequencyWidth := 0, 0 for word, frequency := range wordcount &#123; words = append(words, word) if width := utf8.RuneCountInString(word); width &gt; wordWidth &#123; wordWidth = width &#125; if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth &#123; frequencyWidth = width &#125; &#125; sort.Strings(words) gap := wordWidth + frequencyWidth - len(&quot;Word&quot;) - len(&quot;Frequency&quot;) fmt.Printf(&quot;Word %*s%s &quot;, gap, &quot; &quot;, &quot;Frequency&quot;) for _, word := range words &#123; fmt.Printf(&quot;%-*s %*d &quot;, wordWidth, word, frequencyWidth, wordcount[word]) &#125;&#125;// 从多到少打印词频func (wordcount WordCount) SortReport() &#123; p := make(PairList, len(wordcount)) i := 0 for k, v := range wordcount &#123; // 将wordcount map转换成PairList p[i] = Pair&#123;k, v&#125; i++ &#125; sort.Sort(p) // 因为PairList实现了排序接口，所以可以使用sort.Sort()对其排序 wordWidth, frequencyWidth := 0, 0 for _, pair := range p &#123; word, frequency := pair.Key, pair.Value if width := utf8.RuneCountInString(word); width &gt; wordWidth &#123; wordWidth = width &#125; if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth &#123; frequencyWidth = width &#125; &#125; gap := wordWidth + frequencyWidth - len(&quot;Word&quot;) - len(&quot;Frequency&quot;) fmt.Printf(&quot;Word %*s%s &quot;, gap, &quot; &quot;, &quot;Frequency&quot;) for _, pair := range p &#123; fmt.Printf(&quot;%-*s %*d &quot;, wordWidth, pair.Key, frequencyWidth, pair.Value) &#125;&#125;// 从文件中读取单词，并更新其出现的次数func (wordcount WordCount) UpdateFreq(filename string) &#123; var file *os.File var err error if file, err = os.Open(filename); err != nil &#123; log.Println(&quot;failed to open the file: &quot;, err) return &#125; defer file.Close() // 本函数退出之前时，关闭文件 reader := bufio.NewReader(file) for &#123; line, err := reader.ReadString(&#x27; &#x27;) for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) &#123; if len(word) &gt; utf8.UTFMax || utf8.RuneCountInString(word) &gt; 1 &#123; wordcount[strings.ToLower(word)] += 1 &#125; &#125; if err != nil &#123; if err != io.EOF &#123; log.Println(&quot;failed to finish reading the file: &quot;, err) &#125; break &#125; &#125;&#125;// 并发统计单词频次func (wordcount WordCount) WordFreqCounter(files []string) &#123; results := make(chan Pair, len(files)) // goroutine 将结果发送到该channel done := make(chan struct&#123;&#125;, len(files)) // 每个goroutine工作完成后，发送一个空结构体到该channel，表示工作完成 for i := 0; i &lt; len(files); &#123; // 有多少个文件就开启多少个goroutine, 使用匿名函数的方式 go func(done chan&lt;- struct&#123;&#125;, results chan&lt;- Pair, filename string) &#123; wordcount := make(WordCount) wordcount.UpdateFreq(filename) for k, v := range wordcount &#123; pair := Pair&#123;k, v&#125; results &lt;- pair &#125; done &lt;- struct&#123;&#125;&#123;&#125; &#125;(done, results, files[i]) i++ &#125; for working := len(files); working &gt; 0; &#123; // 监听通道，直到所有的工作goroutine完成任务时才退出 select &#123; case pair := &lt;-results: // 接收发送到通道中的统计结果 wordcount[pair.Key] += pair.Value case &lt;-done: // 判断工作goroutine是否全部完成 working-- &#125; &#125;DONE: // 再次启动for循环处理通道中还未处理完的值 for &#123; select &#123; case pair := &lt;-results: wordcount[pair.Key] += pair.Value default: break DONE &#125; &#125; close(results) close(done)&#125; 然后在 $GOPATH 目录中创建文件 wordfreq.go，输入以下源码： 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;path/filepath&quot; &quot;wordcount&quot;)func main() &#123; if len(os.Args) == 1 || os.Args[1] == &quot;-h&quot; || os.Args[1] == &quot;--help&quot; &#123; fmt.Printf(&quot;usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]] &quot;, filepath.Base(os.Args[0])) os.Exit(1) &#125; wordcounter := make(wordcount.WordCount) // for _, filename := range os.Args[1:] &#123; // wordcount.UpdateFreq(filename) // &#125; wordcounter.WordFreqCounter(os.Args[1:]) wordcounter.SortReport()&#125;","tags":["Go简明手册","Code","GO","面向对象编程"],"categories":["Code","GO","Go简明手册","词频统计综合案例"]},{"title":"Go并发编程——超时机制","path":"/Code/GO/Go简明手册/并发与并行/超时机制/README/","content":"通过前面的内容我们了解到，channel 的读写操作非常简单，只需要通过 &lt;- 操作符即可实现，但是 channel 的使用不当却会带来大麻烦。我们先来看之前的一段代码： 123a := make(chan int)a &lt;- 1z := &lt;-a 观察上面三行代码，第 2 行往 channel 内写入了数据，第 3 行从 channel 中读取了数据，如果程序运行正常当然不会出什么问题，可如果第二行数据写入失败，或者 channel 中没有数据，那么第 3 行代码会因为永远无法从 a 中读取到数据而一直处于阻塞状态。相反的，如果 channel 中的数据一直没有被读取，那么写入操作也会一直处于阻塞状态。如果不正确处理这个情况，很可能会导致整个 goroutine 锁死，这就是超时问题。Go 语言没有针对超时提供专门的处理机制，但是我们却可以利用 select 来巧妙地实现超时处理机制，下面看一个示例： 1234567891011t := make(chan bool)go func &#123; time.Sleep(1e9) //等待1秒 t &lt;- true&#125;select &#123; case &lt;-ch: //从ch中读取数据 case &lt;-t: //如果1秒后没有从ch中读取到数据，那么从t中读取，并进行下一步操作&#125; 这样的方法就可以让程序在等待 1 秒后继续执行，而不会因为 ch 读取等待而导致程序停滞，从而巧妙地实现了超时处理机制，这种方法不仅简单，在实际项目开发中也是非常实用的。 channel 的关闭channel 的关闭非常简单，使用 Go 语言内置的 close() 函数即可关闭 channel，示例： 12ch := make(chan int)close(ch) 关闭了 channel 后如何查看 channel 是否关闭成功了呢？很简单，我们可以在读取 channel 时采用多重返回值的方式，示例： 1x, ok := &lt;-ch 通过查看第二个返回值的 bool 值即可判断 channel 是否关闭，若为 false 则表示 channel 被关闭，反之则没有关闭。","categories":["Code","GO","Go简明手册","并发与并行","超时机制"]},{"title":"Go并发编程——select","path":"/Code/GO/Go简明手册/并发与并行/select/README/","content":"select 用于处理异步 IO 问题，它的语法与 switch 非常类似。由 select 开始一个新的选择块，每个选择条件由 case 语句来描述，并且每个 case 语句里必须是一个 channel 操作。它既可以用于 channel 的数据接收，也可以用于 channel 的数据发送。如果 select 的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。 新建源文件 channel.go，输入以下代码： 1234567891011121314151617181920212223package mainimport &quot;time&quot;import &quot;fmt&quot;func main() &#123; c1 := make(chan string) c2 := make(chan string) go func() &#123; time.Sleep(time.Second * 1) c1 &lt;- &quot;one&quot; &#125;() go func() &#123; time.Sleep(time.Second * 2) c2 &lt;- &quot;two&quot; &#125;() for i := 0; i &lt; 2; i++ &#123; select &#123; case msg1 := &lt;-c1: fmt.Println(&quot;received&quot;, msg1) case msg2 := &lt;-c2: fmt.Println(&quot;received&quot;, msg2) &#125; &#125;&#125; 以上代码先初始化两个 channel c1 和 c2，然后开启两个 goroutine 分别往 c1 和 c2 写入数据，再通过 select 监听两个 channel，从中读取数据并输出。 运行结果如下： 123$ go run channel.goreceived onereceived two","categories":["Code","GO","Go简明手册","并发与并行","select"]},{"title":"Go并发编程——channel","path":"/Code/GO/Go简明手册/并发与并行/channel/README/","content":"channel 是goroutine 之间互相通讯的东西。类似我们 Unix 上的管道（可以在进程间传递消息），用来 goroutine 之间发消息和接收消息。其实，就是在做 goroutine 之间的内存共享。channel 是类型相关的，也就是说一个 channel 只能传递一种类型的值，这个类型需要在 channel 声明时指定。 声明与初始化channel 的一般声明形式：var chanName chan ElementType。 与普通变量的声明不同的是在类型前面加了 channel 关键字，ElementType 则指定了这个 channel 所能传递的元素类型。示例： 123var a chan int //声明一个传递元素类型为int的channelvar b chan float64var c chan string 初始化一个 channel 也非常简单，直接使用 Go 语言内置的 make() 函数，示例： 123a := make(chan int) //初始化一个int型的名为a的channelb := make(chan float64)c := make(chan string) channel 最频繁的操作就是写入和读取，这两个操作也非常简单，示例： 123a := make(chan int)a &lt;- 1 //将数据写入channelz := &lt;-a //从channel中读取数据","categories":["Code","GO","Go简明手册","并发与并行","channel"]},{"title":"Go并发编程——goroutine","path":"/Code/GO/Go简明手册/并发与并行/goroutine/README/","content":"goroutine 是 Go 语言并行设计的核心。goroutine 是一种比线程更轻量的实现，十几个 goroutine 可能在底层就是几个线程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。要使用 goroutine 只需要简单的在需要执行的函数前添加 go 关键字即可。当执行 goroutine 时候，Go 语言立即返回，接着执行剩余的代码，goroutine 不阻塞主线程。下面我们通过一小段代码来讲解 go 的使用： 1234567//首先我们先实现一个 Add()函数func Add(a, b int) &#123; c := a + b fmt.Println(c)&#125;go Add(1, 2) //使用go关键字让函数并发执行 Go 的并发执行就是这么简单，当在一个函数前加上 go 关键字，该函数就会在一个新的 goroutine 中并发执行，当该函数执行完毕时，这个新的 goroutine 也就结束了。不过需要注意的是，如果该函数具有返回值，那么返回值会被丢弃。所以什么时候用 go 还需要酌情考虑。 接着我们通过一个案例来体验一下 Go 的并发到底是怎么样的。新建源文件 goroutine.go，输入以下代码： 1234567891011121314package mainimport &quot;fmt&quot;func Add(a, b int) &#123; c := a + b fmt.Println(c)&#125;func main() &#123; for i := 0; i &lt; 10; i++ &#123; go Add(i, i) &#125;&#125; 执行 goroutine.go 文件会发现屏幕上什么都没有，但程序并不会报错，这是什么原因呢？原来当主程序执行到 for 循环时启动了 10 个 goroutine，然后主程序就退出了，而启动的 10 个 goroutine 还没来得及执行 Add() 函数，所以程序不会有任何输出。也就是说主 goroutine 并不会等待其他 goroutine 执行结束。那么如何解决这个问题呢？Go 语言提供的信道（channel）就是专门解决并发通信问题的，下一节我们将详细介绍。","categories":["Code","GO","Go简明手册","并发与并行","goroutine"]},{"title":"Go并发编程——概要","path":"/Code/GO/Go简明手册/并发与并行/README/","content":"知识点 并发与并行 协程 goroutine channel select 并发编程 并发与并行并发指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，通过 CPU 时间片轮转使多个进程快速交替的执行。而并行的关键是你有同时处理多个任务的能力。并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）CPU 执行，如果可以就说明是并行，而并发是多个线程被（一个）CPU 轮流切换着执行。一个经典且通俗易懂的例子这样解释并发与并行的区别：并发是两个队列，使用一台咖啡机；并行是两个队列，使用两台咖啡机。如果串行，一个队列使用一台咖啡机，那么哪怕前面那个人有事出去了半天，后面的人也只能等着他回来才能去接咖啡，这效率无疑是最低的。图解： 协程*协程也叫轻量级线程。与传统的进程和线程相比，协程最大的优点就在于其足够“轻”，操作系统可以轻松创建上百万个协程而不会导致系统资源枯竭，而线程和进程通常最多不过近万个。而多数语言在语法层面上是不支持协程的，一般都是通过库的方式进行支持，但库的支持方式和功能不够完善，经常会引发阻塞等一系列问题，而 Go 语言在语法层面上支持协程，也叫 goroutine。这让协程变得非常简单，让轻量级线程的切换管理不再依赖于系统的进程和线程，也不依赖 CPU 的数量。 goroutine*goroutine 是 Go 语言并行设计的核心。goroutine 是一种比线程更轻量的实现，十几个 goroutine 可能在底层就是几个线程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。要使用 goroutine 只需要简单的在需要执行的函数前添加 go 关键字即可。当执行 goroutine 时候，Go 语言立即返回，接着执行剩余的代码，goroutine 不阻塞主线程。下面我们通过一小段代码来讲解 go 的使用： 1234567//首先我们先实现一个 Add()函数func Add(a, b int) &#123; c := a + b fmt.Println(c)&#125;go Add(1, 2) //使用go关键字让函数并发执行 Go 的并发执行就是这么简单，当在一个函数前加上 go 关键字，该函数就会在一个新的 goroutine 中并发执行，当该函数执行完毕时，这个新的 goroutine 也就结束了。不过需要注意的是，如果该函数具有返回值，那么返回值会被丢弃。所以什么时候用 go 还需要酌情考虑。 接着我们通过一个案例来体验一下 Go 的并发到底是怎么样的。新建源文件 goroutine.go，输入以下代码： 1234567891011121314package mainimport &quot;fmt&quot;func Add(a, b int) &#123; c := a + b fmt.Println(c)&#125;func main() &#123; for i := 0; i &lt; 10; i++ &#123; go Add(i, i) &#125;&#125; 执行 goroutine.go 文件会发现屏幕上什么都没有，但程序并不会报错，这是什么原因呢？原来当主程序执行到 for 循环时启动了 10 个 goroutine，然后主程序就退出了，而启动的 10 个 goroutine 还没来得及执行 Add() 函数，所以程序不会有任何输出。也就是说主 goroutine 并不会等待其他 goroutine 执行结束。那么如何解决这个问题呢？Go 语言提供的信道（channel）就是专门解决并发通信问题的 channelchannel 是goroutine 之间互相通讯的东西。类似我们 Unix 上的管道（可以在进程间传递消息），用来 goroutine 之间发消息和接收消息。其实，就是在做 goroutine 之间的内存共享。channel 是类型相关的，也就是说一个 channel 只能传递一种类型的值，这个类型需要在 channel 声明时指定。 声明与初始化channel 的一般声明形式：var chanName chan ElementType。 与普通变量的声明不同的是在类型前面加了 channel 关键字，ElementType 则指定了这个 channel 所能传递的元素类型。示例： 123var a chan int //声明一个传递元素类型为int的channelvar b chan float64var c chan string 初始化一个 channel 也非常简单，直接使用 Go 语言内置的 make() 函数，示例： 123a := make(chan int) //初始化一个int型的名为a的channelb := make(chan float64)c := make(chan string) channel 最频繁的操作就是写入和读取，这两个操作也非常简单，示例： 123a := make(chan int)a &lt;- 1 //将数据写入channelz := &lt;-a //从channel中读取数据 selectselect 用于处理异步 IO 问题，它的语法与 switch 非常类似。由 select 开始一个新的选择块，每个选择条件由 case 语句来描述，并且每个 case 语句里必须是一个 channel 操作。它既可以用于 channel 的数据接收，也可以用于 channel 的数据发送。如果 select 的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。 新建源文件 channel.go，输入以下代码： 1234567891011121314151617181920212223package mainimport &quot;time&quot;import &quot;fmt&quot;func main() &#123; c1 := make(chan string) c2 := make(chan string) go func() &#123; time.Sleep(time.Second * 1) c1 &lt;- &quot;one&quot; &#125;() go func() &#123; time.Sleep(time.Second * 2) c2 &lt;- &quot;two&quot; &#125;() for i := 0; i &lt; 2; i++ &#123; select &#123; case msg1 := &lt;-c1: fmt.Println(&quot;received&quot;, msg1) case msg2 := &lt;-c2: fmt.Println(&quot;received&quot;, msg2) &#125; &#125;&#125; 以上代码先初始化两个 channel c1 和 c2，然后开启两个 goroutine 分别往 c1 和 c2 写入数据，再通过 select 监听两个 channel，从中读取数据并输出。 运行结果如下： 123$ go run channel.goreceived onereceived two 超时机制通过前面的内容我们了解到，channel 的读写操作非常简单，只需要通过 &lt;- 操作符即可实现，但是 channel 的使用不当却会带来大麻烦。我们先来看之前的一段代码： 123a := make(chan int)a &lt;- 1z := &lt;-a 观察上面三行代码，第 2 行往 channel 内写入了数据，第 3 行从 channel 中读取了数据，如果程序运行正常当然不会出什么问题，可如果第二行数据写入失败，或者 channel 中没有数据，那么第 3 行代码会因为永远无法从 a 中读取到数据而一直处于阻塞状态。相反的，如果 channel 中的数据一直没有被读取，那么写入操作也会一直处于阻塞状态。如果不正确处理这个情况，很可能会导致整个 goroutine 锁死，这就是超时问题。Go 语言没有针对超时提供专门的处理机制，但是我们却可以利用 select 来巧妙地实现超时处理机制，下面看一个示例： 1234567891011t := make(chan bool)go func &#123; time.Sleep(1e9) //等待1秒 t &lt;- true&#125;select &#123; case &lt;-ch: //从ch中读取数据 case &lt;-t: //如果1秒后没有从ch中读取到数据，那么从t中读取，并进行下一步操作&#125; 这样的方法就可以让程序在等待 1 秒后继续执行，而不会因为 ch 读取等待而导致程序停滞，从而巧妙地实现了超时处理机制，这种方法不仅简单，在实际项目开发中也是非常实用的。 channel 的关闭channel 的关闭非常简单，使用 Go 语言内置的 close() 函数即可关闭 channel，示例： 12ch := make(chan int)close(ch) 关闭了 channel 后如何查看 channel 是否关闭成功了呢？很简单，我们可以在读取 channel 时采用多重返回值的方式，示例： 1x, ok := &lt;-ch 通过查看第二个返回值的 bool 值即可判断 channel 是否关闭，若为 false 则表示 channel 被关闭，反之则没有关闭。","categories":["Code","GO","Go简明手册","并发与并行"]},{"title":"Go简明手册概要","path":"/Code/GO/Go简明手册/Readme/","content":"Go语言基础Go语言介绍Go语言顺序编程并发与并行词频统计综合案例面向对象编程","categories":["Code","GO","Go简明手册"]},{"path":"/Code/GO/Go简明手册/Go语言顺序编程/错误处理/README/","content":"错误处理* 错误处理是任何语言都需要考虑到的问题，而 Go 语言在错误处理上解决得更为完善，优雅的错误处理机制是 Go 语言的一大特点。 errorGo 语言引入了一个错误处理的标准模式，即 error 接口，该接口定义如下： 123type error interface &#123; Error() string&#125; 对于大多数函数，如果要返回错误，可以将 error 作为多返回值的最后一个： 1234func foo(param int)(ret int, err error)&#123; ...&#125; 调用时的代码： 123456n, err := foo(0)if err != nil &#123; // 错误处理&#125; else &#123; // 使用返回值n&#125; 我们还可以自定义错误类型，创建源文件 error.go，输入以下代码： 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;import &quot;errors&quot;//自定义的出错结构type myError struct &#123; arg int errMsg string&#125;//实现Error接口func (e *myError) Error() string &#123; return fmt.Sprintf(&quot;%d - %s&quot;, e.arg, e.errMsg)&#125;//两种出错func error_test(arg int) (int, error) &#123; if arg &lt; 0 &#123; return -1, errors.New(&quot;Bad Arguments - negtive!&quot;) &#125;else if arg &gt;256 &#123; return -1, &amp;myError&#123;arg, &quot;Bad Arguments - too large!&quot;&#125; &#125; return arg*arg, nil&#125;//相关的测试func main() &#123; for _, i := range []int&#123;-1, 4, 1000&#125; &#123; if r, e := error_test(i); e != nil &#123; fmt.Println(&quot;failed:&quot;, e) &#125; else &#123; fmt.Println(&quot;success:&quot;, r) &#125; &#125;&#125;","categories":["Code","GO","Go简明手册","Go语言顺序编程","错误处理"]},{"title":"Go顺序编程——流程控制","path":"/Code/GO/Go简明手册/Go语言顺序编程/流程控制/README/","content":"[toc] Go 语言提供的流程控制语句包括 if、switch、for、goto、select，其中 select 用于监听 channel（通道）在讲解通道的时候再详细介绍。 if 语句语法： 1234567if optionalStatement1; booleanExpression1 &#123; block1&#125; else if optionalStatement2; booleanExpression2 &#123; block2&#125; else &#123; block3&#125; 其中 optionalStatement 是可选的表达式，真正决定分支走向的是 booleanExpression1 的值。 for 语句Go 语言的 for 语句可以遍历数组，切片，映射等类型，也可以用于无限循环。以下是其语法： 123456789101112131415for &#123; // 无限循环 block&#125;for booleanExpression &#123; // while循环，在Go语言中没有while关键字&#125;for index, char := range aString &#123; // 迭代字符串&#125;for item := range aChannel &#123; // 迭代通道&#125; 跳转语句Go 语言中使用 goto 关键字实现跳转。goto 语句的语义非常简单，就是跳转到本函数内的某个标签，例如： 123456789func myfunc()&#123; i := 0 THIS: //定义一个THIS标签 fmt.Println(i) i++ if i &lt; 1 &#123; goto THIS //跳转到THIS标签 &#125;&#125;","tags":["Go简明手册"],"categories":["Code","GO","Go简明手册","Go语言顺序编程","流程控制"]},{"title":"Go顺序编程——类型转换","path":"/Code/GO/Go简明手册/Go语言顺序编程/类型转换/Readme/","content":"[toc] 类型转换Go 语言提供了一种在不同但相互兼容的类型之间相互转换的方式，这种转换非常有用并且是安全的。但是需要注意的是在数值之间进行转换可能造成其他问题，如精度丢失或者错误的结果。以下是类型转换的语法： resultOfType := Type(expression) 几个例子： 1234x := int16(2345) // 声明一个类型为int16的整数，其值为2345y := int32(x) // 将int16类型的整数转换为int32类型a := uint16(65000) // 声明一个类型为uint16类型的整数b := int16(a) // 转换为int16类型，虽然能转换成功，但是由于65000超过in16类型的范围，会导致结果错误，b的值为 -536 另外在 Go 语言中可以通过 type 关键字声明类型，如 type StringsSlice []string 将 []string（string 类型的切片）声明为 StringSlice 类型。 类型断言说到类型断言就需要先了解下 Go 语言中的接口。在 Go 语言中接口是一个自定义类型。它声明了一个或者多个方法。任何实现了这些方法的对象（类型）都满足这个接口。 接口是完全抽象的，不能实例化。interface&#123;&#125; 类型表示一个空接口，任何类型都满足空接口。也就是说 interface&#123;&#125; 类型的值可以用于表示任意 Go 语言类型的值。 这里的空接口有点类似于 Python 语言中的 object 实例。既然 interface&#123;&#125; 可以用于表示任意类型，那有的时候我们需要将 interface&#123;&#125; 类型转换为我们需要的类型，这个操作称为类型断言。 一般情况下只有我们希望表达式是某种特定类型的值时才使用类型断言。Go 语言中可以使用以下语法： resultOfType, boolean := expression.(Type)：安全的类型断言。 resultOfType := expression.(Type)：非安全的类型断言，失败时程序会产生异常。 创建源文件 type_t.go，输入以下源文件： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)func main() &#123; x := uint16(65000) y := int16(x) // 将 x转换为int16类型 fmt.Printf(&quot;type and value of x is: %T and %d &quot;, x, x) // %T 格式化指令的作用是输出变量的类型 fmt.Printf(&quot;type and value of y is: %T and %d &quot;, y, y) var i interface&#123;&#125; = 99 // 创建一个interface&#123;&#125;类型，其值为99 var s interface&#123;&#125; = []string&#123;&quot;left&quot;, &quot;right&quot;&#125; j := i.(int) // 我们假设i是兼容int类型，并使用类型断言将其转换为int类型 fmt.Printf(&quot;type and value of j is: %T and %d &quot;, j, j) if s, ok := s.([]string); ok &#123; // 创建了影子变量，if的作用域中覆盖了外部的变量s fmt.Printf(&quot;%T -&gt; %q &quot;, s, s) &#125;&#125; 运行程序： 12345$ go run type_t.gotype and value of x is: uint16 and 65000type and value of y is: int16 and -536type and value of j is: int and 99[]string -&gt; [&quot;left&quot; &quot;right&quot;]","tags":["Go简明手册"],"categories":["Code","GO","Go简明手册","Go语言顺序编程","类型转换"]},{"title":"Go顺序编程——函数的多返回值","path":"/Code/GO/Go简明手册/Go语言顺序编程/函数的多返回值/README/","content":"与 C&#x2F;C++ 和 JAVA 不同，Go 语言的函数和方法可以有多个返回值，这是 Go 提供的一个优美的特性，示例如下： 12345678910package Divideimport &quot;errors&quot;func divide (a int, b int) (num int, err error)&#123; //定义两个返回值 if b == 0 &#123; err = errors.New(&quot;被除数不能为零！&quot;) return &#125; return a / b, nil //支持多个返回值&#125; 匿名函数在 Go 语言中，你可以在代码里随时定义匿名函数，匿名函数由一个不带函数名的函数声明和函数体组成，示例如下： 123func (a, b, c int) bool &#123; return a * b &lt; c&#125; 你可以将匿名函数直接赋值给一个变量，也可以直接调用运行，示例如下： 1234567x := func (a, b, c int) bool &#123; return a * b &lt; c&#125;func (a, b, c int) bool &#123; return a * b &lt; c&#125; (1, 2, 3) //小括号内直接给参数列表表示函数调用","categories":["Code","GO","Go简明手册","Go语言顺序编程","函数的多返回值"]},{"title":"Go顺序编程——Go语言顺序编程","path":"/Code/GO/Go简明手册/Go语言顺序编程/readme/","content":"知识点 流程控制 函数 类型转换 类型断言 error defer 和 panic 文章列表panic和defer错误处理类型转换","tags":["Go简明手册"],"categories":["Code","GO","Go简明手册","Go语言顺序编程"]},{"title":"Go顺序编程——switch语句","path":"/Code/GO/Go简明手册/Go语言顺序编程/switch语句/README/","content":"Go 语言中 switch 分支既可用于常用的分支就像 C 语言中的 switch 一样，也可以用于类型开关，所谓类型开关就是用于判断变量属于什么类型。但是需要注意的是 Go 语言的 switch 语句不会自动贯穿，相反，如果想要贯穿需要添加 fallthrough 语句。表达式开关 switch 的语法如下： 123456switch optionalStatement; optionalExpression &#123; case expression1: block1 ... case expressionN: blockN default: blockD&#125; 下面是个例子： 12345678switch &#123; // 没有表达式，默认为True值，匹配分支中值为True的分支 case value &lt; minimum: return minimum case value &gt; maximum: return maximum default: return value&#125; 在上面的例子中，switch 后面没有默认的表达式，这个时候 Go 语言默认其值为 True。 在前面我们提到过类型断言，如果我们知道变量的类型就可以使用类型断言，但是当我们知道类型可能是许多类型中的一种时候，我们就可以使用类型开关。其语法如下： 123456switch optionalStatement; typeSwitchGuard &#123; case type1: block1 ... case typeN: blockN default: blockD&#125; 说了这么多，让我们进行下练习，创建源文件 switch_t.go，输入以下代码： 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot;)func classchecker(items ...interface&#123;&#125;) &#123; // 创建一个函数，该函数可以接受任意多的任意类型的参数 for i, x := range items &#123; switch x := x.(type) &#123; // 创建了影子变量 case bool: fmt.Printf(&quot;param #%d is a bool, value: %t &quot;, i, x) case float64: fmt.Printf(&quot;param #%d is a float64, value: %f &quot;, i, x) case int, int8, int16, int32, int64: fmt.Printf(&quot;param #%d is a int, value: %d &quot;, i, x) case uint, uint8, uint16, uint32, uint64: fmt.Printf(&quot;param #%d is a uint, value: %d &quot;, i, x) case nil: fmt.Printf(&quot;param #%d is a nil &quot;, i) case string: fmt.Printf(&quot;param #%d is a string, value: %s &quot;, i, x) default: fmt.Printf(&quot;param #%d&#x27;s type is unknow &quot;, i) &#125; &#125;&#125;func main() &#123; classchecker(5, -17.98, &quot;AIDEN&quot;, nil, true, complex(1, 1))&#125; 以上代码中我们首先创建了一个接收任意数量任意类型参数的函数，然后使用 for ... range aSlice 的语法迭代了每一个在切片 items 中的元素，接着使用了 switch 类型开关判断了每一个参数的类型，并打印了其值和类型。程序运行输出如下： 1234567$ go run switch_t.goparam #0 is a int, value: 5param #1 is a float64, value: -17.980000param #2 is a string, value: AIDENparam #3 is a nilparam #4 is a bool, value: trueparam #5&#x27;s type is unknow","categories":["Code","GO","Go简明手册","Go语言顺序编程","switch语句"]},{"title":"Go基本语法——格式化字符串","path":"/Code/GO/Go简明手册/Go语言基础/格式化字符串/格式化字符串/","content":"Go 语言标准库中的 fmt 包提供了打印函数将数据以字符串形式输出到控制台，文件，其他满足 io.Writer 接口的值以及其他字符串。目前为止我们使用了 fmt.Printf 和 fmt.Println，对于前者的使用，就像 C 语言中的 printf 函数一样，我们可以提供一些格式化指令，让 Go 语言对输出的字符串进行格式化。同样的我们可以使用一些格式化修饰符，改变格式化指令的输出结果， 如左对齐等。常用的格式化指令如下： 格式化指令 含义 %% % 字面量 %b 一个二进制整数，将一个整数格式化为二进制的表达方式 %c 一个 Unicode 的字符 %d 十进制数值 %o 八进制数值 %x 小写的十六进制数值 %X 大写的十六进制数值 %U 一个 Unicode 表示法表示的整形码值，默认是 4 个数字字符 %s 输出以原生的 UTF-8 字节表示的字符，如果 console 不支持 UTF-8 编码，则会输出乱码 %t 以 true 或者 false 的方式输出布尔值 %v 使用默认格式输出值，或者使用类型的 String() 方法输出的自定义值，如果该方法存在的话 %T 输出值的类型 常用的格式化指令修饰符如下： 空白 如果输出的数字为负，则在其前面加上一个减号 -。如果输出的是整数，则在前面加一个空格。使用 %x 或者 %X 格式化指令输出时，会在结果之间添加一个空格。例如 fmt.Printf(&quot;% X&quot;, &quot;实&quot;) 输出 E5 AE 9E。 # 1234567891011121314151617181920212223242526272829303132333435363738 - `%#o` 输出以 `0` 开始的八进制数据。 - `%#x` 输出以 `0x` 开始的十六进制数据。- `+` 让格式化指令在数值前面输出 `+` 号或者 `-` 号，为字符串输出 ASCII 字符（非 ASCII 字符会被转义），为结构体输出其字段名。- `-` 让格式化指令将值向左对齐（默认值为像右对齐）。- `0` 让格式指令以数字 0 而非空白进行填充。让我们练习一下，创建源文件 `fmt_t.go`，输入以下源码：```gopackage mainimport ( &quot;fmt&quot;)func main() &#123; text := &quot;\\u5B9E\\u9A8C\\u697C&quot; fmt.Printf(&quot;bool output: %t %t &quot;, true, false) fmt.Println(&quot;number output, origin value: 64&quot;) fmt.Printf(&quot;|%b|%8b|%-8b|%08b|% 8b| &quot;, 64, 64, 64, 64, 64) fmt.Printf(&quot;|%x|%8x|%-8x|%08X|% 8X| &quot;, 64, 64, 64, 64, 64) fmt.Println(`text output, origin value: \\u5B9E\\u9A8C\\u697C`) fmt.Printf(&quot;content: %s &quot;, text) fmt.Printf(&quot;hex value: % X Unicode value: &quot;, text) for _, char := range text &#123; fmt.Printf(&quot;%U &quot;, char) &#125; fmt.Println() bytes := []byte(text) fmt.Printf(&quot;value of bytes: %s &quot;, bytes) fmt.Printf(&quot;hex value of bytes: % X &quot;, bytes) fmt.Printf(&quot;origin value of bytes: %v &quot;, bytes)&#125; 运行代码，输出如下： 12345678910111213141516$ go run fmt_t.gobool output:truefalsenumber output, origin value: 64|1000000| 1000000|1000000 |01000000| 1000000||40| 40|40 |00000040| 40|text output, origin value: \\u5B9E\\u9A8C\\u697Ccontent: 实验楼hex value: E5 AE 9E E9 AA 8C E6 A5 BCUnicode value: U+5B9E U+9A8C U+697Cvalue of bytes: 实验楼hex value of bytes: E5 AE 9E E9 AA 8C E6 A5 BCorigin value of bytes: [229 174 158 233 170 140 230 165 188] 代码一目了然，就不详细解释了。","tags":["Go简明手册"],"categories":["Code","GO","Go简明手册","Go语言基础","格式化字符串"]},{"path":"/Code/GO/Go简明手册/Go语言顺序编程/panic和defer/README/","content":"panic 和 recoverpanic() 函数用于抛出异常，recover() 函数用于捕获异常，这两个函数的原型如下： 12func panic(interface&#123;&#125;)func recover() interface&#123;&#125; 当在一个函数中调用 panic() 时，正常的函数执行流程将立即终止，但函数中之前使用 defer 关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致逐层向上执行 panic() 流程，直至所属的 goroutine 中所有正在执行的函数被终止。错误信息将被报告，包括在调用 panic() 函数时传入的参数，这个过程称为错误流程处理。 panic() 接受一个 interface&#123;&#125; 参数，可支持任意类型，例如： 123panic(404)panic(&quot;network broken&quot;)panic(Error(&quot;file not exists&quot;)) 在 defer 语句中，可以使用 recover() 终止错误处理流程，这样可以避免异常向上传递，但要注意 recover() 之后，程序不会再回到 panic() 那里，函数仍在 defer 之后返回。新建一个源文件 error1.go，输入以下代码： 12345678910111213141516171819func foo() &#123; panic(errors.New(&quot;i&#x27;m a bug&quot;)) return&#125;func test() (result int) &#123; defer func() &#123; if r := recover(); r != nil &#123; err := r.(error) fmt.Println(&quot;Cache Exception:&quot;, err) &#125; &#125;() foo() return 10&#125;func main() &#123; fmt.Println(test()) // 0&#125;","categories":["Code","GO","Go简明手册","Go语言顺序编程","panic和defer"]},{"title":"Go基本语法——字符类型","path":"/Code/GO/Go简明手册/Go语言基础/字符类型/字符类型/","content":"在 Go 语言中支持两个字符类型，一个是 Byte（实际上是 Unit8 的别名），代表 UTF-8 字符串的单个字节的值；另一个是 rune，代表单个 Unicode 字符。 处于简化语言的考虑，Go 语言的多数 API 都假设字符串为 UTF-8 编码。尽管 Unicode 字符在标准库中有支持，但实际很少使用。 数组Go 语言的数组是一个定长的序列，其中的元素类型相同。多维数组可以简单地使用自身为数组的元素来创建。数组的元素使用操作符号 [ ] 来索引，索引从 0 开始，到 len(array)-1 结束。数组使用以下语法创建： [length]Type [N]Type&#123;value1, value2, ..., valueN&#125; [...]Type&#123;value1, value2, ..., valueN&#125; 如果使用了 ...（省略符）操作符，Go 语言会为我们自动计算数组的长度。在任何情况下，一个数组的长度都是固定的并且不可修改。数组的长度可以使用 len() 函数获得。由于数组的长度是固定的，因此数组的长度和容量都是一样的，因此对于数组而言 cap() 和 len() 函数返回值都是一样的。数组也可以使用和切片一样的语法进行切片，只是其结果为一个切片，而非数组。同样的，数组也可以使用 range 进行索引访问。","tags":["Go简明手册"],"categories":["Code","GO","Go简明手册","Go语言基础","字符类型"]},{"title":"Go基本语法——字符串","path":"/Code/GO/Go简明手册/Go语言基础/字符串/字符串/","content":"Go 语言中的字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节，这与其它语言如 C++、Java 或者 Python 不同。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。 Go 语言中字符串的可以使用双引号 (“) 或者反引号 (&#96;) 来创建。双引号用来创建可解析的字符串字面量，所谓可解析的是指字符串中的一些符号可以被格式化为其他内容，如 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。以下是几个例子： 123t1 := &quot;\\&quot;hello\\&quot;&quot; //内容： &quot;hello&quot;t2 := `&quot;hello&quot;` //内容：和t1一致t3 := &quot;\\u6B22\\u8FCE&quot; //内容：欢迎 Go 语言中的部分转义字符如下表所示： 转义字符 含义 \\\\ 表示反斜线 \\&#39; 单引号 \\&quot; 双引号 换行符 \\uhhhh 4 个 16 进制数字给定的 Unicode 字符 在 Go 语言中单个字符可以使用单引号 (‘) 来创建。之前的课程中，我们有学习过 rune 类型，它等同于 int32，在 Go 语言中，一个单一的字符可以用一个单一的 rune 来表示。这也是容易理解的，因为 Go 语言的字符串是 UTF-8 编码，其底层使用 4 个字节表示，也就是 32 bit。 在 Go 语言中，字符串支持切片操作，但是需要注意的是如果字符串都是由 ASCII 字符组成，那可以随便使用切片进行操作，但是如果字符串中包含其他非 ASCII 字符，直接使用切片获取想要的单个字符时需要十分小心，因为对字符串直接使用切片时是通过字节进行索引的，但是非 ASCII 字符在内存中可能不是由一个字节组成。如果想对字符串中字符依次访问，可以使用 range 操作符。另外获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。字符串支持以下操作： 语法 描述 s += t 将字符串 t 追加到 s 末尾 s + t 将字符串 s 和 t 级联 s[n] 从字符串 s 中索引位置为 n 处的原始字节 s[n:m] 从位置 n 到位置 m-1 处取得的字符（字节）串 s[n:] 从位置 n 到位置 len(s)-1 处取得的字符（字节）串 s[:m] 从位置 0 到位置 m-1 处取得的字符（字节）串 len(s) 字符串 s 中的字节数 len([]rune(s)) 字符串 s 中字符的个数，可以使用更快的方法 utf8.RuneCountInString() []rune(s) 将字符串 s 转换为一个 unicode 值组成的串 string(chars) chars 类型是 []rune 或者 []int32, 将之转换为字符串 []byte(s) 无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节 让我们尝试一个例子，创建源文件 string_t.go，然后输入以下源代码： 1234567891011121314151617package mainimport ( &quot;fmt&quot;)func main() &#123; t0 := &quot;\\u6B22\\u8FCE\\u6765\\u5230&quot; // t0内容：欢迎来到 t1 := &quot;\\u5B9E\\u9A8C\\u697C&quot; // t1内容：实验楼 t2 := t0 + t1 for index, char := range t2 &#123; fmt.Printf(&quot;%-2d %U &#x27;%c&#x27; %X %d &quot;, index, char, char, []byte(string(char)), len([]byte(string(char)))) &#125; fmt.Printf(&quot;length of t0: %d, t1: %d, t2: %d &quot;, len(t0), len(t1), len(t2)) fmt.Printf(&quot;content of t2[0:2] is: %X &quot;, t2[0:2])&#125; 然后通过以下方式运行，在这里一起显示了程序的输出： 12345678910$ go run string_t.go0 U+6B22 &#x27;欢&#x27; E6ACA2 33 U+8FCE &#x27;迎&#x27; E8BF8E 36 U+6765 &#x27;来&#x27; E69DA5 39 U+5230 &#x27;到&#x27; E588B0 312 U+5B9E &#x27;实&#x27; E5AE9E 315 U+9A8C &#x27;验&#x27; E9AA8C 318 U+697C &#x27;楼&#x27; E6A5BC 3length of t0: 12, t1: 9, t2: 21content of t2[0:2] is: E6AC 说明： 通过前面的课程我们知道通过 \\uhhhh 的方式我们可以通过创建 Unicode 字符。 在以上程序中，首先通过 :&#x3D; 符号创建了变量 t0，其值为 \\u6B22\\u8FCE\\u6765\\u5230，是 欢迎来到 中文字符的 unicode 编码，然后以同样的方式创建了变量 t1，其值为 实验楼，然后通过 + 操作符将 t0 和t1 拼接赋值给 t2。然后我们通过 range 操作符号对 unicode 字符串 t2 中的每一个 unicode 字符依次操作，我们这里只是简单的打印出每个字符在 t2 中的位置，每个字符的 unicode 码值，每个字符的字面量，每个字符的十六进制值，以及每个字符的字节长度。 这里我们使用 fmt 包种支持的格式指令，如果读者学习过 C 语言的话就一目了然。接着，我们通过 len 操作符计算出了每个字符串的字节长度。最后，我们使用切片访问了字符串 t2 的第 0-1 个字节，也就是前两个字节，其内容为 E6AC。前面我们说到不能使用切片的方式访问非 ASCII 字符串中的字符，原因在这里一目了然。字符 欢 其底层使用了三个字节表示，内容是 E6ACA2，如果只是简单的使用切片（只取切片中的一项）访问的是不能访问到整个字符的，因为字符的切片是通过字节数来索引的。","tags":["Go简明手册"],"categories":["Code","GO","Go简明手册","Go语言基础","字符串"]},{"title":"Go基本语法——切片","path":"/Code/GO/Go简明手册/Go语言基础/切片/切片/","content":"一般而言，Go 语言的切片比数组更加灵活，强大而且方便。数组是按值传递的（即是传递的副本），而切片是引用类型，传递切片的成本非常小，而且是不定长的。而且数组是定长的，而切片可以调整长度。创建切片的语法如下： make([ ]Type, length, capacity) make([ ]Type, length) [ ]Type&#123;&#125; [ ]Type&#123;value1, value2, ..., valueN&#125; 内置函数 make() 用于创建切片、映射和通道。当用于创建一个切片时，它会创建一个隐藏的初始化为零值的数组，然后返回一个引用该隐藏数组的切片。该隐藏的数组与 Go 语言中的所有数组一样，都是固定长度，如果使用第一种语法创建，那么其长度为切片的容量 capacity；如果是第二种语法，那么其长度记为切片的长度 length。一个切片的容量即为隐藏数组的长度，而其长度则为不超过该容量的任意值。另外可以通过内置的函数 append() 来增加切片的容量。切片可以支持以下操作： 我们练习下，创建源文件 slice_array.go，输入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( &quot;fmt&quot;)func main() &#123; a := [...]int&#123;1, 2, 3, 4, 5, 6, 7&#125; fmt.Printf(&quot;len and cap of array %v is: %d and %d &quot;, a, len(a), cap(a)) fmt.Printf(&quot;item in array: %v is:&quot;, a) for _, value := range a &#123; fmt.Printf(&quot;% d&quot;, value) &#125; fmt.Println() s1 := a[3:6] fmt.Printf(&quot;len and cap of slice: %v is: %d and %d &quot;, s1, len(s1), cap(s1)) fmt.Printf(&quot;item in slice: %v is:&quot;, s1) for _, value := range s1 &#123; fmt.Printf(&quot;%d&quot;, value) &#125; fmt.Println() s1[0] = 456 fmt.Printf(&quot;item in array changed after changing slice: %v is:&quot;, s1) for _, value := range a &#123; fmt.Printf(&quot;%d&quot;, value) &#125; fmt.Println() s2 := make([]int, 10, 20) s2[4] = 5 fmt.Printf(&quot;len and cap of slice: %v is: %d and %d &quot;, s2, len(s2), cap(s2)) fmt.Printf(&quot;item in slice %v is:&quot;, s2) for _, value := range s2 &#123; fmt.Printf(&quot;%d&quot;, value) &#125; fmt.Println()&#125; 以上代码中，我们首先创建了一个数组，数组的长度是由 Go 语言自动计算出的（省略号语法），然后通过切片操作从数组 a 中创建了切片 s1，接着我们修改了该切片的第一个位置的数值，然后发现数组 a 中的值也发生了变化。最后我们通过 make() 函数创建了一个切片，该切片的长度和容量分别为 10 和 20，还可以发现 Go 语言将未初始化的项自动赋予零值。运行代码输出如下： 12345678$ go run slice_array.golen and cap of array [1 2 3 4 5 6 7] is: 7 and 7item in array: [1 2 3 4 5 6 7] is: 1 2 3 4 5 6 7len and cap of slice: [4 5 6] is: 3 and 4item in slice: [4 5 6] is: 4 5 6item in array changed after changing slice: [456 5 6] is: 1 2 3 456 5 6 7len and cap of slice: [0 0 0 0 5 0 0 0 0 0] is: 10 and 20item in slice [0 0 0 0 5 0 0 0 0 0] is: 0 0 0 0 5 0 0 0 0 0","tags":["Go简明手册"],"categories":["Code","GO","Go简明手册","Go语言基础","切片"]},{"title":"Go简明手册——Go创建并使用本地宝","path":"/Code/GO/Go简明手册/Go语言基础/package/README/","content":"[toc] 包 包是各种类型和函数的集合。在包中，如果标示符（类型名称，函数名称，方法名称）的首字母是大写，那这些标示符是可以被导出的，也就是说可以在包以外直接使用。 $GOPATH ：环境变量（指向一个或多个目录），以及其子目录 src 目录的，当我们使用 import 关键字导入包的时候，Go 语言会在 $GOPATH 和 GOROOT 目录中搜索包。 创建并使用自定义包 源文件注意点： go文件名和文件夹名并没有关系，文件名可以是任意的，文件定义的package 才是标识 方法定义一定得是首字母大写 自定义包不能和导入处于同级目录，必须建一个文件夹存放自定义包 先看一下目录结构，以下示例是导入两包，一个是add，一个是simpleinterest 123456789│ go.mod│ main.go│ README.md│├─add│ add.go│└─simpleinterest simpleinterest.go 步骤说明1 创建package文件夹123mkdir packagego mod init packagetest 执行上述命令后，会生成 go.mod 文件，内容如下所示 123module packageTestgo 1.20 2 创建各个文件main.go123456789101112131415161718192021222324252627282930313233package mainimport (\t&quot;fmt&quot;\t&quot;log&quot;\t&quot;packageTest/add&quot; //导入 add 包 这个包必须放在$GOPATH下才可\t&quot;packageTest/simpleinterest&quot;)var p, r, t = 5000.0, 10.0, 1.0/** init function to check if p, r and t are greater than zero */func init() &#123;\tprintln(&quot;Main package initialized&quot;)\tif p &lt; 0 &#123; log.Fatal(&quot;Principal is less than zero&quot;)\t&#125;\tif r &lt; 0 &#123; log.Fatal(&quot;Rate of interest is less than zero&quot;)\t&#125;\tif t &lt; 0 &#123; log.Fatal(&quot;Duration is less than zero&quot;)\t&#125;&#125;func main() &#123;\tc := add.Add(1, 2) //调用 add 包中的 add 函数\tsi := simpleinterest.Calculate(p, r, t) // 调用 simpleinterest 包的 Calculate 函数\tfmt.Println(c)\tfmt.Println(&quot;Simple interest is&quot;, si)&#125; simpleinterest&#x2F;simpleinterest.go1234567891011121314151617package simpleinterestimport &quot;fmt&quot;/* * init function added */func init() &#123;\tfmt.Println(&quot;Simple interest package initialized&quot;)&#125;//Calculate calculates and returns the simple interest for principal p, rate of interest r for time duration t yearsfunc Calculate(p float64, r float64, t float64) float64 &#123;\tinterest := p * (r / 100) * t\treturn interest&#125; add&#x2F;add.go12345package addfunc Add(a int, b int) (num int) &#123;\treturn a + b&#125; 3 执行并调试输出如下所示 1234Main package initializedSimple interest package initialized3Simple interest is 500","tags":["Go简明手册","go","package"],"categories":["Code","GO","Go简明手册","Go语言基础","package"]},{"title":"Go开发经验(1)","path":"/Code/GO/Go开发经验/Go开发经验(1)/","content":"[toc] 1 var 与 := 的区别:= 只能在声明“局部变量”的时候使用，而“var”没有这个限制。","categories":["Code","GO","Go开发经验"]},{"title":"duilib 入门","path":"/Code/Duilib/入门/","content":"[toc] 开卷有益🎈github： duilib&#x2F;duilib 📖说明：Duilib是一个Windows下免费开源的DirectUI界面库，由于简约易扩展的设计以及稳定高效的实现被各大互联网公司普遍接受，广泛应用于包括IM、视频客户端、股票行情软件、导航软件、手机辅助软件、安全软件等多个行业的众多PC客户端软件。Duilib还在不断的发展中，在文档、例子、动画、渲染引擎等多个方面将持续改进。 基于Duilib的软件不完全列表Duilib自2010年8月21日发布以来，获得了众多开发者和大公司的信赖，在各行各业的软件中得到了广泛应用，以下是一个作者知道不完全列表，欢迎大家补充指正 https://github.com/duilib/duilib/wiki/%E5%9F%BA%E4%BA%8EDuilib%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%B8%8D%E5%AE%8C%E5%85%A8%E5%88%97%E8%A1%A8 下面两个修改版本大家可以参考一下 腾讯使用的的duilib修改版https://github.com/tencentyun/TIMSDK/tree/master/cross-platform/Windows/IMApp/Basic/duilib 网易使用的duilib修改版https://github.com/netease-im/NIM_Duilib_Framework/tree/master/duilib 安装使用vcpkg库管理器下载并安装duilib: 12345git clone https://github.com/Microsoft/vcpkg.gitcd vcpkg./bootstrap-vcpkg.sh./vcpkg integrate install./vcpkg install duilib","tags":["duilib"],"categories":["Code","Duilib"]},{"title":"GO HACK PE文件分析","path":"/Code/GO/GO_HACK_PEFILES/","content":"使用 go 对 PE文件进行分析 使用debug&#x2F;pe标准库进行解析 使用Reader对象对PE文件内容进行解析 PE文件结构 DOSheader 包含签名（0x5a4d）peheader(0x3c指向0x50 0x45 0x00 0x00) dos stub coff file header optional header section table 12345678910// pe头type FileHeader struct &#123; Machine uint16 NumberOfSections uint16 // 分区数 TimeDateStamp uint32 PointerToSymbolTable uint32 NumberOfSymbols uint32 SizeOfOptionalHeader uint16 Characteristics uint16&#125; 如果需要增加新分区，插入后门代码，需要修改这里的分区数属性 增加新的Sections 或者在imagebase中增加shellcode 作者：mafa1993链接：https://www.jianshu.com/p/2294fcfc0286来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package mainimport ( &quot;debug/pe&quot; &quot;encoding/binary&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;os&quot;)func main() &#123; f, err := os.Open(&quot;G:\\\\Windows\\\\WinSxS\\\\amd64_microsoft-windows-calc_31bf3856ad364e35_10.0.18362.1_none_7c1b713697f466dd\\\\calc.exe&quot;) // Modify for binary or change to accept args check(err) pefile, err := pe.NewFile(f) // 创建pe文件对象 check(err) defer f.Close() defer pefile.Close() dosHeader := make([]byte, 96) // 读取前96个字节 sizeOffset := make([]byte, 4) // Dec to Ascii (searching for MZ) _, err = f.Read(dosHeader) check(err) fmt.Println(&quot;[-----DOS Header / Stub----- header和stub解析]&quot;) fmt.Printf(&quot;[+] Magic Value: %s%s &quot;, string(dosHeader[0]), string(dosHeader[1])) // Validate PE+0+0 (Valid PE format) pe_sig_offset := int64(binary.LittleEndian.Uint32(dosHeader[0x3c:])) // 从0x3c后开始读取 f.ReadAt(sizeOffset, pe_sig_offset) // sizeoffset为buffer，pe_sig_offset是读取的位置 这里不加:可以吗？？ 读取0x50 0x45 0x00 0x00 fmt.Println(&quot;[-----Signature Header-----]&quot;) fmt.Printf(&quot;[+] LFANEW Value: %s &quot;, string(sizeOffset)) // Create the reader and read COFF Header sr := io.NewSectionReader(f, 0, 1&lt;&lt;63-1) // 读取到2^64次方-1 _, err = sr.Seek(pe_sig_offset+4, os.SEEK_SET) // 重置指针 check(err) binary.Read(sr, binary.LittleEndian, &amp;pefile.FileHeader) // 二进制读取 // Get size of OptionalHeader // 可选头解析 向加载程序提供重要数据，加载程序将可执行文件加载到虚拟内存 var sizeofOptionalHeader32 = uint16(binary.Size(pe.OptionalHeader32&#123;&#125;)) var sizeofOptionalHeader64 = uint16(binary.Size(pe.OptionalHeader64&#123;&#125;)) var oh32 pe.OptionalHeader32 var oh64 pe.OptionalHeader64 // type FileHeader struct &#123; // Machine uint16 // NumberOfSections uint16 // TimeDateStamp uint32 // PointerToSymbolTable uint32 // NumberOfSymbols uint32 // SizeOfOptionalHeader uint16 // Characteristics uint16 // &#125; // Read OptionalHeader switch pefile.FileHeader.SizeOfOptionalHeader &#123; case sizeofOptionalHeader32: binary.Read(sr, binary.LittleEndian, &amp;oh32) case sizeofOptionalHeader64: binary.Read(sr, binary.LittleEndian, &amp;oh64) &#125; // Print File Header fmt.Println(&quot;[-----COFF File Header-----]&quot;) fmt.Printf(&quot;[+] Machine Architecture: %#x &quot;, pefile.FileHeader.Machine) fmt.Printf(&quot;[+] Number of Sections: %#x &quot;, pefile.FileHeader.NumberOfSections) fmt.Printf(&quot;[+] Size of Optional Header: %#x &quot;, pefile.FileHeader.SizeOfOptionalHeader) // Print section names fmt.Println(&quot;[-----Section Offsets-----]&quot;) fmt.Printf(&quot;[+] Number of Sections Field Offset: %#x &quot;, pe_sig_offset+6) // this is the end of the Signature header (0x7c) + coff (20bytes) + oh32 (224bytes) fmt.Printf(&quot;[+] Section Table Offset: %#x &quot;, pe_sig_offset+0xF8) // Print Optional Header fmt.Println(&quot;[-----Optional Header-----]&quot;) // 如果对pe文件加入后门，需要对下面两项有所了解 fmt.Printf(&quot;[+] Entry Point: %#x &quot;, oh32.AddressOfEntryPoint) // 相对于imageBase的可执行代码位置 fmt.Printf(&quot;[+] ImageBase: %#x &quot;, oh32.ImageBase) // 将图像加载到内存时第一个字节位置 fmt.Printf(&quot;[+] Size of Image: %#x &quot;, oh32.SizeOfImage) // 图像的实际大小 fmt.Printf(&quot;[+] Sections Alignment: %#x &quot;, oh32.SectionAlignment) fmt.Printf(&quot;[+] File Alignment: %#x &quot;, oh32.FileAlignment) fmt.Printf(&quot;[+] Characteristics: %#x &quot;, pefile.FileHeader.Characteristics) fmt.Printf(&quot;[+] Size of Headers: %#x &quot;, oh32.SizeOfHeaders) fmt.Printf(&quot;[+] Checksum: %#x &quot;, oh32.CheckSum) fmt.Printf(&quot;[+] Machine: %#x &quot;, pefile.FileHeader.Machine) fmt.Printf(&quot;[+] Subsystem: %#x &quot;, oh32.Subsystem) fmt.Printf(&quot;[+] DLLCharacteristics: %#x &quot;, oh32.DllCharacteristics) // Print Data Directory fmt.Println(&quot;[-----Data Directory----- 数据目录解析，可选头的最后128字节]&quot;) var winnt_datadirs = []string&#123; &quot;IMAGE_DIRECTORY_ENTRY_EXPORT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_IMPORT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_RESOURCE&quot;, &quot;IMAGE_DIRECTORY_ENTRY_EXCEPTION&quot;, &quot;IMAGE_DIRECTORY_ENTRY_SECURITY&quot;, &quot;IMAGE_DIRECTORY_ENTRY_BASERELOC&quot;, &quot;IMAGE_DIRECTORY_ENTRY_DEBUG&quot;, &quot;IMAGE_DIRECTORY_ENTRY_COPYRIGHT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_GLOBALPTR&quot;, &quot;IMAGE_DIRECTORY_ENTRY_TLS&quot;, &quot;IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG&quot;, &quot;IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_IAT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR&quot;, &quot;IMAGE_NUMBEROF_DIRECTORY_ENTRIES&quot;, &#125; for idx, directory := range oh32.DataDirectory &#123; fmt.Printf(&quot;[!] Data Directory: %s &quot;, winnt_datadirs[idx]) fmt.Printf(&quot;[+] Image Virtual Address: %#x &quot;, directory.VirtualAddress) fmt.Printf(&quot;[+] Image Size: %#x &quot;, directory.Size) &#125; fmt.Println(&quot;[-----Section Table----- 解析分区表]&quot;) // 包含了相关分区的详细信息，与coff file header中numberofsections 匹配 for _, section := range pefile.Sections &#123; fmt.Println(&quot;[+] --------------------&quot;) fmt.Printf(&quot;[+] Section Name: %s &quot;, section.Name) fmt.Printf(&quot;[+] Section Characteristics: %#x &quot;, section.Characteristics) fmt.Printf(&quot;[+] Section Virtual Size: %#x &quot;, section.VirtualSize) fmt.Printf(&quot;[+] Section Virtual Offset: %#x &quot;, section.VirtualAddress) fmt.Printf(&quot;[+] Section Raw Size: %#x &quot;, section.Size) fmt.Printf(&quot;[+] Section Raw Offset to Data: %#x &quot;, section.Offset) fmt.Printf(&quot;[+] Section Append Offset (Next Section): %#x &quot;, section.Offset+section.Size) &#125; // s := pefile.Section(&quot;.text&quot;) // fmt.Printf(&quot;%v&quot;, *s) // &quot;Section Table Offset&quot; + (40bytes * number of sections)&#125;func check(e error) &#123; if e != nil &#123; log.Fatal(e) &#125;&#125;","tags":["Go","PE文件"],"categories":["Code","GO"]},{"title":"锁","path":"/Code/CPP/锁/","content":"1std::unique_lock&lt;std::recursive_mutex&gt; lock(sensor_handle_mutex); 1","tags":["cpp","mutex"],"categories":["Code","CPP"]},{"title":"visual studio 编译告警常见处理手段","path":"/Code/CPP/编译告警常见处理手段/","content":"[TOC] C2001 常量中有换行符 文件保存为 UTF-8 签名 C4100 “*” 类型未使用 windows 代码文件中使用 1UNREFERENCED_PARAMETER(X) 如果是在Qt中，则可以使用 1Q_UNUSED(X); 另外，也不建议使用上述两种方式。当实现接口或标准导出内的方法时，有一些参数没有被引用是相当常见的。编译器会发现未 使用的参数，并产生一个警告，有些组件甚至会认为这是一个错误。为避免发生如此情况， 将未使用的参数使用&#x2F;* 参数名 *&#x2F; 语法将其注释掉。不要使用 UNREFERENCED_PARAMETER（） 宏，因为其 1）太繁琐，2）并不能保证参数实际上真的未被引用。 最好的方法就是在函数接口中注释掉未使用的变量。 1LRESULT WndProc（HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM /* lParam */） C4805 操作类型混合不安全：一般在操作 bool 和 int 时会触发这一警告 简单处理就是不要使用这种作为判断的依据，要么用 bool 类型，要么用 int 类型。 也可以使用强制转换。 C4996GetVersionExA 被声明为已否决碰见这种情况，需要关闭项目的SDL检查。 1Project Properties &gt; Configuration Properties &gt; C/C++ &gt; General &gt; SDL checks关掉 其他 ‘qsort’：Use std::sort C5208出现这个问题的原因是 C 风格代码和 C++ 风格代码混用导致的，结构体在 C 和 C++ 中是不一样的： C 1234typedef struct&#123; char *yyy=new zzz[ttt];&#125;xxx; CPP 1234struct xxx &#123; char *yyy=new zzz[ttt];&#125;; 具体原因是：最新的C++20标准中，为了更好的实现模块module的特性，typedef 一个未命名的struct被限制为只能使用纯粹的c语言语法，它不能通过赋值进行类内初始化了。 所以修改的方案就是不要声明匿名结构体，在声明时创建结构体名。 C6387 警告内容：“***”可能是0，这不符合函数“****”的规范。 这个问题就是函数参数没有做校验，也就是判空等情况，如下所示代码就会出现该警告： 123456789101112131415m_hMutex = CreateMutex(NULL, TRUE, this-&gt;MutexName);if (GetLastError() == ERROR_ALREADY_EXISTS)&#123; if (WaitForSingleObject(m_hMutex, INFINITE) == WAIT_OBJECT_0) &#123; Unlock(m_hMutex); return FALSE; &#125; else &#123; g_hMutex = m_hMutex; MutexReleased = FALSE; return TRUE; &#125;&#125; 修改为如下所示： 123456789101112131415161718m_hMutex = CreateMutex(NULL, TRUE, this-&gt;MutexName);if (GetLastError() == ERROR_ALREADY_EXISTS)&#123;\tif (m_hMutex != NULL) // 添加判空逻辑\t&#123; if (WaitForSingleObject(m_hMutex, INFINITE) == WAIT_OBJECT_0) &#123; Unlock(m_hMutex); return FALSE; &#125; else &#123; g_hMutex = m_hMutex; MutexReleased = FALSE; return TRUE; &#125;\t&#125;&#125; LNK4098 LINK : warning LNK4098: 默认库“LIBCMT”与其他库的使用冲突；请使用 &#x2F;NODEFAULTLIB:library 简单处理就是在VS项目属性 -&gt; 链接器 -&gt; 命令行 中添加上述提示的内容。以 LIBCMT 库为例：添加内容如下所示： 1/NODEFAULTLIB:LIBCMT LNK4099 warning LNK4099: 未找到 PDB“cryptlib.pdb”(使用“cryptlib.lib(cryptlib.obj) 一般这种情况属于使用了开源库编译的lib，在项目中使用时，调试信息格式选择了 /zi 选项。因此会提示没有 obj 文件。 解决办法就是程序调试信息选择无即可。另外就是我们编译过程中如果需要调试信息格式，也就是pdb该怎么同时处理这两个问题：","tags":["CPP","visual studio"],"categories":["Code","CPP"]},{"title":"⏰ 时间处理","path":"/Code/CPP/时间处理/","content":"Simple Demo1234567891011#include &lt;iostream&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; time_t t; time(&amp;t); cout &lt;&lt; t &lt;&lt;endl; return 0;&#125; 以上代码会输出一个10位数，表示的是到当前时间的秒数，起点是 1970年1月1日 00:00:00 time_t 转换 string 转 time_t 12345678910111213141516time_t StringToDatetime(std::string str)&#123; char *cha = (char*)str.data(); // 将string转换成char*。 tm tm_; // 定义tm结构体。 int year, month, day, hour, minute, second;// 定义时间的各个int临时变量。 sscanf(cha, &quot;%d-%d-%d %d:%d:%d&quot;, &amp;year, &amp;month, &amp;day, &amp;hour, &amp;minute, &amp;second);// 将string存储的日期时间，转换为int临时变量。 tm_.tm_year = year - 1900; // 年，由于tm结构体存储的是从1900年开始的时间，所以tm_year为int临时变量减去1900。 tm_.tm_mon = month - 1; // 月，由于tm结构体的月份存储范围为0-11，所以tm_mon为int临时变量减去1。 tm_.tm_mday = day; // 日。 tm_.tm_hour = hour; // 时。 tm_.tm_min = minute; // 分。 tm_.tm_sec = second; // 秒。 tm_.tm_isdst = 0; // 非夏令时。 time_t t_ = mktime(&amp;tm_); // 将tm结构体转换成time_t格式。 return t_; // 返回值。&#125; time_t 转 string 123456789101112131415(1) time_t t=std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()); std::stringstream ss; ss&lt;&lt;std::put_time(std::localtime(&amp;t),&quot;%F %X&quot;); ss.str();(2) size_t strftime (char* ptr, size_t maxsize, const char* format, const struct tm* timeptr ); ptr:存储转换结果 maxsize:复制到ptr的最大字符数，包括结束符&#x27;\\0&#x27; format:转换格式，类似printf，可加入其他需要复制过去的字符 timeptr:时间 char buf[20]; tm* local_time = std::localtime(&amp;t); strftime(buf,sizeof(buf),&quot;%F %X&quot;,local_time); C++时间类使用C++时间类处理获取系统当前时间 日期和时间工具 - C++中文 - API参考文档 (apiref.com) 头文件 #include &lt;chrono&gt; 获取当前时间 1system_clock::time_point now = std::chrono::system_clock::now(); 将当前时间转换为time_格式 1time_t tt = std::chrono::system_clock::to_time_t(now); 将time_格式的时间转换为tm *格式 1struct tm* tmNow = localtime(&amp;tt); 将tm*格式的时间转换为可读的时间 12char date[20] = &#123; 0 &#125;;sprintf(date, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,(int)tmNow-&gt;tm_year + 1900, (int)tmNow-&gt;tm_mon + 1, (int)tmNow-&gt;tm_mday, (int)tmNow-&gt;tm_hour, (int)tmNow-&gt;tm_min, (int)tmNow-&gt;tm_sec); 最后，在C++中的话可以将char*字符串转换为std::string字符串来处理 1std::string timeNow(date);","tags":["C++","时间"],"categories":["Code","CPP"]},{"title":"文件后缀校验","path":"/Code/CPP/文件后缀校验/","content":"123456789101112#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; std::string fn = &quot;filename.conf&quot;; if(fn.substr(fn.find_last_of(&quot;.&quot;) + 1) == &quot;conf&quot;) &#123; std::cout &lt;&lt; &quot;Yes...&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;No...&quot; &lt;&lt; std::endl; &#125;&#125;","tags":["cpp"],"categories":["Code","CPP"]},{"title":"动态声明子类","path":"/Code/CPP/动态声明子类/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;class BaseClass &#123;public: BaseClass() &#123; cout&lt;&lt;&quot;BaseClass Construct&quot;&lt;&lt;endl; &#125; virtual ~BaseClass() &#123; cout&lt;&lt;&quot;BaseClass Destruct&quot;&lt;&lt;endl; &#125; virtual void TestFunction() &#123; cout&lt;&lt;&quot;BaseClass TestFunction&quot;&lt;&lt;endl; &#125;protected: int Test;&#125;; class SonClass : public BaseClass&#123;public: SonClass() &#123; cout&lt;&lt;&quot;SonClass Construct&quot;&lt;&lt;endl; &#125; virtual ~SonClass() &#123; cout&lt;&lt;&quot;SonClass Destruct&quot;&lt;&lt;endl; &#125; virtual void TestFunction() &#123; cout&lt;&lt;&quot;SonClass TestFunction&quot;&lt;&lt;endl; &#125;&#125;; typedef void *LPVOID;template&lt;class _baseClass, class _derivedClass&gt;bool DoDynamicSubclassing(_baseClass *pBaseObj)&#123; if(pBaseObj) &#123; static_assert(sizeof(_baseClass) == sizeof(_derivedClass), &quot;DynamicSubclassing to _derivedClass must not have its own members&quot;); _derivedClass _derivedClassinstance; LPVOID *pBaseVirtPtr = (LPVOID*)pBaseObj, *pDerivedVirtPtr = (LPVOID*)&amp;_derivedClassinstance; //assign the virtual ptr of the derived class *pBaseVirtPtr = *pDerivedVirtPtr; return true; &#125; return false;&#125; int main()&#123; BaseClass *Test = new BaseClass; cout &lt;&lt; *(int*)Test &lt;&lt; endl; DoDynamicSubclassing&lt;BaseClass, SonClass&gt;(Test); Test-&gt;TestFunction(); cout &lt;&lt; *(int*)Test &lt;&lt; endl; cout &lt;&lt; &quot; ————————- &quot; &lt;&lt;endl; BaseClass aaaa; cout &lt;&lt; *(int*)&amp;aaaa &lt;&lt; endl; DoDynamicSubclassing&lt;BaseClass, SonClass&gt;(&amp;aaaa); aaaa.TestFunction(); cout &lt;&lt; *(int*)&amp;aaaa &lt;&lt; endl; return 0;&#125;","tags":["cpp"],"categories":["Code","CPP"]},{"title":"各种宏定义用法整理","path":"/Code/CPP/宏定义/","content":"C语言ASCII字符、16进制和BCD码值互转，各种好用的宏定义取值1、把Ascii字符转16进制 1234567891011121314151617181920212223/***************************函数名:Ascii2Hex功能描述:把Ascii字符转16进制参数：Ascii字符返回：16进制***************************/unsigned char Ascii2Hex( unsigned char bAscii ) &#123;\tunsigned char bHex = 0; if( ( bAscii &gt;= 0 ) &amp;&amp; ( bChar &lt;= 9 ) ) &#123; bHex = bAscii + 0x30; &#125; else if( ( bAscii &gt;= 10 ) &amp;&amp; ( bAscii &lt;= 15 ) ) &#123; bHex = bAscii + 0x37; &#125; else &#123; bHex = 0xff; &#125; return bHex;&#125; 2、把16进制转Ascii字符 123456789101112131415161718192021222324252627/***************************函数名:Hex2Ascii功能描述:把16进制转Ascii字符参数：16进制返回：Ascii字符***************************/unsigned char Hex2Ascii( unsigned char bHex ) &#123;\tunsigned char bAscii = 0; if( ( bHex &gt;= &#x27;0&#x27; ) &amp;&amp; ( bHex &lt;= &#x27;9&#x27; ) ) &#123; bAscii = bHex - &#x27;0&#x27;; &#125; else if( ( bHex &gt;= &#x27;A&#x27; ) &amp;&amp; ( bHex &lt;= &#x27;F&#x27; ) ) &#123; bAscii = bHex - &#x27;7&#x27;; &#125; else if( ( bHex &gt;= &#x27;a&#x27; ) &amp;&amp; ( bHex &lt;= &#x27;f&#x27; ) ) &#123; bAscii = bHex - 0x57; &#125;\telse\t&#123; bAscii = 0xff;\t&#125; return bAscii;&#125; 3、把16进制转BCD值 12345678910/***************************函数名:Hex2Bcd功能描述:把16进制转BCD值参数：16进制值返回：BCD值***************************/u_8 Hex2Bcd( u_8 HexCode )&#123; return( ( HexCode % 10 ) + ( HexCode / 10 * 16 ) );&#125; 4、把BCD值转2进制 12345678910/***************************函数名:Bcd2Bin功能描述:把BCD值转2进制参数：BCD值返回：2进制值***************************/u_8 Bcd2Bin( u_8 BcdCode )&#123; return( ( ( ( BcdCode &gt;&gt; 4 ) &amp; 0x0F ) * 10 ) + ( BcdCode &amp; 0x0F )); &#125; 5、把2进制转BCD值 12345678910/***************************函数名:Bin2BCD功能描述:把2进制转BCD值参数：2进制值返回：BCD值***************************/u_8 Bin2BCD( u_8 BinCode )&#123; return( ( ( (BinCode)/10 ) &lt;&lt; 4 ) + ( (BinCode) %10 )); &#125; 6、把x值的第i位置为1 12/********把x值的第i位置为1*************/#define X_SETBIT( x , i ) ( (x) |= ( 0x1 &lt;&lt; (i) )) 7、把x值的第i位清为0 12/**********把x值的第i位清为0**********/#define X_CLRBIT( x , i ) ( (x) &amp;= ( ~( 0x01 &lt;&lt; (i) ))) 8、判断x值的第i位是否为1 12/*********判断x值的第i位是否为1**********/#define X_CHKBIT( x , i ) ( ((x) &gt;&gt; (i) ) &amp; 0x01 ) 9、x,y值中的最小值 12/*********x,y值中的最小值**********/#define X_MIN( x ,y ) (((x)&gt;(y))?(y):(x)) 10、x,y值中的最大值 12/*********x,y值中的最大值**********/#define X_MAX( x ,y ) (((x)&gt;(y))?(x):(y)) 11、取i值的低8位 12/*********取i值的低8位**********/#define GET_4_BYTE(i) (u_8)( ( (i) &amp; 0xFF ) &gt;&gt; 0 ) 12、取i值的8-16位 12/*********取i值的8-16位**********/#define GET_3_BYTE(i) (u_8)( ( (i) &amp; 0xFF00 ) &gt;&gt; 8 ) 13、取i值的16-24位 12/*********取i值的16-24位**********/#define GET_2_BYTE(i) (u_8)( ( (i) &amp; 0xFF0000 ) &gt;&gt; 16 ) 14、取i值的24-32位 12/*********取i值的24-32位**********/#define GET_1_BYTE(i) (u_8)( ( (i) &amp; 0xFF000000 ) &gt;&gt; 24 ) 15、4个字节为int型变量 12/*********4个字节为int型变量**********/#define BYTE_TO_INT( byte,byte1,byte2,byte3 ) ( (byte&lt;&lt;24) | (byte1 &lt;&lt; 16) | (byte2 &lt;&lt; 8) | byte3 ) 16、2个字节为short型变量 12/*********2个字节为short型变量**********/#define BYTE_TO_SHORT( byte ,byte1) ( (byte&lt;&lt;8) | byte1 ) 17、int型变量为4个字节 123456/*********int型变量为4个字节**********/#define INT_TO_BYTE( Val,byte ) do&#123; (byte)[0] = ((Val)&gt;&gt;24)&amp;0xff;\\ (byte)[1] = ((Val)&gt;&gt;16)&amp;0xff;\\ (byte)[2] = ((Val)&gt;&gt;8)&amp;0xff;\\ (byte)[3] = ((Val))&amp;0xff;\\ &#125;while(0) 18、short型变量为2个字节 1234/*********short型变量为2个字节**********/#define SHORT_TO_BYTE( Val ,byte) do&#123; (byte)[0] = ((Val)&gt;&gt;8)&amp;0xff;\\ (byte)[1] = (Val)&amp;0xff;\\ &#125;while(0) 19、标准时间time转换字符串输出 123456/*********标准时间time转换字符串输出**********/#define TIME_2_STR(t, str) do&#123; tm_t tmtime;\\ gmtime_r( (time_t *)&amp;t,&amp;tmtime );\\ sprintf(str,&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;,1900 + tmtime.tm_year, tmtime.tm_mon + 1, \\ tmtime.tm_mday,tmtime.tm_hour, tmtime.tm_min, tmtime.tm_sec);\\ &#125;while(0) 20、IP值转换IP字符串输出 12345/*********IP值转换IP字符串输出**********/#define IPADDR_2_STR(lIp, str) do&#123; u_8 ipaddr[4];\\ memcpy (&amp;(ipaddr[0]), &amp;(lIp), 4);\\ sprintf(str,&quot;%03d.%03d.%03d.%03d&quot;,ipaddr[0],ipaddr[1],ipaddr[2],ipaddr[3]);\\ &#125;while(0) 一、字符串化操作符# # 的功能：将#后面的宏参数转化成字符串。 使用条件：只能用于有传入参数的宏定义中，且#必须置于宏定义体中的参数名前。 123456789#include&lt;stdio.h&gt;// s是宏参数#define Str(s) #s //功能：使用Str(s)将s转化为字符串int main()&#123; printf(Str(HelloWorld)); return;&#125;//输出：HelloWorld 3.对空格的处理 123#define example1(instr) #instrstringstr=example1(abc)； 将会展成：string str=&quot;abc&quot;； 🥝 a、忽略传入参数名前面和后面的空格。 1如：str=example1( abc )； 将会被扩展成 str=&quot;abc&quot;； 🥝 b、当传入参数名间存在空格时，编译器将自动连接各个子字符串，用每个子字符串中只一个空格连接，忽略多余一个空格。 1如：str=exapme1( abc def ); 将会被扩展成 str=&quot;abc def&quot;； 宏定义作为宏参数，不展开，仍然作为字符串字面信息输出。 1234567891011#include &lt;limits.h&gt;#include &lt;stdio.h&gt;#define STR(s) #s int main()&#123; // INT_MAX是某个文件中定义的宏，\tprintf(&quot;int max: %s &quot;, STR(INT_MAX)); // 输出int max: INT_MAX\treturn 0;&#125; 二、符号连接操作符 ## ## 的功能: 将前后两个标识符连接形成一个标识符。 使用条件：只能用于有传入参数的宏定义中，且##必须置于宏定义体中的参数名前。 12345678910#include&lt;stdio.h&gt;#define Var(x) var##xint main()&#123; int Var(1)=1,Var(2)=2,Var(3)=3; printf(&quot;var1=%d &quot;,var1); printf(&quot;var2=%d &quot;,var2); printf(&quot;var3=%d &quot;,var3); return 0;&#125; 3.注意 a、当用##连接形参时，##前后的空格可有可无。 如：#define exampleNum(n) num ## n 相当于 #define exampleNum(n) num##nb、连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。连接之后只是组成了一个参数名，并没有定义，因此要求这个参数名需要是已经存在或者说已经被定义了的参数或宏定义。 c、当宏参数是另一个宏时，凡宏定义中存在#或##的地方，宏参数不会再展开。 （ 只有当前宏生效, 参数里的宏！不会生效 ！） ① 宏定义不存在’#‘和’##&#39;的情况 123456#define TOW (2) #define MUL(a,b) (a*b) printf(&quot;%d*%d=%d/n&quot;, TOW, TOW, MUL(TOW,TOW)); 这行的宏会被展开为： printf(&quot;%d*%d=%d/n&quot;, (2), (2), ((2)*(2))); MUL里的参数TOW会被展开为(2). ② 宏定义存在’#‘或’##&#39;的时候（#在上方有讲解） 12345678910111213141516171819202122232425262728#include &lt;limits.h&gt;#include &lt;stdio.h&gt;\t#define A 2 #define CONS(a,b) (int)(a##e##b) //ps：##放到宏参数后面相当于一个连接 无其他作用int main()&#123; // 由于A是宏，且作为宏CONS的参数，并且宏CONS##符号，所以A不能被解引用，因此上方程序编译报错。 printf(&quot;%d &quot;, CONS(A, A)); // compile error 无法展开\t//printf(&quot;%d &quot;, (int)(AeA)); return 0;&#125;// 报错信息如下：main.c: In function ‘main’:main.c:8:22: error: ‘AeA’ undeclared (first use in this function) 8 | printf(&quot;%d &quot;, CONS(A, A)); // compile error 无法展开 | ^main.c:5:26: note: in definition of macro ‘CONS’ 5 | #define CONS(a,b) (int)(a##e##b) //ps：##放到宏参数后面相当于一个连接 无其他作用 | ^main.c:8:22: note: each undeclared identifier is reported only once for each function it appears in 8 | printf(&quot;%d &quot;, CONS(A, A)); // compile error 无法展开 | ^main.c:5:26: note: in definition of macro ‘CONS’ 5 | #define CONS(a,b) (int)(a##e##b) //ps：##放到宏参数后面相当于一个连接 无其他作用 | ^","tags":["宏定义","用法"],"categories":["Code","CPP"]},{"title":"try-catch块","path":"/Code/CPP/try-catch块/","content":"[toc] 说明 Try 块： 将一或多个异常处理块（catch 子句）与复合语句关联。 声明一个具名形参的 catch 子句 1try &#123; /* */ &#125; catch (const std::exception&amp; e) &#123; /* */ &#125; 声明一个无名形参的 catch 子句 1try &#123; /* */ &#125; catch (const std::exception&amp;) &#123; /* */ &#125; catch-all 处理块，可被任何异常激活 1try &#123; /* */ &#125; catch (...) &#123; /* */ &#125;","tags":["C++","异常"],"categories":["Code","CPP"]},{"title":"C++ 仿函数","path":"/Code/CPP/仿函数/","content":"概述： C++ 防函数使用和说明 [toc] 仿函数顾名思义，就是”仿造函数”的意思，它并不是函数，但是却有着类似于函数的行为. 我们在编程的时候，有时候会发现这样一种情况：有一些相同的功能，会在不同的成员函数中出现. 这时候按照一般的技巧，我们会将这些相同的功能独立出来进行封装. 但是写一个公共函数的话，函数用到的一些变量就可能被迫成为公共的全局变量. 而且，仅仅为了复用这一片代码，就要单独写一个函数，也不是很好维护，这个时候就可以用仿函数了. 按照百度词条的说法：写一个简单的类，除了那些维护一个类的成员函数外，就**只是实现一个operator()**，在类实例化的时候，就将要用的，非参数的元素传入类中. 这样写的好处是： 免去了一些公共变量的全局化的维护. 可以使那些代码独立出来，以便下次复用. 这些仿函数还可以用关联，聚合，依赖的类之间的关系，与用到他们的类组合在一起，这样有利于资源的管理. 作用： 可替代函数指针，使用更加灵活 可存储状态，形成一种类似于闭包的机制 STL 提供的仿函数123456789101112131415161718192021222324252627graph LRA(STL提供的仿函数) --&gt; B(算术类仿函数)A --&gt; C(关系运算符仿函数)A --&gt; D(逻辑运算仿函数)A --&gt; E(&quot;位运算函数(since C++11)&quot;)B --&gt; B1(plus&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 相加B --&gt; B2(minus&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 相减B --&gt; B3(multiplies&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 相乘B --&gt; B4(divides&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 相除B --&gt; B5(modulus&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 取模B --&gt; B6(negate&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 取否C --&gt; C1(equal_to&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 等于C --&gt; C2(not_equal_to&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 不等于C --&gt; C3(greater&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 大于C --&gt; C4(greater_equal&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 大于等于C --&gt; C5(less&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 小于C --&gt; C6(less_equal&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 小于等于D --&gt; D1(logical_and&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 逻辑与D --&gt; D2(logical_or&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 逻辑或D --&gt; D3(logical_no&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 逻辑非E --&gt; E1(bit_and&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 按位与E --&gt; E2(bit_or&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 按位或E --&gt; E3(bit_xor&lt;&lt;a&gt;T&lt;/a&gt;&gt;) --&gt; 按位异或 STL 中 less&lt;T&gt; 的用法示例123456789101112131415161718192021222324252627282930313233343536/* /home/muten003/CPP/functor/002.cpp*/#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; class MyClass&#123;public: int x; int y; friend bool operator&lt;(MyClass a, MyClass b);&#125;; class Compare&#123; friend bool operator&lt;(MyClass a, MyClass b) &#123; return a.x &lt; b.x; &#125;&#125;; int main()&#123; less&lt;MyClass&gt; myclassLes; MyClass myclass[3]; myclass[0].x = 2; myclass[1].x = 1; myclass[2].x = 3; sort(myclass, myclass + 2, myclassLes); for_each(sortClass, sortClass + 3, [] (UseLessClass obj) &#123; cout &lt;&lt; obj.y &lt;&lt; &quot;:&quot; &lt;&lt; obj.x &lt;&lt; endl; &#125;);&#125; 输出： 11 2 3 使用仿函数的优点将一个个功能通过类来实现，大多数情况下会加大代码量. 仿函数也是如此，但是仿函数却有着许多优点,除了上述的有利于资源管理、有利于代码维护外,还具有这些特点 智能性：仿函数是通过仿函数类来实现的，既然是类，里面就可以储存许多变量还有其他的一些信息.我们可以利用这个特征实现许多纯的函数实现不了的功能，举个简单的例子：我若再仿函数中加入了统计调用函数次数的功能。那么在我使用仿函数的时候，就可以自动实现统计次数的功能. 所以说，更加智能。 灵活性：或者说，每个仿函数都可以有自己的类型. 由于仿函数是泛型编程的一个例证, 它可以任意 指定类型。 通常比一般函数速度更快：尤其是大量调用函数的过程中. 比如说：STL排序的时候,所需要的那个排序规则(为一个bool型的函数). 使用实例简单示例1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Compare&#123;public: bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;template &lt;class Function&gt;void comp(int a, int b, Function func)&#123; if (func(a, b)) &#123; cout &lt;&lt; b &lt;&lt; &quot; is bigger than &quot; &lt;&lt; a &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; a &lt;&lt; &quot; is bigger than &quot; &lt;&lt; b &lt;&lt; endl; &#125;&#125;int main()&#123; int a = 6; int b = 2; Compare com; comp(a, b, com);&#125; 与普通函数对比123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;class CompareObject &#123;public:\tvoid operator()() &#123; cout &lt;&lt; &quot;仿函数&quot; &lt;&lt; endl;\t&#125; // 重载\tvoid operator()(int number, int number2) &#123; cout &lt;&lt; &quot;仿函数&quot; &lt;&lt; endl;\t&#125;&#125;;// 查看c++ for_each源码自定义class ShowActionObj &#123;public:\tvoid operator()(int content) &#123; cout &lt;&lt; &quot;custom 仿函数&quot; &lt;&lt; content &lt;&lt; endl;\t&#125;&#125;;// 回调方式void showAction(int content) &#123;\tcout &lt;&lt; &quot;custom 普通函数&quot; &lt;&lt; content &lt;&lt; endl;&#125;int main() &#123; // 直接调用仿函数\tCompareObject fun1;\tfun1(); // 以回调方式调用\tset&lt;int&gt; setVar&#123; 10,20,30,40,50,60 &#125;;\tcout &lt;&lt; &quot;使用仿函数:&quot; &lt;&lt; endl;\tfor_each(setVar.begin(), setVar.end(), ShowActionObj());\tcout &lt;&lt; &quot;使用普通函数&quot; &lt;&lt; endl;\tfor_each(setVar.begin(), setVar.end(), showAction);\treturn 0;&#125; 输出如下所示： 123456789101112131415仿函数使用仿函数:custom 仿函数10custom 仿函数20custom 仿函数30custom 仿函数40custom 仿函数50custom 仿函数60使用普通函数custom 普通函数10custom 普通函数20custom 普通函数30custom 普通函数40custom 普通函数50custom 普通函数60 补充 for_eace 的源码： 1234567891011template &lt;class _InIt, class _Fn&gt;_CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) &#123; // perform function for each element [_First, _Last) _Adl_verify_range(_First, _Last); auto _UFirst = _Get_unwrapped(_First); const auto _ULast = _Get_unwrapped(_Last); for (; _UFirst != _ULast; ++_UFirst) &#123; _Func(*_UFirst); &#125; return _Func;&#125; 参考文章 C++仿函数_c++ 仿函数_我要精通C++的博客-CSDN博客 C++ 仿函数 - 简书","categories":["Code","CPP"]},{"title":"using 用法整理","path":"/Code/CPP/using/","content":"[toc] 简单整理一下using的用法 一、命名空间命名空间的用法相对简单哈 123456789101112131415using namespace std;using std::cout;//////////////////////////namepsapce nsmine &#123; void cout(); namespace minedefine &#123; #define MINE &quot;mine&quot; &#125;&#125;using namespace nsmine;using nsmine::minedefine; 二、使用using起别名相当于 typedef 12typedef std::vector&lt;int&gt; intvec;using intvec\t= std::vector&lt;int&gt;; 以上两种写法等价。同样两种方式也都适用于函数别名的声明。如下所示： 12// 代码 2-2typedef void (*FP) (int, const std::string&amp;); 代码 2-2 使用 typedef 为 void (int, const std::string&amp;) 创建了一个别名 FP。同样我们使用using来做这个操作，函数返回类型是void，接收参数为int,const std::string&amp; 1using Fp = void (*) (int, const std::string&amp;); using的写法把别名的名字强制分离到了左边，而把别名指向的放在了右边，比较清晰，可读性比较好。比如： 123typedef std::string (Foo::* fooMemFnPtr) (const std::string&amp;); using fooMemFnPtr = std::string (Foo::*) (const std::string&amp;);","categories":["Code","CPP"]},{"title":"std::future","path":"/Code/CPP/std/future/","content":"概述: std::future 的用法整理 [toc] 介绍 123#include &lt;future&gt;std::future &lt; T &gt; f std::future是C++11标准库（并发支持库）中的一个模板类，它表示一个异步操作的结果。当我们在多线程编程中使用异步任务时，std::future可以帮助我们在需要的时候获取任务的执行结果。std::future的一个重要特性是能够阻塞当前线程，直到异步操作完成，从而确保我们在获取结果时不会遇到未完成的操作。 成员函数 构造函数 future() noexcept: 默认构造函数。构造无共享状态的 std::future 。构造后， valid() &#x3D;&#x3D; false future( future&amp;&amp; other ) noexcept:移动构造函数。用移动语义，以 other 的共享状态构造 std::future 。构造后 other.valid() &#x3D;&#x3D; false 。 future( const future&amp; other ) = delete : 不可复制构造 (CopyConstructible) 。 析构函数 ~future(); operator&#x3D; future&amp; operator=( future&amp;&amp; other ) noexcept:释放任何共享状态并移动赋值 other 的内容给 *this 。赋值后， other.valid() &#x3D;&#x3D; false 且 this-&gt;valid() 将产生与 other.valid() 在赋值前相同的值。 future&amp; operator=( const future&amp; other ) = delete: 不可复制赋值 (CopyAssignable) 。 share() noexcept: 转移 *this 的共享状态到 std::shared_future 对象。多个 std::shared_future 对象可引用同一共享对象，调用后valid() &#x3D;&#x3D; false 。 T get(): get 方法等待直至 future 拥有合法结果并（依赖于使用哪个模板）获取它。它等效地调用 wait() 等待结果。泛型模板和二个模板特化各含单个 get 版本。 get 的三个版本仅在返回类型有别。若调用此函数前 valid() 为 false 则行为未定义。释放任何共享状态。调用此方法后valid() 为 false 。 bool valid(): 检查future是否可以共享状态。 wait(): 等待结果变得可用 wait_for wait_until 作用 异步操作的结果获取：std::future提供了一种机制，允许我们在多线程环境中安全地获取异步操作的结果。 隐藏异步操作的细节：std::future将异步操作的结果封装起来，使程序员无需关注线程同步和通信的具体实现细节。 线程同步：通过阻塞等待异步操作完成，std::future可以确保我们在继续执行其他操作之前，已经获取了所需的结果。 异常处理：std::future可以捕获异步操作中抛出的异常，并在获取结果时重新抛出，也可以在主线程中对其进行处理，从而使得异常处理更加简单。 提高性能：std::future使得我们能够更好地利用多核处理器的性能，通过并行执行任务来提高程序的执行效率。 使用场景异步任务当我们需要在后台执行一些耗时操作时，如文件读写、网络请求或计算密集型任务，std::future可以用来表示这些异步任务的结果。通过将任务与主线程分离，我们可以实现任务的并行处理，从而提高程序的执行效率。 并发控制在多线程编程中，我们可能需要等待某些任务完成后才能继续执行其他操作。通过使用std::future，我们可以实现线程之间的同步，确保任务完成后再获取结果并继续执行后续操作。 结果获取std::future提供了一种安全的方式来获取异步任务的结果。我们可以使用std::future::get()函数来获取任务的结果。此函数会阻塞当前线程，直到异步操作完成。这样，在调用get()函数时，我们可以确保已经获取到了所需的结果。如果异步操作中发生了异常，get()函数会将异常重新抛出，使得我们能够处理这些异常。 用法示例使用std::async关联异步任务使用std::async将任务与std::future关联。它创建并运行一个异步任务，并返回一个与该任务结果关联的std::future对象。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;chrono&gt;int long_running_task() &#123; std::this_thread::sleep_for(std::chrono::seconds(3)); return 42;&#125;int main() &#123; // std::future&lt;int&gt; 声明的类型与 long_running_task 返回值类型必须一致 std::future&lt;int&gt; result_future = std::async(std::launch::async, long_running_task); // 在此处执行其他操作 int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 使用std::promise与std::future配合std::promise是另一种与std::future配合使用的方式。我们可以使用std::promise对象来显式地设置任务的结果，而std::future对象则用于获取这个结果。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;thread&gt;void long_running_task(std::promise&lt;int&gt; result_promise) &#123; // 执行长时间运行的任务 int result = 42; // 将结果设置到promise对象中 result_promise.set_value(result);&#125;int main() &#123; std::promise&lt;int&gt; result_promise; std::future&lt;int&gt; result_future = result_promise.get_future(); // 创建一个新线程，执行长时间运行的任务 std::thread task_thread(long_running_task, std::move(result_promise)); // 在此处执行其他操作 int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; task_thread.join(); return 0;&#125; 结果获取与异常处理使用std::future::get() 函数可以获取异步任务的结果。此函数会阻塞当前线程，直到异步操作完成。如果异步操作中发生了异常，get()函数会将异常重新抛出。 :warning: 注意：std::future::get()函数只能被调用一次。在调用get()之后，std::future对象将变为无效状态。 :construction: 如果需要多次访问结果，可以考虑使用std::shared_future。 123456789101112131415161718try &#123; int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;&#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception caught: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#125; catch (...) &#123; std::cerr &lt;&lt; &quot;Unknown exception caught&quot; &lt;&lt; std::endl;&#125;std::chrono::milliseconds timeout(100);std::future_status status = result_future.wait_for(timeout);if (status == std::future_status::ready) &#123; int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;&#125; else &#123; std::cerr &lt;&lt; &quot;Timeout: the task is still running&quot; &lt;&lt; std::endl;&#125; 注意事项在使用std::future时，需要注意以下几点： std::future::get()函数只能被调用一次。调用get()之后，std::future对象将变为无效状态。如果需要多次访问结果，可以考虑使用std::shared_future。 std::future对象不可拷贝，但可以通过移动构造函数或移动赋值操作符进行转移。这意味着我们不能将std::future对象存储在容器中，除非使用std::shared_future或指针包装。 当使用std::async时，默认情况下，任务可能会在当前线程上下文中执行。这取决于库实现和系统资源。若要确保任务在新线程中执行，可以使用std::launch::async标志： std::future result_future &#x3D; std::async(std::launch::async, long_running_task); 如果std::future对象在析构时仍关联着一个有效的异步操作，且该操作尚未完成，析构函数会阻塞等待操作完成。在某些情况下，这可能导致程序死锁。为了避免这个问题，可以在析构std::future对象之前显式地调用wait()、wait_for()或wait_until()函数。 虽然std::future在获取异步任务结果和线程同步方面非常有用，但它并不能解决所有并发问题。例如，std::future无法用于实现复杂的并发模式，如线程池、工作窃取等。对于这些高级并发需求，可能需要使用其他库或者自定义实现。 使用std::promise和std::future时，需要确保在调用get()之前已经设置了对应的值，否则会导致未定义的行为。这可能需要对代码进行仔细的设计和调试，以确保正确的执行顺序。 std::future对象的生命周期需要仔细管理。如果std::future对象被提前销毁，那么关联的异步任务可能会变得不可访问。因此，需要确保在异步任务完成之前保持std::future对象的有效性。 在某些情况下，使用std::future可能会导致性能下降。例如，当多个线程频繁地等待异步操作结果时，可能会导致线程阻塞和上下文切换开销。为了避免这个问题，可以考虑使用非阻塞的方式查询异步操作状态，如std::future::wait_for()和std::future::wait_until()函数。这样，我们可以在异步操作未完成时执行其他任务，提高程序的响应性和并发性能。 std::future并不适用于所有场景。例如，它不适用于需要处理多个输入或输出结果的任务，或者需要实现动态任务依赖关系的场景。在这些情况下，可能需要寻找其他并发和同步解决方案。 虽然std::future提供了异常处理机制，但需要注意的是，一旦std::future::get()函数重新抛出异常，该异常需要在调用get()的线程中进行捕获和处理。这意味着需要在主线程和其他线程中设置适当的异常处理策略，以确保程序的稳定性和健壮性。 其他std::shared_futurestd::shared_future是std::future的一个变体，允许多个线程共享同一个异步操作的结果。与std::future不同，std::shared_future对象可以被拷贝，因此可以将其存储在容器中或在多个线程之间传递。此外，std::shared_future::get()函数可以被多次调用，而不会使std::shared_future对象变为无效状态。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;thread&gt;void print_result(std::shared_future&lt;int&gt; result_future) &#123; int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;&#125;int main() &#123; std::promise&lt;int&gt; result_promise; std::shared_future&lt;int&gt; result_future = result_promise.get_future().share(); std::thread t1(print_result, result_future); std::thread t2(print_result, result_future); result_promise.set_value(42); t1.join(); t2.join(); return 0;&#125; std::future_statusstd::future_status是一个枚举类型，表示异步操作的状态。它有三个可能的值： std::future_status::ready：异步操作已完成，结果可用。 std::future_status::timeout：异步操作尚未完成，等待已超时。 std::future_status::deferred：异步操作已被延迟，尚未启动（仅当使用std::launch::deferred策略创建std::future对象时才可能出现）。 我们可以使用std::future::wait_for()和std::future::wait_until()函数查询异步操作的状态，而无需阻塞当前线程。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;chrono&gt;int long_running_task() &#123; std::this_thread::sleep_for(std::chrono::seconds(3)); return 42;&#125;int main() &#123; std::future&lt;int&gt; result_future = std::async(std::launch::async, long_running_task); std::chrono::milliseconds timeout(1000); std::future_status status = result_future.wait_for(timeout); if (status == std::future_status::ready) &#123; int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Timeout: the task is still running&quot; &lt;&lt; std::endl; &#125;\t// 等待任务完成，以便正确获取结果\tint result = result_future.get();\tstd::cout &lt;&lt; &quot;Final result: &quot; &lt;&lt; result &lt;&lt; std::endl;\treturn 0;&#125; 在上面的示例中，我们使用了std::future::wait_for()函数来查询异步操作的状态。如果状态为std::future_status::ready，我们可以立即获取结果。否则，我们可以在等待期间执行其他任务，以提高程序的响应性和并发性能。最后，在退出main函数之前，我们会调用result_future.get()以确保正确获取异步操作的结果。","tags":["cpp","future","std"],"categories":["Code","CPP","std"]},{"title":"队列和栈的互相实现","path":"/Code/CPP/STL/队列和栈的互相实现/","content":"概述：1. 用队列实现栈；2. 用栈实现队列 队列: 先进先出 栈：先进后出 队列实现栈思路1. 实现12345678910111213141516171819202122232425262728293031323334class MyStack &#123;public: void Push(int val) &#123; if(queueSta.empty()) &#123; queueSta.push(val); &#125; else &#123; int cnt = queueSta.size(); queueSta.push(val); while(cnt-- &gt; 0) &#123; queueSta.push(queueSta.front()); queueSta.pop(); &#125; &#125; &#125; int Pop() &#123; int res = queueSta.front(); queueSta.pop(); return res; &#125; bool Empty() &#123;return queueSta.empty();&#125;; private: queue&lt;int&gt; queueSta;&#125;; 栈实现队列思路实现1234567891011121314151617181920212223242526class MyQueue &#123;public: void Push(int val) &#123; sta1.push(val); &#125; int Pop() &#123; if(sta2.empty()) &#123; while(!sta1.empty()) &#123; sta2.push(sta1.top()); sta1.pop(); &#125; &#125; int res = sta2.top(); sta2.pop(); return res; &#125; private: stack&lt;int&gt; sta1,sta2;&#125;;","tags":["cpp","队列","栈"],"categories":["Code","CPP","STL"]},{"title":"C++开发工作经验","path":"/Code/CPP/README/","content":"睡眠 123456头文件定义：#include &lt;thread&gt;std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒（1秒）等同：std::chrono::milliseconds dura(1000);std::this_thread::sleep_for(dura); 2. 随机字符串12345678910111213141516171819202122std::string SPString::RandomString(int length)&#123;\tstd::string chars&#123; &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot; &#125;;\tstd::random_device rd;\tstd::mt19937 generator(rd());\tstd::string output;\toutput.reserve(length);\tint len_chars = chars.length();\twhile (length &gt; 0)\t&#123; auto randNumb = generator(); while (randNumb &gt; len_chars &amp;&amp; length--) &#123; output.push_back(chars[randNumb % len_chars]); randNumb /= len_chars; &#125;\t&#125;\treturn output;&#125; 3. 随机数12345// 生成随机数 std::random_device rd;std::mt19937 gen(rd());std::uniform_int_distribution&lt;&gt; dis(0, 999);int nId = dis(gen);","categories":["Code","CPP"]},{"title":"C++常用写法整理","path":"/Code/CPP/STL/thread/C++常用写法整理/","content":"[toc] 线程睡眠1234567头文件定义：#include &lt;thread&gt;std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒（1秒）等同：std::chrono::milliseconds dura(1000);std::this_thread::sleep_for(dura);","tags":["stl","thread"],"categories":["Code","CPP","STL","thread"]},{"title":"Json11 C++ 用法总结","path":"/Code/CPP/Json11/","content":"[toc] 1234567891011121314151617181920212223242526std::string strMsg = R&quot;(&#123; &quot;user&quot; :&quot;test&quot;, &quot;status&quot;:&quot;login&quot;, //登录状态：login、logout &quot;result&quot;:&quot;1&quot;, //登录和登出结果，1表示成功，0表示失败 &quot;reason&quot;:&quot;&quot;, //原因，比如超时退出，准入策略限制导致登录失败等 &quot;token&quot;:&quot;xxx&quot; //token内容 &#125;)&quot;; std::string strMsg_empty = &quot;&quot;; Json::object jstest = Json::object&#123;&#125;; string err; const auto json = Json::parse(strMsg_empty, err, JsonParse::COMMENTS); jstest[&quot;msgtype&quot;] = &quot;test&quot;; jstest[&quot;data&quot;] = (json); Json json1 = Json(jstest); std::cout &lt;&lt; json1.dump();\tconst Json obj = Json::object(&#123; &#123; &quot;msgtype&quot;, &quot;TEST&quot; &#125;, &#123; &quot;data&quot;, json &#125;, &#125;); std::cout &lt;&lt; obj.dump() &lt;&lt; std::endl;","tags":["C++","Json"],"categories":["Code","CPP"]},{"title":"字符串类型转换整理(char、TCHAR、string、wstring、CString、WCHAR)","path":"/Code/CPP/C++字符串类型相互转换/","content":"[TOC] string &lt;–&gt; CStringstring -&gt; CString12345std::string str = &quot;string&quot;;CString csRet;// csRet.Format(&quot;%s&quot;, str.c_str());// 如果上句报错就使用csRet.Format(_T(&quot;%s&quot;), str.c_str()); CString -&gt; string123CString cstr(&quot;string&quot;);string string &lt; – &gt; wstringstring -&gt; wstringsolution 1： 12345678910#include &lt;string&gt;#include &lt;locale&gt;#include &lt;codecvt&gt; //convert string to wstringinline std::wstring to_wide_string(const std::string&amp; input)&#123;\tstd::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; converter;\treturn converter.from_bytes(input);&#125; solution 2: 1234567891011121314151617wstring stringToWstring(std::string str)&#123; wstring result = L&quot;&quot;; int nLen = MultiByteToWideChar(CP_ACP, 0, str.c_str(), str.size(), NULL, 0); if (nLen == 0) return result; TCHAR* buffer = new TCHAR[nLen + 1]; MultiByteToWideChar(CP_ACP, 0, str.c_str(), str.size(), buffer, nLen); buffer[nLen] = &#x27;\\0&#x27;; result.append(buffer); delete[] buffer; return result;&#125; wstring -&gt; string123456//convert wstring to string inline std::string to_byte_string(const std::wstring&amp; input)&#123;\tstd::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; converter;\treturn converter.to_bytes(input);&#125; DWORD &lt;—&gt; string12345string DwordToString(DWORD val)&#123;\tstring cur_str = to_string(long long (val));\treturn cur_str;&#125; 123456DWORD StringToDword(string val)&#123;\tDWORD cur_dword;\tsscanf(val.c_str(),&quot;%ul&quot;,&amp;cur_dword);\treturn cur_dword;&#125; 更多查看已实现的编码转换文件： win_str_utils win_str_utils.md","tags":["C++","String"],"categories":["Code","CPP"]},{"title":"Lambda表达式","path":"/Code/CPP/Lambda表达式/","content":"概述：lambda表达式使用及说明 [toc] lambda表达式说明lambda表达式的结构如下所示： 1auto func = [capture] (params) opt -&gt; ret &#123; func_body; &#125;; 其中 func 是可以当作 lambda 表达式的名字，作为一个函数使用，capture 是捕获列表，params 是参数表，opt： 不需要可以省略。 （mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ()）， ret 是返回值类型，func_body 是函数体。 12auto f = [](int a) -&gt; int &#123; return a + 1; &#125;;std::cout &lt;&lt; f(1) &lt;&lt; std::endl; // 输出: 2 使用 lambda 表达式捕获列表lambda 表达式还可以通过捕获列表捕获一定范围内的变量： [] 不捕获任何变量。 [&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。 [&#x3D;] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。 [&#x3D;，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。 [bar] 按值捕获 bar 变量，同时不捕获其他变量。 [this] 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 &#x3D;，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。 捕获列表使用实例12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;functional&gt;using namespace std;class lambdaTest&#123;public:\tvoid output(int x, int y)\t&#123; //auto x1 = [] &#123;return m_number; &#125;; // error auto x2 = [=] &#123;return m_number + x + y; &#125;; // ok // auto x3 = [=] &#123; x = 2; return m_number + x + y; &#125;;\t// error auto x4 = [&amp;] &#123;return m_number + x + y; &#125;; // ok auto x5 = [this] &#123;return m_number; &#125;; // ok //auto x6 = [this] &#123;return m_number + x + y; &#125;; // error auto x7 = [this, x, y] &#123;return m_number + x + y; &#125;; // ok\t&#125;\tint m_number = 100;&#125;;int main()&#123;\tlambdaTest test;\ttest.output(1,2);&#125; 函数 是否可读 是否可修改 说明 x1 :x: :x: 错误，没有捕获外部变量，不能使用任何外部变量 x2 :heavy_check_mark: :x: 正确，值传递，可以访问所有外部变量 x3 :heavy_check_mark: :x: 错误，值传递，右值可读不可修改 x4 :heavy_check_mark: :heavy_check_mark: 正确，引用传递，可读可修改 x5 :heavy_check_mark: this指针的成员变量可读:x: 其他变量不可读 :heavy_check_mark: this指针的成员可写:x: 其他变量不可写 正确，捕获this指针，可访问this指针的成员 x6 同 x5 同 x5 错误，捕获 this 指针，x 和 y 不是其成员变量，不可访问 x7 :heavy_check_mark: 值传递三个变量，均可读 :heavy_check_mark: this指针成员可修改 :x: x 和 y 不可修改 正确，捕获 this 指针，x,y 返回值lambda表达式的返回值通过 ‘-&gt;’ 传递，如下所示： 123auto add = [](int x, int y) -&gt; int &#123; return x + y;&#125;； 如上所示的返回类型还可以使用 decltype 推导返回类型： decltype 是一个 C++ 关键字，它用于在编译时推断表达式的类型。这在编写通用代码时非常有用，特别是在使用 C++11 引入的 auto 关键字和范围 for 循环时。 123auto add = [](int x, int y) -&gt; decltype(x+y) &#123; return x + y;&#125;； 说明：decltype(a + b) 推导了 a + b 的结果类型，并将该类型作为 lambda 函数的返回类型。 甚至，从 C++14 开始，还可以使用更简洁的方式来推导 lambda 函数的返回类型，即使用 auto 关键字。例如： 1auto myLambda = [](int a, int b) -&gt; auto &#123; return a + b; &#125;; 需要注意的是，使用 auto 推导返回类型的 lambda 函数在某些情况下可能会引发歧义。例如，如果你在 lambda 表达式中返回一个嵌套类型（如 std::pair），auto 可能会被推导为 std::pair，而不是你期望的嵌套类型的具体类型。在这种情况下，使用 decltype 可以更明确地指定返回类型。 其他关键字使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。 mutable123int a = 0;auto f1 = [=] &#123;return a++; &#125;; // error, 按值捕获外部变量, a是只读的auto f2 = [=]()mutable &#123;return a++; &#125;; // ok :tipping_hand_man: 注意：mutable 只是允许在函数内部修改值而已，作用域仅限于 lambda 函数内部，参考以下代码及输出： 12345678910111213141516171819202122232425262728void lambdaFunc()&#123;\tauto add1 = [](int x, int y) -&gt; int &#123; return x + y;\t&#125;;\tauto add2 = [](int x, int y) -&gt; decltype(x + y) &#123; return x + y;\t&#125;;\tauto add3 = [](int a, int b) -&gt; auto &#123; return a + b; &#125;; auto modify_add = [](int a, int b) mutable -&gt; auto &#123; a = 3; return a + b; &#125;;\tauto value_modify_add = [=](int a, int b) mutable -&gt; auto &#123; a = 4; return a + b; &#125;;\tauto refrence_modify_add = [&amp;](int a, int b) mutable -&gt; auto &#123; a = 5; return a + b; &#125;;\tauto refrence_modify_add_byRef = [&amp;](int&amp; a, int b) mutable -&gt; auto &#123; a = 6; return a + b; &#125;;\tint x = 2, y = 2;\tcout &lt;&lt; &quot;add1:&quot; &lt;&lt; add1(x, y) &lt;&lt; endl; // add1:4\tcout &lt;&lt; &quot;add2:&quot; &lt;&lt; add2(x, y) &lt;&lt; endl; // add2:4\tcout &lt;&lt; &quot;add3:&quot; &lt;&lt; add3(x, y) &lt;&lt; endl; // add3:4\tcout &lt;&lt; &quot;modify_add:&quot; &lt;&lt; value_modify_add(x, y) &lt;&lt; endl; // modify_add:5\tcout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=2\tcout &lt;&lt; &quot;value_modify_add:&quot; &lt;&lt; value_modify_add(x, y) &lt;&lt; endl; // value_modify_add:6\tcout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=2\tcout &lt;&lt; &quot;value_modify_add:&quot; &lt;&lt; refrence_modify_add(x, y) &lt;&lt; endl; // value_modify_add:7\tcout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=2\tcout &lt;&lt; &quot;refrence_modify_add_byRef:&quot; &lt;&lt; refrence_modify_add_byRef(x, y) &lt;&lt; endl; // refrence_modify_add_byRef:8\tcout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=6&#125; 关于为什么通过值拷贝的方式捕获的外部变量是只读的:lambda表达式的类型在C++11中会被看做是一个带 operator() 的类，即仿函数。按照C++标准，lambda表达式的 operator() 默认是 const 的，一个 const 成员函数是无法修改成员变量值的。mutable 选项的作用就在于取消 operator () 的 const 属性。 因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式： 1234567891011121314151617181920212223void testLambdawithfunction()&#123;\t// 包装可调用函数\tstd::function&lt;int(int)&gt; f1 = [](int a) &#123;return a; &#125;;\t// 绑定可调用函数\tstd::function&lt;int(int)&gt; f2 = bind([](int a) &#123;return a; &#125;, placeholders::_1);\t// 绑定可修改的函数\tstd::function&lt;int(int&amp;, int)&gt; f3 = [](int&amp; a, int b) &#123; a = 3; return a + b; &#125;;\t// 绑定可修改的函数\tstd::function&lt;int(int&amp;, int)&gt; f4 = bind([](int&amp; a, int b) &#123; a = 4; return a + b; &#125;, std::placeholders::_1, std::placeholders::_2);\tint x = 2, y = 2;\t// 函数调用\tcout &lt;&lt; &quot;f1(100)&quot; &lt;&lt; f1(100) &lt;&lt; endl; // f1(100)100\tcout &lt;&lt; &quot;f2(200)&quot; &lt;&lt; f2(200) &lt;&lt; endl; // f2(200)200\tcout &lt;&lt; &quot;f3(x, y)&quot; &lt;&lt; f3(x, y) &lt;&lt; endl; // f3(x, y)5\tcout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=3\tcout &lt;&lt; &quot;f3(x, y)&quot; &lt;&lt; f4(x, y) &lt;&lt; endl; // f3(x, y)6\tcout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=4&#125; 对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针： 123456789using func_ptr = int(*)(int);// 没有捕获任何外部变量的匿名函数func_ptr f = [](int a)&#123; return a; &#125;;// 函数调用f(1314); 参考文章 C++——Lambda函数_c++ lambda函数_勿在浮沙築高臺的博客-CSDN博客","categories":["Code","CPP"]},{"path":"/Code/C/goto妙用/","content":"当一个条件不满足，函数要退出时，已经申请的内存没有释放，但是又需要return的情况下，可以使用goto 以下边的函数为例，在判断if(pRet[i] == NULL)时，如果为空时，如果直接return的话，那么已经申请内存的pRet则成了流浪儿，未能完全释放。在这种情况下就可以使用return语句直接调到程序的末尾去执行释放的操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 /* * @fn Merge * @brief 根据输入的int变量求其对应的hash值 * @param[in] intervals: 需要合并的数组 intervalsSize: 需要合并的数组的大小 intervalsColSize: 需要合并的数组的数量 * @param[out]\treturnSize: 合并区间后数组的大小 returncolumnSizes: 合并区间后数组的数量 * @return int: 根据哈希生成的key值 * * @detail * @date 2021-7-20 */int** Merge(_In_ int** intervals, _In_ int intervalsSize, _In_ int* intervalsColSize, _Out_ int* returnSize, _Out_ int** returnColumnSizes)&#123;\t// 如果只有一个区间，直接返回 TODO:有必要的情况下-》申请内存\tif(intervalsSize == 1)\t&#123; return intervals;\t&#125; int nItem = 0; // 第一个元素从小到大排序；如果第一个元素相等，则根据第二个元素从小到大排序 qsort(intervals, intervalsSize, sizeof(int *), Compare); int **pRet = (int**)malloc(sizeof(int*)*ARRSIZE_MAX_N); if(pRet == NULL) &#123; return NULL; &#125; // 定义返回指针 for(int i=0; i&lt;intervalsSize; i++) &#123; pRet[i] = (int*)malloc(sizeof(int)*intervalsColSize[0]); if(pRet[i] == NULL) &#123;- return NULL;+ goto END; &#125; memset(pRet[i],0,sizeof(int)*intervalsColSize[0]); &#125; // 先将第一个区间存入 pRet[nItem][0] = intervals[0][0]; pRet[nItem][1] = intervals[0][1]; //遍历合并到pRet for(int i=0; i &lt; intervalsSize; i++) &#123; // 当前区间起点小于合并区间终点-》覆盖 if(intervals[i][0] &lt;= pRet[nItem][1] &amp;&amp; intervals[i][1] &gt;= pRet[nItem][1]) &#123; pRet[nItem][1] = intervals[i][1]; &#125; // 当前区间的起点大于合并区间的终点-》下一节点 else if(intervals[i][0] &gt; pRet[nItem][1]) &#123; (nItem)++; pRet[nItem][0] = intervals[i][0]; pRet[nItem][1] = intervals[i][1]; &#125; &#125; // 返回结果 *returnSize = nItem + 1; *returnColumnSizes = intervalsColSize; return pRet;// Issue+END:+\tfree(pRet);+\treturn NULL;&#125;","categories":["Code","C"]},{"title":"C++内存分配","path":"/Code/CPP/C++内存分配/","content":"C++ 程序运行期间内存分配整理 [toc] new 内存分配在C++中，使用new关键字分配的内存是在虚拟内存中。虚拟内存是一种抽象概念，它允许程序以连续且固定大小的内存地址空间运行，而不管物理内存的实际配置如何。 当你使用new在C++中创建一个对象或数组时，内存管理器会在堆内存中分配一块空间，并返回指向这块空间的指针。即使这块空间超出了程序当前的实际物理内存，操作系统也会通过页面调度和内存映射机制来确保程序的正确运行。 因此，使用new分配的内存是在虚拟内存中，但操作系统会根据物理内存的实际配置进行管理。","tags":["C++","内存分配"],"categories":["Code","CPP"]},{"path":"/Cover/index.html","content":"🤞👉👇点击图片即可下载 PPT封面通用.pptx 通用背景 封面Qt windows 网络编程 数据结构与算法 C++ 其他"},{"path":"/Demo/index.html","content":"All_Language_Code_Source不区分编程语言，分享的代码段均可以push 博客holdyounger.github.io 语言 Go Python Qt Visual Studio"},{"path":"/UML/index.html","content":"UML 绘图[toc] UML 示例散文件升级.puml"},{"path":"/music/index.html","content":""},{"path":"/resour/index.html","content":"[TOC] 🍳Typora🔧Typora破解🔧Typora主题🍎Viewdll.exe💻内存泄漏检测工具VLD[🧵Cheat Engine](..&#x2F;..&#x2F;resour&#x2F;Cheat Engine&#x2F;CheatEngine75.exe)🔮网速控制工具[🔮Beyond Compare绿色版](..&#x2F;..&#x2F;resour&#x2F;Beyond Compare v4.1.4.20978 x64.exe)🔮PEview🔮OCAM 录屏软件"},{"path":"/xmind/index.html","content":"[TOC] 深入理解windows操作系统.xmindQt类图.pngQt 动画框架结构.xind"},{"path":"/Demo/Python/README.html","content":"Welcome to Python Demo 👋 python 学习及脚本整理 🏠 HomepageAuthor👤 mingming Website: github.com&#x2F;holdyounger Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! 项目介绍 扫描文件夹并展示 扫描和统计代码行数 文本文件编码检测与转换 python socket 客户端python socket 服务端 This README was generated with ❤️ by readme-md-generator"},{"path":"/Demo/Python/index.html","content":"Welcome to Python Demo 👋 python 学习及脚本整理 🏠 HomepageAuthor👤 mingming Website: github.com&#x2F;holdyounger Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! 项目介绍 扫描文件夹并展示 扫描和统计代码行数 文本文件编码检测与转换 python socket 客户端python socket 服务端 This README was generated with ❤️ by readme-md-generator"},{"path":"/Demo/Go/README.html","content":"Welcome to Go Demo For Learn 👋 GoLang 学习demo [toc] 🏠 HomepageAuthor👤 mingming Github: @hodlyounger Hello World基础语法学习记录排序算法设计模式 项目推荐Github 好的 golang 项目推荐 senghoo&#x2F;golang-design-pattern: 设计模式 Golang实现－《研磨设计模式》读书笔记 unknwon&#x2F;the-way-to-go_ZH_CN: 《The Way to Go》中文译本，中文正式名《Go 入门指南》 Show your supportGive a ⭐️ if this project helped you! This README was generated with ❤️ by readme-md-generator"},{"path":"/Demo/Go/index.html","content":"Welcome to Go Demo For Learn 👋 GoLang 学习demo [toc] 🏠 HomepageAuthor👤 mingming Github: @hodlyounger 项目介绍学习 golang 的记录 Hello World基础语法学习记录排序算法设计模式 Show your supportGive a ⭐️ if this project helped you! This README was generated with ❤️ by readme-md-generator"},{"path":"/Demo/Qt/README.html","content":"Welcome to Qt Demo 👋 Qt Code For Learning 🏠 HomepageAuthor👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! This README was generated with ❤️ by readme-md-generator"},{"path":"/Demo/Qt/index.html","content":"Welcome to Qt Demo 👋 Qt Code For Learning 🏠 HomepageAuthor👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! This README was generated with ❤️ by readme-md-generator"},{"title":"说明","path":"/Demo/Visual Studio/README.html","content":"[toc] WindowsVs工程 迭代文件路径 获取处理器数量 获取主机域名 获取驱动文件类型 遍历网卡 获取Tcp端口 获取文件状态 获取系统状态 打开注册表 注册表类型 WaitForSingleObject 获取进程快照 QtQt回车符 QTextCodec C++break用法 引用传值 创建服务 EnumPrint Json11 Demo C实现string 反转链表C++ 翻转链表C TCP客户端和服务端 set容器 Socket通信"},{"title":"说明","path":"/Demo/Visual Studio/index.html","content":"[toc] WindowsVs工程 迭代文件路径 获取处理器数量 获取主机域名 获取驱动文件类型 遍历网卡 获取Tcp端口 获取文件状态 获取系统状态 打开注册表 注册表类型 WaitForSingleObject 获取进程快照 QtQt回车符 QTextCodec C++break用法 引用传值 创建服务 EnumPrint Json11 Demo C实现string 反转链表C++ 翻转链表C TCP客户端和服务端 set容器 Socket通信"},{"path":"/Demo/Vue/README.html","content":"Welcome to Vue Demo 👋 Vue 学习记录 🏠 HomepageAuthor👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! 项目介绍 vue语法 local_AppB站教程学习记录，vue语法使用以及记事本等简单demo实现 vue 使用api demo NetApp请求api接口实现每日一言功能 This README was generated with ❤️ by readme-md-generator"},{"path":"/Demo/Vue/index.html","content":"Welcome to Vue Demo 👋 Vue 学习记录 🏠 HomepageAuthor👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! 项目介绍 vue语法 local_AppB站教程学习记录，vue语法使用以及记事本等简单demo实现 vue 使用api demo NetApp请求api接口实现每日一言功能 This README was generated with ❤️ by readme-md-generator"},{"title":"Go基础","path":"/Demo/Go/shiyanlou_Handbook/ReadMe.html","content":"Go语言顺序编程流程控制Go 语言提供的流程控制语句包括 if、switch、for、goto、select，其中 select 用于监听 channel（通道）在讲解通道的时候再详细介绍。 if 语句语法： 1234567if optionalStatement1; booleanExpression1 &#123; block1&#125; else if optionalStatement2; booleanExpression2 &#123; block2&#125; else &#123; block3&#125; 其中 optionalStatement 是可选的表达式，真正决定分支走向的是 booleanExpression1 的值。 for 语句Go 语言的 for 语句可以遍历数组，切片，映射等类型，也可以用于无限循环。以下是其语法： 123456789101112131415for &#123; // 无限循环 block&#125;for booleanExpression &#123; // while循环，在Go语言中没有while关键字&#125;for index, char := range aString &#123; // 迭代字符串&#125;for item := range aChannel &#123; // 迭代通道&#125; 跳转语句Go 语言中使用 goto 关键字实现跳转。goto 语句的语义非常简单，就是跳转到本函数内的某个标签，例如： 123456789func myfunc()&#123; i := 0 THIS: //定义一个THIS标签 fmt.Println(i) i++ if i &lt; 1 &#123; goto THIS //跳转到THIS标签 &#125;&#125; switch语句Go 语言中 switch 分支既可用于常用的分支就像 C 语言中的 switch 一样，也可以用于类型开关，所谓类型开关就是用于判断变量属于什么类型。但是需要注意的是 Go 语言的 switch 语句不会自动贯穿，相反，如果想要贯穿需要添加 fallthrough 语句。表达式开关 switch 的语法如下： 123456switch optionalStatement; optionalExpression &#123; case expression1: block1 ... case expressionN: blockN default: blockD&#125; 下面是个例子： 12345678switch &#123; // 没有表达式，默认为True值，匹配分支中值为True的分支 case value &lt; minimum: return minimum case value &gt; maximum: return maximum default: return value&#125; 在上面的例子中，switch 后面没有默认的表达式，这个时候 Go 语言默认其值为 True。 在前面我们提到过类型断言，如果我们知道变量的类型就可以使用类型断言，但是当我们知道类型可能是许多类型中的一种时候，我们就可以使用类型开关。其语法如下： 123456switch optionalStatement; typeSwitchGuard &#123; case type1: block1 ... case typeN: blockN default: blockD&#125; 说了这么多，让我们进行下练习，创建源文件 switch_t.go，输入以下代码： 😎😎这个demo很重❗❗❗❗❗❗❗&gt;😎😎 1 以上代码中我们首先创建了一个接收任意数量任意类型参数的函数，然后使用 for ... range aSlice 的语法迭代了每一个在切片 items 中的元素，接着使用了 switch 类型开关判断了每一个参数的类型，并打印了其值和类型。程序运行输出如下： 1234567$ go run switch_t.goparam #0 is a int, value: 5param #1 is a float64, value: -17.980000param #2 is a string, value: AIDENparam #3 is a nilparam #4 is a bool, value: trueparam #5&#x27;s type is unknow 函数Go 语言可以很方便的自定义函数，其中有特殊的函数 main 函数。main 函数必须出现在 main 包里，且只能出现一次。当 Go 程序运行时候会自动调用 main 函数开始整个程序的执行。main 函数不可接收任何参数，也不返回任何结果。 函数的定义在 Go 语言中，函数的基本组成包括：关键字 func、函数名、参数列表、返回值、函数体和返回语句，这里我们用一个简单的加法函数来对函数的定义进行说明。 12345package addfunc Add(a int, b int) (num int)&#123; return a + b&#125; 函数的调用函数调用非常简单，先将被调用函数所在的包导入，就可以直接使用该函数了。注意需要把包文件夹放到 $GOPATH 目录中，实例如下： 1234567891011package mainimport ( &quot;add&quot; //导入 add 包 &quot;fmt&quot;)func main()&#123; c := add.Add(1, 2) //调用 add 包中的 add 函数 fmt.Println(c)&#125; 与 C&#x2F;C++ 和 JAVA 不同，Go 语言的函数和方法可以有多个返回值，这是 Go 提供的一个优美的特性，示例如下： 12345678910package Divideimport &quot;errors&quot;func divide (a int, b int) (num int, err error)&#123; //定义两个返回值 if b == 0 &#123; err = errors.New(&quot;被除数不能为零！&quot;) return &#125; return a / b, nil //支持多个返回值&#125; 匿名函数在 Go 语言中，你可以在代码里随时定义匿名函数，匿名函数由一个不带函数名的函数声明和函数体组成，示例如下： 123func (a, b, c int) bool &#123; return a * b &lt; c&#125; 你可以将匿名函数直接赋值给一个变量，也可以直接调用运行，示例如下： 1234567x := func (a, b, c int) bool &#123; return a * b &lt; c&#125;func (a, b, c int) bool &#123; return a * b &lt; c&#125; (1, 2, 3) //小括号内直接给参数列表表示函数调用 类型转换类型转换Go 语言提供了一种在不同但相互兼容的类型之间相互转换的方式，这种转换非常有用并且是安全的。但是需要注意的是在数值之间进行转换可能造成其他问题，如精度丢失或者错误的结果。以下是类型转换的语法： resultOfType := Type(expression) 几个例子： 1234x := int16(2345) // 声明一个类型为int16的整数，其值为2345y := int32(x) // 将int16类型的整数转换为int32类型a := uint16(65000) // 声明一个类型为uint16类型的整数b := int16(a) // 转换为int16类型，虽然能转换成功，但是由于65000超过in16类型的范围，会导致结果错误，b的值为 -536 另外在 Go 语言中可以通过 type 关键字声明类型，如 type StringsSlice []string 将 []string（string 类型的切片）声明为 StringSlice 类型。 类型断言说到类型断言就需要先了解下 Go 语言中的接口。在 Go 语言中接口是一个自定义类型。它声明了一个或者多个方法。任何实现了这些方法的对象（类型）都满足这个接口。 接口是完全抽象的，不能实例化。interface&#123;&#125; 类型表示一个空接口，任何类型都满足空接口。也就是说 interface&#123;&#125; 类型的值可以用于表示任意 Go 语言类型的值。 这里的空接口有点类似于 Python 语言中的 object 实例。既然 interface&#123;&#125; 可以用于表示任意类型，那有的时候我们需要将 interface&#123;&#125; 类型转换为我们需要的类型，这个操作称为类型断言。 一般情况下只有我们希望表达式是某种特定类型的值时才使用类型断言。Go 语言中可以使用以下语法： resultOfType, boolean := expression.(Type)：安全的类型断言。 resultOfType := expression.(Type)：非安全的类型断言，失败时程序会产生异常。 创建源文件 type_t.go，输入以下源文件： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)func main() &#123; x := uint16(65000) y := int16(x) // 将 x转换为int16类型 fmt.Printf(&quot;type and value of x is: %T and %d &quot;, x, x) // %T 格式化指令的作用是输出变量的类型 fmt.Printf(&quot;type and value of y is: %T and %d &quot;, y, y) var i interface&#123;&#125; = 99 // 创建一个interface&#123;&#125;类型，其值为99 var s interface&#123;&#125; = []string&#123;&quot;left&quot;, &quot;right&quot;&#125; j := i.(int) // 我们假设i是兼容int类型，并使用类型断言将其转换为int类型 fmt.Printf(&quot;type and value of j is: %T and %d &quot;, j, j) if s, ok := s.([]string); ok &#123; // 创建了影子变量，if的作用域中覆盖了外部的变量s fmt.Printf(&quot;%T -&gt; %q &quot;, s, s) &#125;&#125; 运行程序： 12345$ go run type_t.gotype and value of x is: uint16 and 65000type and value of y is: int16 and -536type and value of j is: int and 99[]string -&gt; [&quot;left&quot; &quot;right&quot;] 类型断言说到类型断言就需要先了解下 Go 语言中的接口。在 Go 语言中接口是一个自定义类型。它声明了一个或者多个方法。任何实现了这些方法的对象（类型）都满足这个接口。 接口是完全抽象的，不能实例化。interface&#123;&#125; 类型表示一个空接口，任何类型都满足空接口。也就是说 interface&#123;&#125; 类型的值可以用于表示任意 Go 语言类型的值。 这里的空接口有点类似于 Python 语言中的 object 实例。既然 interface&#123;&#125; 可以用于表示任意类型，那有的时候我们需要将 interface&#123;&#125; 类型转换为我们需要的类型，这个操作称为类型断言。 一般情况下只有我们希望表达式是某种特定类型的值时才使用类型断言。Go 语言中可以使用以下语法： resultOfType, boolean := expression.(Type)：安全的类型断言。 resultOfType := expression.(Type)：非安全的类型断言，失败时程序会产生异常。 创建源文件 type_t.go，输入以下源文件： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)func main() &#123; x := uint16(65000) y := int16(x) // 将 x转换为int16类型 fmt.Printf(&quot;type and value of x is: %T and %d &quot;, x, x) // %T 格式化指令的作用是输出变量的类型 fmt.Printf(&quot;type and value of y is: %T and %d &quot;, y, y) var i interface&#123;&#125; = 99 // 创建一个interface&#123;&#125;类型，其值为99 var s interface&#123;&#125; = []string&#123;&quot;left&quot;, &quot;right&quot;&#125; j := i.(int) // 我们假设i是兼容int类型，并使用类型断言将其转换为int类型 fmt.Printf(&quot;type and value of j is: %T and %d &quot;, j, j) if s, ok := s.([]string); ok &#123; // 创建了影子变量，if的作用域中覆盖了外部的变量s fmt.Printf(&quot;%T -&gt; %q &quot;, s, s) &#125;&#125; 运行程序： 12345$ go run type_t.gotype and value of x is: uint16 and 65000type and value of y is: int16 and -536type and value of j is: int and 99[]string -&gt; [&quot;left&quot; &quot;right&quot;] 错误处理错误处理是任何语言都需要考虑到的问题，而 Go 语言在错误处理上解决得更为完善，优雅的错误处理机制是 Go 语言的一大特点。 errorGo 语言引入了一个错误处理的标准模式，即 error 接口，该接口定义如下： 123type error interface &#123; Error() string&#125; 对于大多数函数，如果要返回错误，可以将 error 作为多返回值的最后一个： 1234func foo(param int)(ret int, err error)&#123; ...&#125; 调用时的代码： 123456n, err := foo(0)if err != nil &#123; // 错误处理&#125; else &#123; // 使用返回值n&#125; 我们还可以自定义错误类型，创建源文件 error.go，输入以下代码： 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;import &quot;errors&quot;//自定义的出错结构type myError struct &#123; arg int errMsg string&#125;//实现Error接口func (e *myError) Error() string &#123; return fmt.Sprintf(&quot;%d - %s&quot;, e.arg, e.errMsg)&#125;//两种出错func error_test(arg int) (int, error) &#123; if arg &lt; 0 &#123; return -1, errors.New(&quot;Bad Arguments - negtive!&quot;) &#125;else if arg &gt;256 &#123; return -1, &amp;myError&#123;arg, &quot;Bad Arguments - too large!&quot;&#125; &#125; return arg*arg, nil&#125;//相关的测试func main() &#123; for _, i := range []int&#123;-1, 4, 1000&#125; &#123; if r, e := error_test(i); e != nil &#123; fmt.Println(&quot;failed:&quot;, e) &#125; else &#123; fmt.Println(&quot;success:&quot;, r) &#125; &#125;&#125; defer你可以在 Go 函数中添加多个 defer 语句，当函数执行到最后时，这些 defer 语句会按照逆序执行（即最后一个 defer 语句将最先执行），最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的： 1234567891011121314151617func CopyFile(dst, src string) (w int64, err error) &#123; srcFile, err := os.Open(src) if err != nil &#123; return &#125; defer srcFile.Close() dstFile, err := os.Create(dst) if err != nil &#123; return &#125; defer dstFile.Close() return io.Copy(dstFile, srcFile)&#125; 如果 defer 后面一条语句干不完清理工作，也可以使用一个匿名函数： 123defer func()&#123; ...&#125;() 注意，defer 语句是在 return 之后执行的，新建源文件 defer.go 输入以下代码： 12345678910func test() (result int) &#123; defer func() &#123; result = 12 &#125;() return 10&#125;func main() &#123; fmt.Println(test()) // 12&#125; panicpanic() 函数用于抛出异常，recover() 函数用于捕获异常，这两个函数的原型如下： 12func panic(interface&#123;&#125;)func recover() interface&#123;&#125; 当在一个函数中调用 panic() 时，正常的函数执行流程将立即终止，但函数中之前使用 defer 关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致逐层向上执行 panic() 流程，直至所属的 goroutine 中所有正在执行的函数被终止。错误信息将被报告，包括在调用 panic() 函数时传入的参数，这个过程称为错误流程处理。 panic() 接受一个 interface&#123;&#125; 参数，可支持任意类型，例如： 123panic(404)panic(&quot;network broken&quot;)panic(Error(&quot;file not exists&quot;)) 在 defer 语句中，可以使用 recover() 终止错误处理流程，这样可以避免异常向上传递，但要注意 recover() 之后，程序不会再回到 panic() 那里，函数仍在 defer 之后返回。新建一个源文件 error1.go，输入以下代码： 12345678910111213141516171819func foo() &#123; panic(errors.New(&quot;i&#x27;m a bug&quot;)) return&#125;func test() (result int) &#123; defer func() &#123; if r := recover(); r != nil &#123; err := r.(error) fmt.Println(&quot;Cache Exception:&quot;, err) &#125; &#125;() foo() return 10&#125;func main() &#123; fmt.Println(test()) // 0&#125; 面向对象编程自定义类型Go 语言的中结构体 struct 与 C++、JAVA 中的类 class 相似，但 Go 放弃了传统面向对象的诸多特性，只保留了组合。 type typeName typeSpecification 其中，typeName 可以是一个包或者函数内唯一合法的 Go 标示符。typeSpecification 可以是任何内置的类型，一个接口或者是一个结构体。所谓结构体，它的字段是由其他类型或者接口组成。例如我们通过结构体定义了一下类型： 1234type ColorPoint struct &#123; color.Color // 匿名字段(嵌入) x, y int // 具名字段(聚合)&#125; 以上代码我们通过结构体自定义了类型 ColorPoint，结构体中 color.Color 字段是 Color 包的类型 color，这个字段没有名字，所以被称为匿名的，也是嵌入字段。字段 x 和 y 是有变量名的，所以被称为具名字段。假如我们创建了类型 ColorPoint 的一个值 point（通过语法：point := ColorPoint&#123;&#125; 创建），那么这些字段可以通过 point.Color、point.x、point.y 访问。其他面向对象语言中的”类 (class)”、”对象 (object)”、”实例 (instance)”在 Go 语言中我们完全避开使用。相反的我们使用”类型 (type)”和其对应的”值”，其中自定义类型的值可以包含方法。 定义了结构体后如何创建并初始化一个对象实例呢？Go 语言支持以下几种方法进行实现： 12345678910//先定义一个结构体Mantype Man struct&#123; name string age int&#125;//对象创建与初始化man := new(Man)man := &amp;Man&#123;&#125;man := &amp;Man&#123;&quot;Tom&quot;, 18&#125;man := &amp;Man&#123;name: &quot;Tom&quot;, age: 18&#125; 为了更加方便的创建对象，我们一般会使用一个全局函数来完成对象的创建，这和传统的“构造函数”类似。 123func NewMan(name string, age int) *Man &#123; return &amp;Man&#123;name, age&#125;&#125; 方法方法是作用在自定义类型上的一类特殊函数，通常自定义类型的值会被传递给该函数，该值可能是以指针或者复制值的形式传递。定义方法和定义函数几乎相同，只是需要在 func 关键字和方法名之间必须写上接接受者。例如我们给类型 Count 定义了以下方法： 12345type Count intfunc (count *Count) Increment() &#123; *count++ &#125; // 接受者是一个 `Count` 类型的指针func (count *Count) Decrement() &#123; *count-- &#125;func (count Count) IsZero() bool &#123; return count == 0 &#125; 以上代码中，我们在内置类型 int 的基础上定义了自定义类型 Count，然后给该类型添加了 Increment()、Decrement() 和 IsZero() 方法，其中前两者的接受者为 Count 类型的指针，后一个方法接收 Count 类型的值。 类型的方法集是指可以被该类型的值调用的所有方法的集合。 一个指向自定义类型的值的指针，它的方法集由该类型定义的所有方法组成，无论这些方法接受的是一个值还是一个指针。如果在指针上调用一个接受值的方法，Go 语言会聪明地将该指针解引用。 一个自定义类型值的方法集合则由该类型定义的接收者为值类型的方法组成，但是不包括那些接收者类型为指针的方法。 其实这些限制 Go 语言帮我们解决的非常好，结果就是我们可以在值类型上调用接收者为指针的方法。假如我们只有一个值，仍然可以调用一个接收者为指针类型的方法，这是因为 Go 语言会自动获取值的地址传递给该方法，前提是该值是可寻址的。 在以上定义的类型 Count 中，*Count 方法集是 Increment(), Decrement() 和 IsZero()，Count 的值的方法集是 IsZero()。但是因为 Count 类型的是可寻址的，所以我们可以使用 Count 的值调用全部的方法。 另外如果结构体的字段也有方法，我们也可以直接通过结构体访问字段中的方法。下面让我们练习下，创建源文件 struct_t.go，输入以下代码： 123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;type Count int // 创建自定义类型 Countfunc (count *Count) Increment() &#123; *count++ &#125; // Count类型的方法func (count *Count) Decrement() &#123; *count-- &#125;func (count Count) IsZero() bool &#123; return count == 0 &#125;type Part struct &#123; // 基于结构体创建自定义类型 Part stat string Count // 匿名字段&#125;func (part Part) IsZero() bool &#123; // 覆盖了匿名字段Count的IsZero()方法 return part.Count.IsZero() &amp;&amp; part.stat == &quot;&quot; // 调用了匿名字段的方法&#125;func (part Part) String() string &#123; // 定义String()方法，自定义了格式化指令%v的输出 return fmt.Sprintf(&quot;&lt;&lt;%s, %d&gt;&gt;&quot;, part.stat, part.Count)&#125;func main() &#123; var i Count = -1 fmt.Printf(&quot;Start \\&quot;Count\\&quot; test: Origin value of count: %d &quot;, i) i.Increment() fmt.Printf(&quot;Value of count after increment: %d &quot;, i) fmt.Printf(&quot;Count is zero t/f? : %t &quot;, i.IsZero()) fmt.Println(&quot;Start: \\&quot;Part\\&quot; test:&quot;) part := Part&#123;&quot;232&quot;, 0&#125; fmt.Printf(&quot;Part: %v &quot;, part) fmt.Printf(&quot;Part is zero t/f? : %t &quot;, part.IsZero()) fmt.Printf(&quot;Count in Part is zero t/f?: %t &quot;, part.Count.IsZero()) // 尽管覆盖了匿名字段的方法，单还是可以访问&#125; 以上代码中，我们创建了 Count 类型，然后在其基础上又创建了结构体类型 Part。我们为 Count 类型定义了 3 个方法，并在 Part 类型中创建了方法 IsZero() 覆盖了其匿名字段 Count 中 IsZero() 方法。但是我们还是可以二次访问到匿名字段中被覆盖的方法。执行代码，输出如下： 123456789101112$ go run struct_t.goStart &quot;Count&quot; test:Origin value of count: -1Value of count after increment: 0Count is zero t/f? : trueStart: &quot;Part&quot; test:Part: &lt;&lt;232, 0&gt;&gt;Part is zero t/f? : falseCount in Part is zero t/f?: true"},{"path":"/Demo/Qt/QSqlCipher/CHANGELOG.html","content":"1.3 (To be decided) Update to Sqlite 3.37.0 Update to wxSqlite3 to main branch Support Qt 6 Tested on following versions: Qt 5.15.2 MSVC2019 Qt 6.2.1 MSVC2019 1.2 (2018-09-08) Add legacy_page_size connection options for all ciphers. 1.1 (2018-08-17)1.0 (2018-07-23) Update wxSQLite3 to 4.0.4 Add Qt private configuration in order to use Qt private headers. Support multiple ciphers, including AES128CBC, AES256CBC, CHACHA20 and SQLCIPHER. 0.7 (2017-04-08) Update sqlitecipher plugin debug name pattern on Mac OS. Port test code to iOS. 0.6 (2017-03-20) Fix a crash bug compiling with gcc. Update sqlite to 3.17.0 Update wxSqlite3 to 3.5.2 0.5 (2016-05-20) Copy private Qt sources to this project. 0.4 (2016-05-19) Update sqlite to 3.12.2 Update wxSqlite3 to 3.3.1 Update driver code to Qt 5.6. Now we could support Qt 5.0 to 5.6, but not for 5.7. Improve Qt private path settings. Add password create, update and remove. Thanks to @topillar Return false when password is incorrect. 0.3 (2014-09-20) Add password paramater to open() function. Update sqlite to 3.8.5 Update wxSqlite3 to 3.1.0 0.2 (2013-01-09) Update sqlite to 3.7.15.1 Support for Qt 5 0.1 (2012-09-27) sqlite 3.7.13"},{"path":"/Demo/Qt/QSqlCipher/README.html","content":"QtCipherSqlitePluginA Qt plugin for cipher SQLite which is based on SQLite source and wxSQLite3 in wxWidget. Qt is a full development framework with tools designed to streamline the creation of applications and user interfaces for desktop, embedded and mobile platforms. You could find more details at https://www.qt.io. SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world. The source code for SQLite is in the public domain. You could find more details at http://www.sqlite.org/. wxSQLite3 is a C++ wrapper around the public domain SQLite 3.x database and is specifically designed for use in programs based on the wxWidgets library. wxSQLite3 includes an optional extension for SQLite supporting key based database file encryption using 128 bit AES encryption. You could find more details at http://utelle.github.io/wxsqlite3. wxSQLite3 is released under wxWindows Library Licence. You could find how to compile this plugin at http://qtciphersqliteplugin.galaxyworld.org. Please read Wiki for more details."},{"path":"/Demo/Qt/QSqlCipherView/CHANGELOG.html","content":"1.3 (To be decided) Update to Sqlite 3.37.0 Update to wxSqlite3 to main branch Support Qt 6 Tested on following versions: Qt 5.15.2 MSVC2019 Qt 6.2.1 MSVC2019 1.2 (2018-09-08) Add legacy_page_size connection options for all ciphers. 1.1 (2018-08-17)1.0 (2018-07-23) Update wxSQLite3 to 4.0.4 Add Qt private configuration in order to use Qt private headers. Support multiple ciphers, including AES128CBC, AES256CBC, CHACHA20 and SQLCIPHER. 0.7 (2017-04-08) Update sqlitecipher plugin debug name pattern on Mac OS. Port test code to iOS. 0.6 (2017-03-20) Fix a crash bug compiling with gcc. Update sqlite to 3.17.0 Update wxSqlite3 to 3.5.2 0.5 (2016-05-20) Copy private Qt sources to this project. 0.4 (2016-05-19) Update sqlite to 3.12.2 Update wxSqlite3 to 3.3.1 Update driver code to Qt 5.6. Now we could support Qt 5.0 to 5.6, but not for 5.7. Improve Qt private path settings. Add password create, update and remove. Thanks to @topillar Return false when password is incorrect. 0.3 (2014-09-20) Add password paramater to open() function. Update sqlite to 3.8.5 Update wxSqlite3 to 3.1.0 0.2 (2013-01-09) Update sqlite to 3.7.15.1 Support for Qt 5 0.1 (2012-09-27) sqlite 3.7.13"},{"path":"/Demo/Qt/QSqlCipherView/README.html","content":"QtCipherSqlitePluginA Qt plugin for cipher SQLite which is based on SQLite source and wxSQLite3 in wxWidget. Qt is a full development framework with tools designed to streamline the creation of applications and user interfaces for desktop, embedded and mobile platforms. You could find more details at https://www.qt.io. SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world. The source code for SQLite is in the public domain. You could find more details at http://www.sqlite.org/. wxSQLite3 is a C++ wrapper around the public domain SQLite 3.x database and is specifically designed for use in programs based on the wxWidgets library. wxSQLite3 includes an optional extension for SQLite supporting key based database file encryption using 128 bit AES encryption. You could find more details at http://utelle.github.io/wxsqlite3. wxSQLite3 is released under wxWindows Library Licence. You could find how to compile this plugin at http://qtciphersqliteplugin.galaxyworld.org. Please read Wiki for more details."},{"path":"/Demo/hexo-auto-issue/lib/githubApi.js","content":"'use strict' const {Octokit} = require(\"@octokit/rest\"); class GithubApi { constructor(options) { this.repo = options.repo; this.owner = options.owner; this.auth = options.auth || process.env.GITHUB_TOKEN; this.userAgent = options.userAgent; } init() { this.octokit = new Octokit({ auth: this.auth, userAgent: this.userAgent || 'hexo-auto-issue', }); } async fetchAllIssues() { const data = await this.octokit .paginate(\"GET /repos/{owner}/{repo}/issues\", { owner: this.owner, repo: this.repo, }); return data; } async createIssue(issueData) { const res = await this.octokit.issues.create({ owner: this.owner, repo: this.repo, ...issueData, }); return res; } async updateIssue(issueData) { const res = await this.octokit.issues.update({ owner: this.owner, repo: this.repo, ...issueData, }) return res; } } module.exports = GithubApi;"},{"path":"/Demo/hexo-auto-issue/lib/utils.js","content":"'use strict'; const fs = require('fs'); const path = require('path'); const crypto = require('crypto'); const nunjucks = require('nunjucks'); const TPL_TITLE = ''; const TPL_BODY = ''use strict'; const fs = require('fs'); const path = require('path'); const crypto = require('crypto'); const nunjucks = require('nunjucks'); const TPL_TITLE = '{{ title }}'; const TPL_BODY = '{{ _content }}'; const TPL_LABELS = \"{{ tags.data|join(',', 'name') }},{{ categories.data|join(',', 'name') }}\"; function issueDataBuilder(item, hexo) { const issueData = {}; const { template: {body = TPL_BODY, title = TPL_TITLE, labels = TPL_LABELS} = {}, withGitalk } = hexo.config.auto_issue || {}; issueData.title = nunjucks.renderString(title, {...item}); issueData.body = nunjucks.renderString(body, {...item}); let allLabels = nunjucks.renderString(labels, {...item}); allLabels = Array.from(new Set(allLabels.split(',').filter(item => !!item))); let gitalkId; if (withGitalk) { const url_for = hexo.extend.helper.get('url_for').bind(hexo); const str = url_for(item.path); // gitalkId = crypto.createHash('md5').update(str).digest('hex'); // allLabels.push(gitalkId); allLabels.push('Gitalk'); } issueData.labels = allLabels; return {issueData, gitalkId}; } module.exports = { issueDataBuilder, }'; const TPL_LABELS = \",\"; function issueDataBuilder(item, hexo) { const issueData = {}; const { template: {body = TPL_BODY, title = TPL_TITLE, labels = TPL_LABELS} = {}, withGitalk } = hexo.config.auto_issue || {}; issueData.title = nunjucks.renderString(title, {...item}); issueData.body = nunjucks.renderString(body, {...item}); let allLabels = nunjucks.renderString(labels, {...item}); allLabels = Array.from(new Set(allLabels.split(',').filter(item => !!item))); let gitalkId; if (withGitalk) { const url_for = hexo.extend.helper.get('url_for').bind(hexo); const str = url_for(item.path); // gitalkId = crypto.createHash('md5').update(str).digest('hex'); // allLabels.push(gitalkId); allLabels.push('Gitalk'); } issueData.labels = allLabels; return {issueData, gitalkId}; } module.exports = { issueDataBuilder, }"},{"path":"/Demo/hexo-auto-issue/lib/index.js","content":"'use strict'; const moment = require('moment'); const GithubApi = require('./githubApi'); const {issueDataBuilder} = require('./utils'); const nunjucks = require('nunjucks'); module.exports = async function () { const hexo = this; const plugConfig = hexo.config.auto_issue || {}; hexo.log.i('++++++++++++++++++++++++') hexo.log.i('Auto Issue'); hexo.log.i('++++++++++++++++++++++++') const githubApi = new GithubApi(plugConfig); githubApi.init(); hexo.log.i('fetching issues that have been published on github, please wait...'); const allissue = await githubApi.fetchAllIssues() || []; hexo.log.i(`fetched ${allissue.length} issues`); await hexo.call('generate'); const sort_by = plugConfig.sort_by || 'date'; const allPosts = hexo.locals.getters.posts().data.filter(item => !item.skipIssue).sort((a, b) => a[sort_by].isSameOrBefore(b[sort_by]) ? -1 : 1); for (const item of allPosts) { const {issueData, gitalkId} = issueDataBuilder(item, hexo); const exixtedIssue = allissue.filter(item => plugConfig.withGitalk ? item.labels.some(label => label.name === gitalkId) : item.title === issueData.title); let res; try { if (exixtedIssue && exixtedIssue.length) { const issue = exixtedIssue[0]; if (moment(item.updated).isAfter(moment(issue.updated))) { hexo.log.i('updating', item.title); res = await githubApi.updateIssue({...issueData, issue_number: issue.issue_number}); } else { hexo.log.i('skiped', item.title); } } else { hexo.log.i('pubshing', item.title); res = await githubApi.createIssue(issueData); } await new Promise((resolved) => { setTimeout(resolved, plugConfig.delay || 2000); }); } catch (e) { hexo.log.e('error', e); } } }"},{"path":"/Demo/Go/DesignPattern/00_simple_Factory/README.html","content":"简单工厂模式go 语言没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。 NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。 在这个simplefactory包中只有API 接口和NewAPI函数为包外可见，封装了实现细节。"},{"title":"Qt 全局注册快捷键","path":"/Demo/Visual Studio/Qt/QGlobalKeyShort/README.html","content":"Qt 提供了 QShortcut 来实现快捷键的功能，不过它的响应范围只局限于窗口内。如果脱离了进程窗口，如在桌面，或者正在使用其他软件，是无法响应的。 要解决这样的问题可以使用 Windows 提供的 API 再结合qt的一些功能来实现一个全局可响应的快捷键。 直接行代码，首先在 main 函数添加快捷绑定进行注册 MyGlobalShortCut *shortcut = new MyGlobalShortCut(&quot;Ctrl+Down&quot;, &amp;w); QObject::connect(shortcut, SIGNAL(activated()), &amp;w, SLOT(rec_testShotCutAns())); 然后添加 MyGlobalShortCut.h","tags":[null,null]},{"title":"Windows注册表查询工具","path":"/Demo/Visual Studio/Utils/WinReg/README.html","content":"Welcome to WinReg 👋 windows 注册表查询封装函数 Author👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! Windows 注册表工具用于windows系统查询注册表，具体方法查看代码 文件WinReg.hWinReg.cpp 使用Demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 遍历网卡std::set&lt;std::string&gt; get_tap_reg()&#123;\tstd::set&lt;std::string&gt; tap_reg;\ttry\t&#123; WinRegKey reg_key; if (!reg_key.open_exist(HKLM, &quot;SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\&#123;4D36E972-E325-11CE-BFC1-08002BE10318&#125;&quot;)) &#123; throw(&quot;open regedit %s faild: %s&quot;, _adapter_key, reg_key.get_error_msg()); &#125; vector&lt;string&gt; sub_keys = reg_key.enum_subkeys(); assert(!sub_keys.empty(), &quot;%s has no child keys&quot;); //iterator subkeys for (auto&amp; iter : sub_keys) &#123; char connection_string[256]; sprintf(connection_string, sizeof(connection_string), &quot;%s\\\\%s&quot;, _adapter_key, iter.c_str()); WinRegKey sub_reg_key; if (!sub_reg_key.open_exist(HKLM, connection_string)) &#123; printf(&quot;Open_exist %s failed: %s&quot;, connection_string, sub_reg_key.get_error_msg()); continue; &#125; string component_id; if (!sub_reg_key.read_key_value(&quot;ComponentId&quot;, component_id)) &#123; printf(&quot;Read %s\\\\ComponentId failed: %s&quot;, connection_string, sub_reg_key.get_error_msg()); continue; &#125; string net_cfg_instance_id; if (!sub_reg_key.read_key_value(&quot;NetCfgInstanceId&quot;, net_cfg_instance_id)) &#123; printf(&quot;Read %s\\\\NetCfgInstanceId failed: %s&quot;, connection_string, sub_reg_key.get_error_msg()); continue; &#125; if (strcmp(component_id.c_str(), _component_id) == 0) &#123; tap_reg.insert(net_cfg_instance_id); &#125; &#125; reg_key.~WinRegKey(); return tap_reg;\t&#125;\tcatch (exception&amp; e)\t&#123; printf(&quot;%s&quot;, e.what()); return tap_reg;\t&#125;&#125; This README was generated with ❤️ by readme-md-generator"},{"path":"/Demo/Visual Studio/Utils/win_str_utills/README.html","content":"Welcome to win_str_utils 👋 windows 字符编码转换相关函数 Author👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! Windows 字符编码转换函数支持的编码转换12345std::string UnicodeToUTF8(const wchar_t* str, int strLen);std::string UnicodeToAnsi(const wchar_t* str, int strLen);std::wstring AnsiToUnicode(const char* str, int strLen);std::string AnsiToUtf8(const std::string&amp; str);std::wstring Utf8ToUnicode(const std::string&amp; str); 文件win_str_utils.hwin_str_utils.cpp This README was generated with ❤️ by readme-md-generator"},{"path":"/Demo/Visual Studio/WinAPI/NcDetection/readme.html","content":"NC异常检测(NCQuery)及修复(NcRecovery)说明[toc] 1. NC异常检测(NCQuery)检测模块 虚拟网卡(netcard) 检查虚拟网卡的状态（禁用、启用、未启用） 通信服务及部分操作(ncopt) 与 Trustcore 的通信及网卡启动前操作 vnic 检查虚拟ip的分配是否成功 路由 检查路由表&gt; 返回结构12345678910111213141516171819202122232425262728293031323334353637383940&#123; &quot;error_code&quot;: 0, &quot;message&quot;: &quot;Configure vnic Success&quot;, &quot;modules&quot;: [ &#123; &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Create remote vnip success&quot;, &quot;name&quot;: &quot;ncip&quot;, &quot;status&quot;: &quot;0&quot;, &quot;time&quot;: &quot; 2023-04-07T10:33:14Z&quot; &#125;, &#123; &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Get &amp; Set OPtions Success&quot;, &quot;name&quot;: &quot;ncopt&quot;, &quot;status&quot;: &quot;0&quot;, &quot;time&quot;: &quot; 2023-04-07T10:33:14Z&quot; &#125;, &#123; &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Configure vnic Success&quot;, &quot;name&quot;: &quot;netcard&quot;, &quot;options&quot;: &quot;&#123;\\&quot;data\\&quot;: &#123;\\&quot;block_exclude_lan\\&quot;: 0, \\&quot;block_internet\\&quot;: 0, \\&quot;dns\\&quot;: [], \\&quot;dns4\\&quot;: [], \\&quot;dns6\\&quot;: [], \\&quot;dns_suffix\\&quot;: \\&quot;\\&quot;, \\&quot;ip\\&quot;: \\&quot;1.1.1.114\\&quot;, \\&quot;ipv4\\&quot;: \\&quot;1.1.1.114\\&quot;, \\&quot;mask\\&quot;: \\&quot;255.255.255.255\\&quot;, \\&quot;route_assign4\\&quot;: [], \\&quot;route_assign6\\&quot;: [], \\&quot;route_auto\\&quot;: \\&quot;1\\&quot;, \\&quot;route_includes4\\&quot;: [\\&quot;1.1.1.1/32\\&quot;, \\&quot;10.41.3.204/32\\&quot;, \\&quot;10.41.3.222/32\\&quot;, \\&quot;10.44.250.1/32\\&quot;, \\&quot;10.44.250.2/31\\&quot;, \\&quot;10.44.250.4/30\\&quot;, \\&quot;10.44.250.8/29\\&quot;, \\&quot;10.44.250.16/28\\&quot;, \\&quot;10.44.250.32/27\\&quot;, \\&quot;10.44.250.64/26\\&quot;, \\&quot;10.44.250.128/30\\&quot;, \\&quot;10.44.250.134/31\\&quot;, \\&quot;10.44.250.136/29\\&quot;, \\&quot;10.44.250.144/28\\&quot;, \\&quot;10.44.250.160/27\\&quot;, \\&quot;10.44.250.192/27\\&quot;, \\&quot;10.44.250.224/28\\&quot;, \\&quot;10.44.250.240/29\\&quot;, \\&quot;10.44.250.248/30\\&quot;, \\&quot;10.44.250.252/31\\&quot;, \\&quot;10.44.250.254/32\\&quot;, \\&quot;10.92.2.33/32\\&quot;, \\&quot;10.92.2.250/32\\&quot;, \\&quot;10.92.3.132/32\\&quot;, \\&quot;198.18.0.0/30\\&quot;, \\&quot;198.18.0.4/31\\&quot;, \\&quot;198.18.0.6/32\\&quot;], \\&quot;route_opt\\&quot;: \\&quot;0\\&quot;, \\&quot;vpn_host\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_ip\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_ip4\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_port\\&quot;: \\&quot;443\\&quot;&#125;, \\&quot;errcode\\&quot;: \\&quot;0\\&quot;&#125;&quot;, &quot;status&quot;: &quot;0&quot;, &quot;time&quot;: &quot; 2023-04-07T10:33:22Z&quot; &#125;, &#123; &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Add route table Success&quot;, &quot;name&quot;: &quot;route&quot;, &quot;routetable&quot;: &quot;[\\&quot;1.1.1.1/32\\&quot;, \\&quot;10.41.3.204/32\\&quot;, \\&quot;10.41.3.222/32\\&quot;, \\&quot;10.44.250.1/32\\&quot;, \\&quot;10.44.250.2/31\\&quot;, \\&quot;10.44.250.4/30\\&quot;, \\&quot;10.44.250.8/29\\&quot;, \\&quot;10.44.250.16/28\\&quot;, \\&quot;10.44.250.32/27\\&quot;, \\&quot;10.44.250.64/26\\&quot;, \\&quot;10.44.250.128/30\\&quot;, \\&quot;10.44.250.134/31\\&quot;, \\&quot;10.44.250.136/29\\&quot;, \\&quot;10.44.250.144/28\\&quot;, \\&quot;10.44.250.160/27\\&quot;, \\&quot;10.44.250.192/27\\&quot;, \\&quot;10.44.250.224/28\\&quot;, \\&quot;10.44.250.240/29\\&quot;, \\&quot;10.44.250.248/30\\&quot;, \\&quot;10.44.250.252/31\\&quot;, \\&quot;10.44.250.254/32\\&quot;, \\&quot;10.92.2.33/32\\&quot;, \\&quot;10.92.2.250/32\\&quot;, \\&quot;10.92.3.132/32\\&quot;, \\&quot;198.18.0.0/30\\&quot;, \\&quot;198.18.0.4/31\\&quot;, \\&quot;198.18.0.6/32\\&quot;]&quot;, &quot;status&quot;: &quot;0&quot;, &quot;time&quot;: &quot; 2023-04-07T10:33:22Z&quot; &#125; ], &quot;os&quot;: &quot;windows&quot;, &quot;service&quot;: &quot;trustnc&quot;, &quot;state&quot;: &quot;R&quot;, &quot;time&quot;: &quot; 2023-04-07T10:33:22Z&quot;&#125; netcard 参数 父节点 类型 说明 netcard \\ 返回虚拟网卡相关状态 level netcard string 返回异常状态的级别 status netcard string 返回虚拟网卡状态的状态码 options Netcard string (独有)返回虚拟网卡的配置信息 message netcard string 返回状态码对应的描述信息 ncip 参数 父节点 类型 说明 ncip \\ 返回虚拟ip相关状态 level ncip string 返回异常状态的级别level status ncip string 返回虚拟ip的状态码 message ncip string 返回状态码对应的描述信息 ncopt 参数 父节点 类型 说明 ncopt \\ 返回nc通信的状态 level ncopt string 返回异常状态的级别 status ncopt string 返回通信状态的状态码 message ncopt string 返回状态码对应的描述信息 route 参数 父节点 类型 说明 route \\ 返回路由信息 status route string 返回路由的状态码 level route string 返回异常状态的级别 message route string 返回路由状态码对应的描述信息 routetable route string 返回路由表的json字符串 Status 说明 虚拟网卡 通信服务 vnic 路由 1. 虚拟网卡[0,1,2~100] level status message 描述 处置动作 0 正常状态 0 1. opened 正常状态：启用虚拟网卡成功 0 2. HKLM Query Class Success 正常状态： 0 3. HKLM Query Network Success 正常状态： 0 4. Find Friendly Name 正常状态： 0 Connect has started 正常状态： 1 unknown 初始化状态 2 Not Found Device Vnic 未找到vnic设备 重新安装 3 Configure vnic failed 设置网卡信息失败（ip、网关、掩码、dns等） 重新获取网卡配置并设置 4 HKLM Query Faild 查询注册表失败 一般情况下还是网卡未安装 2. 通信及操作(ncopt)[0,1,101~200] level status message 描述 处置动作 INFO 0 1. normal 正常状态 INFO 0 Get &amp; Set OPtions Success 获取配置和设置句柄成功 0 Configure vnic Success 正常状态：连接core成功 INFO 0 Connect has started 虚拟网卡已经启动 ？ INFO 1 unknown 初始化状态 ERROR 101 Send initial msg to vpncore failed 发送PTUN请求失败 重新获取配置 ERROR 102 Send initial msg to vpncore failed with option 发送默认路由失败 重新获取配置 ERROR 103 Recv msg header from vpncore failed 接收PTUN消息失败 重新获取配置 ERROR 104 Alloc for msg_body failed 初始化内存失败 重新获取配置 ERROR 105 Recv initial msg response from vpnclient failed 接收消息失败 重新获取配置 ERROR 106 NC options is null 获取NC配置为空 ? ERROR 107 Set Handler Failed 设置控制句柄失败 重新获取配置 3. vnic[0,1,201~300] level status message 描述 处置动作 INFO 0 1. 正常状态 INFO 1 unknown 初始化状态 ERROR 201 Create remote ip failed 创建虚拟ip失败 重新创建且重新走开启虚拟网卡流程 4. 路由表[0,1,301~400] level status message 描述 处置动作 INFO 0 正常状态 INFO 0 Add route table Success 添加路由（同时保存路由表） INFO 1 unknown 初始化状态 ERROR 301 Add route table failed 添加路由失败 重新添加 302 Repair route table failed 修复路由失败 2. NC异常修复(NcRecovery)异常修复针对针对上一节中的 Status 对应的处置动作详细说明。对nc内部发生的异常可供内部修复的项目进行处理。 1234567891011121314151617181920212223242526&#123; &quot;ncip&quot;: &#123; &quot;message&quot;: &quot;unknown&quot;, &quot;status&quot;: &quot;1&quot; &#125;, &quot;ncopt&quot;: &#123; &quot;message&quot;: &quot;unknown&quot;, &quot;status&quot;: &quot;1&quot; &#125;, &quot;netcard&quot;: &#123; &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Add route table Success&quot;, &quot;options&quot;: &quot;&#123;\\&quot;L4\\&quot;: &#123;\\&quot;hostname_excludes\\&quot;: [], \\&quot;hostname_includes\\&quot;: [\\&quot;www.test.com\\&quot;, \\&quot;www.qianxin.com\\&quot;, \\&quot;aa.com\\&quot;], \\&quot;proxy_port\\&quot;: 50568, \\&quot;proxy_rules\\&quot;: [&#123;\\&quot;action\\&quot;: \\&quot;bypass\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;10.44.250.132\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;10.44.250.132\\&quot;, \\&quot;port_max\\&quot;: 443, \\&quot;port_min\\&quot;: 443, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;bypass\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;10.44.250.132\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;10.44.250.132\\&quot;, \\&quot;port_max\\&quot;: 443, \\&quot;port_min\\&quot;: 443, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;bypass\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;port_max\\&quot;: 443, \\&quot;port_min\\&quot;: 443, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv4\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;1.1.1.1\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;1.1.1.1\\&quot;, \\&quot;port_max\\&quot;: 3, \\&quot;port_min\\&quot;: 3, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv4\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;10.44.250.134\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;10.44.250.134\\&quot;, \\&quot;port_max\\&quot;: 80, \\&quot;port_min\\&quot;: 80, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv4\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;10.92.2.33\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;10.92.2.33\\&quot;, \\&quot;port_max\\&quot;: 80, \\&quot;port_min\\&quot;: 80, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv4\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;198.18.255.255\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;198.18.0.0\\&quot;, \\&quot;port_max\\&quot;: 65535, \\&quot;port_min\\&quot;: 0, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv4\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;255.255.255.255\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;0.0.0.0\\&quot;, \\&quot;port_max\\&quot;: 53, \\&quot;port_min\\&quot;: 53, \\&quot;protocol\\&quot;: \\&quot;udp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv6\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;::\\&quot;, \\&quot;port_max\\&quot;: 53, \\&quot;port_min\\&quot;: 53, \\&quot;protocol\\&quot;: \\&quot;udp\\&quot;&#125;]&#125;, \\&quot;data\\&quot;: &#123;\\&quot;block_exclude_lan\\&quot;: 0, \\&quot;block_internet\\&quot;: 0, \\&quot;dns\\&quot;: [], \\&quot;dns4\\&quot;: [], \\&quot;dns6\\&quot;: [], \\&quot;dns_suffix\\&quot;: \\&quot;\\&quot;, \\&quot;ip\\&quot;: \\&quot;1.1.1.29\\&quot;, \\&quot;ipv4\\&quot;: \\&quot;1.1.1.29\\&quot;, \\&quot;mask\\&quot;: \\&quot;255.255.255.255\\&quot;, \\&quot;route_assign4\\&quot;: [], \\&quot;route_assign6\\&quot;: [], \\&quot;route_auto\\&quot;: \\&quot;1\\&quot;, \\&quot;route_includes4\\&quot;: [\\&quot;1.1.1.1/32\\&quot;, \\&quot;10.44.250.130/32\\&quot;, \\&quot;10.44.250.134/32\\&quot;, \\&quot;10.92.2.33/32\\&quot;, \\&quot;198.18.0.0/31\\&quot;, \\&quot;198.18.0.2/32\\&quot;], \\&quot;route_opt\\&quot;: \\&quot;0\\&quot;, \\&quot;vpn_host\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_ip\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_ip4\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_port\\&quot;: \\&quot;443\\&quot;&#125;, \\&quot;errcode\\&quot;: \\&quot;0\\&quot;&#125;&quot;, &quot;routetable&quot;: &quot;[\\&quot;1.1.1.1/32\\&quot;, \\&quot;10.44.250.130/32\\&quot;, \\&quot;10.44.250.134/32\\&quot;, \\&quot;10.92.2.33/32\\&quot;, \\&quot;198.18.0.0/31\\&quot;, \\&quot;198.18.0.2/32\\&quot;]&quot;, &quot;status&quot;: &quot;0&quot; &#125;, &quot;recv&quot;: &#123; &quot;route&quot;: &#123; &quot;status&quot;: &quot;1&quot; &#125; &#125;, &quot;route&quot;: &#123; &quot;message&quot;: &quot;unknown&quot;, &quot;status&quot;: &quot;1&quot; &#125;&#125; 触发nc的操作1234567891011SP_TAP_STAGE_CREATE = 0x00, // CreatedSP_TAP_STAGE_ACCEPT_APP = 0x01, // Accept APP end&#x27;s connection, or connected backend APP server// TODO: more stage for PROXY supports: proxy-connecting proxy-handshakingSP_TAP_STAGE_CONNECT_LOOKUP = 0x02, // DNS lookup, resolving remote hostSP_TAP_STAGE_CONNECT_TCP = 0x03, // connecting remote host by TCPSP_TAP_STAGE_CONNECT_SSL = 0x04, // connecting remote host by SSL or SSL handshaking on exists TCPSP_TAP_STAGE_HANDSHAKE = 0x05, // has connected SSLVPN server authorizingSP_TAP_STAGE_FORWARD = 0x06, // has authorized SSLVPN Server forwarding dataSP_TAP_STAGE_IDLE = 0x07, // has NO L3 services, nc tunnel is not connected, idle state// SP_TAP_STAGE_ERROR = 0x7E,SP_TAP_STAGE_CLOSED = 0x7F 触发 SP_TAP_STAGE_FORWARD 的操作 OnTapAppRead stage!=SP_TAP_STAGE_FORWARD 已认证需要tap数据 SPTapTunnelBypass::OnTapVpnEvent stage&lt;SP_TAP_STAGE_HANDSHAKE 已连接但未认证 SPTapTunnelRelay::OnTapVpnEvent stage== BEV_EVENT_CONNECTED &amp;&amp; stage&lt;SP_TAP_STAGE_HANDSHAKE 已连接但未认证 SPTapTrustTunnelTCP::OnHandshakeRsp接口 errorcode == 0 SPTapTrustTunnelIP::OnHandshakeRsp接口errorcode == 0 SPTapAgent::OnTapVpnRead 隧道建立成功 &amp;&amp; stage==SP_TAP_STAGE_HANDSHAKE SPTapAgent::OnTapVpnRead tag == SP_MSG_VPN_AGT_SESSION_START 会话开始 SPTapAgentHub::OnRspMsgBinary tag==SP_MSG_VPN_AGT_PROXY_AUTH 服务访问授权 SPTapUDPGateway::OnTapAppRead stage&lt;SP_TAP_STAGE_FORWARD SPTapTrustRESTful::OnTapVpnRead stage == SP_TAP_STAGE_HANDSHAKE SPTapTunnelHTTPD::OnTapAppRead stage!=SP_TAP_STAGE_FORWARD SPTapTunnelNC::OnTapVpnRead stage==SP_TAP_STAGE_FORWARD SPTapTunnelMsg::OnTapVpnEvent stage==SP_TAP_STAGE_CONNECT_SSL 测试建议设置网卡 对应下发节点（data节点）： ip 虚拟路由 ipv4 虚拟路由 mask 掩码 vpn_ip 网关 Win7及以后#112netsh interface ip set address 14 static 1.1.1.95 255.255.255.255 store=active# netsh interface ip set address ? # 查看详细帮助 14: 为 “TrusgAgent VNIC” 的索引（此处也可以设置为名称）。 1.1.1.95: 为下发的虚拟ip 255.255.255.255: 为掩码 store: active 时表示设置仅持续到下一次启动；persistent ，设置永久有效 #212netsh interface ip set interface interface=14 metric=1 store=active# netsh interface ip set interface ? #查看帮助 interface: 接口名称或索引 metric: 接口跃点数，已添加到接口上的所有路由的路由跃点数 store: 同【#1】 #31netsh interface ip delete dns 14 all netsh interface ip delete ? 下列指令有效: 此上下文中的命令:delete address - 从指定的接口删除 IP 地址或默认网关。delete arpcache - 刷新一个特定接口或所有接口的 ARP 缓存。delete destinationcache - 删除目标缓存。delete dnsservers - 从指定的接口删除 DNS 服务器。delete excludedportrange - 为连续的端口块删除排除。delete neighbors - 刷新一个特定接口或所有接口的 ARP 缓存。delete route - 删除路由。delete winsservers - 从指定的接口删除 WINS 服务器。 #4添加dns服务武器IP和wins服务器IP 1234# 添加 dns 服务器IPnetsh interface ip add dns 14 %s validate = no# 添加 Wins 服务器IPnetsh interface ip add wins %d %s 其他#11netsh interface ip set address 以太网 dhcp 以太网： 网络名称 dhcp：动态路由 #2通过系统API添加(虚拟ip、目标ip、掩码等） 1DeviceIoControl #3通过系统API设置dns 添加路由 对应下发节点： data &gt; route_includes vnic执行的命令如下所示： 1ADD %ip% MASK %mask% %remoteip% ipv4 ip: 获取配置字段中的vpn_ip，一般为【tap地址】 mask: remotip ipv6 ip: 同【ipv4】 mask: 同 【ipv4】 remoteip:添加ipv6路由时，远端ip为 &quot;20.21.8.20&quot; 删除路由使用 Route Print 查看活动路由 123route DELETE %s MASK %s# 示例：删除[网络目标]为 10.44.250.144,[网络掩码]为 255.255.255.240的条目# route delete 10.44.250.144 mask 255.255.255.240"},{"title":"注册表句柄泄漏定位","path":"/Demo/Visual Studio/WinAPI/句柄泄漏/README.html","content":"句柄查看handle.exe 使用handle 可以查看进程的句柄，直接运行查看系统当前所有的句柄，使用 -p 指定 pid 查询某个进程的句柄 123456789101112131415161718Nthandle v4.22 - Handle viewerCopyright (C) 1997-2019 Mark RussinovichSysinternals - www.sysinternals.comusage: handle [[-a [-l]] [-u] | [-c &lt;handle&gt; [-y]] | [-s]] [-p &lt;process&gt;|&lt;pid&gt;] [name] [-nobanner] -a Dump all handle information. -l Just show pagefile-backed section handles. -c Closes the specified handle (interpreted as a hexadecimal number). You must specify the process by its PID. WARNING: Closing handles can cause application or system instability. -y Don&#x27;t prompt for close handle confirmation. -s Print count of each type of handle open. -u Show the owning user name when searching for handles. -p Dump handles belonging to process (partial name accepted). name Search for handles to objects with &lt;name&gt; (fragment accepted). -nobanner Do not display the startup banner and copyright message.No arguments will dump all file references. 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string str1 = &quot;hello&quot;; string str2 = &quot;world&quot;; if (str1 == str2) &#123; cout &lt;&lt; &quot;两个字符串相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;两个字符串不相等&quot; &lt;&lt; endl; &#125; return 0;&#125;","tags":[null,null,null]}]